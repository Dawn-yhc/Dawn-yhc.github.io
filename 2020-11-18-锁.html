<!DOCTYPE html>
<html lang="zh-CN,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="1111RcBkV43JHcyiH4z1Yk2xu-mqlS1fQNk5Dzv7_q0">
  <meta name="msvalidate.01" content="1111BC77E02800759CE29C4ACCE487BD">
  <meta name="yandex-verification" content="11112a93328de5da">
  <meta name="baidu-site-verification" content="1111-wFDrn4lvkD">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuhaicheng.xyz","root":"/","scheme":"Gemini","version":"8.0.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="null">
<meta property="og:type" content="article">
<meta property="og:title" content="锁">
<meta property="og:url" content="https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html">
<meta property="og:site_name" content="曙光苑">
<meta property="og:description" content="null">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190507233042199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oZWcyMDEw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180314222522710">
<meta property="og:image" content="https://img-blog.csdn.net/20180314222533843">
<meta property="og:image" content="https://img-blog.csdn.net/20180314222539318">
<meta property="article:published_time" content="2020-11-18T14:05:14.000Z">
<meta property="article:modified_time" content="2020-12-01T08:05:14.000Z">
<meta property="article:author" content="Dawn-yhc">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190507233042199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oZWcyMDEw,size_16,color_FFFFFF,t_70">


<link rel="canonical" href="https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>锁 | 曙光苑</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-108155018-3"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-108155018-3');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="曙光苑" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">曙光苑</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">有朋自远方来，不亦乐乎</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">46</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-baidusitemap">

    <a href="/baidusitemap.xml" rel="section"><i class="fa fa-cloud fa-fw"></i>百度站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.1.</span> <span class="nav-text">悲观锁、乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%AE%83%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">1.1.1.</span> <span class="nav-text">排它锁、共享锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.2.</span> <span class="nav-text">可重入锁、不可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.3.</span> <span class="nav-text">公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">Synchronized锁的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">1.4.1.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">1.4.2.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%87%86%E6%8D%A2"><span class="nav-number">1.4.3.</span> <span class="nav-text">轻量级锁、偏向锁的状态准换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS"><span class="nav-number">2.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS-%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E2%BD%85%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">AQS 对资源的共享⽅式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ReentrantLock"><span class="nav-number">2.2.</span> <span class="nav-text">1 ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-ReentrantLock%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.1 ReentrantLock特性概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-ReentrantLock%E4%B8%8EAQS%E7%9A%84%E5%85%B3%E8%81%94"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2 ReentrantLock与AQS的关联</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AQS"><span class="nav-number">2.3.</span> <span class="nav-text">2 AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.1 原理概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">2.1.1 AQS数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81State"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">2.1.2 同步状态State</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-AQS%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E4%B8%8EReentrantLock%E7%9A%84%E5%85%B3%E8%81%94"><span class="nav-number">2.4.</span> <span class="nav-text">2.2 AQS重要方法与ReentrantLock的关联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%80%9A%E8%BF%87ReentrantLock%E7%90%86%E8%A7%A3AQS"><span class="nav-number">2.5.</span> <span class="nav-text">2.3 通过ReentrantLock理解AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.3.1 线程加入等待队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-1-%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">2.3.1.1 加入队列的时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-2-%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">2.3.1.2 如何加入队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-3-%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%87%BA%E9%98%9F%E5%88%97%E6%97%B6%E6%9C%BA"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">2.3.1.3 等待队列中线程出队列时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-CANCELLED%E7%8A%B6%E6%80%81%E8%8A%82%E7%82%B9%E7%94%9F%E6%88%90"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.3.2 CANCELLED状态节点生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E5%A6%82%E4%BD%95%E8%A7%A3%E9%94%81"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.3.3 如何解锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.3.4 中断恢复后的执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-%E5%B0%8F%E7%BB%93"><span class="nav-number">2.5.5.</span> <span class="nav-text">2.3.5 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-AQS%E5%BA%94%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">3 AQS应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-ReentrantLock%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E5%BA%94%E7%94%A8"><span class="nav-number">2.6.1.</span> <span class="nav-text">3.1 ReentrantLock的可重入应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-JUC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.6.2.</span> <span class="nav-text">3.2 JUC中的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-number">2.6.3.</span> <span class="nav-text">3.3 自定义同步工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS"><span class="nav-number">3.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intel%E6%89%8B%E5%86%8C%E5%AF%B9lock%E5%89%8D%E7%BC%80%E7%9A%84%E8%AF%B4%E6%98%8E%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">intel手册对lock前缀的说明如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">3.3.</span> <span class="nav-text">CAS的缺点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7%EF%BC%9A"><span class="nav-number">3.4.</span> <span class="nav-text">循环时间长开销很大：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">3.5.</span> <span class="nav-text">只能保证一个变量的原子操作：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFABA%E9%97%AE%E9%A2%98%EF%BC%9FABA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">3.6.</span> <span class="nav-text">什么是ABA问题？ABA问题怎么解决？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">4.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E8%94%BD"><span class="nav-number">5.</span> <span class="nav-text">内存屏蔽</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.</span> <span class="nav-text">1. 指令重排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84happen-before%E5%8E%9F%E5%88%99"><span class="nav-number">5.2.</span> <span class="nav-text">2. java 内存模型中的happen before原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-Memory-Barrier"><span class="nav-number">5.3.</span> <span class="nav-text">3. 内存屏障(Memory Barrier)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-volatile%E8%AF%AD%E4%B9%89%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">5.4.</span> <span class="nav-text">4. volatile语义中的内存屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-final%E8%AF%AD%E4%B9%89%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">5.5.</span> <span class="nav-text">5. final语义中的内存屏障</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dawn-yhc"
      src="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg">
  <p class="site-author-name" itemprop="name">Dawn-yhc</p>
  <div class="site-description" itemprop="description">JAVA、技术</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhd24teWhjLw==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dawn-yhc&#x2F;"><i class="fab fa-github fa-fw"></i></span>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93ZWlsaW5pbmcuZ2l0aHViLmlv" title="https:&#x2F;&#x2F;weilining.github.io">Ln</span>
        </li>
    </ul>
  </div>

  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.html" title="面试记录.html"></a>
        </li>
    </ul>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/time.js" async="async"></script>


<div id="binft"class="links-of-recent-posts motion-element"></div>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/word.js" async="async"></script>
      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhd24teWhjL0Rhd24teWhjLmdpdGh1Yi5pbw==" title="Fork NexT on GitHub" aria-label="Fork NexT on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg">
      <meta itemprop="name" content="Dawn-yhc">
      <meta itemprop="description" content="JAVA、技术">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曙光苑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          锁<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhd24teWhjL0Rhd24teWhjLmdpdGh1Yi5pby9lZGl0L21haW4vc291cmNlL19wb3N0cy8yMDIwLTExLTE4LemUgS5tZA==" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-18 22:05:14" itemprop="dateCreated datePublished" datetime="2020-11-18T22:05:14+08:00">2020-11-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-01 16:05:14" itemprop="dateModified" datetime="2020-12-01T16:05:14+08:00">2020-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">锁的分类</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>33k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

            <div class="post-description"></div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中划分锁的方式不同，就产生了各种对锁的定义，如果不能清楚知道不同锁的特点那么就很容易将JUC中的锁弄混淆，在学习JUC方面知识之前先学习下锁的划分。</p>
<h2 id="悲观锁、乐观锁"><a href="#悲观锁、乐观锁" class="headerlink" title="悲观锁、乐观锁"></a>悲观锁、乐观锁</h2><p>对于悲观锁和乐观锁划分关键是：是否默认在进行多线程操作时，总认为有其他线程会进行同步操作。</p>
<p>悲观锁：顾名思义，每次去拿数据的时候都被认为别人会修改，所以每次在拿数据的时候都会被锁上，这样别人想拿这个数据就会block直到它拿到锁，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先锁上。</p>
<p>java中的悲观锁是synchronized<strong>，AQS框架下的锁则是先尝试CAS乐观锁去获取，获取不到，才会转为悲观锁，如RetreenLock</strong></p>
<p>乐观锁：每次去拿数据的时候都认为别人不会修改，<strong>所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号等机制</strong>。乐观锁适用于多度的应用类型，这样可以<strong>提高吞吐量</strong>。</p>
<p>乐观锁策略：提交版本必须大于记录当前版本才能执行更新。java乐观锁基本都通过<code>CAS</code>操作实现的，<code>CAS</code>是一种依赖系统指令集实现原子操作，比较当前变量值与预期值是否一样,如果相同就使用系统原语进行更新。</p>
<p>例如：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值大于前数据库中的 version 值时才更新，否则重试更新操作，直到更新成功。</p>
<h3 id="排它锁、共享锁"><a href="#排它锁、共享锁" class="headerlink" title="排它锁、共享锁"></a>排它锁、共享锁</h3><p><code>排它锁</code>其实就是悲观锁机制实现的锁、<code>共享锁</code>就是乐观锁机制实现的锁。</p>
<h2 id="可重入锁、不可重入锁"><a href="#可重入锁、不可重入锁" class="headerlink" title="可重入锁、不可重入锁"></a>可重入锁、不可重入锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">functionA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;iAmFunctionA&quot;</span>);</span><br><span class="line">        functionB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">functionB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;iAmFunctionB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><code>可重入锁</code>：当线程拥有对象的同步方法锁后可访问其他同步方法 ，java中synchronized和ReentrantLock都是可重入锁<br><code>不可重入</code>：当线程拥有对象的同步方法锁后再访问其他同步方法也需要排队或等待</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><code>公平锁</code>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p>
<p><code>非公平锁</code>不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁</p>
<p>synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过构造函数进行设置</p>
<h2 id="Synchronized锁的优化"><a href="#Synchronized锁的优化" class="headerlink" title="Synchronized锁的优化"></a>Synchronized锁的优化</h2><p>Synchronized</p>
<p>在Java中<code>Synchronized</code>是我们常用的<code>同步互斥手段</code>，在早期版本中，它是一个<code>悲观锁</code>设计下的<code>独占锁</code>，并且<code>可重入</code>。<code>Synchronized在获取到同步锁后，其他线程将会阻塞，对于阻塞或者唤醒一个线程都需要操作系统来完成，这就需要从用户态切换到内核态，这样的操作就需要消耗很多处理器时间，具有很强的性能损耗</code>，因此Synchronized在1.6中做了很多的优化，减少频繁的切换到内核态。</p>
<p>在1.6之中为了提高Synchronized的性能，增加了<code>自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等来高效地共享数据，解决竞争问题</code>。<br><code>自旋锁</code>:在多线程操作中共享数据的锁定可能是和短暂的，避免线程在很短的时间内做用户态的切换，那么在允许多线程并行的基础上，让后面请求锁的线程“等待一下”，等待过程不放弃处理器的执行时间，为了让线程等待只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br><code>自适应自旋</code>是对自旋锁的优化，自旋锁的缺点就是如果锁占用的时间很长，那么就会浪费处理器资源，并且还对处理器有要求。加入自适应自旋就是自旋的时间不再固定，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态决定，如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋很可能再次成功，应此可能允许等待时间更长；如果某一个锁上，很少自旋成功，那么将跳过自旋过程，避免资源浪费。虚拟机使用这一的策略和技术完成对Synchronized的一种优化</p>
<p><code>锁消除</code>是指在虚拟机及时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除如：消除锁的判断主要来于逃逸分析的数据支持，如果判断在一段代码中，堆上的数据都不会逃逸出去从而被其他线程访问到，那么就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁就自热无效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1,String s2，String s3)</span></span>&#123;</span><br><span class="line">	StringBuffer sb=<span class="keyword">new</span> SrringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	sb.append(s3);</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>对于上述代码，StringBuffer.append()方法都具有一个同步块，锁就是对象sb,但sb变量永远不会被其他线程所访问，其一直动态作用域被限制在concatString方法中，其他线程并不能访问。因此此处的锁可以被安全的消除掉。</p>
<p><code>锁粗化</code>一段代码里面对同一个对象进行反复的加锁和解锁，那么也会带来性能的损耗，应该将锁同步范围扩展（粗化）到整个操作序列的外部。如上面代码就是扩展到第一个append()操作之前直至追后一个append()操作之后，这样就只需要加一次锁</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的作用是在没有多线程的前提下，<code>减少重量级锁在使用操作系统互斥量产生的新能消耗</code>。在无竞争的情况下获取锁使用的是<code>CAS</code>操作。CAS操作主要是用于更新对象头中thread ID， 要理解轻量级锁，得先了解HotPost虚拟机的对象头部分，对象头中一部分保存这GC年龄代，哈希码等信息，官方称为Mark Work，在32位的HotPost下，PostMark Work的32bit存储空间中，有25bit用于存储对象哈希码，4bit用于存储对象的分代年龄，2bit用于存储锁标志位，1bit固定为0；</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空、不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向锁ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>偏向锁</code>是<code>在无竞争的情况下把整个同步都消除掉</code>，偏向锁的意思是<code>同步锁会偏向第一次获得它的线程，如果在接下来的执行中，该锁没有其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</code>。使用偏向锁需要虚拟机默认支持，如果在没有设置的情况下将不支持偏向锁。接下来用一张图讲解轻量级锁和偏向锁的转换关系</p>
<h3 id="轻量级锁、偏向锁的状态准换"><a href="#轻量级锁、偏向锁的状态准换" class="headerlink" title="轻量级锁、偏向锁的状态准换"></a>轻量级锁、偏向锁的状态准换</h3><p><img data-src="https://img-blog.csdnimg.cn/20190507233042199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oZWcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>首先根据<code>偏向锁可用</code>和<code>不可用</code>分为左右两种逻辑</p>
<p><code>可偏向左边上面部分</code>：如果偏向锁可用，初始化的的对象标志位为01，那么这是一个未锁定、未偏向但是可偏向的对象</p>
<p><code>可偏向左边下面部分</code>：当第一次线程获取到锁的时候，那么虚拟机将头中的标志位设置为<code>01</code>，<code>同时使用CAS操作将线程的thread ID写入到Mark Work中</code>，成功后，持有偏向锁的线程再进入这个锁的相关同步块时，都不用做同步操作。<br>对象Mark Work中写入了thread ID状态下，对象可能处于锁定状态或未锁定状态。如果是<code>在锁定</code>情况下，有另一个线程去获取这个锁时，偏向锁模式将结束，将回到轻量级锁定。<br>如果是在<code>没有锁定</code>状态下，有另一个线程去获取这个锁时，偏向锁模式将结束，将回到未锁定、未偏向但是可偏向状态，如果撤销偏向，将回到未锁定、不可偏向对象</p>
<p><code>不可偏向右上部分</code>：如果偏向锁不可用，初始化的的对象标志位为<code>01</code>，那么这是一个未锁定、不可偏向对象</p>
<p><code>不可偏向中间部分</code>：当有一个线程获取同步对象时，如果同步对象没有被锁定，那么在<code>当前线程的栈帧中开辟一个叫“Lock Record”的空间保存一份同步对象的Mark Word部分的拷贝，并且使用CAS操作将这个对象的Mark Word更新指向栈帧的“Lock Record”</code>，如果成功，那么将标志位改为<code>00</code>；如果更新失败，但当前线程已经拥有对象锁，那就直接运行同步块代码；否则说明有线程在争夺锁，那么轻量级锁就不再有效，要膨胀成重量级锁</p>
<p><code>不可偏向下面部分</code>：当同步对象已经是轻量级锁，但有另一个线程在竞争锁资源时，轻量级锁将膨胀成重量级锁，锁的标志位状态值变为<code>“10”</code>，Mark Word中存储的指向重量级锁的指针，后面等待锁的线程也将进入阻塞状态。</p>
<p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS-对资源的共享⽅式"><a href="#AQS-对资源的共享⽅式" class="headerlink" title="AQS 对资源的共享⽅式"></a>AQS 对资源的共享⽅式</h2><p>AQS定义两种资源共享⽅式</p>
<p><strong>Exclusive（独占）</strong>：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：</p>
<ul>
<li><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p>
</li>
<li><p>⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的</p>
</li>
</ul>
<p><strong>Share（共享）</strong>：多个线程可同时执⾏，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后⾯讲到。</p>
<p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：</p>
<p><img data-src="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png" alt="img" loading="lazy"></p>
<h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink" title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p>
<p><img data-src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img" loading="lazy"></p>
<p>下面通过伪代码，进行更加直观的比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; **************************Synchronized的使用方式**************************</span><br><span class="line">&#x2F;&#x2F; 1.用于代码块</span><br><span class="line">synchronized (this) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 2.用于对象</span><br><span class="line">synchronized (object) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 3.用于方法</span><br><span class="line">public synchronized void test () &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 4.可重入</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">	synchronized (this) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; **************************ReentrantLock的使用方式**************************</span><br><span class="line">public void test () throw Exception &#123;</span><br><span class="line">	&#x2F;&#x2F; 1.初始化选择公平锁、非公平锁</span><br><span class="line">	ReentrantLock lock &#x3D; new ReentrantLock(true);</span><br><span class="line">	&#x2F;&#x2F; 2.可用于代码块</span><br><span class="line">	lock.lock();</span><br><span class="line">	try &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; 3.支持多种加锁方式，比较灵活; 具有可重入特性</span><br><span class="line">			if(lock.tryLock(100, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			&#x2F;&#x2F; 4.手动释放锁</span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink" title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5qUTVNVEk1T0E9PSZtaWQ9MjY1MTc0OTQzNCZpZHg9MyZzbj01ZmZhNjNhZDQ3ZmUxNjZmMmYxYTlmNjA0ZWQxMDA5MSZjaGtzbT1iZDEyYTU3NzhhNjUyYzYxNTA5ZDllNzE4YWIwODZmZjI3YWQ4NzY4NTg2ZWE5YjM4YzNkY2Y5ZTAxN2E4ZTQ5YmNhZTNkZjliY2M4JnNjZW5lPTM4I3dlY2hhdF9yZWRpcmVjdA==">不可不说的Java“锁”事<i class="fa fa-external-link-alt"></i></span>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p>
<p>非公平锁源码中的加锁流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock#NonfairSync</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非公平锁</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">	...</span><br><span class="line">	final void lock() &#123;</span><br><span class="line">		if (compareAndSetState(0, 1))</span><br><span class="line">			setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">		else</span><br><span class="line">			acquire(1);</span><br><span class="line">		&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块代码的含义为：</p>
<ul>
<li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li>
<li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li>
</ul>
<p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p>
<ul>
<li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li>
</ul>
<p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p>
<p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<ul>
<li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li>
<li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li>
<li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li>
</ul>
<p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock#FairSync</span><br><span class="line"></span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">  ...  </span><br><span class="line">	final void lock() &#123;</span><br><span class="line">		acquire(1);</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
<p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p>
<p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p>
<h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p>
<p><img data-src="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img" loading="lazy"></p>
<ul>
<li>上图中有颜色的为Method，无颜色的为Attribution。</li>
<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>
<li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>
<p><img data-src="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt="img" loading="lazy"></p>
<h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p>主要原理图如下：</p>
<p><img data-src="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png" alt="img" loading="lazy"></p>
<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<h4 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构</h4><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>
<p><img data-src="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png" alt="img" loading="lazy"></p>
<p>解释一下几个方法和属性值的含义：</p>
<table>
<thead>
<tr>
<th align="left">方法和属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">waitStatus</td>
<td align="left">当前节点在队列中的状态</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示处于该节点的线程</td>
</tr>
<tr>
<td align="left">prev</td>
<td align="left">前驱指针</td>
</tr>
<tr>
<td align="left">predecessor</td>
<td align="left">返回前驱节点，没有的话抛出npe</td>
</tr>
<tr>
<td align="left">nextWaiter</td>
<td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">后继指针</td>
</tr>
</tbody></table>
<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody></table>
<h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h4><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure>

<p>下面提供了几个访问这个字段的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">protected final int getState()</td>
<td align="left">获取State的值</td>
</tr>
<tr>
<td align="left">protected final void setState(int newState)</td>
<td align="left">设置State的值</td>
</tr>
<tr>
<td align="left">protected final boolean compareAndSetState(int expect, int update)</td>
<td align="left">使用CAS方式更新State</td>
</tr>
</tbody></table>
<p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>
<p><img data-src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png" alt="img" loading="lazy"><img data-src="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img" loading="lazy"></p>
<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p>
<h2 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink" title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">protected boolean isHeldExclusively()</td>
<td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>
</tr>
<tr>
<td align="left">protected boolean tryAcquire(int arg)</td>
<td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td align="left">protected boolean tryRelease(int arg)</td>
<td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td align="left">protected int tryAcquireShared(int arg)</td>
<td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
</tr>
<tr>
<td align="left">protected boolean tryReleaseShared(int arg)</td>
<td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>
</tr>
</tbody></table>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>
<p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p>
<p><img data-src="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png" alt="img" loading="lazy"></p>
<p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p>
<p><img data-src="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png" alt="img" loading="lazy"></p>
<p>加锁：</p>
<ul>
<li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li>
<li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li>
<li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li>
<li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li>
</ul>
<p>解锁：</p>
<ul>
<li>通过ReentrantLock的解锁方法Unlock进行解锁。</li>
<li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li>
<li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>
<li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li>
</ul>
<p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p>
<p><img data-src="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt="img" loading="lazy"></p>
<h2 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink" title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h2><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p>
<p>在非公平锁中，有一段这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">	...</span><br><span class="line">	final void lock() &#123;</span><br><span class="line">		if (compareAndSetState(0, 1))</span><br><span class="line">			setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">		else</span><br><span class="line">			acquire(1);</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下这个Acquire是怎么写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下tryAcquire方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">	throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p>
<h3 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列</h3><h4 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1 加入队列的时机</h4><p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p>
<h4 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列</h4><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">	Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">	&#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">	Node pred &#x3D; tail;</span><br><span class="line">	if (pred !&#x3D; null) &#123;</span><br><span class="line">		node.prev &#x3D; pred;</span><br><span class="line">		if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">			pred.next &#x3D; node;</span><br><span class="line">			return node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enq(node);</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">	return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的流程如下：</p>
<ul>
<li>通过当前的线程和锁模式新建一个节点。</li>
<li>Pred指针指向尾节点Tail。</li>
<li>将New中Node的Prev指针指向Pred。</li>
<li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		stateOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">		headOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">		tailOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">		waitStatusOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">		nextOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line">	&#125; catch (Exception ex) &#123; </span><br><span class="line">    throw new Error(ex); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p>
<ul>
<li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		Node t &#x3D; tail;</span><br><span class="line">		if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">			if (compareAndSetHead(new Node()))</span><br><span class="line">				tail &#x3D; head;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			node.prev &#x3D; t;</span><br><span class="line">			if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">				t.next &#x3D; node;</span><br><span class="line">				return t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p>
<p>总结一下，线程获取锁的时候，过程大体如下：</p>
<ol>
<li>当没有线程获取到锁时，线程1获取锁成功。</li>
<li>线程2申请锁，但是锁被线程1占有。</li>
</ol>
<p><img data-src="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png" alt="img" loading="lazy"></p>
<ol>
<li>如果再有线程要获取锁，依次在队列中往后排队即可。</li>
</ol>
<p>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">	&#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class="line">	&#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class="line">	&#x2F;&#x2F; thread is first in queue.</span><br><span class="line">	Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class="line">	Node h &#x3D; head;</span><br><span class="line">	Node s;</span><br><span class="line">	return h !&#x3D; t &amp;&amp; ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p>
<blockquote>
<p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><br><span class="line"></span><br><span class="line">if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">	if (compareAndSetHead(new Node()))</span><br><span class="line">		tail &#x3D; head;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	node.prev &#x3D; t;</span><br><span class="line">	if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">		t.next &#x3D; node;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p>
<h4 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink" title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h4><p>回到最初的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p>
<p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>
<p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">	&#x2F;&#x2F; 标记是否成功拿到资源</span><br><span class="line">	boolean failed &#x3D; true;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F; 标记等待过程中是否中断过</span><br><span class="line">		boolean interrupted &#x3D; false;</span><br><span class="line">		&#x2F;&#x2F; 开始自旋，要么获取锁，要么中断</span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			&#x2F;&#x2F; 获取当前节点的前驱节点</span><br><span class="line">			final Node p &#x3D; node.predecessor();</span><br><span class="line">			&#x2F;&#x2F; 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><br><span class="line">			if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">				&#x2F;&#x2F; 获取锁成功，头指针移动到当前node</span><br><span class="line">				setHead(node);</span><br><span class="line">				p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">				failed &#x3D; false;</span><br><span class="line">				return interrupted;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><br><span class="line">			if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">				interrupted &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (failed)</span><br><span class="line">			cancelAcquire(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">	head &#x3D; node;</span><br><span class="line">	node.thread &#x3D; null;</span><br><span class="line">	node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 靠前驱节点判断当前线程是否应该被阻塞</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取头结点的节点状态</span><br><span class="line">	int ws &#x3D; pred.waitStatus;</span><br><span class="line">	&#x2F;&#x2F; 说明头结点处于唤醒状态</span><br><span class="line">	if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">		return true; </span><br><span class="line">	&#x2F;&#x2F; 通过枚举值我们知道waitStatus&gt;0是取消状态</span><br><span class="line">	if (ws &gt; 0) &#123;</span><br><span class="line">		do &#123;</span><br><span class="line">			&#x2F;&#x2F; 循环向前查找取消节点，把取消节点从队列中剔除</span><br><span class="line">			node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">		&#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">		pred.next &#x3D; node;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F; 设置前任节点等待状态为SIGNAL</span><br><span class="line">		compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的流程图如下：</p>
<p><img data-src="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png" alt="img" loading="lazy"></p>
<p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p>
<p><img data-src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png" alt="img" loading="lazy"></p>
<p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>
<ul>
<li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li>
<li>是在什么时间释放节点通知到被挂起的线程呢？</li>
</ul>
<h3 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink" title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h3><p>acquireQueued方法中的Finally代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">	boolean failed &#x3D; true;</span><br><span class="line">	try &#123;</span><br><span class="line">    ...</span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			final Node p &#x3D; node.predecessor();</span><br><span class="line">			if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">				...</span><br><span class="line">				failed &#x3D; false;</span><br><span class="line">        ...</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (failed)</span><br><span class="line">			cancelAcquire(node);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将无效节点过滤</span><br><span class="line">	if (node &#x3D;&#x3D; null)</span><br><span class="line">		return;</span><br><span class="line">  &#x2F;&#x2F; 设置该节点不关联任何线程，也就是虚节点</span><br><span class="line">	node.thread &#x3D; null;</span><br><span class="line">	Node pred &#x3D; node.prev;</span><br><span class="line">  &#x2F;&#x2F; 通过前驱节点，跳过取消状态的node</span><br><span class="line">	while (pred.waitStatus &gt; 0)</span><br><span class="line">		node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">  &#x2F;&#x2F; 获取过滤后的前驱节点的后继节点</span><br><span class="line">	Node predNext &#x3D; pred.next;</span><br><span class="line">  &#x2F;&#x2F; 把当前node的状态设置为CANCELLED</span><br><span class="line">	node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">  &#x2F;&#x2F; 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span><br><span class="line">  &#x2F;&#x2F; 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span><br><span class="line">	if (node &#x3D;&#x3D; tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">		compareAndSetNext(pred, predNext, null);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		int ws;</span><br><span class="line">    &#x2F;&#x2F; 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span><br><span class="line">    &#x2F;&#x2F; 如果1和2中有一个为true，再判断当前节点的线程是否为null</span><br><span class="line">    &#x2F;&#x2F; 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span><br><span class="line">		if (pred !&#x3D; head &amp;&amp; ((ws &#x3D; pred.waitStatus) &#x3D;&#x3D; Node.SIGNAL || (ws &lt;&#x3D; 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread !&#x3D; null) &#123;</span><br><span class="line">			Node next &#x3D; node.next;</span><br><span class="line">			if (next !&#x3D; null &amp;&amp; next.waitStatus &lt;&#x3D; 0)</span><br><span class="line">				compareAndSetNext(pred, predNext, next);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span><br><span class="line">			unparkSuccessor(node);</span><br><span class="line">		&#125;</span><br><span class="line">		node.next &#x3D; node; &#x2F;&#x2F; help GC</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前的流程：</p>
<ul>
<li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li>
<li>根据当前节点的位置，考虑以下三种情况：</li>
</ul>
<p>(1) 当前节点是尾节点。</p>
<p>(2) 当前节点是Head的后继节点。</p>
<p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p>
<p>根据上述第二条，我们来分析每一种情况的流程。</p>
<p>当前节点是尾节点。</p>
<p><img data-src="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png" alt="img" loading="lazy"></p>
<p>当前节点是Head的后继节点。</p>
<p><img data-src="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png" alt="img" loading="lazy"></p>
<p>当前节点不是Head的后继节点，也不是尾节点。</p>
<p><img data-src="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png" alt="img" loading="lazy"></p>
<p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p>
<blockquote>
<p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">	node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h3><p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">	sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，本质释放锁的地方，是通过框架来完成的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	if (tryRelease(arg)) &#123;</span><br><span class="line">		Node h &#x3D; head;</span><br><span class="line">		if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">			unparkSuccessor(h);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.Sync</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法返回当前锁是不是没有被线程持有</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">	&#x2F;&#x2F; 减少可重入次数</span><br><span class="line">	int c &#x3D; getState() - releases;</span><br><span class="line">	&#x2F;&#x2F; 当前线程不是持有锁的线程，抛出异常</span><br><span class="line">	if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">		throw new IllegalMonitorStateException();</span><br><span class="line">	boolean free &#x3D; false;</span><br><span class="line">	&#x2F;&#x2F; 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br><span class="line">	if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		free &#x3D; true;</span><br><span class="line">		setExclusiveOwnerThread(null);</span><br><span class="line">	&#125;</span><br><span class="line">	setState(c);</span><br><span class="line">	return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来解释下述源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	&#x2F;&#x2F; 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><br><span class="line">	if (tryRelease(arg)) &#123;</span><br><span class="line">		&#x2F;&#x2F; 获取头结点</span><br><span class="line">		Node h &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F; 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><br><span class="line">		if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">			unparkSuccessor(h);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p>
<blockquote>
<p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p>
<p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p>
<p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p>
</blockquote>
<p>再看一下unparkSuccessor方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取头结点waitStatus</span><br><span class="line">	int ws &#x3D; node.waitStatus;</span><br><span class="line">	if (ws &lt; 0)</span><br><span class="line">		compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">	&#x2F;&#x2F; 获取当前节点的下一个节点</span><br><span class="line">	Node s &#x3D; node.next;</span><br><span class="line">	&#x2F;&#x2F; 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><br><span class="line">	if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">		s &#x3D; null;</span><br><span class="line">		&#x2F;&#x2F; 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><br><span class="line">		for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">			if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">				s &#x3D; t;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 如果当前节点的下个节点不为空，而且状态&lt;&#x3D;0，就把当前节点unpark</span><br><span class="line">	if (s !&#x3D; null)</span><br><span class="line">		LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p>
<p>之前的addWaiter方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">	Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">	&#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">	Node pred &#x3D; tail;</span><br><span class="line">	if (pred !&#x3D; null) &#123;</span><br><span class="line">		node.prev &#x3D; pred;</span><br><span class="line">		if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">			pred.next &#x3D; node;</span><br><span class="line">			return node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enq(node);</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>
<p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p>
<h3 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4 中断恢复后的执行流程</h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">	LockSupport.park(this);</span><br><span class="line">	return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">	boolean failed &#x3D; true;</span><br><span class="line">	try &#123;</span><br><span class="line">		boolean interrupted &#x3D; false;</span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			final Node p &#x3D; node.predecessor();</span><br><span class="line">			if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">				setHead(node);</span><br><span class="line">				p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">				failed &#x3D; false;</span><br><span class="line">				return interrupted;</span><br><span class="line">			&#125;</span><br><span class="line">			if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">				interrupted &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (failed)</span><br><span class="line">			cancelAcquire(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果acquireQueued为True，就会执行selfInterrupt方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">	Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p>
<h3 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h3><p>我们在1.3小节中提出了一些问题，现在来回答一下。</p>
<blockquote>
<p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是CLH变体的FIFO双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：可以详细看下2.3.1.3小节。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p>
<p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>
</blockquote>
<h2 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h2><h3 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink" title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h3><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p>
<p>公平锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span><br><span class="line"></span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</span><br><span class="line">		setExclusiveOwnerThread(current);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">	int nextc &#x3D; c + acquires;</span><br><span class="line">	if (nextc &lt; 0)</span><br><span class="line">		throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">	setState(nextc);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span><br><span class="line"></span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	if (compareAndSetState(0, acquires))&#123;</span><br><span class="line">		setExclusiveOwnerThread(current);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">	int nextc &#x3D; c + acquires;</span><br><span class="line">	if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">		throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">	setState(nextc);</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure>

<p>接下来看State这个字段主要的过程：</p>
<ol>
<li>State初始化的时候为0，表示没有任何线程持有锁。</li>
<li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li>
<li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li>
</ol>
<h3 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景</h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p>
<table>
<thead>
<tr>
<th align="left">同步工具</th>
<th align="left">同步工具与AQS的关联</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ReentrantLock</td>
<td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>
</tr>
<tr>
<td align="left">Semaphore</td>
<td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td>
</tr>
<tr>
<td align="left">CountDownLatch</td>
<td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>
</tr>
<tr>
<td align="left">ReentrantReadWriteLock</td>
<td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td>
</tr>
<tr>
<td align="left">ThreadPoolExecutor</td>
<td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>
</tr>
</tbody></table>
<h3 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h3><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LeeLock  &#123;</span><br><span class="line"></span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire (int arg) &#123;</span><br><span class="line">            return compareAndSetState(0, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease (int arg) &#123;</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively () &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Sync sync &#x3D; new Sync();</span><br><span class="line">    </span><br><span class="line">    public void lock () &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void unlock () &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过我们自己定义的Lock完成一定的同步功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LeeMain &#123;</span><br><span class="line"></span><br><span class="line">    static int count &#x3D; 0;</span><br><span class="line">    static LeeLock leeLock &#x3D; new LeeLock();</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run () &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(runnable);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。</p>
<p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p>
<p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，并返或true，否则返回false。整个比较并替换的操作是一个原子操作。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上面源码分析时，提到最后调用了compareAndSwapInt方法，接着继续深入探讨该方法，该方法在Unsafe中对应的源码如下。</p>
<p><img data-src="https://img-blog.csdn.net/20180314222522710" alt="img" loading="lazy"></p>
<p>可以看到调用了“Atomic::cmpxchg”方法，“Atomic::cmpxchg”方法在linux_x86和windows_x86的实现如下。</p>
<p><strong>linux_x86的实现：</strong></p>
<p><img data-src="https://img-blog.csdn.net/20180314222533843" alt="img" loading="lazy"></p>
<p><strong>windows_x86的实现：</strong></p>
<p><img data-src="https://img-blog.csdn.net/20180314222539318" alt="img" loading="lazy"></p>
<p><strong>Atomic::cmpxchg方法解析：</strong></p>
<p>mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。</p>
<ol>
<li>如果当前系统是多处理器，该函数返回1。</li>
<li>否则，返回0。</li>
</ol>
<p>LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。</p>
<ol>
<li>如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。</li>
<li>否则，不加lock前缀。</li>
</ol>
<p>这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。</p>
<h2 id="intel手册对lock前缀的说明如下："><a href="#intel手册对lock前缀的说明如下：" class="headerlink" title="intel手册对lock前缀的说明如下："></a>intel手册对lock前缀的说明如下：</h2><ol>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第1点保证了CAS操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有volatile读和volatile写的内存语义。</p>
<h2 id="CAS的缺点："><a href="#CAS的缺点：" class="headerlink" title="CAS的缺点："></a>CAS的缺点：</h2><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>
<ol>
<li>循环时间长开销很大。</li>
<li>只能保证一个变量的原子操作。</li>
<li>ABA问题。</li>
</ol>
<h2 id="循环时间长开销很大："><a href="#循环时间长开销很大：" class="headerlink" title="循环时间长开销很大："></a>循环时间长开销很大：</h2><p>CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>
<h2 id="只能保证一个变量的原子操作："><a href="#只能保证一个变量的原子操作：" class="headerlink" title="只能保证一个变量的原子操作："></a>只能保证一个变量的原子操作：</h2><p>当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p>
<h2 id="什么是ABA问题？ABA问题怎么解决？"><a href="#什么是ABA问题？ABA问题怎么解决？" class="headerlink" title="什么是ABA问题？ABA问题怎么解决？"></a>什么是ABA问题？ABA问题怎么解决？</h2><p>在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。 假设有以下顺序事件：</p>
<blockquote>
<p>1、线程1从内存位置V中取出A </p>
<p>2、线程2从内存位置V中取出A </p>
<p>3、线程2进行了写操作，将B写入内存位置V </p>
<p>4、线程2将A再次写入内存位置V </p>
<p>5、线程1进行CAS操作，发现V中仍然是A，交换成功</p>
</blockquote>
<p>尽管线程1的CAS操作成功，但线程1并不知道内存位置V的数据发生过改变</p>
<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。根据实际情况，判断是否处理ABA问题。如果ABA问题并不会影响我们的业务结果，可以选择性处理或不处理;如果ABA会影响我们的业务结果的，这时就必须处理ABA问题了。对于AtomicInteger等,没有什么可修改的属性;且我们只在意其结果值，所以对于这些类来说，本身就算发生了ABA现象，也不会对原线程的结果造成什么影响。</p>
<p>这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类<strong>“AtomicStampedReference”</strong>，它可以通过<strong>控制变量值的版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>1.使⽤ volatile 修饰变量就可以<strong>禁⽌ JVM 的指令重排</strong>，保证在多线程环境下也能正常运⾏。 </p>
<p>2.在 JDK1.2 之前，<strong>Java 的内存模型</strong>实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致。要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使⽤它都到主存中进⾏读取。所以，volatile 关键字 除了防⽌ JVM 的指令重排 ，还有⼀个重要的作⽤就是<strong>保证变量的可⻅性。</strong></p>
<h1 id="内存屏蔽"><a href="#内存屏蔽" class="headerlink" title="内存屏蔽"></a>内存屏蔽</h1><h2 id="1-指令重排序"><a href="#1-指令重排序" class="headerlink" title="1. 指令重排序"></a>1. 指令重排序</h2><p>程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能。这种内存乱序问题主要是由两种原因引起的：</p>
<ul>
<li>编译器在编译时进行了编译优化，导致指令重排；</li>
<li>在多cpu环境下，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。</li>
</ul>
<p><strong>为什么需要内存屏障</strong><br>我们知道，在多CPU（核）场景下，为了充分利用CPU，会通过流水线将指令并行进行。为了能并行执行，又需要将指令进行重排序以便进行并行执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则（如Happens Before 规则）之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性, 不能确保内存与CPU缓存数据一致性的指令也不能重排，<strong>内存屏障正是通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法</strong>。</p>
<h2 id="2-java-内存模型中的happen-before原则"><a href="#2-java-内存模型中的happen-before原则" class="headerlink" title="2. java 内存模型中的happen before原则"></a>2. java 内存模型中的happen before原则</h2><p>JSR-1337制定了Java内存模型(Java Memory Model, JMM)中规定的hb原则大致有以下几点：</p>
<ul>
<li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li>
<li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li>
<li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li>
<li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li>
<li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li>
<li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li>
<li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li>
<li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li>
</ul>
<p>jmm 对java语义的比较重要的两个扩展是：</p>
<ul>
<li>对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。</li>
<li>对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（前提是没有this引用溢出）。</li>
</ul>
<h2 id="3-内存屏障-Memory-Barrier"><a href="#3-内存屏障-Memory-Barrier" class="headerlink" title="3. 内存屏障(Memory Barrier)"></a>3. 内存屏障(Memory Barrier)</h2><ul>
<li>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。</li>
<li>Memory barrier是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</li>
<li>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。</li>
</ul>
<p>Memory Barrier可以被分为以下几种类型：</p>
<ul>
<li><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
</li>
<li><p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>
</li>
<li><p><strong>Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序</strong>。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。具体用法可以看下disruptor的Sequence的set方法。</p>
</li>
<li><p>Intel 64/IA-32架构下写操作之间不会发生重排序，也就是说在处理器上操作的顺序是可以保证的，这时候使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。采用putOrderedObject可以解决这个问题。</p>
</li>
<li><p>即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。</p>
</li>
</ul>
<h2 id="4-volatile语义中的内存屏障"><a href="#4-volatile语义中的内存屏障" class="headerlink" title="4. volatile语义中的内存屏障"></a>4. volatile语义中的内存屏障</h2><ul>
<li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li>
<li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li>
</ul>
<p>volatile的内存屏障策略非常严格保守，保证了线程可见性。</p>
<h2 id="5-final语义中的内存屏障"><a href="#5-final语义中的内存屏障" class="headerlink" title="5. final语义中的内存屏障"></a>5. final语义中的内存屏障</h2><ul>
<li>新建对象过程中，构造体中对final域的初始化写入(StoreStore屏障)和这个对象赋值给其他引用变量，这两个操作不能重排序；</li>
<li>初次读包含final域的对象引用和读取这个final域（LoadLoad屏障），这两个操作不能重排序；</li>
<li>Intel 64/IA-32架构下写操作之间不会发生重排序StoreStore会被省略，这种架构下也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li>
</ul>
<p><strong>常见的应用场景</strong></p>
<p>（1）通过 Synchronized关键字包住的代码区域,当线程进入到该区域读取变量信息时,保证读到的是最新的值.这是因为在同步区内对变量的写入操作,在离开同步区时就将当前线程内的数据刷新到内存中,而对数据的读取也不能从缓存读取,只能从内存中读取,保证了数据的读有效性.这就是插入了StoreStore屏障；<br>（2）使用了volatile修饰变量,则对变量的写操作,会插入StoreLoad屏障；<br>（3）其余的操作,则需要通过Unsafe这个类来执行；</p>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Dawn-yhc 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Dawn-yhc 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文博主： </strong>Dawn-yhc
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html" title="锁">https://yuhaicheng.xyz/2020-11-18-锁.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%94%81/" rel="tag"><i class="fa fa-tag"></i> 锁</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020-11-17-%E9%93%BE%E8%A1%A8.html" rel="prev" title="链表">
                  <i class="fa fa-chevron-left"></i> 链表
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020-11-18-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8.html" rel="next" title="集合容器">
                  集合容器 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NDkyOC8yMTQ1MA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawn-yhc</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">295k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:28</span>
  </span>
</div><div class="footer-custom">

<span id="jinrishici-sentence">正在加载今日诗词....</span>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/jinrishici.js" charset="utf-8" async="async"></script>
</div>
<script color= "255, 255, 255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>
<div>
    <canvas id="snow" width="570" height="696"></canvas>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/snow.min.js" async="async"></script>
</div>
<!-- 社会主义价值观 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/text.js" async="async"></script>


    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/motion.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/local-search.js"></script>










<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>



  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>


  








    <div class="pjax">
  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html',]
      });
      });
  </script>

<script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "2020-11-18-锁.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
</body>
</html>
