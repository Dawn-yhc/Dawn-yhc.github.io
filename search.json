[{"title":"最方便的 Hexo 部署","url":"/2.html","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: git</span><br><span class=\"line\">    repo:</span><br><span class=\"line\">      github:</span><br><span class=\"line\">        url: https:&#x2F;&#x2F;github.com:name&#x2F;name.git</span><br><span class=\"line\">        branch: master</span><br><span class=\"line\">        token: GitHub_Personal_Access_Token</span><br><span class=\"line\">    name: name</span><br><span class=\"line\">    email: email@163.com</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuY2YvMy5odG1s\">获取 GitHub Personal Access Token 方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<a id=\"more\"></a>\n\n\n\n","categories":["Hexo"],"tags":["Next"]},{"title":"枯燥的学习","url":"/2020-10-02-%E6%9E%AF%E7%87%A5%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%AD.html","content":"<h1 id=\"面对生活\"><a href=\"#面对生活\" class=\"headerlink\" title=\"面对生活\"></a>面对生活</h1><p>一个人最好的生活状态： 该看书时看书，该玩时尽情玩； 看见优秀的人欣赏，看见落魄的人也不轻视； 有自己的小生活和小情趣， 不用去想改变世界，努力去活出自己； 没有人爱时专注自己，有人爱时有能力拥抱彼此。</p>\n","categories":["生活"],"tags":["加油"]},{"title":"JAVA 基础笔试题","url":"/2020-10-27-java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98.html","content":"<p>1.笔试题：Java中子类和父类相关方法的执行顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sup</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是父类中的无参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sup</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是父类中的有参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;代码块_父类sup&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;static_sup&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">p</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sup</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sub</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是子类中的无参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sub</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是子类中的有参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;代码块_子类sub&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;static_sub&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">p</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Sup s = new Sup();</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t Sup s = <span class=\"keyword\">new</span> Sup();</span><br><span class=\"line\">\t\t  Sub s2 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">\t\t  System.out.println(s2.p());</span><br><span class=\"line\">\t\t  System.out.println(s.p());</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t <span class=\"comment\">// Sup s1 = new Sub();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sub s3 = new Sub(3);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sup s4 = new Sup(3);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sub s5 = new Sub(5);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sup s6 = new Sub(6);</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//System.out.println(s.p());</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    结果</span><br><span class=\"line\">        static_sup</span><br><span class=\"line\">        static_sub</span><br><span class=\"line\">        代码块_父类sup</span><br><span class=\"line\">        我是父类中的无参构造方法</span><br><span class=\"line\">        代码块_父类sup</span><br><span class=\"line\">        我是父类中的有参构造方法</span><br><span class=\"line\">        代码块_子类sub</span><br><span class=\"line\">        我是子类中的无参构造方法</span><br><span class=\"line\">        <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结</p>\n<p>new一个类对象，类中各部分执行顺序：静态代码块—非静态代码块—构造函数—一般方法。</p>\n<p>子类继承父类各部分执行顺序为：父静态代码块–子静态代码块–父非静态代码–父无参构造函数–子静态代码块–子构造函数–方法。</p>\n<p>注意：创建子类对象调用子类的构造方法的时候会先调用父类的构造方法，在子类的构造方法中调用父类的构造方法是用super()，如果没有写super()，则默认调用父类的无参构造方法。</p>\n","categories":["笔试题"],"tags":["java"]},{"title":"单例模式","url":"/2020-10-28-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html","content":"<p>感觉现在网上介绍的单例模式大部分都很不全面，要不是种类不够，就是写的不够深，介绍的都不全面，所以我会花大量时间写一个单例模式的全面解析，包括介绍、优缺点、多线程下安全与否、模拟攻击单例模式。</p>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p>​        单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>​        单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个 Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。</p>\n<p>​        总之，选择单例模式就是为了避免不一致状态。 </p>\n<h3 id=\"1-饿汉式\"><a href=\"#1-饿汉式\" class=\"headerlink\" title=\"1.饿汉式\"></a>1.饿汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 饿汉式（立即加载）</span></span><br><span class=\"line\"><span class=\"comment\">\t * 饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的</span></span><br><span class=\"line\"><span class=\"comment\">\t * （事实上，通过 反射机制是能够实例化构造方法为 的类的，会使 单例实现失效） </span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton single=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> single;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton.getInstance().hashCode());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSingletonTest singleton = <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">\t\tSingletonTest singleton1 = <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">\t\tsingleton.start();</span><br><span class=\"line\">\t\tsingleton1.start();</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">  </span><br><span class=\"line\">\t线程Thread-<span class=\"number\">0</span>@<span class=\"number\">366712642</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">1</span>@<span class=\"number\">366712642</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-懒汉式\"><a href=\"#2-懒汉式\" class=\"headerlink\" title=\"2.懒汉式\"></a>2.懒汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 懒汉式（延迟加载）：</span></span><br><span class=\"line\"><span class=\"comment\">\t * 该示例虽然用延迟加载方式实现了懒汉式单例，但在多线程环境下会产生多个 对象  是不安全的</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  Singleton s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">                s = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程&quot;</span>+currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SingletonTest s = <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">        SingletonTest s1= <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">        SingletonTest s2= <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">        s.start();</span><br><span class=\"line\">        s1.start();</span><br><span class=\"line\">        s2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">    线程Thread-<span class=\"number\">0</span>@<span class=\"number\">1089813737</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">2</span>@<span class=\"number\">2056467717</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">1</span>@<span class=\"number\">431309546</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-懒汉式（加同步锁、使之安全）\"><a href=\"#3-懒汉式（加同步锁、使之安全）\" class=\"headerlink\" title=\"3.懒汉式（加同步锁、使之安全）\"></a>3.懒汉式（加同步锁、使之安全）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton3</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * 同步锁（解决线程安全问题）： </span></span><br><span class=\"line\"><span class=\"comment\">\t\t在方法上加 synchronized 同步锁或是用同步代码块对类加同步锁，此种方式虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程</span></span><br><span class=\"line\"><span class=\"comment\">\t\t想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。 </span></span><br><span class=\"line\"><span class=\"comment\">\t */</span>\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton3 instance=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton3 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (Singleton3.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">\t                instance=<span class=\"keyword\">new</span> Singleton3();</span><br><span class=\"line\">\t            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t                e.printStackTrace();</span><br><span class=\"line\">\t            &#125; </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton3.getInstance().hashCode());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSingletonTest3 s1 = <span class=\"keyword\">new</span> SingletonTest3();</span><br><span class=\"line\">\t\tSingletonTest3 s2 = <span class=\"keyword\">new</span> SingletonTest3();</span><br><span class=\"line\">\t\tSingletonTest3 s3 = <span class=\"keyword\">new</span> SingletonTest3();</span><br><span class=\"line\">\t\ts1.start();</span><br><span class=\"line\">\t\ts2.start();</span><br><span class=\"line\">\t\ts3.start();</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果：</span><br><span class=\"line\">    线程Thread-<span class=\"number\">2</span>@<span class=\"number\">280481333</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">0</span>@<span class=\"number\">280481333</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">1</span>@<span class=\"number\">280481333</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-双重检查锁（提高同步锁的效率）\"><a href=\"#4-双重检查锁（提高同步锁的效率）\" class=\"headerlink\" title=\"4.双重检查锁（提高同步锁的效率）\"></a>4.双重检查锁（提高同步锁的效率）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton4</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 双重检查锁（提高同步锁的效率）： </span></span><br><span class=\"line\"><span class=\"comment\">\t\t使用双重检查锁进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率。</span></span><br><span class=\"line\"><span class=\"comment\">        这里还用到了volatile关键字来修饰singleton，其最关键的作用是防止指令重排</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton4 instance=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton4 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (Singleton4.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t instance=<span class=\"keyword\">new</span> Singleton4();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不加volatile；问题会出现在创建对象的语句<code>instance=new Singleton4();</code> 上，在java中创建一个对象并非是一个原子操作，可以被分解成三行伪代码：</p>\n<ol>\n<li>分配内存空间</li>\n<li>初始化对象</li>\n<li>将对象指向刚分配的内存空间</li>\n</ol>\n<p>但是有些编译器为了性能的原因，可能会将第二步和第三步进行<strong>重排序（指令重排）</strong>，执行顺序可能就成了：</p>\n<ol>\n<li>分配内存空间</li>\n<li>将对象指向刚分配的内存空间（原第3步）</li>\n<li>初始化对象（原第2步）</li>\n</ol>\n<p>在单线程程序下，重排序不会对最终结果产生影响，但是并发的情况下，可能会导致某些线程访问到未初始化的变量。</p>\n<p>模拟一个2个线程创建单例的场景，如下表：现在考虑重排序后，两个线程发生了以下调用：</p>\n<table>\n<thead>\n<tr>\n<th>Time</th>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>T1</td>\n<td>检查到<code>instance</code>为空</td>\n<td></td>\n</tr>\n<tr>\n<td>T2</td>\n<td>获取锁</td>\n<td></td>\n</tr>\n<tr>\n<td>T3</td>\n<td>再次检查到<code>instance</code>为空</td>\n<td></td>\n</tr>\n<tr>\n<td>T4</td>\n<td>为<code>instance</code>分配内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>T5</td>\n<td>将<code>instance</code>指向已分配的内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>T6</td>\n<td></td>\n<td>检查到<code>instance</code>不为空</td>\n</tr>\n<tr>\n<td>T7</td>\n<td></td>\n<td>访问<code>instance</code>的数据（此时<code>uniqueSingleton</code>对象还未完成初始化）</td>\n</tr>\n<tr>\n<td>T8</td>\n<td>初始化<code>instance</code></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在这种情况下，T7时刻线程B对<code>instance</code>进行的访问，访问的是一个<strong>初始化未完成</strong>的对象，就产生了重大安全隐患。</p>\n<p>按照这样的顺序执行，线程B将会获得一个未初始化的对象，并且自始至终，线程B无需获取锁！</p>\n<h3 id=\"5-静态内部类\"><a href=\"#5-静态内部类\" class=\"headerlink\" title=\"5.静态内部类\"></a>5.静态内部类</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton5</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 静态内部类： </span></span><br><span class=\"line\"><span class=\"comment\">\t\t这种方式引入了一个内部静态类（static class），静态内部类只有在调用时才会加载，它保证了Singleton 实例的延迟初始化，又保证了实例的唯一性。</span></span><br><span class=\"line\"><span class=\"comment\">\t\t它把singleton 的实例化操作放到一个静态内部类中，在第一次调用getInstance() 方法时，JVM 才会去加载InnerObject 类，同时初始化singleton 实例，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t所以能让 getInstance() 方法线程安全。 </span></span><br><span class=\"line\"><span class=\"comment\">\t\t特点是：即能延迟加载，也能保证线程安全。 </span></span><br><span class=\"line\"><span class=\"comment\">\t\t静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerObject</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton5 instance = <span class=\"keyword\">new</span> Singleton5(); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton5 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> InnerObject.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest5</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton5.getInstance().hashCode());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSingletonTest5 s1 = <span class=\"keyword\">new</span> SingletonTest5();</span><br><span class=\"line\">\t\tSingletonTest5 s2 = <span class=\"keyword\">new</span> SingletonTest5();</span><br><span class=\"line\">\t\tSingletonTest5 s3 = <span class=\"keyword\">new</span> SingletonTest5();</span><br><span class=\"line\">\t\ts1.start();</span><br><span class=\"line\">\t\ts2.start();</span><br><span class=\"line\">\t\ts3.start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//反射攻击</span></span><br><span class=\"line\">\t\tSingleton5 singleton = Singleton5.getInstance();</span><br><span class=\"line\">\t    Constructor&lt;Singleton5&gt; constructor = Singleton5.class.getDeclaredConstructor();</span><br><span class=\"line\">\t    constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t    Singleton5 newSingleton = constructor.newInstance();</span><br><span class=\"line\">\t    System.out.println(singleton == newSingleton);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果：</span><br><span class=\"line\">    线程Thread-<span class=\"number\">1</span>@<span class=\"number\">1311878651</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">2</span>@<span class=\"number\">1311878651</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">0</span>@<span class=\"number\">1311878651</span></span><br><span class=\"line\">    flase</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-枚举类实现（防止反射攻击）\"><a href=\"#6-枚举类实现（防止反射攻击）\" class=\"headerlink\" title=\"6.枚举类实现（防止反射攻击）\"></a>6.枚举类实现（防止反射攻击）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String objName;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getObjName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> objName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObjName</span><span class=\"params\">(String objName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.objName = objName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 单例测试</span></span><br><span class=\"line\">        Singleton firstSingleton = Singleton.INSTANCE;</span><br><span class=\"line\">        firstSingleton.setObjName(<span class=\"string\">&quot;firstName&quot;</span>);</span><br><span class=\"line\">        System.out.println(firstSingleton.getObjName());</span><br><span class=\"line\">        Singleton secondSingleton = Singleton.INSTANCE;</span><br><span class=\"line\">        secondSingleton.setObjName(<span class=\"string\">&quot;secondName&quot;</span>);</span><br><span class=\"line\">        System.out.println(firstSingleton.getObjName());</span><br><span class=\"line\">        System.out.println(secondSingleton.getObjName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 反射获取实例测试</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Singleton enumConstant : enumConstants) &#123;</span><br><span class=\"line\">                System.out.println(enumConstant.getObjName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">    firstName</span><br><span class=\"line\">\tsecondName</span><br><span class=\"line\">\tsecondName</span><br><span class=\"line\">\tsecondName</span><br></pre></td></tr></table></figure>\n\n<p>最后一种还不算太会，等会了在说！！！</p>\n","categories":["设计模式"],"tags":["单例设计"]},{"title":"冒泡排序","url":"/2020-11-11-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html","content":"<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p><strong>原理：</strong>冒泡排序法是对一组数据进行两两比较，也就是说第一个元素和第二个元素进行比较，如果第一个元素大于第二个元素，两个元素就交换位置，然后第二个元素再和第三个元素进行比较、交换位置，以此类推到倒数第二个元素结束和倒数第一个元素比较交换。这样经过一次遍历就会得到一组数据中的最大元素，然后再进行一组遍历又会得到剩下元素中最大的元素，直到遍历到排序完成。</p>\n<p><strong>得名：</strong>因为每一次遍历都是从第一个元素开始，中间可能会进行多次两两交换，直到遍历结束获得最大的元素。将元素形象的比作气泡，交换到最后的元素就是这组数据中的最大元素也就是最后浮出水面的气泡，因此得名冒泡排序法。</p>\n<ul>\n<li><strong>时间复杂度（平均）：</strong>O(n²) ；最好O(n)，最差O(n²)</li>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTklQkElRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYvOTY2NDI1Nz9mcj1hbGFkZGlu\">空间复杂度<i class=\"fa fa-external-link-alt\"></i></span>：</strong>O(1)</li>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlOTIlRTUlQkElOEYlRTclQUUlOTclRTYlQjMlOTUlRTclQTglQjMlRTUlQUUlOUElRTYlODAlQTcvOTc2MzI1MA==\">稳定性<i class=\"fa fa-external-link-alt\"></i></span>：</strong>稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">publiv <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[])</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;data.length-i-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(data[j]&gt;data[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> temp=data[j];</span><br><span class=\"line\">               data[j]=data[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">               data[j+<span class=\"number\">1</span>]=temp;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.bubbleSort(data);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length;i++)&#123;</span><br><span class=\"line\">\t   \t\t System.out.print(data[i]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">9</span> <span class=\"number\">18</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> </span><br></pre></td></tr></table></figure>\n\n<p><strong>优化：</strong>看上面的测试可知，在第5次排序时就已经排好序了，但是程序自己不知道，还会一层一层的比较。所以我们可以进行一下优化，设置一个标志位让程序知道什么时候已经排好序了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> []data)</span></span>&#123;</span><br><span class=\"line\">   \t\t <span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">     \t\t   <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"> \t\t\t   &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t   <span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;data.length-i-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span>(data[j]&gt;data[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">int</span> temp=data[j];</span><br><span class=\"line\">\t\t                data[j]=data[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t                data[j+<span class=\"number\">1</span>]=temp;</span><br><span class=\"line\">\t\t                flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t       &#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t    \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">9</span> <span class=\"number\">18</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> </span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["排序算法"],"tags":["简单排序"]},{"title":"插入排序","url":"/2020-11-11-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html","content":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p><strong>原理：</strong>插入排序法就是先选定一个待插入的元素，然后将待插入的元素插入到已经有序的一组数据中。当开始进行遍历时，待插入的元素会和前一个元素进行比较，如果前一个元素大于待插入的元素，就会进行交换元素位置或进行位置移动，直到遇到前一个元素小于当前元素，才会结束当前遍历。继续选定待插入元素继续遍历，当所有待插入元素都已经插入到有序的序列中时排序完成。</p>\n<p><strong>得名：</strong>因为每一次都是将待插入元素插入到一个有序的一组数据中，故得名插入排序法。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(n²)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data[j - <span class=\"number\">1</span>] &gt; data[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = data[j];</span><br><span class=\"line\">                    data[j] = data[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    data[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  \t    <span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">77</span>,<span class=\"number\">88</span>,<span class=\"number\">99</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.insertSorting(data);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length;i++)&#123;</span><br><span class=\"line\">\t    \tSystem.out.print(data[i]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">4</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">4</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">4</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n<p>优化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> []data)</span></span>&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> cur=data[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> per =i;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">while</span>(per &gt;=<span class=\"number\">0</span> &amp;&amp; data[per]&gt;cur)&#123;</span><br><span class=\"line\">\t\t    \t   data[per+<span class=\"number\">1</span>]=data[per];</span><br><span class=\"line\">\t\t    \t   per--;</span><br><span class=\"line\">\t\t       &#125;</span><br><span class=\"line\">\t\t       data[per+<span class=\"number\">1</span>]= cur;</span><br><span class=\"line\">\t\t       System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["简单排序"]},{"title":"选择排序","url":"/2020-11-11-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html","content":"<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p><strong>原理：</strong>选择排序法就是在遍历一组数据之前先选择一个元素，如果后面的元素小于选择的元素，则将后面的元素与选择的元素进行交换，直到遍历到最后一个元素，这样经过一次遍历后就会得到这组数据的最小的元素也就是有序数据的第一个元素。按照这样的方式继续选择元素继续遍历，直到遍历到这组数据完全有序。</p>\n<p><strong>得名：</strong>因为每一次遍历前都要选择一个元素作为基准，跟后面的元素进行比较后交换元素位置，故得名选择排序法。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(n²)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;data.length;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(data[i]&gt;data[j])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp=data[i];</span><br><span class=\"line\">                data[i]=data[j];</span><br><span class=\"line\">                data[j]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">77</span>,<span class=\"number\">88</span>,<span class=\"number\">99</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.selectSort(data);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length;i++)&#123;</span><br><span class=\"line\">\t   \t\t System.out.print(data[i]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n<p><strong>优化：</strong>在排序过程中可能会出现这种情况，当我们进行一趟排序的过程中找到的最小数字就是当前需要交换的位置，也就是说当前位置就是当躺最小的值，就不需要在比较了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort1</span><span class=\"params\">(<span class=\"keyword\">int</span> []data)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> selectminindex=i;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;data.length;j++)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span>(data[j]&lt;data[selectminindex])&#123;</span><br><span class=\"line\">\t\t            \tselectminindex=j;</span><br><span class=\"line\">                    &#125;\t </span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">if</span>(selectminindex!=i)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">int</span> temp=data[i];</span><br><span class=\"line\">\t\t            data[i]=data[selectminindex];</span><br><span class=\"line\">\t\t            data[selectminindex]=temp;</span><br><span class=\"line\">\t\t       &#125;</span><br><span class=\"line\">\t\t       System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["排序算法"],"tags":["简单排序"]},{"title":"希尔排序","url":"/2020-11-12-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html","content":"<p><strong>原理：</strong>希尔排序法就是将一组无序的数据分割成若干个小的子序列分别进行插入排序的方法。因此希尔排序首先要选定一个增量值作为分组的依据，通过增量值的间隔来得到不同的插入排序组，然后对每一组的数据进行插入排序，但增量值要不断地进行递减才能达到排序的目的。</p>\n<p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>\n<p><strong>说明：</strong>希尔排序法的本质是插入排序法，通过递减增量值的方式使得排序变得更加高效，因此希尔排序法也可以叫做缩小增量法。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = data.length/<span class=\"number\">2</span>;<span class=\"comment\">//每次的最大的增量是数组长度的一半，一直到1后排序完成并结束       </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (h &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = h; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i - h; j &gt;= <span class=\"number\">0</span>; j -= h) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (data[j] &gt; data[i]) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> temp = data[i];</span><br><span class=\"line\">                        data[i] = data[j];</span><br><span class=\"line\">                        data[j] = temp;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;h等于&quot;</span>+h+<span class=\"string\">&quot;排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">            h /= <span class=\"number\">2</span>;            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">测试：</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\tDemo_Sort.shellSorting(data);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">h等于<span class=\"number\">5</span>排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>]</span><br><span class=\"line\">h等于<span class=\"number\">2</span>排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">h等于<span class=\"number\">1</span>排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"归并排序","url":"/2020-11-12-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html","content":"<p><strong>原理：</strong>进行归并排序法时首先将一组数据尽可能的拆分成两个个数均等的子组，然后对两个子组继续进行拆分，直到将每个子组的元素个数拆分到1为止，然后开始对相邻的两个子组进行归并，重复归并操作直至所有子组归并为一组时排序完成。</p>\n<p><strong>说明：</strong>归并排序法就是将一组数据先进行连续的拆分后再进行连续的归并，类似于快速排序法也是一种“分治法”的体现。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(n)</li>\n<li><strong>稳定性：</strong>稳定</li>\n<li><strong>排序位置：</strong>非原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSorting</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        assist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[data.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = data.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        sort(data, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] assist;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> low     指向数组第一个元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> high      指向数组最后一个元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (low &gt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid =(high + low) / <span class=\"number\">2</span>; <span class=\"comment\">//取中间的数，进行拆分</span></span><br><span class=\"line\">        sort(data, low, mid);<span class=\"comment\">//左边的数不断进行拆分</span></span><br><span class=\"line\">        sort(data, mid + <span class=\"number\">1</span>, high); <span class=\"comment\">//右边的数不断进行拆分</span></span><br><span class=\"line\">        merge(data, low, mid, high);<span class=\"comment\">//合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p1 = low;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[p1] &gt; data[p2]) &#123;</span><br><span class=\"line\">                assist[i++] = data[p2++];                </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                assist[i++] = data[p1++];               </span><br><span class=\"line\">            &#125;        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 &lt;= mid) &#123;</span><br><span class=\"line\">            assist[i++] = data[p1++];           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p2 &lt;= high) &#123;</span><br><span class=\"line\">            assist[i++] = data[p2++];            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 把新数组中的数覆盖原data数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = low; index &lt;= high; index++) &#123;</span><br><span class=\"line\">        \tdata[index] = assist[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\tDemo_Sort.mergeSorting(data);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]    </span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"快速排序","url":"/2020-11-12-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html","content":"<p><strong>原理：</strong>快速排序法就是通过一次排序将待排序的一组数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程采用递归的方式进行，以此达到所有数据变成有序的序列。</p>\n<p><strong>说明：</strong>快速排序是一种“分治法”的体现，将原本的问题进行拆分成两个子问题，然后再分别的去解决这两个子问题，达到“分而治之”的效果。 </p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(logn)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[],<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i,j,temp,t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(low&gt;high)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ti=low;</span><br><span class=\"line\">\t\tj=high;</span><br><span class=\"line\">\t\ttemp=data[low];<span class=\"comment\">//选中的基准数  选左面第一位为基准数 一定要从右面先动</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;基准位&quot;</span>+temp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//先看右边</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(temp&lt;=data[j] &amp;&amp; i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//后看左边</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(temp&gt;=data[i] &amp;&amp; i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果满足条件则交换</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;交换数据:&quot;</span>+data[i]+<span class=\"string\">&quot;和&quot;</span>+data[j]);</span><br><span class=\"line\">\t\t\t\tt=data[j];</span><br><span class=\"line\">\t\t\t\tdata[j]=data[i];</span><br><span class=\"line\">\t\t\t\tdata[i]=t;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//最后将基准位与i和j相等的位置交换</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;基准位&quot;</span>+temp+<span class=\"string\">&quot;和i、j相遇的位置&quot;</span>+data[i]+<span class=\"string\">&quot;交换&quot;</span>);</span><br><span class=\"line\">\t\tdata[low]=data[i];</span><br><span class=\"line\">\t\tdata[i]=temp;</span><br><span class=\"line\">\t\tSystem.out.println(java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用左半边数组</span></span><br><span class=\"line\">\t\tquickSort(data, low, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用右半边数组</span></span><br><span class=\"line\">\t\tquickSort(data, j+<span class=\"number\">1</span>, high);</span><br><span class=\"line\">\t\t\t&#125;\t\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.quickSort(data, <span class=\"number\">0</span>, data.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">基准位<span class=\"number\">36</span></span><br><span class=\"line\">交换数据:<span class=\"number\">55</span>和<span class=\"number\">9</span></span><br><span class=\"line\">[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">9</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">交换数据:<span class=\"number\">66</span>和<span class=\"number\">18</span></span><br><span class=\"line\">[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">36</span>和i、j相遇的位置<span class=\"number\">6</span>交换</span><br><span class=\"line\">[<span class=\"number\">6</span>, <span class=\"number\">22</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">6</span></span><br><span class=\"line\">交换数据:<span class=\"number\">22</span>和<span class=\"number\">4</span></span><br><span class=\"line\">[<span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">6</span>和i、j相遇的位置<span class=\"number\">4</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">4</span></span><br><span class=\"line\">基准位<span class=\"number\">4</span>和i、j相遇的位置<span class=\"number\">4</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">9</span></span><br><span class=\"line\">基准位<span class=\"number\">9</span>和i、j相遇的位置<span class=\"number\">9</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">18</span></span><br><span class=\"line\">基准位<span class=\"number\">18</span>和i、j相遇的位置<span class=\"number\">18</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">31</span></span><br><span class=\"line\">基准位<span class=\"number\">31</span>和i、j相遇的位置<span class=\"number\">22</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">22</span></span><br><span class=\"line\">基准位<span class=\"number\">22</span>和i、j相遇的位置<span class=\"number\">22</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">66</span></span><br><span class=\"line\">基准位<span class=\"number\">66</span>和i、j相遇的位置<span class=\"number\">55</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">基准位<span class=\"number\">55</span></span><br><span class=\"line\">基准位<span class=\"number\">55</span>和i、j相遇的位置<span class=\"number\">55</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"SSM中的过滤器和拦截器","url":"/2020-11-13-SSM%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.html","content":"<h3 id=\"过滤器-Filter-和拦截器-Interceptor\"><a href=\"#过滤器-Filter-和拦截器-Interceptor\" class=\"headerlink\" title=\"过滤器(Filter)和拦截器(Interceptor)\"></a>过滤器(Filter)和拦截器(Interceptor)</h3><p>过滤器(Filter)和拦截器(Interceptor)都是可以作用于若干种不同的请求路径的组件，都可以对某种请求进行阻止，不允许继续向后执行，也可以选择放行，按照原本设定的处理流程继续执行！并且，在同一个项目中，允许同时存在若干个过滤器或拦截器，以形成过滤器链或拦截器链，如果某个请求涉及多个过滤器或拦截器，必须每个过滤器或拦截器都放行，才可以继续执行！</p>\n<h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><ol>\n<li>过滤器是Java EE中的组件，而拦截器是SpringMVC中的组件！只要是Java EE(web)项目，都可以使用过滤器，但是，只有使用了SpringMVC框架，才可以使用拦截器，并且，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！</li>\n<li>过滤器和拦截器的执行时间节点、执行的方法的数量都不相同，过滤器是在所有Servlet组件之前执行的！而拦截器的第1次执行是在DispatcherServlet之后，且在Controller组件之前执行的，而且，当拦截器选择“放行”时，在Controller执行之后，和执行最终的响应之前，还会各执行1次！</li>\n<li>过滤器和拦截器的配置也不相同，过滤器是在<strong>web.xml</strong>中配置的，在配置过程中，可以配置若干个请求路径，也可以使用星号(*)作为通配符，但是，无法配置例外路径（白名单），而拦截器是在Spring的配置文件中进行配置的，其配置方式非常灵活，可以配置若干个请求路径，也可以使用通配符，还可以配置若干个例外路径！</li>\n</ol>\n<p>在一般情况下，我们更关注项目的管理，由于过滤器和拦截器都会出现在真正处理请求的组件之前，所以，都可以实现“阻止”和“放行”的效果，那么，哪个简单、易用、功能更强大，就使用哪个！所以，更优先推荐使用拦截器解决项目中的问题！但是，这也并不代表拦截器就可以完全取代过滤器，例如，某些处理过程应该出现在更早的执行时间节点，就必须使用过滤器，而不能使用拦截器！</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>\n<p>过滤器</p>\n<ul>\n<li>servlet规范中的一部分，任何java web工程都可以使用</li>\n<li>在url-pattern中配置了/*之后，可以对<strong>所有要访问的资源</strong>进行拦截</li>\n</ul>\n<p>拦截器</p>\n<ul>\n<li>拦截器是springMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>\n<li>拦截器只会<strong>拦截访问的控制器方法</strong>，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！，如果访问的是jsp/html/css/image/js是不会进行拦截</li>\n</ul>\n","categories":["SSM"],"tags":["SSM框架"]},{"title":"堆排序","url":"/2020-11-13-%E5%A0%86%E6%8E%92%E5%BA%8F.html","content":"<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p><strong>原理：</strong>堆排序法顾名思义采用了堆的数据结构来进行排序。堆排序法就是把堆顶的元素与最后一个元素交换，因为交换后破坏了堆的特性，因此需要把堆中剩余的元素重建成一个满足堆的性质的堆，然后再把堆顶的元素与倒数第二个元素交换，再次进行堆的重建，以此类推直至堆中仅剩最后一个元素排序完成</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<p><strong>堆：</strong>因为堆顶的元素是一个最值，当堆是大顶堆时堆顶就是最大值，采用堆排序法时可将数据进行升序排列；若堆为小顶堆则堆顶就是最小值，采用堆排序法时可将数据进行降序排列。</p>\n<ul>\n<li>堆中节点的值总是大于或小于其父节点的值</li>\n<li>堆总是一棵完全二叉树</li>\n</ul>\n<p><strong>堆的数组实现：</strong></p>\n<ul>\n<li>下标为i的节点的父节点下标为：(i-1)/2</li>\n<li>下标为i的节点的左孩子下标为：i*2+1</li>\n<li>下标为i的节点的右孩子下标为：i*2+2</li>\n</ul>\n<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>\n<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>\n<p><img data-src=\"https://i.loli.net/2020/11/13/Zf13XhilSju7T5y.png\" alt=\"堆\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = data.length;</span><br><span class=\"line\">        <span class=\"comment\">//创建大顶堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//从第一个非叶子节点从下到上，从右到左调整结构</span></span><br><span class=\"line\">            standardization(data, n, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = data[<span class=\"number\">0</span>];</span><br><span class=\"line\">            data[<span class=\"number\">0</span>] = data[i];</span><br><span class=\"line\">            data[i] = temp;</span><br><span class=\"line\">            <span class=\"comment\">//重新对堆进行调整,因为第一次已经调成大顶堆了，所以在调只需要在1、2中找一个最大的</span></span><br><span class=\"line\">            standardization(data, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">standardization</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> largest = i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftSon = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightSon = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftSon &lt; n &amp;&amp; data[leftSon] &gt; data[largest]) &#123;</span><br><span class=\"line\">            largest = leftSon;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rightSon &lt; n &amp;&amp; data[rightSon] &gt; data[largest]) &#123;</span><br><span class=\"line\">            largest = rightSon;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = data[i];</span><br><span class=\"line\">            data[i] = data[largest];</span><br><span class=\"line\">            data[largest] = temp;</span><br><span class=\"line\">            <span class=\"comment\">//保证下一层也是大顶堆的情况</span></span><br><span class=\"line\">            standardization(data, n, largest);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\tDemo_Sort.heapSort(data);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"http status 301/302 & java重定向/转发","url":"/2020-11-17-http-status-301302-&-java%E9%87%8D%E5%AE%9A%E5%90%91%E8%BD%AC%E5%8F%91.html","content":"<h2 id=\"一、301-302\"><a href=\"#一、301-302\" class=\"headerlink\" title=\"一、301/302\"></a><strong>一、301/302</strong></h2><h3 id=\"1、什么是301转向-什么是301重定向\"><a href=\"#1、什么是301转向-什么是301重定向\" class=\"headerlink\" title=\"1、什么是301转向?什么是301重定向?\"></a>1、什么是301转向?什么是301重定向?</h3><p>　　301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p>\n<h3 id=\"2、什么是302重定向\"><a href=\"#2、什么是302重定向\" class=\"headerlink\" title=\"2、什么是302重定向?\"></a>2、什么是302重定向?</h3><p>　　302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向(temporary redirect)，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服 务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</p>\n<h3 id=\"3、301重定向与302重定向的区别\"><a href=\"#3、301重定向与302重定向的区别\" class=\"headerlink\" title=\"3、301重定向与302重定向的区别\"></a>3、301重定向与302重定向的区别</h3><p>　　302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>\n<p>　　301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>\n<h3 id=\"4、为什么302-重定向和网址劫持有关联\"><a href=\"#4、为什么302-重定向和网址劫持有关联\" class=\"headerlink\" title=\"4、为什么302 重定向和网址劫持有关联\"></a>4、为什么302 重定向和网址劫持有关联</h3><p>　　从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL 劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</p>\n<p>　　比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>\n<p>　　302 重定向所造成的网址URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>\n<h2 id=\"二、重定向-转发\"><a href=\"#二、重定向-转发\" class=\"headerlink\" title=\"二、重定向/转发\"></a><strong>二、重定向/转发</strong></h2><h3 id=\"1、什么是重定向\"><a href=\"#1、什么是重定向\" class=\"headerlink\" title=\"1、什么是重定向?\"></a>1、什么是重定向?</h3><p>​      服务器向浏览器发送一个302状态码及一个Location消息头(该消息头的值是一个地址)。浏览器在收到之后，会立即向这个地址发送请求。</p>\n<p>如果是按照通俗一点的按照流程里说就是这样：发送请求 --&gt;服务器处理请求--&gt;响应请求，返回给浏览器一个新的地址与响应码（302状态 码）--&gt;浏览器根据响应码（302状态码），判定该响应为重定向，自动发送一个新的请求给服务器，请求地址为之前返回的地址--&gt;服务器运 行--&gt;响应请求给浏览器</p>\n<p>在编程的时候怎么写：</p>\n<p> response.sendRedirect(String url);很简单的一句代码就行了。但是有两个问题是要注意的：</p>\n<ul>\n<li>①重定向之前，不能够有任何的输出，否则会发生错误。</li>\n<li>②重定向之前，会先清空response中缓存的数据。 </li>\n</ul>\n<p>特点是：</p>\n<ul>\n<li>①重定向的地址是任意的。</li>\n<li>②重定向之后，浏览器地址栏的地址会变成Location所指定的地址。</li>\n</ul>\n<h3 id=\"2、什么是转发\"><a href=\"#2、什么是转发\" class=\"headerlink\" title=\"2、什么是转发?\"></a>2、什么是转发?</h3><p>​    一个web组件(servlet/jsp) 将未完成的处理交给另外一个web组件继续完成。</p>\n<p>​    一般应用的场合：一个servlet处理请求之后，将处理结果交给一个jsp，让jsp依据处理结果生成相应的界面。如果是按照通俗一点的按照流程里说就是这样：发送请求 --&gt;服务器处理请求--&gt;进行请求的重新设置，例如通过 request.setAttribute(name,value)--&gt;根据转发的地址，获取该地址的jsp网页--&gt;响应请求给浏览器。<br>编程的时候怎么写？这个比重定向要复杂一点：</p>\n<p>① 将处理结果绑订定到request对象上。request.setAttribute(String name,Object obj);//如果name对应的值不存在，则返回null。Object request.getAttribute(String name);request.removeAttribute(String name);</p>\n<p>② 获得转发器</p>\n<p>//uri:是要转发的目的地，目的地只能是同一个应用的内部。RequestDispatcher rd = request.getRequestDispatcher(String uri);</p>\n<p>③ 转发</p>\n<p>rd.forward(request,response);需要注意的是：转发之前，不要有任何的刷新操作，否则会出错。转发之前，如果response当中缓存有数据，会先清空。</p>\n<p><strong>转发的特点</strong></p>\n<p>① 转发的目的地只能是同一个应用内部的各个组件之间。</p>\n<p>② 转发之后，浏览器地址栏的地址不会变。</p>\n<p>综合上面解说：总结下重定向和转发的区别：</p>\n<p>区别①：</p>\n<p>重定向时，浏览器上的网址改变</p>\n<p>转发时，浏览器上的网址不变</p>\n<p>区别②：</p>\n<p>重定向实际上产生了两次请求</p>\n<p>转发只有一次请求</p>\n<p>区别③：</p>\n<p>重定向的时候网址可以是任何的网址</p>\n<p>转发的网址只能是本站点的网址</p>\n<p>根据上面的分析，所以说，用重定向和转发不是一个习惯不习惯的问题，而是在什么情况下必须用的问题。</p>\n","categories":["java"],"tags":["重定向/转发"]},{"title":"链表","url":"/2020-11-17-%E9%93%BE%E8%A1%A8.html","content":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p><strong>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）</strong>。</p>\n<h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值（NULL）。单向链表只可向一个方向遍历。查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。也可以提前把一个节点的位置另外保存起来，然后直接访问。</p>\n<p>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</p>\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a><strong>双向链表</strong></h3><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。第一个节点的&quot;前连接&quot;指向NULL，最后一个节点的&quot;后连接&quot;指向NULL。这样可以从任何一个节点访问前一个节点，也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。</p>\n<p>单链表只有一个指向下一结点的指针，也就是只能next.<br>双链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</p>\n<h4 id=\"单链表和双向链表区别\"><a href=\"#单链表和双向链表区别\" class=\"headerlink\" title=\"单链表和双向链表区别\"></a>单链表和<strong>双向链表</strong>区别</h4><p>1、因为在双向链表中，我们可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表。</p>\n<p>所以删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样的，指针的总的移动操作都会有2*i次。而如果用双向链表，则不需要定位前驱结点。因此指针总的移动操作为i次。</p>\n<p>2、查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍。</p>\n<p>可是为什么市场上单链表的使用多余双链表呢？</p>\n<p>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</p>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a><strong>循环链表</strong></h3><p>在一个循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。循环链表可以被视为&quot;无头无尾&quot;。</p>\n<p>循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大。</p>\n<p>在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。</p>\n<p><strong>对于循环链表来说唯一的区别是循环结束的条件改为是否指向头指针。</strong></p>\n<h4 id=\"单向循环链表：\"><a href=\"#单向循环链表：\" class=\"headerlink\" title=\"单向循环链表：\"></a>单向循环链表：</h4><p>如果把单链表的最后一个节点的指针指向链表头部，而不是指向NULL，那么就构成了一个单向循环链表，通俗讲就是把尾节点的下一跳指向头结点。</p>\n<h4 id=\"双向循环链表：\"><a href=\"#双向循环链表：\" class=\"headerlink\" title=\"双向循环链表：\"></a>双向循环链表：</h4><p>双（向）链表中有两条方向不同的链，即每个结点中除next域存放后继结点地址外，还增加一个指向其直接前趋的指针域prior。</p>\n<h3 id=\"联系：\"><a href=\"#联系：\" class=\"headerlink\" title=\"联系：\"></a>联系：</h3><h4 id=\"LinkedList用的是单链表还是双链表？\"><a href=\"#LinkedList用的是单链表还是双链表？\" class=\"headerlink\" title=\"LinkedList用的是单链表还是双链表？\"></a>LinkedList用的是单链表还是双链表？</h4><p>JDK1.6之前为循环双向链表，JDK1.7取消了循环。</p>\n<h4 id=\"双向链表和双向循环链表的区别\"><a href=\"#双向链表和双向循环链表的区别\" class=\"headerlink\" title=\"双向链表和双向循环链表的区别\"></a>双向链表和双向循环链表的区别</h4><p>双向链表： 包含两个指针，⼀个prev指向前⼀个节点，⼀个next指向后⼀个节点。</p>\n<p>双向循环链表： 最后⼀个节点的 next 指向head，⽽ head 的prev指向最后⼀个节点，构成⼀个环</p>\n<h4 id=\"LinkedList-为什么不用单链表，而是用双链表？\"><a href=\"#LinkedList-为什么不用单链表，而是用双链表？\" class=\"headerlink\" title=\"LinkedList 为什么不用单链表，而是用双链表？\"></a>LinkedList 为什么不用单链表，而是用双链表？</h4><h4 id=\"LinkedList-删除元素，默认是删除最后一个还是第一个元素？\"><a href=\"#LinkedList-删除元素，默认是删除最后一个还是第一个元素？\" class=\"headerlink\" title=\"LinkedList 删除元素，默认是删除最后一个还是第一个元素？\"></a>LinkedList 删除元素，默认是删除最后一个还是第一个元素？</h4><h3 id=\"链表跟数组的区别？\"><a href=\"#链表跟数组的区别？\" class=\"headerlink\" title=\"链表跟数组的区别？\"></a>链表跟数组的区别？</h3><ol>\n<li>数组静态分配内存，链表动态分配内存；</li>\n<li>数组在内存中连续，链表不连续；</li>\n<li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</li>\n<li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li>\n</ol>\n<h4 id=\"数组的优点\"><a href=\"#数组的优点\" class=\"headerlink\" title=\"数组的优点\"></a>数组的优点</h4><ul>\n<li>随机访问性强（通过下标进行快速定位）</li>\n<li>查找速度快</li>\n</ul>\n<h4 id=\"数组的缺点\"><a href=\"#数组的缺点\" class=\"headerlink\" title=\"数组的缺点\"></a>数组的缺点</h4><ul>\n<li>插入和删除效率低（插入和删除需要移动数据）</li>\n<li>可能浪费内存（因为是连续的，所以每次申请数组之前必须规定数组的大小，如果大小不合理，则可能会浪费内存）</li>\n<li>内存空间要求高，必须有足够的连续内存空间。</li>\n<li>数组大小固定，不能动态拓展</li>\n</ul>\n<h4 id=\"链表的优点\"><a href=\"#链表的优点\" class=\"headerlink\" title=\"链表的优点\"></a>链表的优点</h4><ul>\n<li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li>\n<li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li>\n<li>大小没有固定，拓展很灵活。</li>\n</ul>\n<h4 id=\"链表的缺点\"><a href=\"#链表的缺点\" class=\"headerlink\" title=\"链表的缺点\"></a>链表的缺点</h4><ul>\n<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>\n</ul>\n","categories":["数据结构"],"tags":["单向链表、双向链表"]},{"title":"JUC容器","url":"/2020-11-18-JUC%E5%AE%B9%E5%99%A8.html","content":"<p><code>juc</code>是java中<code>java.util.concurrent</code>包的简称.这个包里面的东西就是<code>Doug Lea</code>写的,它主要包括<code>atomic</code>支持原子操作类相关代码,<code>locks</code>java中锁相关代码,还有其他并发容器相关代码.</p>\n<h2 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h2><p>这个包里面提供了许多支持原子相关操作类的代码,例如:<code>AtomicBoolean</code>,<code>AtomicInteger</code>...等等.这些类就是通过<code>CAS</code>来提供原子操作支持的.</p>\n<h2 id=\"locks\"><a href=\"#locks\" class=\"headerlink\" title=\"locks\"></a>locks</h2><p>这个包主要提供了很多java中的锁.例如:<code>ReentrantLock</code>,<code>ReentrantReadWriteLock</code>...等等.这些类就是通过<code>AQS</code>来实现的.</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>在<code>java.util.concurrent</code>下的其他类主要提供了并发容器相关类,例如:<code>ConcurrentHashMap</code>,<code>ConcurrentLinkedQueue</code>...等等相关类.还有线程池相关类,例如:<code>ThreadPoolExecutor</code>,<code>ScheduledThreadPoolExecutor</code>...等等.</p>\n<p>CopyOnWriteArrayList，底层使用到了重入锁，在写的时候加锁，在读的时候不加锁。写的时候复制一份要操作的数组，之后再设置回去。而这个数组用volatile保证内存可见性。</p>\n","categories":["集合"],"tags":["JUC"]},{"title":"Spring 原理","url":"/2020-11-18-Spring-%E5%8E%9F%E7%90%86.html","content":"<h3 id=\"1、什么是Spring-Bean类\"><a href=\"#1、什么是Spring-Bean类\" class=\"headerlink\" title=\"1、什么是Spring Bean类\"></a><strong>1、什么是Spring Bean类</strong></h3><p>Spring Bean是事物处理组件类和实体类（POJO）对象的总称，Spring Bean被Spring IOC容器初始化，装配和管理。</p>\n<h3 id=\"2、Bean类的配置项\"><a href=\"#2、Bean类的配置项\" class=\"headerlink\" title=\"2、Bean类的配置项\"></a><strong>2、Bean类的配置项</strong></h3><p>Spring IOC容器管理Bean时，需要了解Bean的类名、名称、依赖项、属性、生命周期及作用域等信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。</p>\n<ul>\n<li>① class: 该配置项是强制项，用于指定创建Bean实例的Bean类的路径。</li>\n<li>② name: 该配置项是强制项，用于指定Bean唯一的标识符，在基于 XML 的配置项中，可以使用 id和或 name 属性来指定 Bean唯一 标识符。</li>\n<li>③ scope: 该配置项是可选项，用于设定创建Bean对象的作用域。</li>\n<li>④ constructor-arg: 该配置项是可选项，用于<strong>指定通过构造函数注入依赖数据到Bean</strong>。</li>\n<li>⑤ properties: 该配置项是可选项，用于<strong>指定通过set方法注入依赖数据到Bean</strong>。</li>\n<li>⑥ autowiring mode: 该配置项是可选项，用于<strong>指定通过自动依赖方法注入依赖数据到Bean</strong>。</li>\n<li>⑦ lazy-initialization mode: 该配置项是可选项，用于<strong>指定IOC容器延迟创建Bean</strong>，在用户请求时创建Bean，而不要在启动时就创建Bean。</li>\n<li>⑧ initialization: 该配置项是可选项，用于<strong>指定IOC容器完成Bean必要的创建后，调用Bean类提供的回调方法对Bean实例进一步处理</strong>。</li>\n<li>⑨ destruction: 该配置项是可选项，用于<strong>指定IOC容器在销毁Bean时，调用Bean类提供的回调方法</strong>。</li>\n</ul>\n<p><strong>3、将Bean类添加到Spring IOC容器</strong></p>\n<p>将Bean类添加到Spring IOC容器有三种方式。</p>\n<ul>\n<li>一种方式是基于XML的配置文件；</li>\n<li>一种方式是基于注解的配置；</li>\n<li>一种方式是基于Java的配置。</li>\n</ul>\n<p>下面主要介绍基于XML的配置方式，基于注解和基于Java的配置放在后面进行讨论，放在后面讨论的原因是一些其它重要的Spring概念还需要掌握。</p>\n<p><strong>（1）XML配置文件的创建与存储</strong></p>\n<p><strong>（2）Spring配置文件的加载</strong></p>\n<p>加载Spring的配置文件有多种方式，比较常用的是在web.xml加载配置文件。</p>\n<p>① 使用ContextLoaderListener加载配置文件</p>\n<p>ContextLoaderListener类在启动Web容器时，自动加载Spring applicationContext.xml的配置信息。</p>\n<p>② 加载自命名的配置文件</p>\n<p>③ 通过配置目录加载配置文件</p>\n<p><strong>（3）在Spring配置文件中定义Bean</strong></p>\n<p><bean>标签用于定义Bean，各属性说明如下：</p>\n<p>① id：Bean的唯一标识，ApplicationContext对象可以通过id获取该Bean的实例。</p>\n<p>② calss：Bean类的存储路径。</p>\n<p><property>标签用于从外部注入Bean的属性值， <property>标签各属性说明如下：</p>\n<p>① name：Bean类的属性名称。</p>\n<p>② value：name所值属性的值。</p>\n","categories":["框架"],"tags":["Spring"]},{"title":"索引优化","url":"/2020-11-18-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96.html","content":"<h3 id=\"1-索引是什么？\"><a href=\"#1-索引是什么？\" class=\"headerlink\" title=\"1.索引是什么？\"></a>1.索引是什么？</h3><p>排好序的快速查找的数据结构；</p>\n<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p>\n<p>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p>\n<h3 id=\"2-sql执行顺序\"><a href=\"#2-sql执行顺序\" class=\"headerlink\" title=\"2.sql执行顺序\"></a><strong>2.sql执行顺序</strong></h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。下面是经常出现的查询顺序：</p>\n<p><strong>手写：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">\t&lt;<span class=\"keyword\">select</span> <span class=\"keyword\">list</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\t&lt;<span class=\"keyword\">left</span> <span class=\"keyword\">table</span>&gt; &lt;<span class=\"keyword\">join</span> <span class=\"keyword\">type</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span>&lt; <span class=\"keyword\">right</span> <span class=\"keyword\">table</span>&gt; <span class=\"keyword\">ON</span> &lt;<span class=\"keyword\">join</span> condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\t&lt;where_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\t&lt;group_by_list&gt;</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span></span><br><span class=\"line\">\t&lt;having_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\t&lt;order_by_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>机读：</strong>从from开始做笛卡尔积计算，然后on 保留主表，然后同时做join和where判断，然后GROUP BY 、HAVING，然乎在select，最后用ORDER BY排序 、LIMIT限</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM &lt;left_table&gt;</span><br><span class=\"line\">ON&lt;join_condition&gt;</span><br><span class=\"line\">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class=\"line\">WHERE &lt;where_condition&gt;</span><br><span class=\"line\">GROUP BY &lt;group_by_list&gt;</span><br><span class=\"line\">HAVING &lt;having_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\"><span class=\"keyword\">DISTINCT</span> &lt;select_list&gt;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> &lt;order_by_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-索引的种类\"><a href=\"#3-索引的种类\" class=\"headerlink\" title=\"3.索引的种类\"></a>3.索引的种类</h3><ul>\n<li>主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引，主键索引不允许为空</li>\n<li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值</li>\n<li>复合索引：即一个索引包含多个列；在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)当表的行数远大于索引列的数目时可以使用复合索引</li>\n</ul>\n<h4 id=\"索引建立成哪种索引类型？\"><a href=\"#索引建立成哪种索引类型？\" class=\"headerlink\" title=\"索引建立成哪种索引类型？\"></a>索引建立成哪种索引类型？</h4><p>根据数据引擎类型自动选择的索引类型；除开 innodb 引擎主键默认为聚簇索引 外。 innodb 的索引都采用的 B+TREE；myisam 则都采用的 B-TREE索引</p>\n<h4 id=\"B-Tree与B-Tree-的区别？\"><a href=\"#B-Tree与B-Tree-的区别？\" class=\"headerlink\" title=\"B+Tree与B-Tree 的区别？\"></a>B+Tree与B-Tree 的区别？</h4><p>结论在内存有限的情况下，B+TREE 永远比 B-TREE好。无限内存则后者方便。</p>\n<p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)<br>　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是<strong>减少磁盘访问次数</strong>。尽管B+树找到一个记录所需的比较次数要比B-树多，但是<strong>一次磁盘访问的时间相当于成百上千次内存比较的时间</strong>，因此实际中B+树的性能可能还会好些，<strong>而且B+树的叶子节点使用指针连接在一起，方便顺序遍历</strong>（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br>　<br>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p>\n<ol>\n<li>B+树的磁盘读写代价更低<br>　　<strong>B+树的内部结点并没有指向关键字具体信息的指针</strong>。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。<strong>相对来说IO读写次数也就降低了。</strong> </li>\n<li>B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。<strong>所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</strong></li>\n</ol>\n<h3 id=\"4-使用索引但索引失效的场景（复合索引）\"><a href=\"#4-使用索引但索引失效的场景（复合索引）\" class=\"headerlink\" title=\"4.使用索引但索引失效的场景（复合索引）\"></a>4.使用索引但索引失效的场景（复合索引）</h3><h4 id=\"如何创建显示删除复合索引？\"><a href=\"#如何创建显示删除复合索引？\" class=\"headerlink\" title=\"如何创建显示删除复合索引？\"></a>如何创建显示删除复合索引？</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> idx_id_name_age <span class=\"keyword\">ON</span> <span class=\"string\">`user`</span>(<span class=\"keyword\">id</span>,<span class=\"keyword\">name</span>,age)</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">FROM</span> <span class=\"string\">`user`</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> idx_id_name_age <span class=\"keyword\">ON</span> <span class=\"string\">`user`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EXPLAIN-是用来干什么的，怎么用？\"><a href=\"#EXPLAIN-是用来干什么的，怎么用？\" class=\"headerlink\" title=\"EXPLAIN 是用来干什么的，怎么用？\"></a>EXPLAIN 是用来干什么的，怎么用？</h4><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p>\n<p>能干什么：</p>\n<ul>\n<li>表的读取顺序</li>\n<li>哪些索引可以使用</li>\n<li>数据读取操作的操作类型</li>\n<li>哪些索引被实际使用</li>\n<li>表之间的引用</li>\n<li>每张表有多少行被优化器查询</li>\n</ul>\n<p>怎么样：</p>\n<ul>\n<li>Explain + SQL语句</li>\n<li>执行计划包含的信息</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/11/24/U4dLfojQNkxAX7u.png\" loading=\"lazy\"></p>\n<ul>\n<li>id:  select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序;<strong>id相同，执行顺序由上至下;id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行;id相同不同，同时存在。</strong></li>\n<li>select_type:  查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</li>\n<li>table:  显示这一行的数据是关于哪张表的。</li>\n<li>type:  type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是: system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL;一般来说，得保证查询至少达到range级别，最好能达到ref。</li>\n<li>possible_keys:  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</li>\n<li>key:  实际使用的索引。如果为NULL，则没有使用索引；查询中若使用了覆盖索引，则该索引和查询的select字段重叠</li>\n<li>key_len:  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</li>\n<li>ref:  显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</li>\n<li>rows:  rows列显示MySQL认为它执行查询时必须检查的行数。越少越好</li>\n<li>Extra:  包含不适合在其他列中显示但十分重要的额外信息</li>\n</ul>\n<p>Extra又包含：</p>\n<ul>\n<li><p><strong>Using filesort ：</strong> 说明mysql会对数据使用一个<strong>外部的索引排序</strong>，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。<strong>九死一生的,相当于是你在查找时从一楼直接让你上三楼，你自己只能自寻办法，不能走楼梯上去</strong></p>\n</li>\n<li><p><strong>Using temporary：</strong>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。<strong>十死无生的，相当于让你去二楼，然后没给你一楼，空中楼阁</strong></p>\n</li>\n<li><p><strong>USING index：</strong>表示相应的select操作中使用了**覆盖索引(Covering Index)**，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。比较好的！！</p>\n<p>覆盖索引（Covering Index）也叫索引覆盖。理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。</p>\n</li>\n<li><p>Using where：表明使用了where过滤</p>\n</li>\n<li><p>using join buffer：使用了连接缓存</p>\n</li>\n<li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p>\n</li>\n<li><p>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p>\n</li>\n</ul>\n<p>type又包含：<img data-src=\"https://i.loli.net/2020/11/24/rNUu1ex6acyA2I8.png\" loading=\"lazy\"></p>\n<ul>\n<li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li>\n<li>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li>\n<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行；本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，<br>它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li>\n<li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>\n<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</li>\n<li>all：Full Table Scan，将遍历全表以找到匹配的行</li>\n</ul>\n<p><strong>索引失效的场景</strong>：----------------------------------------------------------------------------------------------------------------------</p>\n<p>最好的索引是全值索引，创建的索引都用到了（按序用的）</p>\n<ol>\n<li><strong>最佳左前缀法则：</strong>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。但是有前提条件：1. and 忽略左右关系。即使没有没有按顺序 由于优化器的存在，会自动优化。2. 建立索引CREATE INDEX idx_name_age ON <code>user</code>(name,age)，id为主键；<strong>当使用覆盖索引的方式时</strong>，(select name,age,id from <code>user</code> where age=23(后面没有其他没有索引的字段条件))，即使不是以 name 开头，也会使用 dx_name_age 索引。但是看rows 字段信息搜索的行数是全表的行数，type字段 是index。<strong>第二条是重点！！！</strong></li>\n<li><strong>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</strong></li>\n<li><strong>存储引擎不能使用索引中范围条件右边的列:</strong>  范围 若有索引则能使用到索引，范围条件右边的索引会失效,本身不会失效(范围条件右边与范围条件使用的同一个组合索引，右边的才会失效。若是不同索引则不会失效)</li>\n<li>*<em>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select **</em></li>\n<li><strong>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</strong>：使用 != 和 &lt;&gt; 的字段索引失效( != 针对数值类型。 &lt;&gt; 针对字符类型；前提 where and 后的字段在混合索引中的位置比当前字段靠后  where age != 10 and name=&#39;xxx&#39;  ,这种情况下，mysql自动优化，将 name=&#39;xxx&#39; 放在 age ！=10 之前，name 依然能使用索引。只是 age 的索引失效)</li>\n<li><strong>is not null 也无法使用索引,但是is null是可以使用索引的</strong></li>\n<li><strong>like以通配符开头(&#39;%abc...&#39;)，mysql索引失效会变成全表扫描的操作</strong>：like ‘%abc%’  type 类型会变成 all；like ‘abc%’  type 类型为 range ，算是范围，可以使用索引</li>\n<li><strong>字符串不加单引号索引失效</strong>：底层进行转换使索引失效，使用了函数造成索引失效</li>\n<li><strong>少用or,用它来连接时会索引失效</strong></li>\n</ol>\n","categories":["MySql"],"tags":["sql"]},{"title":"某东实习一面","url":"/2020-11-20-%E6%9F%90%E4%B8%9C%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2.html","content":"<h4 id=\"1-谈谈Spring框架\"><a href=\"#1-谈谈Spring框架\" class=\"headerlink\" title=\"1.谈谈Spring框架\"></a>1.谈谈Spring框架</h4><p>Spring是一个优秀的轻量级框架，大大的提高了项目的开发管理与维护。spring的轻量级是是从它的大小和开销来说的，完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。3</p>\n<p>Spring是非侵入式的,spring的api是不会出现在业务逻辑上出现的，对于应用而言，业务逻辑可以从当前应用剥离出来，实现复用，对于框架而言，业务逻辑也可以从spring框架中快速的移植到别的框架</p>\n<p>spring提供容器功能，容器可以管理对象的生命周期，对象和对象之间的依赖关系等。通常我们都是可以写一个配置文件，在上面定义对象的名字等，在容器启动以后，这些对象就被实例化好了，我们可以直接去用。而且依赖关系也建立好了。</p>\n<p>Spring有两个核心模块。一个是IOC，一个是AOP。</p>\n<p>IOC:　就是控制反转的意思，指的是我们将对象的控制权从应用代码本身转移到外部容器。通过IOC容器在程序运行期间基于JAVA反射机制</p>\n<p>动态的创建对象，配置对象，建立对象之间的依赖关系，管理对象的生命周期。<strong>而DI作为依赖注入，是实现IOC控制反转的一种手段。</strong>常见的依赖注入方式有:set方式注入、构造器方式注入、接口注入、注解注入。通过依赖注入在程序运行期间动态的注入依赖对象，建立对象之间的依赖关系，降低对象之间的耦合度。</p>\n<p>AOP:面向切面编程，是对面向对象编程的补充。我们将通用的业务功能代码块封装起来作为切面，通过指定切入点，也就是指定切面作用的目标方法，</p>\n<p>最后通过不同类型的通知，告诉容器在调用目标方法的什么时机插入切面代码块。像Spring的声明式事物管理就是基于AOP，在程序运行期间，通过动态代理技术给service层的bean追加事物管理，保证事物的ACID特性。我们可以通过AOP将一些任务单独封装，通过动态代理技术，在不改变原有代码的情况下追加功能，提高代码的复用和简化编程。</p>\n<h4 id=\"2-bean的作用域\"><a href=\"#2-bean的作用域\" class=\"headerlink\" title=\"2.bean的作用域\"></a>2.bean的作用域</h4><p>Spring Bean 中所说的作用域，在配置文件中即是“<strong>scope</strong>”，在面向对象程序设计中<strong>作用域一般指对象或变量之间的可见范围。</strong></p>\n<p>而在Spring容器中<strong>是指其创建的Bean对象相对于其他Bean对象的请求可见范围</strong>。</p>\n<ul>\n<li>singleton:  Spring的默认作用域，容器里拥有唯一的Bean实例</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>prototype：针对每个getBean请求，容器都会创建一个Bean实例</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; prototype &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>request：会为每个Http请求创建一个Bean实例,而且该Bean只在当前request内是有效的</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; request &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>session：会为每个session创建一个Bean实例,而且该Bean只在当前http session内是有效的。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; session &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效.Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span>scope=“globalSession<span class=\"string\">&quot;&gt;&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-aop实现原理\"><a href=\"#3-aop实现原理\" class=\"headerlink\" title=\"3.aop实现原理\"></a>3.aop实现原理</h4><p>Spring采用的方式，通过动态代理的方式，实现简单（运行时织入）</p>\n<h4 id=\"4-在你的项目中那个场景用到了aop\"><a href=\"#4-在你的项目中那个场景用到了aop\" class=\"headerlink\" title=\"4.在你的项目中那个场景用到了aop\"></a>4.在你的项目中那个场景用到了aop</h4><h4 id=\"5-常用的集合类，hashmap、hashtable区别\"><a href=\"#5-常用的集合类，hashmap、hashtable区别\" class=\"headerlink\" title=\"5.常用的集合类，hashmap、hashtable区别\"></a>5.常用的集合类，hashmap、hashtable区别</h4><h4 id=\"6-开发过程中常用的IO操作\"><a href=\"#6-开发过程中常用的IO操作\" class=\"headerlink\" title=\"6.开发过程中常用的IO操作\"></a>6.开发过程中常用的IO操作</h4><h4 id=\"7-左连接、右连接、内连接的区别\"><a href=\"#7-左连接、右连接、内连接的区别\" class=\"headerlink\" title=\"7.左连接、右连接、内连接的区别\"></a>7.左连接、右连接、内连接的区别</h4><h4 id=\"8-mysql的存储引擎都有哪些\"><a href=\"#8-mysql的存储引擎都有哪些\" class=\"headerlink\" title=\"8.mysql的存储引擎都有哪些\"></a>8.mysql的存储引擎都有哪些</h4><h4 id=\"9-INNODB下，行锁-情况下对每行进行updata-没有加where条件他锁的是什么-，或是加了where没有走索引会有什么问题\"><a href=\"#9-INNODB下，行锁-情况下对每行进行updata-没有加where条件他锁的是什么-，或是加了where没有走索引会有什么问题\" class=\"headerlink\" title=\"9.INNODB下，行锁 情况下对每行进行updata 没有加where条件他锁的是什么 ，或是加了where没有走索引会有什么问题\"></a>9.INNODB下，行锁 情况下对每行进行updata 没有加where条件他锁的是什么 ，或是加了where没有走索引会有什么问题</h4><h4 id=\"10-mybatis-和-的区别\"><a href=\"#10-mybatis-和-的区别\" class=\"headerlink\" title=\"10.mybatis #{}和${}的区别\"></a>10.mybatis #{}和${}的区别</h4><ul>\n<li><p>${}是 Properties ⽂件中的变量占位符，它可以⽤于标签属性值和 sql 内部，属于静态⽂本替换，⽐如${driver}会被静态替换为 com.mysql.jdbc.Driver。</p>\n</li>\n<li><p>#{}是 sql 的参数占位符，mybatis在处理#{}时，会将sql中的#{}替换为 ?，调用PreparedStatement的set方法来赋值，按序给 sql 的?号占位符设置参数值；使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</p>\n</li>\n</ul>\n<p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;select id&#x3D;&quot;selectPerson&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;hashmap&quot;&gt;</span><br><span class=\"line\">  SELECT * FROM PERSON WHERE ID &#x3D; #&#123;id&#125;</span><br><span class=\"line\">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p>\n<p>注意参数符号：#{id}</p>\n<p>这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 近似的 JDBC 代码，非 MyBatis 代码...</span><br><span class=\"line\">String selectPerson &#x3D; &quot;SELECT * FROM PERSON WHERE ID &#x3D; ?&quot;;</span><br><span class=\"line\">PreparedStatement ps &#x3D; conn.prepareStatement(selectPerson);</span><br><span class=\"line\">ps.setInt(1,id);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用：\"><a href=\"#引用：\" class=\"headerlink\" title=\"引用：\"></a><strong>引用：</strong></h3><h4 id=\"什么是MySql注入\"><a href=\"#什么是MySql注入\" class=\"headerlink\" title=\"什么是MySql注入\"></a><strong>什么是MySql注入</strong></h4><blockquote>\n<p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p>\n</blockquote>\n<p>简单说，就是我们在拼接sql的时候，没有过滤用户的非法sql，导致查询结果和我们预想的不一样。</p>\n<p><strong>举个简单例子来帮助理解（实际开发中可能不存在这种简单的错误）</strong></p>\n<p><strong>比如我们要根据用户名和密码进行登录，我们后台sql这样写</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username = ? <span class=\"keyword\">and</span> <span class=\"keyword\">password</span> = ?</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们预想的：用户输入 username：张三，password：123456</strong></p>\n<p><strong>但实际人家黑客这样输入： username：张三，password： &quot; or 1 = 1 --</strong></p>\n<p><strong>根据黑客输入的参数，我们的sql将变成这样了</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username = <span class=\"string\">&quot;张三&quot;</span> <span class=\"keyword\">and</span> <span class=\"keyword\">password</span> = <span class=\"string\">&quot;&quot;</span> <span class=\"keyword\">or</span> <span class=\"number\">1</span> = <span class=\"number\">1</span> <span class=\"comment\">-- &quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>后面这个 -- 就是注释，它注释了后面的其它内容，整个sql就变成下面这样，因为 or 1 = 1，所以怎么都会出结果</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username = <span class=\"string\">&quot;张三&quot;</span> <span class=\"keyword\">and</span> <span class=\"keyword\">password</span> = <span class=\"string\">&quot;&quot;</span> <span class=\"keyword\">or</span> <span class=\"number\">1</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>当然了上面只是一个简单的sql注入，有人说实际开发中，我们根本不会这样去做。当然了实际情况中黑客也比我牛批一亿倍，这个例子是为了让你简单理解什么是sql注入。</p>\n<h4 id=\"防止Sql注入攻击\"><a href=\"#防止Sql注入攻击\" class=\"headerlink\" title=\"防止Sql注入攻击\"></a>防止Sql注入攻击</h4><p><strong>1.（简单又有效的方法）PreparedStatement</strong></p>\n<p> 采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。</p>\n<p> 使用好处：</p>\n<ol>\n<li><p> 代码的可读性和可维护性.</p>\n</li>\n<li><p>PreparedStatement尽最大可能提高性能.</p>\n</li>\n<li><p>最重要的一点是极大地提高了安全性.</p>\n<p>原理：</p>\n<p>sql注入只对sql语句的准备(编译)过程有破坏作用</p>\n<p>而PreparedStatement已经准备好了,执行阶段只是把输入串作为数据处理, 而不再对sql语句进行解析准备,因此也就避免了sql注入问题.</p>\n</li>\n</ol>\n<p><strong>2.使用正则表达式过滤传入的参数</strong></p>\n<p><strong>3.字符串过滤</strong></p>\n<p><strong>4.jsp中调用该函数检查是否包函非法字符</strong></p>\n<p> 防止SQL从URL注入：</p>\n<p><strong>5.JSP页面判断代码：</strong></p>\n<p> 使用<span class=\"exturl\" data-url=\"aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2phdmFzY3JpcHQ=\">JavaScript<i class=\"fa fa-external-link-alt\"></i></span>在客户端进行不安全字符屏蔽</p>\n<p> 功能介绍：检查是否含有”‘”,”\\”,”/”</p>\n<p> 参数说明：要检查的字符串</p>\n<p> 返回值：0：是1：不是</p>\n<p> 总的说来，防范一般的SQL注入只要在代码规范上下点功夫就可以了。</p>\n<p> 凡涉及到执行的SQL中有变量时，用JDBC（或者其他数据持久层）提供的如：<strong>PreparedStatement</strong>就可以 ，切记不要用拼接字符串的方法就可以了。</p>\n","categories":["面试"]},{"title":"深演智能一面视频","url":"/2020-11-20-%E6%B7%B1%E6%BC%94%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91.html","content":"<p>linux 下查内存命令</p>\n<p>jscri 中怎么用隐藏的标签（就是怎么把vlaue值隐藏）</p>\n<p>spring 中事务在项目中怎么用的 配置文件了吗</p>\n<p>mybatis 开启一级和二级缓存 怎么保证删除数据库中的文件后缓存中数据的一致性</p>\n<p>怎么看自己项目的gc</p>\n<p>怎么解决oom</p>\n<p>linux 查看文件名称包含哪个字符串怎么查找</p>\n<p>inux 下查剩余内存命令</p>\n<p>数据库limit的使用</p>\n<p>索引失效的举例</p>\n","categories":["java"]},{"title":"linux下查看剩余内存、查看文件根据文件名字符串","url":"/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%89%A9%E4%BD%99%E5%86%85%E5%AD%98%E3%80%81%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2.html","content":"<h2 id=\"linux下查看剩余内存\"><a href=\"#linux下查看剩余内存\" class=\"headerlink\" title=\"linux下查看剩余内存\"></a>linux下查看剩余内存</h2><p>看linux系统中空闲内存/物理内存使用/剩余内存</p>\n<p>查看系统内存有很多方法，<strong>但主要的是用top命令和free 命令</strong> 当执行top命令看到结果，要怎么看呢？</p>\n<p>这里说明一下： Mem: 666666k total, 55555k used,并不是代表你的应用程序已经使用了55555k的内存,这55555k是包含了:应用程序内存 + 缓冲 + 缓存的内存的。 </p>\n<p><strong>1.用free命令查看更直接： 下面是一个例子(单位是MB):</strong> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@linuxzgf ~]# free -m</span><br><span class=\"line\">                    total       used       free     shared    buffers     cached</span><br><span class=\"line\">Mem:          <span class=\"number\">7982</span>       <span class=\"number\">6811</span>       <span class=\"number\">1171</span>          <span class=\"number\">0</span>        <span class=\"number\">350</span>       <span class=\"number\">5114</span></span><br><span class=\"line\">-<span class=\"regexp\">/+ buffers/</span>cache:       <span class=\"number\">1346</span>       <span class=\"number\">6636</span></span><br><span class=\"line\">Swap:        <span class=\"number\">16935</span>         <span class=\"number\">11</span>      <span class=\"number\">16924</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.  一些简单的计算方法：  物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M</p>\n<p>物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存 </p>\n<p>应用程序可用空闲内存 = 总物理内存 - 实际已用内存 </p>\n<p>应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存</p>\n<p><strong>2.top命令的结果详解 top命令 是Linux下常用的性能 分析工具 ，能够实时显示系统 中各个进程的资源占用状况，类似于Windows的任务管理 器。下面详细介绍它的使用方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">top - <span class=\"number\">0</span>2:<span class=\"number\">53</span>:<span class=\"number\">32</span> up <span class=\"number\">16</span> days,  <span class=\"number\">6</span>:<span class=\"number\">34</span>, <span class=\"number\">17</span> users,  load average: <span class=\"number\">0.24</span>, <span class=\"number\">0.21</span>, <span class=\"number\">0.24</span></span><br><span class=\"line\">Tasks: <span class=\"number\">481</span> total,   <span class=\"number\">3</span> running, <span class=\"number\">474</span> sleeping,   <span class=\"number\">0</span> stopped,   <span class=\"number\">4</span> zombie</span><br><span class=\"line\">Cpu(s): <span class=\"number\">10.3</span>%us,  <span class=\"number\">1.8</span>%sy,  <span class=\"number\">0.0</span>%ni, <span class=\"number\">86.6</span>%id,  <span class=\"number\">0.5</span>%wa,  <span class=\"number\">0.2</span>%hi,  <span class=\"number\">0.6</span>%si,  <span class=\"number\">0.0</span>%st</span><br><span class=\"line\">Mem:   <span class=\"number\">4042764</span>k total,  <span class=\"number\">4001096</span>k used,    <span class=\"number\">41668</span>k free,   <span class=\"number\">383536</span>k buffers</span><br><span class=\"line\">Swap:  <span class=\"number\">2104472</span>k total,     <span class=\"number\">7900</span>k used,  <span class=\"number\">2096572</span>k free,  <span class=\"number\">1557040</span>k cached</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class=\"line\"><span class=\"number\">32497</span> jacky     <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">669</span>m <span class=\"number\">222</span>m  <span class=\"number\">31</span>m R   <span class=\"number\">10</span>  <span class=\"number\">5.6</span>       <span class=\"number\">29</span>:<span class=\"number\">27.62</span> firefox</span><br><span class=\"line\"> <span class=\"number\">4788</span> yiuwing   <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">257</span>m  <span class=\"number\">18</span>m  <span class=\"number\">13</span>m S    <span class=\"number\">5</span>  <span class=\"number\">0.5</span>          <span class=\"number\">5</span>:<span class=\"number\">42.44</span> konsole</span><br><span class=\"line\"> <span class=\"number\">5657</span> Liuxiaof  <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">585</span>m <span class=\"number\">159</span>m  <span class=\"number\">30</span>m S    <span class=\"number\">4</span>  <span class=\"number\">4.0</span>          <span class=\"number\">5</span>:<span class=\"number\">25.06</span> firefox</span><br><span class=\"line\"> <span class=\"number\">4455</span> xiefc      <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">542</span>m  <span class=\"number\">124</span>m  <span class=\"number\">30</span>m R    <span class=\"number\">4</span>  <span class=\"number\">3.1</span>         <span class=\"number\">7</span>:<span class=\"number\">23.03</span> firefox</span><br><span class=\"line\"> <span class=\"number\">6188</span> Liuxiaof  <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">191</span>m   <span class=\"number\">17</span>m  <span class=\"number\">13</span>m S    <span class=\"number\">4</span>  <span class=\"number\">0.5</span>          <span class=\"number\">0</span>:<span class=\"number\">0</span>1<span class=\"number\">.16</span> konsole</span><br></pre></td></tr></table></figure>\n\n","categories":["linux"]},{"title":"linux下查看文件内容、实时查看","url":"/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B.html","content":"<h2 id=\"Linux下查看文件内容的命令\"><a href=\"#Linux下查看文件内容的命令\" class=\"headerlink\" title=\"Linux下查看文件内容的命令\"></a>Linux下查看文件内容的命令</h2><p>查看文件内容的命令：</p>\n<p>cat   由第一行开始显示内容，并将所有内容输出</p>\n<p>tac   从最后一行倒序显示内容，并将所有内容输出</p>\n<p>more   根据窗口大小，一页一页的现实文件内容</p>\n<p>less   和more类似，但其优点可以往前翻页，而且进行可以搜索字符</p>\n<p>head   只显示头几行</p>\n<p>tail   只显示最后几行</p>\n<p>nl    类似于cat -n，显示时输出行号</p>\n<p>tailf  类似于tail -f </p>\n<h3 id=\"1-cat-与-tac\"><a href=\"#1-cat-与-tac\" class=\"headerlink\" title=\"1.cat 与 tac\"></a><strong>1.cat 与 tac</strong></h3><p>cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。但是cat并不常用，原因是当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。</p>\n<p>cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</p>\n<p>tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令也不常用。</p>\n<p>tac语法：tac 文件名。</p>\n<h3 id=\"2-more和less（常用）\"><a href=\"#2-more和less（常用）\" class=\"headerlink\" title=\"2.more和less（常用）\"></a>2.more和less（常用）</h3><p>more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</p>\n<p>more的语法：more 文件名</p>\n<p>Enter 向下n行，需要定义，默认为1行； </p>\n<p>Ctrl f 向下滚动一屏； </p>\n<p>空格键 向下滚动一屏； </p>\n<p>Ctrl b 返回上一屏； </p>\n<p>= 输出当前行的行号； </p>\n<p>:f 输出文件名和当前行的行号； </p>\n<p>v 调用vi编辑器； </p>\n<p>! 命令 调用Shell，并执行命令； </p>\n<p>q 退出more</p>\n<p>less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</p>\n<p>less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</p>\n<p>less的语法：less 文件名</p>\n<p>less还有一个功能，可以在文件中进行搜索你想找的内容，假设你想在passwd文件中查找有没有weblogic字符串，那么你可以这样来做：</p>\n<p>[root@redhat etc]# less passwd</p>\n<p>然后输入：</p>\n<p>/weblogic</p>\n<p>回车</p>\n<p>此时如果有weblogic字符串，linux会把该字符已高亮方式显示。</p>\n<p>退出查看页面，请按“q”键。</p>\n<h3 id=\"3-head和tail\"><a href=\"#3-head和tail\" class=\"headerlink\" title=\"3.head和tail\"></a>3.head和tail</h3><p>head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</p>\n<p>head的语法：head [n number] 文件名 (number 显示行数)</p>\n<p>tail的功能恰好和head相反，只显示最后几行内容</p>\n<p>tail的语法:tail [-n number] 文件名</p>\n<h3 id=\"4-nl\"><a href=\"#4-nl\" class=\"headerlink\" title=\"4.nl\"></a>4.nl</h3><p>nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</p>\n<p>nl的语法：nl 文件名 </p>\n<h3 id=\"5-tailf\"><a href=\"#5-tailf\" class=\"headerlink\" title=\"5.tailf\"></a>5.tailf</h3><p>　tailf命令几乎等同于tail -f，严格说来应该与tail --follow=name更相似些。当文件改名之后它也能继续跟踪，特别适合于日志文件的跟踪（follow the growth of a log file）。与tail -f不同的是，如果文件不增长，它不会去访问磁盘文件（It is similar to tail -f but does not access the file when it is not growing. This has the side effect of not updating the access time for the file, so a filesystem flush does not occur periodically when no log activity is happening.）。tailf特别适合那些便携机上跟踪日志文件，因为它能省电，因为减少了磁盘访问嘛（tailf is extremely useful for monitoring log files on a laptop when logging is infrequent and the user desires that the hard disk spin down to conserve battery life.）。tailf命令不是个脚本，而是一个用C代码编译后的二进制执行文件，某些Linux安装之后没有这个命令，本文提供了怎么编译安装tailf命令的方法。</p>\n<h2 id=\"面就谈谈二者的区别：\"><a href=\"#面就谈谈二者的区别：\" class=\"headerlink\" title=\"面就谈谈二者的区别：\"></a>面就谈谈二者的区别：</h2><ol>\n<li><p>tailf 总是从文件开头一点一点的读， 而tail -f 则是从文件尾部开始读</p>\n</li>\n<li><p>tailf check文件增长时，使用的是文件名， 用stat系统调用；而tail -f 则使用的是已打开的文件描述符； 注：tail 也可以做到类似跟踪文件名的效果； 但是tail总是使用fstat系统调用，而不是stat系统调用；结果就是：默认情况下，当tail的文件被偷偷删除时，tail是不知道的，而tailf是知道的。</p>\n<p>常用参数</p>\n</li>\n</ol>\n<p>格式：tailf logfile</p>\n<p>动态跟踪日志文件logfile，最初的时候打印文件的最后10行内容。</p>\n<p>watch -n 1 aa.txt  #每个1秒显示aa.txt的内容</p>\n<h3 id=\"Linux下实时显示文件内容\"><a href=\"#Linux下实时显示文件内容\" class=\"headerlink\" title=\"Linux下实时显示文件内容\"></a>Linux下实时显示文件内容</h3><ol>\n<li><p> watch -n 1 aa.txt    #每个1秒显示aa.txt的内容</p>\n</li>\n<li><p>tail -f  ***.log</p>\n</li>\n</ol>\n<p>Linux shell中有一个tail命令，常用来显示一个文件的最后n行文档内容</p>\n<p>但更多情况下，我们要在服务器端运行程序，并且需要实时监控运行日志，这时候有什么办法实时滚动显示log文件内容？</p>\n<p>这里可以利用tail命令加参数f实现，具体用法如下：</p>\n<p>tail -f  ***.log</p>\n<p>参数说明-f, --follow[={name|descriptor}]：output appended data as the file grows; -f, --follow, and --follow=descriptor are equivalent</p>\n<p>用法：tail  (-10f)  test ：（-10f）可选，tail  -10f server.xml    </p>\n<p>tail  (-10f)  test：中间-10f为可选，不输入该属性时，显示文件的全部内容；如-10f，显示当前文件的最后10行内容，10为显示文件的行数，可变，如果不输入中间参数例如10的时候，我们直接tail -f  server.xml查看实时内容。</p>\n<p>tail其它参数运行 man tail 查看</p>\n","categories":["linux"],"tags":["linux下查看文件内容"]},{"title":"redis常见问题","url":"/2020-11-24-redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html","content":"<h1 id=\"一、Redis雪崩、穿透、击穿、并发等难题解决方案\"><a href=\"#一、Redis雪崩、穿透、击穿、并发等难题解决方案\" class=\"headerlink\" title=\"一、Redis雪崩、穿透、击穿、并发等难题解决方案\"></a>一、Redis雪崩、穿透、击穿、并发等难题解决方案</h1><p><strong>使用缓存的主要目是提升查询速度和减轻数据库压力。而缓存最常见的问题是缓存穿透、击穿和雪崩，在高并发下这三种情况都会有大量请求落到数据库，导致数据库资源占满，引起数据库故障。</strong></p>\n<h2 id=\"1-缓存雪崩\"><a href=\"#1-缓存雪崩\" class=\"headerlink\" title=\"1.缓存雪崩\"></a>1.缓存雪崩</h2><p>定义：在高并发下，缓存（key）在同⼀时间内⼤⾯积的失效，所以后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。</p>\n<p>雪崩过程：</p>\n<ol>\n<li>redis集群大面积故障</li>\n<li>缓存失效，但依然大量请求访问缓存服务redis</li>\n<li>redis大量失效后，大量请求转向到mysql数据库</li>\n<li>mysql的调用量暴增，很快就扛不住了，甚至直接宕机</li>\n<li>由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>事前：①<strong>保证redis高可用</strong>，配置redis集群，如果发现有宕机的尽快补上；这种方案就是在发生雪崩前对缓存集群实现高可用，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。②选择合适的<strong>内存淘汰策略</strong>，让缓存失效的时间点尽量均匀。③<strong>数据预热</strong>，数据预热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中；在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>\n<li>事中：<strong>使用本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</strong>；使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster （集群）完全不可用的时候，ehcache 本地缓存还能够支撑一阵。使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。</li>\n<li>事后：<strong>利⽤ redis 持久化机制保存的数据尽快恢复缓存</strong>；一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</li>\n</ol>\n<h2 id=\"2-缓存穿透\"><a href=\"#2-缓存穿透\" class=\"headerlink\" title=\"2.缓存穿透\"></a>2.缓存穿透</h2><p>定义：缓存穿透就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这⼀层，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。。</p>\n<p>穿透过程：</p>\n<ol>\n<li>请求的key首先到达redis缓存中，发现不存在，访问数据库；如果是正常访问，存在就直接返回数据了。</li>\n<li>然后请求到达数据库，然后数据库中还不存在，直接返回结果；如果存在则把数据缓存到redis中，并返回数据。</li>\n</ol>\n<blockquote>\n<p>⼀般MySQL 默认的最⼤连接数在 150 左右，这个可以通过 show variables like &#39;%max_connections%&#39;;命令来查看。最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹络等⽆⼒条件都是其运⾏指标，这些指标都会限制其并发能⼒！所以，⼀般 3000 个并发请求就能打死⼤部分数据库了。</p>\n</blockquote>\n<p>解决办法：</p>\n<p>最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的数据库 id 不能⼩于 0、传⼊的邮箱格式不正确的时候直接返回错误消息给客户端等等。</p>\n<ol>\n<li>缓存⽆效 key :  如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时间，具体命令如下： SET key value EX 10086。这种⽅式可以解决请求的 key 变化不频繁的情况，如果⿊客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存⼤量⽆效的 key 。很明显，这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key的过期时间设置短⼀点⽐如 1 分钟。另外，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。</li>\n<li>布隆过滤器：布隆过滤器是⼀个⾮常神奇的<strong>数据结构</strong>，<strong>通过它我们可以⾮常⽅便地判断⼀个给定数据是否存在与海量数据中</strong>。我们需要的就是判断 key 是否合法，<strong>拦截对 不存在数据的请求</strong>。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会⾛下⾯的流程。<strong>使用：</strong>将数据库中所有的查询条件，放入布隆过滤器中，当一个查询请求过来时，先经过布隆过滤器进行查看，如果判断请求查询值存在，则继续查；如果判断请求查询不存在，直接丢弃。</li>\n</ol>\n<p>布隆过滤器这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</p>\n<blockquote>\n<h3 id=\"布隆过滤器的原理介绍\"><a href=\"#布隆过滤器的原理介绍\" class=\"headerlink\" title=\"布隆过滤器的原理介绍\"></a>布隆过滤器的原理介绍</h3><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>\n<ol>\n<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>\n<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>\n</ol>\n<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>\n<ol>\n<li>对给定元素再次进行相同的哈希计算；</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>\n</ol>\n<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>\n<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<p><strong>应用场景</strong></p>\n<ol>\n<li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li>\n<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li>\n</ol>\n</blockquote>\n<h2 id=\"3-缓存击穿\"><a href=\"#3-缓存击穿\" class=\"headerlink\" title=\"3.缓存击穿\"></a>3.缓存击穿</h2><p>定义：在高并发下，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。会造成某一时刻数据库请求量过大，压力剧增。这种现象我们称为<strong>缓存击穿</strong>。</p>\n<p>解决办法：</p>\n<ol>\n<li>使用锁，单机用synchronized,lock等，分布式用分布式锁：上<strong>面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它；其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</strong></li>\n<li>缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。</li>\n<li>在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。</li>\n<li>设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存</li>\n</ol>\n<h2 id=\"4-Redis为什么时高并发的、快速的\"><a href=\"#4-Redis为什么时高并发的、快速的\" class=\"headerlink\" title=\"4.Redis为什么时高并发的、快速的\"></a>4.Redis为什么时高并发的、快速的</h2><p>1.redis是基于内存的，内存的读写速度非常快；</p>\n<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>\n<p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>\n<p>下面重点介绍单线程设计和IO多路复用核心设计快的原因。</p>\n<p><strong>为什么Redis是单线程的？</strong></p>\n<p><strong>1.官方答案</strong></p>\n<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p><strong>2.性能指标</strong></p>\n<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p><strong>3.详细原因</strong></p>\n<p><strong>1）不需要各种锁的性能消耗</strong></p>\n<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>\n<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>\n<p><strong>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</strong></p>\n<p><strong>2）单线程多进程集群方案</strong></p>\n<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>\n<p><strong>所以单线程、多进程的集群不失为一个好的解决方案。</strong></p>\n<p><strong>3）CPU消耗</strong></p>\n<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>\n<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>\n<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>\n<p>Redis单线程的优劣势</p>\n<p><strong>单进程单线程优势</strong></p>\n<ul>\n<li>代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU</li>\n</ul>\n<p><strong>单进程单线程弊端</strong></p>\n<ul>\n<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>\n</ul>\n<p><strong>IO多路复用技术</strong></p>\n<p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p>\n<p>多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。</p>\n<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>\n<p><strong>Redis高并发快总结</strong></p>\n<ol>\n<li><p>Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</p>\n</li>\n<li><p>再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</p>\n</li>\n<li><p>Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p>\n</li>\n<li><p>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p>\n</li>\n<li><p>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p>\n</li>\n</ol>\n<blockquote>\n<p>什么是上下⽂切换?<br>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。<br>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。<strong>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</strong></p>\n</blockquote>\n","categories":["redis"]},{"title":"索引种类","url":"/2020-11-24%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB.html","content":"<h1 id=\"MySql\"><a href=\"#MySql\" class=\"headerlink\" title=\"MySql\"></a>MySql</h1><h2 id=\"MySQL索引种类\"><a href=\"#MySQL索引种类\" class=\"headerlink\" title=\"MySQL索引种类\"></a>MySQL索引种类</h2><p>在 InnoDB 中，有聚簇索引和普通索引之分，聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，根据主键查询可以直接利用聚簇索引定位到所在记录。而普通索引根据申明这个索引时候的列来构建，叶子节点存放的是这一行记录对应的主键的值，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。如果我们查询一整行记录的话，一定要去聚簇索引上查找，而如果我们只需要根据普通索引查询主键的值，由于这些值在普通索引上已经存在，所以并不需要回表，这个称为索引覆盖，在一定程度上可以提高查询效率。</p>\n<p>1.普通索引<br>2.唯一索引<br>3.主键索引<br>4.组合索引<br>5.全文索引</p>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a><strong>语句</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE table_name[col_name data type]</span><br><span class=\"line\">[unique|fulltext][index|key][index_name](col_name[length])[asc|desc]</span><br></pre></td></tr></table></figure>\n\n<p>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引<br>2.index和key为同义词，两者作用相同，用来指定创建索引<br>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择<br>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值<br>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度<br>6.asc或desc指定升序或降序的索引值存储</p>\n<p>1.普通索引<br>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p>\n<p>（2）修改表结构的方式添加索引</p>\n<p>（3）创建表的时候同时创建索引</p>\n<p>2.唯一索引<br>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p>\n<p>（2）修改表结构</p>\n<p>（3）创建表的时候直接指定</p>\n<p>3.主键索引<br>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</p>\n<p>4.组合索引<br>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>\n<p>5.全文索引<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br>（1）创建表的适合添加全文索引</p>\n<p>（2）修改表结构添加全文索引</p>\n<p>（3）直接创建索引</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1.虽然索引大大提高了查询速度，<strong>同时却会降低更新表的速度</strong>，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。</p>\n<p>2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。</p>\n<p>索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>使用索引时，有以下一些技巧和注意事项：</p>\n<p>1.最佳左前缀法则</p>\n<p>2.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一至）），减少select *</p>\n<p>3.索引列排序</p>\n<p>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>\n<p>4.like语句操作<br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>\n<p>5.不要在列上进行运算（函数）<br>这将导致索引失效而进行全表扫描，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name WHERE YEAR(column_name)&lt;2017;</span><br></pre></td></tr></table></figure>\n\n<p>6.不使用！=和&lt;&gt;操作</p>\n<h2 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h2><p><strong>InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号。</strong>每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。</p>\n<p>所谓的<code>MVCC（Multi-Version Concurrency Control ，多版本并发控制）</code>指的就是在使用<code>读已提交（READ COMMITTD）、可重复读（REPEATABLE READ）</code>这两种隔离级别的事务<strong>在执行普通的SELECT操作时访问记录的版本链的过程</strong>，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>\n<p>这两个隔离级别的一个很大不同就是：<code>生成ReadView的时机不同</code>，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，数据的可重复读其实就是ReadView的重复使用。</p>\n<p>这样去解释这些技术，主要是希望大家对现象背后的本质多点思考，不然你去背出这几种隔离级别，以及各种数据现象是没有任何意义的，实际开发过程中真的出现了问题，你不懂本质以及过程，你去排查也会很难受的，到头来还是要看书，看资料。</p>\n<p><strong>在REPEATABLE READ的条件下：</strong></p>\n<p>SELECT InnoDB会根据以下两个条件检查每行纪录：</p>\n<ul>\n<li>InnoDB只查找版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。 只有符合上述两个条件的纪录，才能作为查询结果返回。</li>\n</ul>\n<p>INSERT - InnoDB为插入的每一行保存当前系统版本号作为行版本号。</p>\n<p>DELETE - InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>\n<p>UPDATE - InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时，保存当前系统版本号到原来的行作为行删除标识。</p>\n<p>优点： 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好。</p>\n<p>缺点： 每行纪录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>\n<p>读到这里，也许会有一个疑问，考虑如下执行序列：</p>\n<p><img data-src=\"https://pic1.zhimg.com/80/v2-ed8058116c2d603a88c69209e795f490_720w.jpg\" alt=\"img\" loading=\"lazy\"></p>\n<p>按照之前的Select规则，会话B 的事务是在 会话A的后面开启的，那么B的事务版本号大于A的事务版本号。这样在A中插入的数据在未提交的情况下，B可以读到A修改的数据，这不就自相矛盾了么？其实不然，InnoDB每个事务在开始的时候，会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list）创建一个副本（read view），然后一致性读去比较记录的tx id的时候，并不是根据当前事务的tx id，而是根据read view最早一个事务的tx id（read view-&gt;up_limit_id）来做比较的，这样就能确保在事务B之前没有提交的所有事务的变更，B事务都是看不到的。如下图所示：</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-f76b5721c5b6f4b2ecfaccf892db57be_720w.jpg\" alt=\"img\" loading=\"lazy\"></p>\n","categories":["MySql"],"tags":["sql"]},{"title":"SpringBoot整合Redis","url":"/2020-11-25-SpringBoot%E6%95%B4%E5%90%88Redis.html","content":"<p><strong>Redis</strong></p>\n<p>基于内存进行存储，支持key-value的存储形式，底层是用C语言写的。</p>\n<p>基于key-value形式的数据字典，结构非常简单，没有数据表的概念，直接用键值对的形式完成数据的管理，支持5种数据类型：</p>\n<ul>\n<li>字符串String</li>\n<li>列表List</li>\n<li>集合Set</li>\n<li>有序集合zSet</li>\n<li>哈希hash</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">offCOPY&#x2F;&#x2F;Redis启动批处理程序</span><br><span class=\"line\">title redis-server</span><br><span class=\"line\">set ENV_HOME&#x3D;&quot;C:\\redis&quot;</span><br><span class=\"line\">C:</span><br><span class=\"line\">color 0F</span><br><span class=\"line\">cd %ENV_HOME%</span><br><span class=\"line\">redis-server redis.windows.conf</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-Boot-整合-Redis\"><a href=\"#Spring-Boot-整合-Redis\" class=\"headerlink\" title=\"Spring Boot 整合 Redis\"></a>Spring Boot 整合 Redis</h3><p>实际上使用Spring Data Redis操作Redis，</p>\n<p>1、创建maven工程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class=\"line\">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;com.hhzhu&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;redis_practice&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class=\"line\">    &lt;&#x2F;parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;!--连接池 redis客户端需要的支持--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;!--简化实体类的开发--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\">    &lt;&#x2F;dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、创建实体类，实现序列化接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.hhzhu.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@Data</span><br><span class=\"line\">&#x2F;&#x2F;实现序列化接口，否则无法存入redis，因为redis是存在内存中的</span><br><span class=\"line\">public class Student implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private Double score;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、创建控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYpackage com.hhzhu.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.hhzhu.pojo.Student;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class StudentHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;&#x2F;set&quot;)</span><br><span class=\"line\">    &#x2F;&#x2F;Request将json数据转换成java对象</span><br><span class=\"line\">    public void set(@RequestBody Student student)&#123;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(&quot;student&quot;,student);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、创建配置文件appliacation.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYspring:</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    database: 0</span><br><span class=\"line\">    host: localhost</span><br><span class=\"line\">    port: 6379</span><br></pre></td></tr></table></figure>\n\n<p>5、创建启动类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYpackage com.hhzhu;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(Application.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6、CRUD</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYpackage com.hhzhu.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.hhzhu.pojo.Student;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class StudentHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;&#x2F;set&quot;)</span><br><span class=\"line\">    &#x2F;&#x2F;Request将json数据转换成java对象</span><br><span class=\"line\">    public void set(@RequestBody Student student)&#123;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(&quot;student&quot;,student);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(&quot;&#x2F;get&#x2F;&#123;key&#125;&quot;)</span><br><span class=\"line\">    public Student get(@PathVariable(&quot;key&quot;) String key)&#123;</span><br><span class=\"line\">        return (Student) redisTemplate.opsForValue().get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @DeleteMapping(&quot;&#x2F;delete&#x2F;&#123;key&#125;&quot;)</span><br><span class=\"line\">    public boolean delete(@PathVariable(&quot;key&quot;) String key)&#123;</span><br><span class=\"line\">        redisTemplate.delete(key);</span><br><span class=\"line\">        return redisTemplate.hasKey(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redis-5种数据类型\"><a href=\"#Redis-5种数据类型\" class=\"headerlink\" title=\"Redis 5种数据类型\"></a>Redis 5种数据类型</h3><ul>\n<li><p><strong>字符串</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;string&quot;)</span><br><span class=\"line\">public String stringTest()&#123;</span><br><span class=\"line\">    redisTemplate.opsForValue().set(&quot;str&quot;,&quot;Hello world&quot;);</span><br><span class=\"line\">    &#x2F;&#x2F;System.out.println(redisTemplate.opsForValue().get(&quot;str&quot;));</span><br><span class=\"line\">    String str &#x3D; (String) redisTemplate.opsForValue().get(&quot;str&quot;);</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>列表</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;list&quot;)</span><br><span class=\"line\">public List&lt;String&gt; listTest()&#123;</span><br><span class=\"line\">    ListOperations&lt;String,String&gt; listOperations &#x3D; redisTemplate.opsForList();</span><br><span class=\"line\">    listOperations.leftPush(&quot;list&quot;,&quot;hello&quot;);</span><br><span class=\"line\">    listOperations.leftPush(&quot;list&quot;,&quot;world&quot;);</span><br><span class=\"line\">    listOperations.rightPush(&quot;list&quot;,&quot;java&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">    List&lt;String&gt; list &#x3D; listOperations.range(&quot;list&quot;,0,2);</span><br><span class=\"line\">    return list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>集合(set)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;set&quot;)</span><br><span class=\"line\">public Set&lt;String&gt; setTest()&#123;</span><br><span class=\"line\">    SetOperations&lt;String,String&gt; setOperations &#x3D; redisTemplate.opsForSet();</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;Hello&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;Hello&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;world&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;world&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;java&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;java&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">    Set&lt;String&gt; set &#x3D; setOperations.members(&quot;set&quot;);</span><br><span class=\"line\">    return set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>有序集合</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;zset&quot;)</span><br><span class=\"line\">public Set&lt;String&gt; zsetTest()&#123;</span><br><span class=\"line\">    ZSetOperations&lt;String,String&gt; zSetOperations &#x3D; redisTemplate.opsForZSet();</span><br><span class=\"line\">    zSetOperations.add(&quot;zset&quot;,&quot;Hello&quot;,1);</span><br><span class=\"line\">    zSetOperations.add(&quot;zset&quot;,&quot;world&quot;,2);</span><br><span class=\"line\">    zSetOperations.add(&quot;zset&quot;,&quot;java&quot;,3);</span><br><span class=\"line\">  </span><br><span class=\"line\">    Set&lt;String&gt; set &#x3D; zSetOperations.range(&quot;zset&quot;,0,2);</span><br><span class=\"line\">    return set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>哈希</strong></p>\n<p>Hash：key value</p>\n<p>HashOperations：key hashkey value</p>\n<p>key是每一组数据的ID，hashkey和value是一组完整的HashMap数据，通过key来区分不同的HashMap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYHashMap hashMap &#x3D; new HashMap();</span><br><span class=\"line\">hashMap.put(key1,value1);</span><br><span class=\"line\">HashMap hashMap &#x3D; new HashMap();</span><br><span class=\"line\">hashMap.put(key2,value2);</span><br><span class=\"line\">HashMap hashMap &#x3D; new HashMap();</span><br><span class=\"line\">hashMap.put(key3,value3);</span><br><span class=\"line\"></span><br><span class=\"line\">HashOperations&lt;String,String,String&gt; hashOperation &#x3D; redisTemplate.opsForHash();</span><br><span class=\"line\">hashOperation.put(hashMap1,key1,value1);</span><br><span class=\"line\">hashOperation.put(hashMap2,key2,value2);</span><br><span class=\"line\">hashOperation.put(hashMap3,key3,value3);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;hash&quot;)</span><br><span class=\"line\">public void hashTest()&#123;</span><br><span class=\"line\">    HashOperations&lt;String,String,String&gt; hashOperations &#x3D; redisTemplate.opsForHash();</span><br><span class=\"line\">    hashOperations.put(&quot;key&quot;,&quot;hashKey&quot;,&quot;Hello&quot;);</span><br><span class=\"line\">    System.out.println(hashOperations.get(&quot;key&quot;,&quot;hashKey&quot;));</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":["Redis"]},{"title":"获取 GitHub Personal Access Token 方法","url":"/3.html","content":"<a id=\"more\"></a>\n\n<p>要将博客部署到 GitHub Pages 上， push 操作自然是免不了的，这就要求要有相应的仓库权限。直接用帐号密码无疑是十分不安全的，所以这里通过 GitHub Personal Access Token 来实现。</p>\n<p>点击 GitHub <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Byb2ZpbGU=\">用户设置页面<i class=\"fa fa-external-link-alt\"></i></span> 最下方的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2FwcHM=\">Developer setting<i class=\"fa fa-external-link-alt\"></i></span> ，然后选择 <code>Personal access tokens</code> 来生成一个 token，由于我们只需要能够对普通仓库 push 就行了，所以把 <code>repo</code> 部分勾上即可。<br><img data-src=\"/3/1240.jpeg\" alt=\"GitHub Personal Access Token\" loading=\"lazy\"></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"最简单的 Hexo npm 版本升级","url":"/4.html","content":"<p>[TOC]</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JhaW5lb3JzaGluZS9ucG0tY2hlY2stdXBkYXRlcw==\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"安装npm-check-updates\"><a href=\"#安装npm-check-updates\" class=\"headerlink\" title=\"安装npm-check-updates\"></a>安装npm-check-updates</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"更新-Hexo\"><a href=\"#更新-Hexo\" class=\"headerlink\" title=\"更新 Hexo\"></a>更新 Hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更新所有插件\"><a href=\"#更新所有插件\" class=\"headerlink\" title=\"更新所有插件\"></a>更新所有插件</h2><h3 id=\"检测版本\"><a href=\"#检测版本\" class=\"headerlink\" title=\"检测版本\"></a>检测版本</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新package-json\"><a href=\"#更新package-json\" class=\"headerlink\" title=\"更新package.json\"></a>更新package.json</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu -u</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装package-json新版本\"><a href=\"#安装package-json新版本\" class=\"headerlink\" title=\"安装package.json新版本\"></a>安装package.json新版本</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><p><code>vi update.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu</span><br><span class=\"line\">ncu -u</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p><code>bash update.sh</code></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"彻底解决 hexo init 卡顿问题","url":"/5.html","content":"<p>[TOC]</p>\n<p><code>hexo init blog</code>卡住？<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lRTUlQkQlQkIlRTUlQkElOTUlRTglQTclQTMlRTUlODYlQjMraGV4bytpbml0KyVFNSU4RCVBMSVFOSVBMSVCRiVFOSU5NyVBRSVFOSVBMiU5OCZvcT0lRTUlQkQlQkIlRTUlQkElOTUlRTglQTclQTMlRTUlODYlQjMraGV4bytpbml0KyVFNSU4RCVBMSVFOSVBMSVCRiVFOSU5NyVBRSVFOSVBMiU5OCZhcXM9Y2hyb21lLi42OWk1Ny40MDZqMGoxJnNvdXJjZWlkPWNocm9tZSZpZT1VVEYtOA==\">Google<i class=\"fa fa-external-link-alt\"></i></span>谷姐没好办法，分享下自己办法（其实是在翻译源码换gitee源）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">## git submodule init</span><br><span class=\"line\">## git submodule update</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-theme-landscape.git themes&#x2F;landscape</span><br><span class=\"line\">npm i</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n\n\n<a id=\"more\"></a>\n\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWNsaS9ibG9iL21hc3Rlci9saWIvY29uc29sZS9pbml0Lmpz\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update</span><br><span class=\"line\">npm i</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"换gitee\"><a href=\"#换gitee\" class=\"headerlink\" title=\"换gitee\"></a>换gitee</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update</span><br><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm i</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL0dpdC0lRTUlQjclQTUlRTUlODUlQjctJUU1JUFEJTkwJUU2JUE4JUExJUU1JTlEJTk3\">Git 工具 - 子模块<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcw==\">hexojs<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"解决 GitHub Pages 出现独角兽","url":"/6.html","content":"<p><img data-src=\"/6/image-20201021023637217.png\" alt=\"image-20201021023637217\" loading=\"lazy\"></p>\n<a id=\"more\"></a>\n\n<p><strong>We&#39;re having a really bad day.</strong></p>\n<p>The Unicorns have taken over. We&#39;re doing our best to get them under control and get GitHub back up and running.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvbnRhY3Q=\">Contact Support<i class=\"fa fa-external-link-alt\"></i></span> — <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGF0dXMuZ2l0aHViLmNvbS8=\">GitHub Status<i class=\"fa fa-external-link-alt\"></i></span> — <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9naXRodWJzdGF0dXM=\">@githubstatus<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><a href=\"https://weilining.cf/\"><img data-src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mME2UYbodtt+2222u35QheoCCYGBQligIJgkZJNPzgigoaTEj8AdFEMfADfyABkgWiiWcieK4S+QOiHAYUj2hMNKgYlEujpNttu9vttbvdw+chU1K6M535pt3ubHCSyezR+b73eb73+t7vrfXsufOW4bz6+vom9/b23ovnNNw34b5xYGAgODg46Mbt4mesVmsWd1qSpHhdXd2fuP/Afcput5/A88xwymcdBgLqenp6FuRyuWV4zu/v759QyWBjxoz5t76+/gun09mK5xFyakoCAPSaTCazNpvNPoYVbh6O1YKGRF0u13sNDQ27QMzfpiAAKj0lnU6/gBVfAZW2WWpwwVzy0IgP3G73FpjI6REhAGA9qVRqA1b9mVoBVyIC2tDi8Xg24+dUzQiAbS/s7Ox8G2o/3mKCC+Zw0efzPQEfcVjYrARX3dbV1bUtHo8fMgt42f+Mp0yUTVQbdWsAHVsikdiHkHaPxcQXQufXgUBgMRxme9U0AAxfH4vFvjM7eF6UkbJS5qoQwEQGA57Ac5JllFyUVZZ5ckUEgMVxsK2jlSYzI+QXJsiyjzNEAJyJAzb/KQa41jJKL8pODMQiTEAymXw5n8/P0IjD3bh7Rgog59aanxiIRTVvV/oj0tnHca/WMrVwODwB3raTGxzkBg/gnZVapFV62Wy2n5AO70HM/5wbJ0QnXyQSaVPDIuNZzY0V3ntHMwxiwHA0Gj2Np7ecIBDgaDAYXKCQJM1DhrgJ3nhulcPbl8j4NmHe46X/g60fwbz3aewjkqFQaAqebWU1AOqyQwt8Id6qEHMc97zu7u7FGGsn7HAiVuosVw7P35C1nccdgSCxop1dHeZswmfHMnxBo6ZTk+jN8dl/vF7vWofDsa+MLN9oEUBMxOb3+1eoEsBVw6Zmua49r8YmhAKDiEPcMwBsxMiqQ+ixzPFxZyqRpXARG/YOr1ObFJ0gUskXBbamcR1OKmMUvDxHRAu8/LmY3jFLMUpFqz9HxG65smYJdyKyECOxDiEAe/p1gjF2oonivZAsxVgl2daa4EQWCW6J55qFAFFZiJWYLxNQy2qOSUzGRsyXCUDIeliwAHEO4WSlWQBRFoZakXcKmCXmyXAKs0Ve9vl8q42WoIYpJU4hV3hKcNs8m9gl7p/xQ73eF5kB4j5mNrWmTJRNwAzqiV1CxjVTZCIkEq+Z1bZFZSN2CenmVAFVy4Plz8xKAGWjjAKFk6lCBMDR/MJjLLMSQNm43xAiQKTaA+9/wewhDjL+JVI1kkTSSOTcKbMTwPqESAot6dn6Fr1gHwVJju6IRuyiByPuUUBAg5DGkAgBmxlvdgIEK9gDkohdY/BJo4CAG0R8miRSsGABkgVQs4KXu098IgUXSSRsFAoKZiVAVDY2WUiiPTjYRi41KwGisrGsLtlsth8Fiwnz2fBkQvWfRtlE3iF2yW63/yCacXZ1dW02GwGyTFaRd4idJnCKHRaCxYRHoG5LTKT6SyiToP1fJHbmAYPYRR0UnZQtMnA6s0zg+GZBlt0Gdo7EPHgpE3Q6nZ8YyLhc8Xj8MJh/aKTAY+5FPAKHLE7RdwuYJZmNwzyCMkBCYyKROJBMJl9B/PXXCjjmCmDOVzH3fiPpObEWGqoKe4EBl8v1hlqsdLvd23mkxHM9pc9kMpmno9HoeTii7ewbHEZPPx1ztLS1tV3AnGuMjiNjvbQFuHw6zDo5By7dTPAQNBgMLrRarTkSls1mnwT7uwp9virx9QzbW/HuV/j5d/b+6jniKlllP8lkeONJDk+dq9GsQTnC4fB1heO0K47Hwe7WdDr9nAKgXwOBwHI+C45Htj1d6sd429TUNEcmUdc+PRaLHcvn87dXW4ugzdsaGxufL94NFv9zi1J7GVbhlvb2dnaJ3SVrxfc+n2+NTsZ7/H7/Mr3g5XdSIHyJSH1PZ+7fToyl2+ErqilgZ4NaLYB9goVGaHjR93Hv1ZrU4XDsFT20kH3PObzbWk0CgG1jacVIUnAQb9F+VexyLMzkpcLv0IJV7AHQIOCAUYHx7v5qgScmYHtTqSAyZLEJTK22Bie4iq3xsqpm4SAf9Hq9a2DnJ4uLK3SEULcdRvp3i3zHySqpficxEdsQc1NrlYXXvR+O7qASSezXB+h1SuUomgg9LL8BUoV4749EIolKh+EiqWmqVEZlDgHks2pxHw7xTqUQw9J5NcAXOK10AGIoZ6Zli6JY6Z1Q461KoZ4NiKLHarW+KDsxlDUPHZ5zPQZqUVDPJsTqb5n9malbpAh8C2XXDLl62+WZIDFRUlNVOiwencnNU3aQEkL+cDMSoLvZo2fQB7AJssNAuFuvorlDVVkkg2I87+jo2K2QAVphDrfyViK5VqtO34OkaxXCp+7drdDBCAdubm6eidX+2WwqT5komwh4YQLk+H4aE93h8Xg2gvHekQZOGSgLZTLyDTLJ4Lx9/KZWKBSainT4Iy3FqQBfnUZR42PKQFksBr9QKVXCPusD3OiA/RkQ5kP8qV/Jl1WywAp/6+dcmPM2zL1UrUahe4JqfnWWKXIul3uUbfP8njAFLW1OFr3gdFtZ72cNH+PtQT7/brW+NXqJAHh0y9V8/U/A1U7AfwIMAD7mS3pCbuWJAAAAAElFTkSuQmCC\" alt=\"img\" loading=\"lazy\"></a> </p>\n<p>[TOC]</p>\n<h2 id=\"裸yourname-github-io\"><a href=\"#裸yourname-github-io\" class=\"headerlink\" title=\"裸yourname.github.io\"></a>裸yourname.github.io</h2><p>只能等GitHub Pages恢复正常</p>\n<h2 id=\"域名绑定GitHub-Pages\"><a href=\"#域名绑定GitHub-Pages\" class=\"headerlink\" title=\"域名绑定GitHub Pages\"></a>域名绑定GitHub Pages</h2><p>当GitHub Pages出现独角兽，站点文件可以托管到<span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJjZWwuY29tLw==\">vercel<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmV0bGlmeS5jb20v\">netlify<i class=\"fa fa-external-link-alt\"></i></span>，域名可以解析到托管平台。</p>\n<h3 id=\"部署到vercel\"><a href=\"#部署到vercel\" class=\"headerlink\" title=\"部署到vercel\"></a>部署到vercel</h3><p>不支持QQ邮箱、163邮箱，换句话说，请使用谷歌邮箱</p>\n<h4 id=\"使用谷歌邮箱注册登陆gitlab\"><a href=\"#使用谷歌邮箱注册登陆gitlab\" class=\"headerlink\" title=\"使用谷歌邮箱注册登陆gitlab\"></a>使用谷歌邮箱注册登陆gitlab</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRsYWIuY29tL3VzZXJzL3NpZ25faW4=\">https://gitlab.com/users/sign_in<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"使用gitlab注册登陆vercel\"><a href=\"#使用gitlab注册登陆vercel\" class=\"headerlink\" title=\"使用gitlab注册登陆vercel\"></a>使用gitlab注册登陆vercel</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJjZWwuY29tLw==\">https://vercel.com<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"导入github的repo\"><a href=\"#导入github的repo\" class=\"headerlink\" title=\"导入github的repo\"></a>导入github的repo</h4><h4 id=\"vercel的Domains绑定域名\"><a href=\"#vercel的Domains绑定域名\" class=\"headerlink\" title=\"vercel的Domains绑定域名\"></a>vercel的Domains绑定域名</h4><h4 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">A记录解析76.76.21.21 || CNAME记录解析cname.vercel-dns.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到netlify\"><a href=\"#部署到netlify\" class=\"headerlink\" title=\"部署到netlify\"></a>部署到netlify</h3><p>要科学，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGkubmV0bGlmeS5jb23miZPkuI3lvIDlsLHnp5HlrablkKcv\">https://api.netlify.com打不开就科学吧<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"GitHub登陆\"><a href=\"#GitHub登陆\" class=\"headerlink\" title=\"GitHub登陆\"></a>GitHub登陆</h4><h4 id=\"导入GitHub-repo\"><a href=\"#导入GitHub-repo\" class=\"headerlink\" title=\"导入GitHub repo\"></a>导入GitHub repo</h4><h4 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h4><h4 id=\"域名解析-1\"><a href=\"#域名解析-1\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h4><h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvZ2l0aHViL3dvcmtpbmctd2l0aC1naXRodWItcGFnZXMvYWJvdXQtZ2l0aHViLXBhZ2Vz\">关于 GitHub Pages<i class=\"fa fa-external-link-alt\"></i></span>流量每月100GB</p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"最简单的 LaTeX 入门","url":"/7.html","content":"<p>mac下使用Typora添加数学公式<code>command+option+B</code></p>\n<h2 id=\"下标\"><a href=\"#下标\" class=\"headerlink\" title=\"下标\"></a>下标</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">R_&#123;ij&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"长分式\"><a href=\"#长分式\" class=\"headerlink\" title=\"长分式\"></a>长分式</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\frac&#123;X&#125;&#123;Y&#125;</span><br></pre></td></tr></table></figure>\n<p>好用！</p>\n<h2 id=\"练手\"><a href=\"#练手\" class=\"headerlink\" title=\"练手\"></a>练手</h2><p>$$<br>R_i=\\sum_{i}^{n}{\\frac{X_i}{x}}\\ln(\\frac{\\frac{X_i}{X}}{\\frac{Y_i}{Y}})<br>$$</p>\n<p>$$<br>R_{ai}=\\sum_{i}{\\frac{X_{ji}}{X_j}}\\ln(\\frac{\\frac{X_ji}{Xj}}{\\frac{P_ji}{P_j}})<br>$$</p>\n<p>$$<br>R_a=\\sum_{j}{\\frac{X_j}{x}}R_{ai}<br>$$</p>\n<p>$$<br>R_b=\\sum_{j}{\\frac{Xj}{X}}\\ln(\\frac{\\frac{X_j}{X}}{\\frac{P_j}{P}})<br>$$</p>\n<p>$$<br>R=R_a+{R_b}<br>$$</p>\n<p>$$<br>Z_a=\\frac{R_a}{R}<br>$$</p>\n<p>$$<br>Z_b=\\frac{R_b}{R}<br>$$</p>\n<p>$$<br>Z_j=\\frac{X_jR_{ai}}{XR}<br>$$</p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"最简单的使用 jsdelivr 加速网站","url":"/8.html","content":"<p>[TOC]</p>\n<h2 id=\"jsdelivr加速效果\"><a href=\"#jsdelivr加速效果\" class=\"headerlink\" title=\"jsdelivr加速效果\"></a>jsdelivr加速效果</h2><p>使用 jsDelivr 为 Hexo 博客提供高效免费的CDN加速，节省服务器流量且减少宽带占用</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3BpbmcuY2hpbmF6LmNvbS9jZG4uanNkZWxpdnIubmV0\">http://ping.chinaz.com/cdn.jsdelivr.net<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>感受下jsdelivr的加速效果</p>\n<a id=\"more\"></a>\n\n<h2 id=\"使用-jsdelivr-加速-Github-仓库资源背景等图\"><a href=\"#使用-jsdelivr-加速-Github-仓库资源背景等图\" class=\"headerlink\" title=\"使用 jsdelivr 加速 Github 仓库资源背景等图\"></a>使用 jsdelivr 加速 Github 仓库资源背景等图</h2><p>当我们使用 <code>Github</code> 仓库资源时，会因为一些奇怪的原因而掉链子，但我们可以通过 jsdelivr 做 CDN 加速</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==\">jsdelivr<i class=\"fa fa-external-link-alt\"></i></span> 是一个免费的开源 CDN</p>\n<h3 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h3><p><code>https://cdn.jsdelivr.net/gh/</code> Github 用户名/仓库名/资源路径</p>\n<p>默认会访问 <code>master</code> 分支下的资源，可以通过 仓库名拼接 @ + <code>release / commit / branch</code> 来访问特定版本下的资源</p>\n<h3 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlaWxpbmluZy9ibG9nLmlvL21hc3Rlci9pbWFnZXMvYmFja2dyb3VuZC1kYXJrLmpwZw==\">https://raw.githubusercontent.com/weilining/blog.io/master/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn\">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"背景图\"><a href=\"#背景图\" class=\"headerlink\" title=\"背景图\"></a>背景图</h3><p>GitHub仓库：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn\">https://github.com/weilining/blog.io/blob/master/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>对应jsdelivr地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn\">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>修改地址：<code>blog/source/_data/styles.styl</code></p>\n<h4 id=\"本地\"><a href=\"#本地\" class=\"headerlink\" title=\"本地\"></a>本地</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">body&#123;</span><br><span class=\"line\">  background:url(&#x2F;images&#x2F;background-dark.jpg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"套jsdelivr作为CDN\"><a href=\"#套jsdelivr作为CDN\" class=\"headerlink\" title=\"套jsdelivr作为CDN\"></a>套jsdelivr作为CDN</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">body&#123;</span><br><span class=\"line\">  background:url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;background-dark.jpg&#39;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"头像\"><a href=\"#头像\" class=\"headerlink\" title=\"头像\"></a>头像</h3><p>GitHub地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2ltYWdlcy9sb2dvLnN2Zw==\">https://github.com/weilining/blog.io/blob/master/images/logo.svg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>jsdelivr地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9sb2dvLnN2Zw==\">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>修改地址：<code>_config.next.yml</code></p>\n<h4 id=\"本地-1\"><a href=\"#本地-1\" class=\"headerlink\" title=\"本地\"></a>本地</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  url: &#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"套jsdelivr作为CDN-1\"><a href=\"#套jsdelivr作为CDN-1\" class=\"headerlink\" title=\"套jsdelivr作为CDN\"></a>套jsdelivr作为CDN</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"鼠标点击特效：社会主义价值观\"><a href=\"#鼠标点击特效：社会主义价值观\" class=\"headerlink\" title=\"鼠标点击特效：社会主义价值观\"></a>鼠标点击特效：社会主义价值观</h3><p>GitHub地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2pzL2N1cnNvci9jbGljay13b3JkLmpz\">https://github.com/weilining/blog.io/blob/master/js/cursor/click-word.js<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>jsdelivr地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2pzL2N1cnNvci9jbGljay13b3JkLmpz\">https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/click-word.js<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"本地-2\"><a href=\"#本地-2\" class=\"headerlink\" title=\"本地\"></a>本地</h4><p><code>source/_data/head.njk</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- jquery --&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;click-loveword.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"套jsdelivr作为CDN-2\"><a href=\"#套jsdelivr作为CDN-2\" class=\"headerlink\" title=\"套jsdelivr作为CDN\"></a>套jsdelivr作为CDN</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- jquery --&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.4.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;js&#x2F;cursor&#x2F;click-loveword.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>click-loveword.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;* 社会主体核心价值观效果 *&#x2F;</span><br><span class=\"line\">var a_idx &#x3D; 0;</span><br><span class=\"line\">jQuery(document).ready(function($) &#123;</span><br><span class=\"line\">    $(&quot;body&quot;).click(function(e) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; var a &#x3D; new Array(&quot;❤富强❤&quot;,&quot;❤民主❤&quot;,&quot;❤文明❤&quot;,&quot;❤和谐❤&quot;,&quot;❤自由❤&quot;,&quot;❤平等❤&quot;,&quot;❤公正❤&quot;,&quot;❤法治❤&quot;,&quot;❤爱国❤&quot;,&quot;❤敬业❤&quot;,&quot;❤诚信❤&quot;,&quot;❤友善❤&quot;);</span><br><span class=\"line\">        var a &#x3D; new Array(&quot;富强&quot;,&quot;民主&quot;,&quot;文明&quot;,&quot;和谐&quot;,&quot;自由&quot;,&quot;平等&quot;,&quot;公正&quot;,&quot;法治&quot;,&quot;爱国&quot;,&quot;敬业&quot;,&quot;诚信&quot;,&quot;友善&quot;);</span><br><span class=\"line\">        var $i &#x3D; $(&quot;&lt;span&gt;&lt;&#x2F;span&gt;&quot;).text(a[a_idx]);</span><br><span class=\"line\">        a_idx &#x3D; (a_idx + 1) % a.length;</span><br><span class=\"line\">        var x &#x3D; e.pageX,</span><br><span class=\"line\">        y &#x3D; e.pageY;</span><br><span class=\"line\">        $i.css(&#123;</span><br><span class=\"line\">            &quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999,</span><br><span class=\"line\">            &quot;top&quot;: y - 20,</span><br><span class=\"line\">            &quot;left&quot;: x,</span><br><span class=\"line\">            &quot;position&quot;: &quot;absolute&quot;,</span><br><span class=\"line\">            &quot;font-weight&quot;: &quot;bold&quot;,</span><br><span class=\"line\">            &quot;color&quot;: &quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        $(&quot;body&quot;).append($i);</span><br><span class=\"line\">        $i.animate(&#123;</span><br><span class=\"line\">            &quot;top&quot;: y - 180,</span><br><span class=\"line\">            &quot;opacity&quot;: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        1500,</span><br><span class=\"line\">        function() &#123;</span><br><span class=\"line\">            $i.remove();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;* 爱心特效 *&#x2F;</span><br><span class=\"line\">! function (e, t, a) &#123;</span><br><span class=\"line\">    function n() &#123;</span><br><span class=\"line\">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function r() &#123;</span><br><span class=\"line\">        for (var e &#x3D; 0; e &lt; d.length; e++) d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class=\"line\">        requestAnimationFrame(r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function o() &#123;</span><br><span class=\"line\">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class=\"line\">        e.onclick &#x3D; function (e) &#123;</span><br><span class=\"line\">            t &amp;&amp; t(), i(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function i(e) &#123;</span><br><span class=\"line\">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class=\"line\">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class=\"line\">            el: a,</span><br><span class=\"line\">            x: e.clientX - 5,</span><br><span class=\"line\">            y: e.clientY - 5,</span><br><span class=\"line\">            scale: 1,</span><br><span class=\"line\">            alpha: 1,</span><br><span class=\"line\">            color: s()</span><br><span class=\"line\">        &#125;), t.body.appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function c(e) &#123;</span><br><span class=\"line\">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class=\"line\">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            a.appendChild(t.createTextNode(e))</span><br><span class=\"line\">        &#125; catch (t) &#123;</span><br><span class=\"line\">            a.styleSheet.cssText &#x3D; e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function s() &#123;</span><br><span class=\"line\">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var d &#x3D; [];</span><br><span class=\"line\">    e.requestAnimationFrame &#x3D; function () &#123;</span><br><span class=\"line\">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123;</span><br><span class=\"line\">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(), n()</span><br><span class=\"line\">&#125;(window, document);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><p>jsdelivr github 延迟，建议使用<code>https://cdn.jsdelivr.net/gh/</code> Github 用户名/仓库名/资源路径</p>\n<p>有延迟：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvQG1hc3Rlci9qcy9jdXJzb3Iv\">https://cdn.jsdelivr.net/gh/weilining/blog.io@master/js/cursor/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>无延迟：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2pzL2N1cnNvci8=\">https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>无延迟：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvQDEuMC9qcy9jdXJzb3Iv\">https://cdn.jsdelivr.net/gh/weilining/blog.io@1.0/js/cursor/<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"Hxeo 写一篇博客的具体细节","url":"/9.html","content":"<h1 id=\"以我用的Next主题为例\"><a href=\"#以我用的Next主题为例\" class=\"headerlink\" title=\"以我用的Next主题为例\"></a>以我用的Next主题为例</h1><p>一篇博客头写的内容</p>\n<ul>\n<li>toc: true  目录是否生成</li>\n<li>comments: true  评论是否开启</li>\n<li>sticky: 100  数值越大，置顶，相同取第一个写的</li>\n<li>tags: - Next 标签名字</li>\n<li>categories: - Hexo  分类名字</li>\n<li>description: - 描述，一篇博客，不点开，只能看到题目+这个描述  </li>\n<li>date: 2020-10-23 23:04:05  时间</li>\n<li>updated: 2020-10-23 23:04:05    更新时间</li>\n</ul>\n","categories":["Hexo"],"tags":["Next"]},{"title":"线程池相关概念、回表","url":"/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.html","content":"<h4 id=\"1-线程池\"><a href=\"#1-线程池\" class=\"headerlink\" title=\"1.线程池\"></a>1.线程池</h4><p><strong>一、corePoolSize 核心线程大小</strong><br>线程池中最小的线程数量，即使处理空闲状态，也不会被销毁，除非设置了allowCoreThreadTimeOut。</p>\n<p>CPU密集型：核心线程数 = CPU核数 + 1<br>IO密集型：核心线程数 = CPU核数 * 2+1<br>注：IO密集型（某大厂实践经验）<br>核心线程数 = CPU核数 / （1-阻塞系数）<br>例如阻塞系数 0.8，CPU核数为4，则核心线程数为20</p>\n<p><strong>二、maximumPoolSize 线程池最大线程数量</strong><br>一个任务被提交后，首先会被缓存到工作队列中，等工作队列满了，则会创建一个新线程，处理从工作队列中的取出一个任务。</p>\n<p><strong>三、keepAliveTime 空闲线程存活时间</strong><br>当线程数量大于corePoolSize时，一个处于空闲状态的线程，在指定的时间后会被销毁。</p>\n<p><strong>四、unit 空间线程存活时间单位</strong><br>keepAliveTime的计量单位</p>\n<p><strong>五、workQueue 工作队列</strong>，jdk中提供了四种工作队列<br>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。<br>①ArrayBlockingQueue<br>基于数组的有界阻塞队列，按FIFO排序。<br>②LinkedBlockingQuene<br>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。<br>④PriorityBlockingQueue<br>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>\n<p><strong>六、threadFactory 线程工厂</strong><br>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等<br><strong>七、handler 拒绝策略</strong><br>当工作队列中的任务已满并且线程池中的线程数量也达到最大，这时如果有新任务提交进来，拒绝策略就是解决这个问题的，jdk中提供了4中拒绝策略：<br>①CallerRunsPolicy<br>该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。<br>②AbortPolicy<br>该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。<br>③DiscardPolicy<br>该策略下，直接丢弃任务，什么都不做。<br>④DiscardOldestPolicy<br>该策略下，抛弃最早进入队列的那个任务，然后尝试把这次拒绝的任务放入队列。</p>\n<h4 id=\"2-mysql-索引的分类（聚簇索引、非聚簇索引）回表\"><a href=\"#2-mysql-索引的分类（聚簇索引、非聚簇索引）回表\" class=\"headerlink\" title=\"2.mysql 索引的分类（聚簇索引、非聚簇索引）回表\"></a>2.mysql 索引的分类（聚簇索引、非聚簇索引）回表</h4><p>MyISAM引擎主要用的是非聚簇索引</p>\n<p>InnoDB引擎主要用的是聚簇索引</p>\n<h3 id=\"①mysql索引\"><a href=\"#①mysql索引\" class=\"headerlink\" title=\"①mysql索引\"></a>①mysql索引</h3><p><strong>B+Tree结构都可以用在MyISAM和InnoDB上</strong>。mysql中，不同的存储引擎对索引的实现方式不同，大致说下MyISAM和InnoDB两种存储引擎。</p>\n<p><strong>MyISAM的是非聚簇索引，</strong>B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，<br>这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>\n<p>InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。</p>\n<p><strong>InnoDB使用的是聚簇索引</strong>，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用&quot;where id = 14&quot;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p>\n<h3 id=\"②聚簇索引\"><a href=\"#②聚簇索引\" class=\"headerlink\" title=\"②聚簇索引\"></a>②聚簇索引</h3><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。</p>\n<p>聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。</p>\n<h3 id=\"③非聚簇索引\"><a href=\"#③非聚簇索引\" class=\"headerlink\" title=\"③非聚簇索引\"></a>③非聚簇索引</h3><p>非聚集索引，类似于图书的附录，那个专业术语出现在哪个章节，这些专业术语是有顺序的，但是出现的位置是没有顺序的。每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放。但是，一个表可以有不止一个非聚簇索引。</p>\n<h1 id=\"mysql-索引回表\"><a href=\"#mysql-索引回表\" class=\"headerlink\" title=\"mysql 索引回表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXVuaWNoL3AvMTI5NjM3NDkuaHRtbA==\">mysql 索引回表<i class=\"fa fa-external-link-alt\"></i></span></h1><p>因为主键索引对应的是整行数据块，通过主键索引查询只需要查询一次</p>\n<p>通过普通索引查询到数据块记录的是主键索引，再通过主键索引查询到记录的过程叫回表</p>\n<p>我们知道，Mysql中InnoDB中索引结构为B+树，这是综合了B+树寻址次数少且查询耗时较稳定等优点决定的。</p>\n<p>那B+树中存储的是什么东西呢？根据索引树就能直接找到对应的数据行吗？要说明这一点，就要详细地聊一下B+树的储存内容。</p>\n<p><strong>回表</strong><br>实际上，InnoDB除了维护了一个索引B+树之外，还维护了一个主键B+树。索引B+树节点上存放的数据实际上是主键的值，而主键B+树上存放的才是真正的数据行本身(因为InnoDB是聚集索引，所以直接存储了数据行，如果是MyIsam非聚集索引，这里储存的只是数据行的一个地址，还需要去磁盘中获取数据行。这点具体可以看一下聚集索引与非聚集索引的区别)</p>\n<p>那么这点弄清楚了，就可以分析一下，如果一条指令通过索引(同时不是主键)来检索数据，会发生什么呢？</p>\n<p>例如在一个居民表中，有以下字段，其中id是主键，并且建立了name索引。</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>age</th>\n<th>remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>aaa</td>\n<td>20</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2</td>\n<td>bbb</td>\n<td>14</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<p>当执行语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM MyTable WHERE name&#x3D;aaa;</span><br></pre></td></tr></table></figure>\n\n\n<p>首先MySQL分析到该次查询是通过name索引来检索的,所以就会去检索索引B+树。</p>\n<p>而刚才我们也说了，索引树上存的实际上是主键，所以不出意外的话，我们能从索引树上获取到id=1这个主键。</p>\n<p>于是这时如果想查询出整行数据，就要发生 回表：拿着id=1这个主键，再去主键树上进行查询，进而查询出真正的一条数据行。这个查询语句才算执行完成了。</p>\n<p>回顾一下，在这个查询过程了，我们一共进行了两次B+树的检索，其中后面一次就是回表。就像我们猜测的一样，回标操作必然会导致查询时间的增加，开销的增大。</p>\n<p>如果此时使用覆盖索引就可以避免回表操作，那啥是覆盖索引？考虑这个SQL语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT id FROM MyTable WHERE name&#x3D;aaa;</span><br></pre></td></tr></table></figure>\n\n\n<p>那这样执行流程是怎么样？我们发现，检索索引树的时候，直接就把id给查询出来，符合我们的预期结果了，不需要再进行一次回表。那这种操作就叫做覆盖索引，实际中也经常使用覆盖索引来进行性能的优化。</p>\n<p><strong>联合索引</strong><br>基于刚说完的覆盖索引，我们再考虑一个问题，当在一个需要进行”根据name查询出age“操作很频繁的场景之下，按照我们刚才所建立的主键和索引，我们不难判断这个操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT age FROM MyTable WHERE name&#x3D;aaa;</span><br></pre></td></tr></table></figure>\n\n\n<p>或者这个操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT 一个其他属性 FROM MyTable WHERE name&#x3D;aaaAND age&#x3D;20;</span><br></pre></td></tr></table></figure>\n\n\n<p>每次执行时都需要进行回表操作(因为索引树中并没有age相关的数据)，这很明显是不太合理的。那咋办？把主键声明为age，利用覆盖索引避免回表操作？别傻了，不同的人可能会有相同的age，这怎么能作为主键呢？那这时，我们可以定义联合索引了。</p>\n<p>取{name,age}作为一个联合索引，那么每次查询的时候，因为索引下推（会检索索引的所有值，只有都符合条件的时候，才会对该索引进行回表），MySQL除了查出name之外，还能查出age的值，这样我们就能从索引树直接获得age字段，而避免了一次回表操作。当然这样做也有缺点，联合索引因为比较复杂，通常来说维护起来也会产生比单个索引更大的开销，这个就要和实际情况相结合来进行取舍了。</p>\n<p><strong>最左前缀原则</strong><br>回表的问题可算是解决了，建立一个联合索引{name,age}就可以。那问题又来了：</p>\n<p>我不一定是通过name和age来检索数据啊，我们可能直接通过name来检索，那这时咋办，同时建立一个{name,age}联合索引来满足联合查询，和一个{name}单独索引来满足单独查询？是不是太繁琐了？</p>\n<p>MySQL也考虑到了这个问题，所以MySQL有一个最左前缀原则。</p>\n<p>拿{name,age}来举例，该索引中的最左边是name字段，根据最左前缀原则，该索引既可以用于name和age组合查询，也可以用于name的单独查询。那么这就好办了，只需要维护{name,age}就可以了，无需再多建立一个name索引。当然如果还需要一个单独的age索引，因为它不是在联合索引的最左边，所以还是需要额外建立age索引的，否则会进行全表扫描</p>\n","categories":["线程池"]},{"title":"2020 Hexo NexT 最简单的深度美化","url":"/1.html","content":"<p>[TOC]</p>\n<h2 id=\"1分钟教程\"><a href=\"#1分钟教程\" class=\"headerlink\" title=\"1分钟教程\"></a>1分钟教程</h2><p>看完1分钟教程，后面初始化用来理解和查缺补漏</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\"></span><br><span class=\"line\">npm i</span><br><span class=\"line\">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>先配置好以下环境</p>\n<ul>\n<li><p>Git</p>\n</li>\n<li><p>Node.js</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Hexo-amp-amp-NexT安装\"><a href=\"#Hexo-amp-amp-NexT安装\" class=\"headerlink\" title=\"Hexo&amp;&amp;NexT安装\"></a>Hexo&amp;&amp;NexT安装</h3><h4 id=\"正常\"><a href=\"#正常\" class=\"headerlink\" title=\"正常\"></a>正常</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install hexo-theme-next@latest ### https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next</span><br></pre></td></tr></table></figure>\n<h4 id=\"代理快速安装\"><a href=\"#代理快速安装\" class=\"headerlink\" title=\"代理快速安装\"></a>代理快速安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-theme-landscape.git themes&#x2F;landscape</span><br><span class=\"line\">npm i</span><br><span class=\"line\">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p><code>_config.yml</code>的<code>theme: landscape</code>改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地预览\"><a href=\"#本地预览\" class=\"headerlink\" title=\"本地预览\"></a>本地预览</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo cl &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==\">http://localhost:4000<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"生成静态网页文件\"><a href=\"#生成静态网页文件\" class=\"headerlink\" title=\"生成静态网页文件\"></a>生成静态网页文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo cl &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>先准备好以下</p>\n<ul>\n<li><p>GitHub账号</p>\n</li>\n<li><p>创建<code>_config.next.yml</code>(在<code>_config.yml</code>旁边)</p>\n</li>\n</ul>\n<h3 id=\"网页个人信息\"><a href=\"#网页个人信息\" class=\"headerlink\" title=\"网页个人信息\"></a>网页个人信息</h3><p><code>_config.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: Ln&#39;s Blog</span><br><span class=\"line\">subtitle: &#39;有朋自远方来，不亦乐乎&#39;</span><br><span class=\"line\">description: &#39;算法、技术&#39;</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: Lining Wei</span><br><span class=\"line\">language: zh-CN</span><br><span class=\"line\">timezone: &#39;Asia&#x2F;ShangHai</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速配置\"><a href=\"#快速配置\" class=\"headerlink\" title=\"快速配置\"></a>快速配置</h3><p>使用快速配置可以直接跳过进阶，直达高级</p>\n<p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">scheme: Gemini</span><br><span class=\"line\">darkmode: true</span><br><span class=\"line\">creative_commons:</span><br><span class=\"line\">  license: by-nc-sa</span><br><span class=\"line\">  sidebar: false</span><br><span class=\"line\">  post: true #文章底部是否显示</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-bell</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  baidusitemap: &#x2F;baidusitemap.xml || fa fa-cloud</span><br><span class=\"line\">menu_settings:</span><br><span class=\"line\">  icons: true</span><br><span class=\"line\">  badges: true</span><br><span class=\"line\">sidebar:</span><br><span class=\"line\">  position: left</span><br><span class=\"line\">  display: post</span><br><span class=\"line\">  padding: 18</span><br><span class=\"line\">  offset: 12</span><br><span class=\"line\">avatar:</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">  rounded: true   #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆</span><br><span class=\"line\">  rotated: true #设置鼠标移到图片上后头像是否转动</span><br><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blog.io || fab fa-github</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  icons_only: true</span><br><span class=\"line\">  transition: true</span><br><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  number: true</span><br><span class=\"line\">  wrap: true # 如果为true，则如果标题宽度比侧栏宽度长，则所有单词将放在下一行。</span><br><span class=\"line\">footer:</span><br><span class=\"line\">  since: 2015</span><br><span class=\"line\">  icon:</span><br><span class=\"line\">    name: fa fa-heart</span><br><span class=\"line\">    animated: true</span><br><span class=\"line\">    color: &quot;#808080&quot;</span><br><span class=\"line\">  copyright: Ln</span><br><span class=\"line\">  powered: false</span><br><span class=\"line\">post_meta:</span><br><span class=\"line\">  updated_at:</span><br><span class=\"line\">    enable: true # 文章“更新于”显示</span><br><span class=\"line\">post_edit:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blogbackup.io&#x2F;edit&#x2F;main&#x2F;source&#x2F;</span><br><span class=\"line\">mobile_layout_economy: true # 手机文章紧挨着</span><br><span class=\"line\">codeblock:</span><br><span class=\"line\">  theme:</span><br><span class=\"line\">    light: default</span><br><span class=\"line\">    dark: tomorrow-night</span><br><span class=\"line\">  copy_button:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    style: mac</span><br><span class=\"line\">back2top:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  sidebar: false</span><br><span class=\"line\">  scrollpercent: true</span><br><span class=\"line\">github_banner:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  permalink: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blog.io</span><br><span class=\"line\">  title: Fork NexT on GitHub</span><br><span class=\"line\">math:</span><br><span class=\"line\">  mathjax:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">pjax: true</span><br><span class=\"line\">mediumzoom: true</span><br><span class=\"line\">livere_uid: MTAyMC80NDkyOC8yMTQ1MA&#x3D;&#x3D;</span><br><span class=\"line\">google_analytics:</span><br><span class=\"line\">  tracking_id: UA-108155018-3</span><br><span class=\"line\">note:</span><br><span class=\"line\">  style: simple</span><br><span class=\"line\">  icons: true</span><br><span class=\"line\">  light_bg_offset: -3</span><br><span class=\"line\">tabs:</span><br><span class=\"line\">  transition:</span><br><span class=\"line\">    tabs: true</span><br><span class=\"line\">    labels: true</span><br><span class=\"line\">mermaid:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">motion:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  async: true</span><br><span class=\"line\">vendors:</span><br><span class=\"line\">  internal: jsdelivr</span><br><span class=\"line\">quicklink:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  home: true</span><br><span class=\"line\">  archive: true</span><br><span class=\"line\">  delay: true</span><br><span class=\"line\">  timeout: 3000</span><br><span class=\"line\">  priority: true</span><br><span class=\"line\">  ignores:</span><br><span class=\"line\">nprogress:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  spinner: true</span><br><span class=\"line\">tag_icon: true</span><br><span class=\"line\">favicon:</span><br><span class=\"line\">  small: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;favicon-16x16-next.png</span><br><span class=\"line\">  medium: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;favicon-32x32-next.png</span><br><span class=\"line\">  apple_touch_icon: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">  safari_pinned_tab: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">reward_settings:</span><br><span class=\"line\">  enable: true </span><br><span class=\"line\">  animation: true</span><br><span class=\"line\">  comment: Buy me a coffee #这里填你的提示语</span><br><span class=\"line\">reward:</span><br><span class=\"line\">  wechatpay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">  alipay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">canvas_ribbon:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  size: 300 # The width of the ribbon</span><br><span class=\"line\">  alpha: 0.6 # The transparency of the ribbon</span><br><span class=\"line\">  zIndex: -1 # The display level of the ribbon</span><br><span class=\"line\">links_settings:</span><br><span class=\"line\">  icon: fa fa-globe</span><br><span class=\"line\">  title: 友情链接</span><br><span class=\"line\">  # Available values: block | inline</span><br><span class=\"line\">  layout: inline</span><br><span class=\"line\">links:</span><br><span class=\"line\">  Ln: https:&#x2F;&#x2F;weilining.github.io</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true</span><br><span class=\"line\">  total_visitors_icon: fa fa-user</span><br><span class=\"line\">  total_views: true</span><br><span class=\"line\">  total_views_icon: fa fa-eye</span><br><span class=\"line\">  post_views: true</span><br><span class=\"line\">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"换Gemini主题\"><a href=\"#换Gemini主题\" class=\"headerlink\" title=\"换Gemini主题\"></a>换Gemini主题</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"暗黑模式\"><a href=\"#暗黑模式\" class=\"headerlink\" title=\"暗黑模式\"></a>暗黑模式</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">darkmode: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打赏\"><a href=\"#打赏\" class=\"headerlink\" title=\"打赏\"></a>打赏</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reward_settings:</span><br><span class=\"line\">  enable: true </span><br><span class=\"line\">  animation: true</span><br><span class=\"line\">  comment: Buy me a coffee #这里填你的提示语</span><br><span class=\"line\">reward:</span><br><span class=\"line\">  wechatpay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">  alipay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打开jsdelivr加速\"><a href=\"#打开jsdelivr加速\" class=\"headerlink\" title=\"打开jsdelivr加速\"></a>打开jsdelivr加速</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vendors:</span><br><span class=\"line\">  internal: jsdelivr</span><br><span class=\"line\">  plugins: jsdelivr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打开动画异步加载\"><a href=\"#打开动画异步加载\" class=\"headerlink\" title=\"打开动画异步加载\"></a>打开动画异步加载</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">motion:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  async: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码mac风格-amp-amp-粘贴按钮\"><a href=\"#代码mac风格-amp-amp-粘贴按钮\" class=\"headerlink\" title=\"代码mac风格&amp;&amp;粘贴按钮\"></a>代码mac风格&amp;&amp;粘贴按钮</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">codeblock:</span><br><span class=\"line\">  copy_button:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    style: mac</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阅读百分比显示\"><a href=\"#阅读百分比显示\" class=\"headerlink\" title=\"阅读百分比显示\"></a>阅读百分比显示</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">back2top:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  scrollpercent: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进度条\"><a href=\"#进度条\" class=\"headerlink\" title=\"进度条\"></a>进度条</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nprogress:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  spinner: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">creative_commons:</span><br><span class=\"line\">  license: by-nc-sa</span><br><span class=\"line\">  sidebar: false</span><br><span class=\"line\">  post: true #文章底部是否显示</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"菜单栏\"><a href=\"#菜单栏\" class=\"headerlink\" title=\"菜单栏\"></a>菜单栏</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-bell</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  baidusitemap: &#x2F;baidusitemap.xml || fa fa-cloud</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"菜单栏设置\"><a href=\"#菜单栏设置\" class=\"headerlink\" title=\"菜单栏设置\"></a>菜单栏设置</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu_settings:</span><br><span class=\"line\">  icons: true</span><br><span class=\"line\">  badges: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"侧边栏设置\"><a href=\"#侧边栏设置\" class=\"headerlink\" title=\"侧边栏设置\"></a>侧边栏设置</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sidebar:</span><br><span class=\"line\">  position: left</span><br><span class=\"line\">  display: post</span><br><span class=\"line\">  padding: 18</span><br><span class=\"line\">  offset: 12</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"头像设置\"><a href=\"#头像设置\" class=\"headerlink\" title=\"头像设置\"></a>头像设置</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  # url: &#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">  rounded: true   #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆</span><br><span class=\"line\">  rotated: true #设置鼠标移到图片上后头像是否转动</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blog.io || fab fa-github</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  icons_only: true</span><br><span class=\"line\">  transition: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  number: true</span><br><span class=\"line\">  wrap: true # 如果为true，则如果标题宽度比侧栏宽度长，则所有单词将放在下一行。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"底部设置\"><a href=\"#底部设置\" class=\"headerlink\" title=\"底部设置\"></a>底部设置</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">footer:</span><br><span class=\"line\">  since: 2015</span><br><span class=\"line\">  icon:</span><br><span class=\"line\">    name: fa fa-heart</span><br><span class=\"line\">    animated: true</span><br><span class=\"line\">    color: &quot;#808080&quot;</span><br><span class=\"line\">  copyright: Ln</span><br><span class=\"line\">  powered: false</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h3><h4 id=\"GitHub创建仓库并打开GitHub-Pages功能\"><a href=\"#GitHub创建仓库并打开GitHub-Pages功能\" class=\"headerlink\" title=\"GitHub创建仓库并打开GitHub Pages功能\"></a>GitHub创建仓库并打开GitHub Pages功能</h4><p>仓库名：Github 用户名.github.io</p>\n<p>例如：weilining.github.io</p>\n<p>验证仓库是否创建成功：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy93ZWlsaW5pbmcuZ2l0aHViLmlv\">https://github.com/weilining/weilining.github.io<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>PS:记得打开GitHub Pages</p>\n<p><code>setting-&gt;GitHub Pages</code></p>\n<h4 id=\"URL设置\"><a href=\"#URL设置\" class=\"headerlink\" title=\"URL设置\"></a>URL设置</h4><p><code>_config.yml</code>的<code>url: http://example.com</code>改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: https:&#x2F;&#x2F;weilining.github.io</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: git</span><br><span class=\"line\">    repo:</span><br><span class=\"line\">      github:</span><br><span class=\"line\">        url: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;weilining.github.io.git # https:&#x2F;&#x2F;github.com&#x2F;Github 用户名&#x2F;仓库名&#x2F;资源路径</span><br><span class=\"line\">        branch: master</span><br><span class=\"line\">        token: f7e4ee8c4b57d3fab8c0680e192c11111fa844f6 # GitHub Personal Access Token </span><br><span class=\"line\">    name: weilining # Github 用户名</span><br><span class=\"line\">    email: email@gmail.com # Github 登陆邮箱</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuY2YvMy5odG1s\">获取 GitHub Personal Access Token 方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"GitHub-Pages预览\"><a href=\"#GitHub-Pages预览\" class=\"headerlink\" title=\"GitHub Pages预览\"></a>GitHub Pages预览</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuZ2l0aHViLmlvLw==\">https://weilining.github.io<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h2><p>先准备好以下</p>\n<ul>\n<li>创建<code>blog/source/_data/styles.styl</code></li>\n</ul>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1nZW5lcmF0b3Itc2VhcmNoZGI=\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: all</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.next.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  trigger: auto</span><br><span class=\"line\">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.next.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  RSS: &#x2F;atom.xml || fa fa-rss</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"宠物\"><a href=\"#宠物\" class=\"headerlink\" title=\"宠物\"></a>宠物</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJkL2Jsb2IvbWFzdGVyL1JFQURNRS56aC1DTi5tZA==\">官方<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3hpYXpleXUvbGl2ZTJkLXdpZGdldC1tb2RlbHM=\">模型<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"模块安装\"><a href=\"#模块安装\" class=\"headerlink\" title=\"模块安装\"></a>模块安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-helper-live2d</span><br><span class=\"line\">npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">live2d:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  scriptFrom: local</span><br><span class=\"line\">  pluginRootPath: live2dw&#x2F;</span><br><span class=\"line\">  pluginJsPath: lib&#x2F;</span><br><span class=\"line\">  pluginModelPath: assets&#x2F;</span><br><span class=\"line\">  tagMode: false</span><br><span class=\"line\">  log: false</span><br><span class=\"line\">  model:</span><br><span class=\"line\">    use: live2d-widget-model-wanko</span><br><span class=\"line\">  display:</span><br><span class=\"line\">    position: right</span><br><span class=\"line\">    width: 150</span><br><span class=\"line\">    height: 300</span><br><span class=\"line\">  mobile:</span><br><span class=\"line\">    show: true</span><br><span class=\"line\">  react:</span><br><span class=\"line\">    opacity: 0.7</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"背景透明\"><a href=\"#背景透明\" class=\"headerlink\" title=\"背景透明\"></a>背景透明</h3><p><code>blog/source/_data/styles.styl</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 背景透明</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">  opacity: 0.9;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加背景\"><a href=\"#加背景\" class=\"headerlink\" title=\"加背景\"></a>加背景</h3><p><code>blog/source/_data/styles.styl</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;背景</span><br><span class=\"line\">body&#123;</span><br><span class=\"line\">  background:url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;background-dark.jpg&#39;);</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  background-repeat:repeat-x;</span><br><span class=\"line\">  background-attachment:fixed;</span><br><span class=\"line\">  background-size:cover;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h3><p><code>_config.yml</code> 的<code>post_asset_folder: true</code>改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">### https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;asset-folders</span><br><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"顶级\"><a href=\"#顶级\" class=\"headerlink\" title=\"顶级\"></a>顶级</h2><h3 id=\"百度SEO\"><a href=\"#百度SEO\" class=\"headerlink\" title=\"百度SEO\"></a>百度SEO</h3><h4 id=\"安装站点地图模块\"><a href=\"#安装站点地图模块\" class=\"headerlink\" title=\"安装站点地图模块\"></a>安装站点地图模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-4\"><a href=\"#配置-4\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code>后面加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">baidusitemap:</span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo s</code></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwL2JhaWR1c2l0ZW1hcC54bWw=\">http://localhost:4000/baidusitemap.xml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"安装主动推送模块\"><a href=\"#安装主动推送模块\" class=\"headerlink\" title=\"安装主动推送模块\"></a>安装主动推送模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-submit-urls-to-search-engine</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-5\"><a href=\"#配置-5\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL3NpdGUvaW5kZXgjIyMv\">百度站点管理<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>普通收录-&gt;资源提交-&gt;API提交-&gt;推送接口里有token</p>\n<p><code>_config.yml</code>后面加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo_submit_urls_to_search_engine:</span><br><span class=\"line\">  submit_condition: count ###链接被提交的条件，可选值：count | period 现仅支持count</span><br><span class=\"line\">  count: 10 ### 提交最新的10个链接</span><br><span class=\"line\">  period: 900 ### 提交修改时间在 900 秒内的链接</span><br><span class=\"line\">  google: 0 ### 是否向Google提交，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  bing: 1 ### 是否向bing提交，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  baidu: 1 ### 是否向baidu提交，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  txt_path: submit_urls.txt #### 文本文档名， 需要推送的链接会保存在此文本文档里</span><br><span class=\"line\">  baidu_host: https:&#x2F;&#x2F;cjh0613.github.io #### 在百度站长平台中注册的域名</span><br><span class=\"line\">  baidu_token: 请按照文档说明获取 #### 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span><br><span class=\"line\">  bing_host: https:&#x2F;&#x2F;cjh0613.github.io #### 在bing站长平台中注册的域名</span><br><span class=\"line\">  bing_token: 请按照文档说明获取 #### 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span><br><span class=\"line\">  google_host: https:&#x2F;&#x2F;cjh0613.github.io #### 在google站长平台中注册的域名</span><br><span class=\"line\">  google_key_file: Project.json ###存放google key的json文件，放于网站根目录（与hexo _config.yml文件位置相同），请不要把json文件内容直接发布在公众仓库里!</span><br><span class=\"line\">  replace: 0  ### 是否替换链接中的部分字符串，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  find_what: http:&#x2F;&#x2F;cjh0613.github.io&#x2F;blog</span><br><span class=\"line\">  replace_with: https:&#x2F;&#x2F;cjh0613.com</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.yml</code>的<code>deploy:</code>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: &#39;&#39;</span><br><span class=\"line\">  - type: baidu_url_submitter ### 主动提交百度爬虫</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.yml</code>的<code>url: http://example.com</code>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: https:&#x2F;&#x2F;weilining.cf</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo d</code>最后出现<code>&#123;&quot;remain&quot;:2996,&quot;success&quot;:2&#125;</code>即可</p>\n<h4 id=\"缩短url\"><a href=\"#缩短url\" class=\"headerlink\" title=\"缩短url\"></a>缩短url</h4><p><code>_config.yml</code>的<code>permalink: :year/:month/:day/:title/</code>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">permalink: :title.html</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NexT防止外链搜索及SEO设置\"><a href=\"#NexT防止外链搜索及SEO设置\" class=\"headerlink\" title=\"NexT防止外链搜索及SEO设置\"></a>NexT防止外链搜索及SEO设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd blog</span><br><span class=\"line\">vi _config.next.yml</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.next.yml</code>写入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">disable_baidu_transformation: true ### 禁用移动设备上的百度转换，建议 true</span><br><span class=\"line\">index_with_subtitle: true ### 带副标题的索引,开启后会在标签标题后面自动加上网站名称，建议 true</span><br><span class=\"line\">### nofollow防止外链搜索</span><br><span class=\"line\">exturl: true ### 使用Base64加密和解密自动添加外部URL。</span><br><span class=\"line\">baidu_site_verification: code-wFDrn4lvkD</span><br><span class=\"line\">baidu_push: true ###建议 true ###启用百度推送，这样博客会自动把网址推到百度，这对SEO很有帮助。</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo s</code></p>\n<h4 id=\"quicklink加载性能优化\"><a href=\"#quicklink加载性能优化\" class=\"headerlink\" title=\"quicklink加载性能优化\"></a>quicklink加载性能优化</h4><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">quicklink:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  home: true</span><br><span class=\"line\">  archive: true</span><br><span class=\"line\">  delay: true</span><br><span class=\"line\">  timeout: 3000</span><br><span class=\"line\">  priority: true</span><br><span class=\"line\">  ignores:</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"robots-txt\"><a href=\"#robots-txt\" class=\"headerlink\" title=\"robots.txt\"></a>robots.txt</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd blog</span><br><span class=\"line\">vi source&#x2F;robots.txt</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">User-agent: *</span><br><span class=\"line\">Allow: &#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">Sitemap: https:&#x2F;&#x2F;weilining.cf&#x2F;sitemap.xml</span><br><span class=\"line\">Sitemap: https:&#x2F;&#x2F;weilining.cf&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3Rvb2xzL3JvYm90cy10ZXN0aW5nLXRvb2w/dXRtX3NvdXJjZT1zdXBwb3J0Lmdvb2dsZS5jb20vd2VibWFzdGVycy8mdXRtX21lZGl1bT1yZWZlcnJhbCZ1dG1fY2FtcGFpZ249NjA2MjU5OA==\">打开“robots.txt 测试工具”<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"谷歌SEO\"><a href=\"#谷歌SEO\" class=\"headerlink\" title=\"谷歌SEO\"></a>谷歌SEO</h3><h4 id=\"安装站点地图模块-1\"><a href=\"#安装站点地图模块-1\" class=\"headerlink\" title=\"安装站点地图模块\"></a>安装站点地图模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-6\"><a href=\"#配置-6\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code>后面加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo s</code></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwL3NpdGVtYXAueG1s\">http://localhost:4000/sitemap.xml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><code>_config.next.yml</code>加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">google_site_verification: KZjcRcBkV43JHcyiH4z1Yk2xu-mqlS1fQNk5Dzv7_q0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到服务器\"><a href=\"#部署到服务器\" class=\"headerlink\" title=\"部署到服务器\"></a>部署到服务器</h3><p><code>blog/public</code>下所有文件复制到nginx的web服务器根目录</p>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXNoLmNsb3VkZmxhcmUuY29tLw==\">cloudflare<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>建议：要开启CDN，先删除其他A/AAAA，只留一条。关闭CDN之后再加多条A/AAAA。</p>\n<h3 id=\"MarkDown书写\"><a href=\"#MarkDown书写\" class=\"headerlink\" title=\"MarkDown书写\"></a>MarkDown书写</h3><p>二级标题后紧跟的子标题级别必须是三级标题。<br>一个页面一个H1标签，以二级标题为起点，二级标题不要太多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">## 标题</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加一言\"><a href=\"#添加一言\" class=\"headerlink\" title=\"添加一言\"></a>添加一言</h3><p><code>blog/source/_data/sidebar.njk</code></p>\n<p>将下面这段代码放入页面内需要展示一句话的位置即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;# 一言 #&#125;</span><br><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;api.uixsj.cn&#x2F;hitokoto&#x2F;w.php?code&#x3D;js&quot;&gt;&lt;&#x2F;script&gt;&lt;div id&#x3D;&quot;xsjhitokoto&quot;&gt;&lt;script&gt;xsjhitokoto()&lt;&#x2F;script&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>中英文版 使用方法同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;api.uixsj.cn&#x2F;hitokoto&#x2F;en.php?code&#x3D;js&quot;&gt;&lt;&#x2F;script&gt;&lt;div id&#x3D;&quot;enhitokoto&quot;&gt;&lt;script&gt;enhitokoto()&lt;&#x2F;script&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"网页Get测试\"><a href=\"#网页Get测试\" class=\"headerlink\" title=\"网页Get测试\"></a>网页Get测试</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuMTdjZS5jb20v\">https://www.17ce.com/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"页面加载性能测试\"><a href=\"#页面加载性能测试\" class=\"headerlink\" title=\"页面加载性能测试\"></a>页面加载性能测试</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==\">Google PageSpeed Insights<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=\">NexT<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuY2Yv\">Ln&#39;s Blog<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"各平台收录查询\"><a href=\"#各平台收录查询\" class=\"headerlink\" title=\"各平台收录查询\"></a>各平台收录查询</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9c2l0ZTp3ZWlsaW5pbmcuY2Y=\">百度收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5iaW5nLmNvbS9zZWFyY2g/cT1zaXRlOndlaWxpbmluZy5jZg==\">必应收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT1zaXRlOndlaWxpbmluZy5jZg==\">谷歌收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc28uY29tL3M/cT1zaXRlOndlaWxpbmluZy5jZg==\">360收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly95YW5kZXguY29tL3NlYXJjaC8/dGV4dD1zaXRlOndlaWxpbmluZy5jZg==\">yandex收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc29nb3UuY29tL3dlYj9xdWVyeT1zaXRlOndlaWxpbmluZy5jZg==\">搜狗收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"各平台-Robots-txt-测试工具\"><a href=\"#各平台-Robots-txt-测试工具\" class=\"headerlink\" title=\"各平台 Robots.txt 测试工具\"></a>各平台 Robots.txt 测试工具</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL3JvYm90cw==\">百度<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmluZy5jb20vd2VibWFzdGVycy9yb2JvdHN0eHR0ZXN0ZXI=\">必应<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3Rvb2xzL3JvYm90cy10ZXN0aW5nLXRvb2w=\">谷歌<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJtYXN0ZXIueWFuZGV4LnJ1L3NpdGUvaHR0cHM6d2VpbGluaW5nLmNmOjQ0My90b29scy9yb2JvdHN0eHQv\">Yandex<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"各平台管理\"><a href=\"#各平台管理\" class=\"headerlink\" title=\"各平台管理\"></a>各平台管理</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmluZy5jb20vd2VibWFzdGVycy9ob21lP3NpdGVVcmw9aHR0cHM6Ly93ZWlsaW5pbmcuY2Yv\">必应<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL2Rhc2hib2FyZC9pbmRleD9zaXRlPWh0dHBzOi8vd2VpbGluaW5nLmNmLw==\">百度<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJtYXN0ZXIueWFuZGV4LnJ1L3NpdGUvaHR0cHM6d2VpbGluaW5nLmNm\">Yandex<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJz\">谷歌<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><table>\n<thead>\n<tr>\n<th>插件名</th>\n<th>版本号</th>\n<th>官方文档</th>\n<th>功能</th>\n<th>NexT集成</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hexo-related-popular-posts</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-related-popular-posts?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RlYTMvaGV4by1yZWxhdGVkLXBvcHVsYXItcG9zdHM=\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></td>\n<td>相关文章</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-generator-baidu-sitemap</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-baidu-sitemap?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>百度站点地图</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-generator-sitemap</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-sitemap?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>谷歌站点地图</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-deployer-git</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-deployer-git?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>部署</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-generator-searchdb</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-searchdb?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>本地搜索</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-generator-feed</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-feed?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>RSS</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-submit-urls-to-search-engine</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-submit-urls-to-search-engine?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>百度主动推送</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-word-counter</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-word-counter?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>文字数</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-theme-next</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-theme-next?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>NexT主题</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-helper-live2d</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-helper-live2d?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJkL2Jsb2IvbWFzdGVyL1JFQURNRS56aC1DTi5tZA==\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></td>\n<td>宠物</td>\n<td>否</td>\n</tr>\n<tr>\n<td>live2d-widget-model-wanko</td>\n<td><img data-src=\"https://img.shields.io/npm/v/live2d-widget-model-wanko?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3hpYXpleXUvbGl2ZTJkLXdpZGdldC1tb2RlbHM=\">模型<i class=\"fa fa-external-link-alt\"></i></span></td>\n<td>宠物模型</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vd2VpbGluaW5nL2hleG8tc3RhcnRlci9ibG9iL21hc3Rlci9fY29uZmlnLnltbA==\">https://gitee.com/weilining/hexo-starter/blob/master/_config.yml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2NzL2Jsb2IvbWFzdGVyL19jb25maWcubmV4dC55bWw=\">theme-next-docs/_config.next.yml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2NzL2Jsb2IvbWFzdGVyL19jb25maWcueW1s\">theme-next-docs/_config.yml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2Nz\">theme-next-docs<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2Nz\">NexT docs<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhv\">Hexo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYW9ndWFpL3AvMTEyMzkxODIuaHRtbA==\">2019Hexo博客Next主题深度美化 打造一个炫酷博客(2)-奥怪的小栈<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmJpbGwubW9lL2hleG8tdGhlbWUtbmV4dC1jb25maWctb3B0aW1pemF0aW9uLw==\">https://blog.bill.moe/hexo-theme-next-config-optimization/<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"第一天线下笔试","url":"/2020-10-19-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8B%E9%9D%A2%E8%AF%95.html","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>今天第一次参加了线下的Java开发面试，和想象的有点不一样；参加面试的公司是海能达公司，去的是江北的分公司参加的面试，整个过程只有3轮面试，但我的第一次只献给了一面，还没见到二面，有点惨哦。</p>\n<p>第一眼见到面试官，感觉很和蔼，他让我坐下并低头看着简历，他：先来个自我介绍，我：巴拉巴拉，期间他笑了一下，也许他感觉我太紧张，笑话我? 然后他就看着我的简历，他：你做过两个项目，我: 嗯 ！他：那就先说说你的项目，你的第一个项目是网上书店系统ssm，</p>\n<h3 id=\"项目1\"><a href=\"#项目1\" class=\"headerlink\" title=\"项目1\"></a>项目1</h3><h4 id=\"1-他：问的问题：\"><a href=\"#1-他：问的问题：\" class=\"headerlink\" title=\"1.他：问的问题：\"></a>1.他：问的问题：</h4><h5 id=\"①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；\"><a href=\"#①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；\" class=\"headerlink\" title=\"①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；\"></a>①<strong>那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；</strong></h5><h5 id=\"②你前端发送的一个请求是怎么找到相应的Controller的\"><a href=\"#②你前端发送的一个请求是怎么找到相应的Controller的\" class=\"headerlink\" title=\"②你前端发送的一个请求是怎么找到相应的Controller的\"></a>②<strong>你前端发送的一个请求是怎么找到相应的Controller的</strong></h5><h5 id=\"③你的Spring-mvc是怎么工作的，工作原理\"><a href=\"#③你的Spring-mvc是怎么工作的，工作原理\" class=\"headerlink\" title=\"③你的Spring mvc是怎么工作的，工作原理\"></a>③<strong>你的Spring mvc是怎么工作的，工作原理</strong></h5><h5 id=\"④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况\"><a href=\"#④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况\" class=\"headerlink\" title=\"④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况\"></a>④<strong>你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况</strong></h5><h5 id=\"⑤mybatis的一个知识-我忘\"><a href=\"#⑤mybatis的一个知识-我忘\" class=\"headerlink\" title=\"⑤mybatis的一个知识 我忘...\"></a>⑤mybatis的一个知识 我忘...</h5><h5 id=\"⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里\"><a href=\"#⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里\" class=\"headerlink\" title=\"⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里\"></a>⑥<strong>你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里</strong></h5><h5 id=\"⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录-并追问怎么实现（表的字段等）；\"><a href=\"#⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录-并追问怎么实现（表的字段等）；\" class=\"headerlink\" title=\"⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录 并追问怎么实现（表的字段等）；\"></a>⑦<strong>你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录 并追问怎么实现（表的字段等）；</strong></h5><p>他：行，项目先问到着，问问你基础；我：嗯嗯，问了==和equal、hashcode和equals、public protected default private、线程的实现几种方式和区别、你理解的多态、有几种线程池并解释、说出几种NIO的实现类；</p>\n<p>然后他又看简历，说：说说maven是做什么的，并说几条maven常见命令；你用过redis吗，在哪了用的，说说redis是干什么（具体用与什么场景）；他：那我再问问你下一个项目，你的自行车报名系统是干什么的、管理员都干了些什么；</p>\n<p>最后帮我总结了一下，说我刚开始的框架知识给他的印象很差，但后来的基础知识答得很好，可以用自己得理解来答，希望你能好好看自己得框架部分，注意细节。---end---</p>\n<h3 id=\"解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜\"><a href=\"#解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜\" class=\"headerlink\" title=\"解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜...\"></a>解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜...</h3><h5 id=\"①\"><a href=\"#①\" class=\"headerlink\" title=\"①\"></a><strong>①</strong></h5><p><strong>首先我用工具建立了一个web工程、导入ssm框架得jar包、配置对应得xml文件、写demo测试，没问题了就可以开发了。</strong></p>\n<p>细节：</p>\n<p>（对应得xml文件主要有applicationContext.xml、spring-mvc.xml、mybatis-config.xml、web.xml文件；</p>\n<p>applicationContext.xml文件主要是：</p>\n<p>a、配置注解扫描范围</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.haina.ssmbicycle.service&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>b、引用数据库配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>c、配置数据源（</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;pooledDateSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;jdbcUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClass&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;user&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>d、配置MyBatis的SqlSessionFactory，他是单个数据库映射关系经过编译后的内存镜像</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;configLocation&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><span class=\"comment\">&lt;!-- 配置mybatis全局配置文件 --&gt;</span> </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;pooledDateSource&quot;</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span><span class=\"comment\">&lt;!-- 兼容xml方式 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>e、配置Dao所在包 Mybatis会动态创建实现类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span></span></span><br><span class=\"line\">    &lt;property name=&quot;basePackage&quot; value=&quot;com.haina.ssmbicycle.dao&quot;/&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>mybatis-config.xml文件主要是：</p>\n<p>a、开启驼峰命名转换、打印sql语句                </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 开启驼峰命名转换 user_id ==&gt; userId --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapUnderscoreToCamelCase&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 驼峰规则：一般数据库表类似tb_user,里面字段都为uesr_id、uese_name等，而对应的实体类都为userId、userName --&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 打印sql语句 STDOUT_LOGGING为标准日志输出 --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>springmvc.xml文件主要是：</p>\n<p>a、配置注解扫描范围</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.haina.ssmbicycle.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>b、配置拦截器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;prefix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;suffix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>c、配置多媒体文件解析器，用于文件上传）</p>\n<p>web.xml文件：(在web/WEB-INF/web.xml)</p>\n<p>（默认欢迎页面的配置、字符编码过滤器的配置、前端控制器、以及指定spring核心配置文件和SpringMVC的配置文件，DispatcherServlet是前端控制器;</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 默认主页 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 指定spring配置文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置spring监听器 :可以在web容器启动的时候自动初始化spring容器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 调用Spring的编码过滤器 ：</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSpring中的字符集过滤器可以很方便的为我们解决项目中出现的中文乱码问题，而且使用方法也很简单，只需要在web.xml文件中配置一下该过滤器，设置两个重要的参数（encoding和forceEncoding）即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>myencoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 编码过滤器映射路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>myencoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在这里再解释一下@Controller：标名它是一个控制器，被Spring容器所管理，这个注解是在@Component后面出的，为了表示代码的分层，于是就有了@Controller、@Service、@Mapper这三个注解，他们的作用是一样的。</p>\n<p>@RequestMapping：表示接受的请求，还是GetMapping、PostMapping等注解表示请求方法的不同。</p>\n<p>@Autowired：表示自动注入，前提就是被注入的对象被Spring容器所管理。</p>\n<p>ModelAndView：这个前面说过，它装的就是数据和逻辑视图名。）</p>\n<h5 id=\"②\"><a href=\"#②\" class=\"headerlink\" title=\"②\"></a><strong>②</strong></h5><p><strong>前端jsp页面进行action请求到对应的servlet(springmvc)去处理，如果想要springmvc去处理，而不是普通的servlet，需要去web.xml文件去配置dispatcherServlet</strong></p>\n<pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n/：一切请求，注意不是/ *\n/ user：拦截以/ user开始的请求\n/user/abc.do：只拦截该请求\n.action：只拦截.action最后的请求</code></pre>\n<p>）然后通过映射是去匹配@RequestMapping注解，找到相应的controller；如果面试官还问怎么扫描到你的@RequestMapping注解，是在springmvc-config.xml文件中配置扫描controller包；</p>\n<p><strong>Jsp被访问时，执行的过程（使用Servlet）:</strong></p>\n<ul>\n<li>客户端-&gt;发起请求-&gt;服务器接收请求-&gt;Jsp本身-&gt;翻译-&gt;编译-&gt;执行</li>\n</ul>\n<p><strong>服务器是如何查找处理请求用的Servlet的呢？</strong></p>\n<ul>\n<li> 客户端-&gt;发出请求-&gt;服务器接收请求-&gt;web.xml-&gt;寻找与请求匹配的<url-pattern>-&gt;当前<servlet-mapping>中的同级<servlet-name>的值-&gt;利用该值寻找;与该<servlet-mapping>配对的<servlet>的<servlet-name>的值-&gt;获取<servlet-class>中的完整类路径</li>\n</ul>\n<h5 id=\"③\"><a href=\"#③\" class=\"headerlink\" title=\"③\"></a>③</h5><p>a.客户端（浏览器）发送请求，直接请求到DispatcherServlet（前端控制器）。</p>\n<p>b.DispatcherServlet根据请求信息调用HandlerMapping(HandlerMapping,充当着url和Controller之间映射关系配置的角色;HandlerMapping是接口，Spring MVC提供了一系列HandlerMapping的实现，根据一定的规则选择controller。如果当前的HandlerMappign实现中没有能够满足你所需要的规则是，可以通过实现HandlerMapping接口进行扩展。它主要有三部分组成：HandlerMapping映射注册、根据url获取对应的处理器、拦截器注册。),解析请求对应的Handler。</p>\n<p>c.解析到对应的Handler(也就是我们常说的Controller控制器)后，开始由HandlerAdapter适配器处理。</p>\n<p>d.HandlerAdapter适配器会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。</p>\n<p>e.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View</p>\n<p>f.ViewResolver（视图解析器）会根据逻辑上的View查找实际的View</p>\n<p>g.DispatcherServlt把返回的Model数据对象传给View（进行视图渲染）</p>\n<p>h.把View返回给请求者（浏览器）</p>\n<h5 id=\"④\"><a href=\"#④\" class=\"headerlink\" title=\"④\"></a>④</h5><p>首先用户想要买书，必须先要把书加入到购物车，在购物车里点击提交订单时会验证你数据库中图书的库存，如果购买图书大于库存数量，会提示购买图书的名字库存不足，并告诉库存有多少图书。</p>\n<h5 id=\"⑤\"><a href=\"#⑤\" class=\"headerlink\" title=\"⑤\"></a>⑤</h5><h5 id=\"⑥\"><a href=\"#⑥\" class=\"headerlink\" title=\"⑥\"></a>⑥</h5><p><strong>Mybatis中接口和对应的mapper文件不一定要放在同一个包下，放在一起的目的是为了Mybatis进行自动扫描，并且要注意此时java接口的名称和mapper文件的名称要相同（mybatis会根据Mapper.xml中配置的信息创建一个实现了Maper.java接口的代理类(使用JDK动态代理)），否则会报异常，由于此时Mybatis会自动解析对应的接口和相应的配置文件，所以就不需要配置mapper文件的位置了。如果接口和mapper文件不在同一个包下，就不能进行自动扫描解析了，需要对接口和文件分别进行配置；使用Spring来配置</strong></p>\n<pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;!-- 配置mybatis全局配置文件 --&gt; \n           &lt;property name=&quot;dataSource&quot; ref=&quot;pooledDateSource&quot;/&gt;\n    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;!-- 兼容xml方式 --&gt;\n&lt;/bean&gt;</code></pre>\n<p>如果在工程中使用了maven构建工具，那么就会出现一个问题：我们知道在典型的maven工程中，目录结构有：src/main/java和src/main/resources，前者是用来存放java源代码的，后者则是存放一些资源文件，比如配置文件等，在默认的情况下maven打包的时候，对于src/main/java目录只打包源代码，而不会打包其他文件。所以此时如果把对应的mapper文件放到src/main/java目录下时，不会打包到最终的jar文件夹中，也不会输出到target文件夹中，由于在进行单元测试的时候执行的是/target目录下/test-classes下的代码，所以在测试的时候也不会成功。</p>\n<h5 id=\"⑦\"><a href=\"#⑦\" class=\"headerlink\" title=\"⑦\"></a>⑦</h5><p>一个人同时买多本书在数据库中订单表只产生一条记录，而记录表中产生多条记录；这个订单信息主要有订单id、总价、商品详情（书名 价格 数量）、收货信息（收货人、电话、收获地址）、订单状态（已付款、未付款、已完成）、支付方式（微信、支付宝、货到付款）、下单时间、操作；对应的数据库中有两个表，一个是<strong>记录表</strong>，主要是记录每一本书的价格、数量、订单id、图书id；另一个是<strong>订单表</strong>，主要记录记录订单id、总价、订单状态（已付款、未付款、已完成）、支付方式（微信、支付宝、货到付款）、收货人、电话、收货地址、下单时间、user_id。那么前端具体怎么实现的呢，是通过&lt;c:forEach var=&quot;order&quot; items=&quot;${orderList}&quot;&gt;jstl标签把后端循环遍历来的数据放到orderList，通过model.addAttribute(&quot;orderList&quot;, orderList)传到前端，然后每次取到的数据存放到val变量中，然后在前端jsp页面上写好死的显示页面，如果有单条记录有多个信息的，比如说是一个人的订单中的多本书的信息，可以用jstl表达式往出拿信息。</p>\n<h3 id=\"基础：\"><a href=\"#基础：\" class=\"headerlink\" title=\"基础：\"></a>基础：</h3><h4 id=\"1-与-equals-重要\"><a href=\"#1-与-equals-重要\" class=\"headerlink\" title=\"1.== 与 equals(重要)\"></a>1.<strong>== 与 equals(重要)</strong></h4><p>==:<br>   它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型⽐较的是值，引⽤数据类型⽐较的是内存地址)。</p>\n<p>equals() :<br>   它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“==”⽐较这两个对象。情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>\n<h4 id=\"2-hashcode和equals\"><a href=\"#2-hashcode和equals\" class=\"headerlink\" title=\"2.hashcode和equals\"></a>2.<strong>hashcode和equals</strong></h4><p>  hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode()在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。</p>\n<p>hashCode（）与 equals（）的相关规定 </p>\n<pre><code>    1. 如果两个对象相等，则 hashcode ⼀定也是相同的\n    2. 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true\n    3. 两个对象有相同的 hashcode 值，它们也不⼀定是相等的\n    4. 因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖\n    5. hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）</code></pre>\n<h4 id=\"3-public-protected-default-private的访问权限修饰区别\"><a href=\"#3-public-protected-default-private的访问权限修饰区别\" class=\"headerlink\" title=\"3.public protected default private的访问权限修饰区别\"></a>3.<strong>public protected default private的访问权限修饰区别</strong></h4><p>  public在本类中、同一包中、子类中不在同一包中、其他包下都能访问<br>  protected在本类中、同一包中、子类中不在同一包中都能访问<br>  default在本类中、同一包中都能访问<br>  private在本类中能访问</p>\n<h4 id=\"4-多线程的实现方式和区别\"><a href=\"#4-多线程的实现方式和区别\" class=\"headerlink\" title=\"4.多线程的实现方式和区别\"></a>4.<strong>多线程的实现方式和区别</strong></h4><p>①继承Thread类<br>    public class MyThread extends Thread {<br>    @Override<br>    public void run(){<br>        super.run();<br>        System.out.println(&quot;执行子线程...&quot;);<br>    }</p>\n<p>测试用例</p>\n<pre><code>public class Test &#123;\npublic static void main(String[] args) &#123;\n    MyThread myThread = new MyThread();\n    myThread.start();\n    System.out.println(&quot;主线程...&quot;);\n    &#125;\n&#125;</code></pre>\n<p>②实现Rannable接口</p>\n<pre><code>public class MyRunnable implements Runnable &#123;\n@Override\npublic void run() &#123;\n    System.out.println(&quot;执行子线程...&quot;);\n        &#125;\n&#125;</code></pre>\n<p>测试用例</p>\n<pre><code> public class Test &#123;\npublic static void main(String[] args) &#123;\n\n    Runnable runnable = new MyRunnable();\n    Thread thread = new Thread(runnable);\n    thread.start();\n    System.out.println(&quot;主线程运行结束!&quot;);\n&#125;</code></pre>\n<p>③使用Callable和Future创建线程</p>\n<p>上面的两种方式都有这两个问题：</p>\n<ul>\n<li>无法获取子线程的返回值</li>\n<li>run方法不可以抛出异常</li>\n</ul>\n<p>为了解决这两个问题，我们就需要用到Callable这个接口了。说到接口，上面的Runnable接口实现类实例是作为Thread类的构造函数的参数传入的，之后通过Thread的start执行run方法中的内容。但是Callable并不是Runnable的子接口，是个全新的接口，它的实例不能直接传入给Thread构造，所以需要另一个接口来转换一下。</p>\n<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个实现类FutureTask，该实现类的继承关系如图所示：</p>\n<pre><code>import java.util.concurrent.Callable;\npublic class MyCallable implements Callable &#123;\nint i = 0;\n@Override\npublic Object call() throws Exception &#123;\n    System.out.println(Thread.currentThread().getName()+&quot;  i的值：&quot;+ i);\n    return i++; //call方法可以有返回值\n    &#125;\n&#125;    </code></pre>\n<p>测试用例</p>\n<pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\npublic class Test &#123;\npublic static void main(String[] args) &#123;\n    Callable callable = new MyCallable();\n    for (int i = 0; i &lt; 10; i++) &#123;\n        FutureTask task = new FutureTask(callable);\n        new Thread(task,&quot;子线程&quot;+ i).start();\n        try &#123;\n            //获取子线程的返回值\n            System.out.println(&quot;子线程返回值：&quot;+task.get() + &quot;\\n&quot;);\n        &#125;  catch (Exception e) &#123;\n            e.printStackTrace();\n                &#125;\n        &#125;\n        &#125;\n&#125;</code></pre>\n<p>④使用线程池</p>\n<p><strong>前三种实现多线程的比较：</strong></p>\n<p>第一种和后面两种的对比：</p>\n<ul>\n<li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li>\n<li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li>\n</ul>\n<p>第二种和第三种方式对比：</p>\n<ul>\n<li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li>\n<li>第三种方法有两个优点：有返回值、可以抛出异常</li>\n</ul>\n<p><strong>实现多线程的总结</strong></p>\n<p><strong>实际开发中可能有更复杂的代码实现，需要继承其他的类，所以平时更推荐通过实现接口来实现多线程，也就是通过第二或第三种方式来实现，这样能保持代码灵活和解耦。<br>而选择第二还是第三种方式，则要根据run()方法是不是需要返回值或者捕获异常来决定，如果不需要，可以选择用第二种方式实现，代码更简洁。</strong></p>\n<h4 id=\"5-有几种线程池并解释\"><a href=\"#5-有几种线程池并解释\" class=\"headerlink\" title=\"5.有几种线程池并解释\"></a><strong>5.有几种线程池并解释</strong></h4><ol>\n<li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li>\n<li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n<li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li>\n<li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li>\n</ol>\n<h4 id=\"6-说出几种NIO的实现类\"><a href=\"#6-说出几种NIO的实现类\" class=\"headerlink\" title=\"6.说出几种NIO的实现类\"></a><strong>6.说出几种NIO的实现类</strong></h4><p>NIO 包含下面几个核心的组件：</p>\n<ul>\n<li>Channel(通道)</li>\n<li>Buffer(缓冲区)</li>\n<li>Selector(选择器)</li>\n</ul>\n<p>想到这扩展一下：BIO,NIO,AIO 有什么区别? </p>\n<ul>\n<li><strong>BIO（Blocking I/0）：同步阻塞I/0模式</strong>，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐较不错的，可以让每⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。</li>\n<li><strong>NIO（Non-blocking/New I/0）：NIO是一种同步非阻塞的I/0模型</strong>，在Java 1.4中引入了NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。</li>\n<li><strong>AIO（Asynchronous I/0）：AIO也就是NIO 2，</strong>在Java 7中引入了NIO的改进版NIO 2，它是异步非阻塞的I0模型。异步10是基于事件和回调机制实现的,</li>\n</ul>\n<h4 id=\"7-你理解的多态\"><a href=\"#7-你理解的多态\" class=\"headerlink\" title=\"7.你理解的多态\"></a><strong>7.你理解的多态</strong></h4><p>所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，<strong>即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。</strong></p>\n<p>在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖[又叫重写]接⼝中同一方法）。</p>\n<h4 id=\"8-说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗\"><a href=\"#8-说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗\" class=\"headerlink\" title=\"8.说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗\"></a><strong>8.说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗</strong></h4><p><strong>概述</strong></p>\n<ul>\n<li>Maven是一个构建工具，服务与构建使用Maven配置好项目后，输入简单的命令如：mvn clean install，Maven会帮我们处理那些繁琐的任务</li>\n</ul>\n<ul>\n<li><p>Maven是跨平台的</p>\n</li>\n<li><p>Maven最大化的消除了构建的重复</p>\n</li>\n<li><p>Maven可以帮助我们标准化构建过程所有的项目都是简单一致的，简化了学习成本总之Maven作为一个构建工具不仅帮我们自动化构建，还能抽象构建过程提供构建任务实现他跨平台，对外提供一致的操作接口，这一切足以使他成为优秀的，流行的构建工具</p>\n</li>\n<li><p>但是Maven不仅是构建工具，他还是一个依赖管理工具和项目信息管理工具，他还提供了中央仓库，能帮我们自动下载构件</p>\n</li>\n<li><p>使用Maven还能享受一个额外的好处，即Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置Convention Over Configuration）</p>\n</li>\n</ul>\n<p><strong><em>它是一个Apache的开源项目，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理，还提供了中央仓库，能自动下载构件，为了不重复造轮子。</em></strong></p>\n<p>例如：两个项目A B，项目A需要依赖一些jar包，项目B也需要依赖这些jar包，那么此时如果都把jar包引入到项目中，就是在重复造轮子，我们应该把这些所有的jar包放到一个地方，需要用的时候过去取即可。</p>\n<p><strong>常用的maven命令：</strong></p>\n<ul>\n<li><p>maven clean：对项目进行清理，清理的过程中会删除删除target目录下编译的内容。</p>\n</li>\n<li><p>maven compile：编译项目源代码。</p>\n</li>\n<li><p>maven test：对项目的运行测试。</p>\n</li>\n<li><p>maven deploy： 发布项目</p>\n</li>\n<li><p>maven packet：可以打包后的文件存放到项目的 target 目录下，打包好的文件通常都是编译后生成的class文件。</p>\n</li>\n<li><p>maven install：在本地仓库生成仓库的安装包可以供其他项目引用，同时打包后的文件存放到项目的 target 目录下。对项目打包有三种打包方式，pom打包，jar包和war包。打包方式在pom.xml文件中进行指定。</p>\n</li>\n</ul>\n<p><em>pom工程一般是聚合工程，代表父工程，负责管理jar包的版本、maven插件的版本等，主要做统一的依赖管理。</em></p>\n<p><em>jar包就是普通的打包方式，可以是pom工程的子工程。</em></p>\n<p><em>war包的都是web工程，是可以直接放到tomcat下运行的工程。</em></p>\n<p>我的项目中主要是用maven来对项目中jar包依赖进行统一的管理。</p>\n<h4 id=\"9-你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）\"><a href=\"#9-你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）\" class=\"headerlink\" title=\"9.你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）\"></a><strong>9.你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）</strong></h4><p><strong>简介</strong></p>\n<p><strong>Redis:</strong> REmote DIctionary Server(远程字典服务器)是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。</p>\n<p><strong>redis使用场景</strong></p>\n<ol>\n<li><p>热点数据的缓存<br>由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。</p>\n</li>\n<li><p>限时业务的运用<br>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>\n</li>\n<li><p>计数器相关问题<br>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>\n</li>\n<li><p>排行榜相关问题<br>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。例如：在奶茶活动中，我们需要展示各个部门的点赞排行榜，所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p>\n</li>\n<li><p>分布式锁<br>这个主要利用redis的setnx命令进行，setnx：&quot;set if not exists&quot;就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。</p>\n</li>\n<li><p>延时操作<br>这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p>\n</li>\n<li><p>队列<br>由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。　</p>\n</li>\n</ol>\n<h3 id=\"项目2\"><a href=\"#项目2\" class=\"headerlink\" title=\"项目2\"></a>项目2</h3><p><strong>1.你的自行车报名系统是干什么的，管理员都干了些什么</strong></p>\n<p>随着自行车赛事活动的增加，把赛事变得更加理性和规范，使赛事朝着IP化、品质化方向发展。参赛者可以线上报名为赛事提供诸多便利。</p>\n<p>完成管理员的登录、完成管理员创建比赛、查看比赛列表、管理员查看赛事报名状态、<br>对赛事管理（修改、删除）</p>\n","categories":["面试"],"tags":["java"]},{"title":"贪心算法","url":"/2020-11-08-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html","content":"<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><p>在以下的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p>\n<h3 id=\"1-分配饼干\"><a href=\"#1-分配饼干\" class=\"headerlink\" title=\"1.分配饼干\"></a>1.分配饼干</h3><ol start=\"455\">\n<li>Assign Cookies (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYXNzaWduLWNvb2tpZXMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXNzaWduLWNvb2tpZXMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：每个孩子都有一个满足度 g，每个饼干都有一个大小 s，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解析：</p>\n<ol>\n<li><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</p>\n</li>\n<li><p>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</p>\n</li>\n</ol>\n<p>每个孩子的满足度和饼干的大小不是顺序排序的，所以首先我们要把这两个数组进行顺序排序，选择升序排序，因为我们要输出可以满足孩子的数量，所以要先满足满足度最小的孩子后，在满足比他大的，具体怎么比较呢：</p>\n<p>因为我们不知道有多少个g、s，不知道循环次数，所以用while来判断s、g是否超出边界；每次第一个孩子满足度（最小的）和饼干大小（最小的）比较；第一种情况：g&lt;=s,记录满足孩子数量，进行第二个组g、s，相当于g、s +1；第二种情况：g&gt;s,不记录满足孩子数量，进行第二个组g、s+1比较，相当于g、s+1;总结来说s是一直要+1的，也就是说满不满足s都要+1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findContentChildren</span><span class=\"params\">(<span class=\"keyword\">int</span>[] g, <span class=\"keyword\">int</span>[] s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(g==<span class=\"keyword\">null</span> || s==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Array.sort(g);</span><br><span class=\"line\">        Array.sort(s);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> gi=<span class=\"number\">0</span>;<span class=\"keyword\">int</span> si=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(gi&lt;g.length &amp;&amp; si&lt;s.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(g[gi]&lt;=s[si])&#123;</span><br><span class=\"line\">                gi++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            si++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-不重叠的区间个数\"><a href=\"#2-不重叠的区间个数\" class=\"headerlink\" title=\"2.不重叠的区间个数\"></a>2.不重叠的区间个数</h3><ol start=\"435\">\n<li>Non-overlapping Intervals (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p>\n<ul>\n<li>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</li>\n<li>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</li>\n<li>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 2</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [ [1,2], [2,3] ]</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解析：进行二维数组中第二位数升序排序，输入: [ [1,2], [2,3], [3,4], [1,3] ]，排完序后是[ [1,2], [2,3], [1,3], [3,4] ]，把第一个结束校验的位置放到end = intervals[0][1],因为第一组区间一定存在，然后往后面判断不重复的区间，所以存在不重复区间cnt=1，默认第一个区间存在；如果end &gt; intervals[i][0]成立,说明第二组区间和第一组区间重合，跳出（continue），不计cnt，然后i+1，继续判断end &gt; intervals[i][0],如果不成立，cnt+1、更新end的值end=ntervals[i][1] 因为这个区间和上一个区间不重复，并且本区间中后面的数较大，所以end等于本区间最大值，i+1,一直到循环结束，用还数组长度-cnt=重复的区间数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] intervals)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        <span class=\"comment\">//二维数组，第二个元素排序，另一个元素跟随</span></span><br><span class=\"line\">        <span class=\"comment\">//Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o[]));</span></span><br><span class=\"line\">        <span class=\"comment\">//二维数组，第一个元素排序 ，另一个元素跟随                          </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end=intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][<span class=\"number\">0</span>] &lt; end )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;           </span><br><span class=\"line\">                end=intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.length-cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-投飞镖刺破气球\"><a href=\"#3-投飞镖刺破气球\" class=\"headerlink\" title=\"3. 投飞镖刺破气球\"></a>3. 投飞镖刺破气球</h3><ol start=\"452\">\n<li>Minimum Number of Arrows to Burst Balloons (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1udW1iZXItb2YtYXJyb3dzLXRvLWJ1cnN0LWJhbGxvb25zL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1udW1iZXItb2YtYXJyb3dzLXRvLWJ1cnN0LWJhbGxvb25zL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>\n<p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：points = [[<span class=\"number\">10</span>,<span class=\"number\">16</span>],[<span class=\"number\">2</span>,<span class=\"number\">8</span>],[<span class=\"number\">1</span>,<span class=\"number\">6</span>],[<span class=\"number\">7</span>,<span class=\"number\">12</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">2</span></span><br><span class=\"line\">解释：对于该样例，x = <span class=\"number\">6</span> 可以射爆 [<span class=\"number\">2</span>,<span class=\"number\">8</span>],[<span class=\"number\">1</span>,<span class=\"number\">6</span>] 两个气球，以及 x = <span class=\"number\">11</span> 射爆另外两个气球</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">5</span>,<span class=\"number\">6</span>],[<span class=\"number\">7</span>,<span class=\"number\">8</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">4</span>,<span class=\"number\">5</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findMinArrowShots</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] points)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(points.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Array.sort(points,Comparator.comparingInt(o-&gt;o[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end=points[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;points.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(points[i][<span class=\"number\">0</span>] &lt;= end)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                end=points[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-根据身高和序号重组队列\"><a href=\"#4-根据身高和序号重组队列\" class=\"headerlink\" title=\"4.根据身高和序号重组队列\"></a>4.根据身高和序号重组队列</h3><ol start=\"406\">\n<li>Queue Reconstruction by Height(Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcXVldWUtcmVjb25zdHJ1Y3Rpb24tYnktaGVpZ2h0L2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcXVldWUtcmVjb25zdHJ1Y3Rpb24tYnktaGVpZ2h0L2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p>\n<p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</p>\n<p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[[<span class=\"number\">7</span>,<span class=\"number\">0</span>], [<span class=\"number\">4</span>,<span class=\"number\">4</span>], [<span class=\"number\">7</span>,<span class=\"number\">1</span>], [<span class=\"number\">5</span>,<span class=\"number\">0</span>], [<span class=\"number\">6</span>,<span class=\"number\">1</span>], [<span class=\"number\">5</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[<span class=\"number\">5</span>,<span class=\"number\">0</span>], [<span class=\"number\">7</span>,<span class=\"number\">0</span>], [<span class=\"number\">5</span>,<span class=\"number\">2</span>], [<span class=\"number\">6</span>,<span class=\"number\">1</span>], [<span class=\"number\">4</span>,<span class=\"number\">4</span>], [<span class=\"number\">7</span>,<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n\n<p> 解释：身高从高到低排序的好处是，对于前面已经排好的队</p>\n<p>1.如果下一个人(h,k)比前面所有人都矮，那么，他插入队列的k处，使其达到k的要求，对其他人没影响，达到要求！</p>\n<p> 2.如果下一个人跟之前排好队的人中最矮的身高一样，这时候，就体现为什么之前排序时候，先考虑身高，再按照k的升序了，这时候，新来的人虽然与之前最矮之人身高一样，但是由于他的k比之前最矮的人的k都大，所以，他插入的地方一定在已经排好队的，和他身高一样的，最矮之人的后面，对这些最矮人们没有影响，当然，对其他比他高的人就更没有影响了。</p>\n<p>其只要了解一点：我们一个一个地排队，对于前面已经排好的队，如果我们在k的位置插入一个新人，那么对k之前的人没有任何影响，对于k之后比新人高的人也没有任何影响，因此，我们每插入一个人的时候，要么保证前面所有人都比新人高，要么至少保证插入的位置后面的所有人都比新人高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] reconstructQueue(<span class=\"keyword\">int</span>[][] people) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (people == <span class=\"keyword\">null</span> || people.length == <span class=\"number\">0</span> || people[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 当第一维相等时比较第二维的</span></span><br><span class=\"line\">    Arrays.sort(people, (a, b) -&gt; (a[<span class=\"number\">0</span>] == b[<span class=\"number\">0</span>] ? a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] : b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *for(元素类型t 元素变量x : 遍历对象obj)&#123; </span></span><br><span class=\"line\"><span class=\"comment\">    *\t\t\t引用了x的java语句; </span></span><br><span class=\"line\"><span class=\"comment\">\t*\t\t\t&#125; </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] p : people) &#123;</span><br><span class=\"line\">        queue.add(p[<span class=\"number\">1</span>], p);<span class=\"comment\">//因为之前的已经排过序了，所以直接插入自己的位置就可以了</span></span><br><span class=\"line\">        <span class=\"comment\">//相对于[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]经过h降序、k升序</span></span><br><span class=\"line\">        <span class=\"comment\">//-&gt; [[7,0], [7,1], [6,1],[5,0],[5,2]，[4,4],]</span></span><br><span class=\"line\">        <span class=\"comment\">//经过foreach后 p[1]= 0 1 1 0 2 4</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0], [7,1], [6,1], [5,0], [5,2], [4,4]</span></span><br><span class=\"line\">        <span class=\"comment\">// 再一个一个插入。</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0]</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0], [6,1], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [5,0], [7,0], [6,1], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [5,0], [7,0], [5,2], [6,1], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [5,0], [7,0], [5,2], [6,1], [4,4], [7,1]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回一个数组，该数组按正确顺序（从第一个元素到最后一个元素）包含此列表中的所有元素。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[queue.size()][]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-买卖股票最大的收益\"><a href=\"#5-买卖股票最大的收益\" class=\"headerlink\" title=\"5. 买卖股票最大的收益\"></a>5. 买卖股票最大的收益</h3><ol start=\"121\">\n<li>Best Time to Buy and Sell Stock (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p>\n<p>解释：只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出，最大利润 = <span class=\"number\">6</span>-<span class=\"number\">1</span> = <span class=\"number\">5</span> 。</span><br><span class=\"line\">     注意利润不能是 <span class=\"number\">7</span>-<span class=\"number\">1</span> = <span class=\"number\">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class=\"number\">0</span>。    </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> minf=prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">       <span class=\"keyword\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(minf&gt;prices[i])&#123;</span><br><span class=\"line\">               minf=prices[i];</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               max = Math.max(max,prices[i]-minf);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-买卖股票的最大收益-II\"><a href=\"#6-买卖股票的最大收益-II\" class=\"headerlink\" title=\"6. 买卖股票的最大收益 II\"></a>6. 买卖股票的最大收益 II</h3><ol start=\"122\">\n<li>Best Time to Buy and Sell Stock II (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay1paS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay1paS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<p>解释：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此**当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0**，那么就把 prices[i] - prices[i-1] 添加到收益中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">7</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">3</span> 天（股票价格 = <span class=\"number\">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class=\"number\">5</span>-<span class=\"number\">1</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\">     随后，在第 <span class=\"number\">4</span> 天（股票价格 = <span class=\"number\">3</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class=\"number\">6</span>-<span class=\"number\">3</span> = <span class=\"number\">3</span> 。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">1</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天 （股票价格 = <span class=\"number\">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class=\"number\">5</span>-<span class=\"number\">1</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\">     注意你不能在第 <span class=\"number\">1</span> 天和第 <span class=\"number\">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class=\"line\">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if a&lt;=b&lt;=c&lt;=d</span></span><br><span class=\"line\">    <span class=\"comment\">//max=d-a</span></span><br><span class=\"line\">    <span class=\"comment\">//d-a=(d-c)+(c-b)+(b-a)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[i]&gt;prices[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                sum+=prices[i]-prices[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-种植花朵\"><a href=\"#7-种植花朵\" class=\"headerlink\" title=\"7. 种植花朵\"></a>7. 种植花朵</h3><ol start=\"605\">\n<li>Can Place Flowers (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。也就是flowerbed 数组中 1 表示已经种下了花朵，0代表每种下。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: flowerbed = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>], n = <span class=\"number\">1</span></span><br><span class=\"line\">输出: True</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入: flowerbed = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>], n = <span class=\"number\">2</span></span><br><span class=\"line\">输出: False</span><br><span class=\"line\">注意：</span><br><span class=\"line\">    数组内已种好的花不会违反种植规则。</span><br><span class=\"line\">\t输入的数组长度范围为 [<span class=\"number\">1</span>, <span class=\"number\">20000</span>]。</span><br><span class=\"line\">\tn 是非负整数，且不会超过输入数组的大小。    </span><br></pre></td></tr></table></figure>\n\n<p>解释：在[1,0,0,0,1],插入1，并且需怕满足一个1的前后都是0，所以我们可以换一个思路想，我们找0，如果0的前后都是0，那么这个o就可以置为1了（这里要特殊判断一下，数组的0、data.length-1索引，因为要判断到最前面和最后面后出现数组越界），并且记录插入的值，因为最后要返回的是是否种下了n朵花，用插入的cnt和n比较，如果cnt&gt;=n，代表能够种下n多花。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canPlaceFlowers</span><span class=\"params\">(<span class=\"keyword\">int</span>[] flowerbed, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;flowerbed.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flowerbed[i]==<span class=\"number\">0</span> &amp;&amp; (i==<span class=\"number\">0</span> || flowerbed[i-<span class=\"number\">1</span>]==<span class=\"number\">0</span>) &amp;&amp; (i==flowerbed.length-<span class=\"number\">1</span> || flowerbed[i+<span class=\"number\">1</span>]==<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">                flowerbed[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count&gt;=n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-判断是否为子序列\"><a href=\"#8-判断是否为子序列\" class=\"headerlink\" title=\"8. 判断是否为子序列\"></a>8. 判断是否为子序列</h3><ol start=\"392\">\n<li>Is Subsequence (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>\n<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">输入：s = <span class=\"string\">&quot;abc&quot;</span>, t = <span class=\"string\">&quot;ahbgdc&quot;</span></span><br><span class=\"line\">返回 <span class=\"keyword\">true</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = <span class=\"string\">&quot;axc&quot;</span>, t = <span class=\"string\">&quot;ahbgdc&quot;</span></span><br><span class=\"line\">返回 <span class=\"keyword\">false</span>.</span><br></pre></td></tr></table></figure>\n\n<p>解释：这道题如果你会java的一些常见API就会很简单了，首先把子序列用toCharArray()转成一个字符数组，然后用int indexOf(String str, int index)返回从 index位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1；把index初始值赋为-1，如果在遍历中index==-1则返回false,否则返回true.</p>\n<p>//toCharArray() 方法将字符串转换为字符数组。<br>public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p>\n<p>foreach语句是java5的新特征之一，在遍历数组、集合方面，foreach为开发人员提供了极大的方便。<br>foreach 语法格式如下：<br>for(元素类型t 元素变量x : 遍历对象obj){<br>     引用了x的java语句; } </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isSubsequence(String s, String t) &#123;</span><br><span class=\"line\">    int index &#x3D; -1;</span><br><span class=\"line\">    for(char c : s.toCharArray())&#123;</span><br><span class=\"line\">        index &#x3D; t.indexOf(c,index+1);</span><br><span class=\"line\">        if(index &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-修改一个数成为非递减数组\"><a href=\"#9-修改一个数成为非递减数组\" class=\"headerlink\" title=\"9. 修改一个数成为非递减数组\"></a>9. 修改一个数成为非递减数组</h3><ol start=\"665\">\n<li>Non-decreasing Array (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbm9uLWRlY3JlYXNpbmctYXJyYXkvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLWRlY3JlYXNpbmctYXJyYXkvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p>\n<p>解释：这道题主要就是判断两种情况，判断5 7 4 6这样的数   判断4 2 1这样的数，第一种是把4变成7，第二种是把4变成2</p>\n<p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">true</span></span><br><span class=\"line\">解释: 你可以通过把第一个<span class=\"number\">4</span>变成<span class=\"number\">1</span>来使得它成为一个非递减数列。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入: nums = [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">false</span></span><br><span class=\"line\">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。  </span><br><span class=\"line\">   </span><br><span class=\"line\">    </span><br><span class=\"line\">输入: nums = [<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">false</span></span><br><span class=\"line\">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入: nums = [<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">true</span></span><br><span class=\"line\">解释: 你可以通过把第一个<span class=\"number\">4</span>变成<span class=\"number\">7</span>来使得它成为一个非递减数列。        </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkPossibility</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length&amp;&amp;cnt&lt;<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用cnt&lt;2 当出现第二个比前面大的数，直接停止循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;=nums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">               <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i-<span class=\"number\">2</span>&gt;=<span class=\"number\">0</span> &amp;&amp; nums[i]&lt;nums[i-<span class=\"number\">2</span>])&#123;<span class=\"comment\">//判断5 7 4 8这样的数</span></span><br><span class=\"line\">            <span class=\"comment\">//7&gt;5 ,4&lt;7  只能让4的位置换成7才能不是递减</span></span><br><span class=\"line\">                nums[i]=nums[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">                nums[i-<span class=\"number\">1</span>]=nums[i];<span class=\"comment\">//判断4 2 3这样的数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-子数组最大的和\"><a href=\"#10-子数组最大的和\" class=\"headerlink\" title=\"10. 子数组最大的和\"></a>10. 子数组最大的和</h3><ol start=\"53\">\n<li>Maximum Subarray (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>解释：要找到一个连续数组的最大和，首先要找到一个大于0的数，然后判断，取一个temp中间值，如果temp大于0 temp=temp+nums[i];只有返回的temp大于0，才会使连续的数组，如果中间出现temp小于0，就代表放弃前面的数组了，重新开始从本nums[i]加起。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [-<span class=\"number\">2</span>,<span class=\"number\">1</span>,-<span class=\"number\">3</span>,<span class=\"number\">4</span>,-<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,-<span class=\"number\">5</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">6</span></span><br><span class=\"line\">解释: 连续子数组 [<span class=\"number\">4</span>,-<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>] 的和最大，为 <span class=\"number\">6</span>。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            temp = temp&gt;<span class=\"number\">0</span> ? nums[i]+temp:nums[i];</span><br><span class=\"line\">            max = Math.max(temp,max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-分隔字符串使同种字符出现在一起\"><a href=\"#11-分隔字符串使同种字符出现在一起\" class=\"headerlink\" title=\"11. 分隔字符串使同种字符出现在一起\"></a>11. 分隔字符串使同种字符出现在一起</h3><ol start=\"763\">\n<li>Partition Labels (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<p>解释：一想到分割字符串就想到了回溯，但本题其实不用那么复杂。</p>\n<p>可以分为如下两步：</p>\n<p>统计每一个字符最后出现的位置<br>从头遍历字符，如果找到之前字符最大出现位置下标和当前下标相等，则找到了分割点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：S = <span class=\"string\">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class=\"line\">输出：[<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">划分结果为 <span class=\"string\">&quot;ababcbaca&quot;</span>, <span class=\"string\">&quot;defegde&quot;</span>, <span class=\"string\">&quot;hijhklij&quot;</span>。</span><br><span class=\"line\">每个字母最多出现在一个片段中。</span><br><span class=\"line\">像 <span class=\"string\">&quot;ababcbacadefegde&quot;</span>, <span class=\"string\">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">partitionLabels</span><span class=\"params\">(String S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//统计每个字母出现的最大下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] lastIndexsOfChar = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class=\"line\">        lastIndexsOfChar[char2Index(S.charAt(i))] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个集合装返回的数据</span></span><br><span class=\"line\">    List&lt;Integer&gt; partitions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> firstIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (firstIndex &lt; S.length()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastIndex = firstIndex;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = firstIndex; i &lt; S.length() &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = lastIndexsOfChar[char2Index(S.charAt(i))];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &gt; lastIndex) &#123;</span><br><span class=\"line\">                lastIndex = index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//装每个分割点的字符数</span></span><br><span class=\"line\">        partitions.add(lastIndex - firstIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//重新遍历下一个字符开始的字符串</span></span><br><span class=\"line\">        firstIndex = lastIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> partitions;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">char2Index</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["算法"],"tags":["贪心算法"]},{"title":"ConcurrentHashMap","url":"/2020-11-17-ConcurrentHashMap.html","content":"<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><h2 id=\"JDK1-7\"><a href=\"#JDK1-7\" class=\"headerlink\" title=\"JDK1.7\"></a>JDK1.7</h2><h3 id=\"1-存储结构\"><a href=\"#1-存储结构\" class=\"headerlink\" title=\"1. 存储结构\"></a>1. 存储结构</h3><p><img data-src=\"https://i.loli.net/2020/11/17/3LAd5JPm4V8N6RU.png\" loading=\"lazy\"></p>\n<p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现.</p>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2. 初始化\"></a>2. 初始化</h3><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class=\"line\"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public ConcurrentHashMap() &#123;</span><br><span class=\"line\">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 默认初始化容量</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 默认负载因子</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 默认并发级别</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure>\n\n<p>接着看下这个有参构造函数的内部实现逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 参数校验</span><br><span class=\"line\">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException();</span><br><span class=\"line\">    &#x2F;&#x2F; 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br><span class=\"line\">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class=\"line\">        concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class=\"line\">    &#x2F;&#x2F; Find power-of-two sizes best matching arguments</span><br><span class=\"line\">    &#x2F;&#x2F; 2的多少次方</span><br><span class=\"line\">    int sshift &#x3D; 0;</span><br><span class=\"line\">    int ssize &#x3D; 1;</span><br><span class=\"line\">    &#x2F;&#x2F; 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br><span class=\"line\">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class=\"line\">        ++sshift;</span><br><span class=\"line\">        ssize &lt;&lt;&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 记录段偏移量</span><br><span class=\"line\">    this.segmentShift &#x3D; 32 - sshift;</span><br><span class=\"line\">    &#x2F;&#x2F; 记录段掩码</span><br><span class=\"line\">    this.segmentMask &#x3D; ssize - 1;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置容量</span><br><span class=\"line\">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class=\"line\">    &#x2F;&#x2F; c &#x3D; 容量 &#x2F; ssize ，默认 16 &#x2F; 16 &#x3D; 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br><span class=\"line\">    int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class=\"line\">    if (c * ssize &lt; initialCapacity)</span><br><span class=\"line\">        ++c;</span><br><span class=\"line\">    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class=\"line\">    &#x2F;&#x2F;Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br><span class=\"line\">    while (cap &lt; c)</span><br><span class=\"line\">        cap &lt;&lt;&#x3D; 1;</span><br><span class=\"line\">    &#x2F;&#x2F; create segments and segments[0]</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Segment 数组，设置 segments[0]</span><br><span class=\"line\">    Segment&lt;K,V&gt; s0 &#x3D; new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class=\"line\">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class=\"line\">    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class=\"line\">    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]</span><br><span class=\"line\">    this.segments &#x3D; ss;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p>\n<ol>\n<li>必要参数校验。</li>\n<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造<strong>默认值是 16.</strong></li>\n<li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>\n<li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li>\n<li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li>\n<li><strong>初始化 segments[0]**，</strong>默认大小为 2<strong>，</strong>负载因子 0.75<strong>，</strong>扩容阀值是 2*0.75=1.5**，插入第二个值时才会进行扩容。</li>\n</ol>\n<h3 id=\"3-put\"><a href=\"#3-put\" class=\"headerlink\" title=\"3. put\"></a>3. put</h3><p>接着上面的初始化参数继续查看 put 方法源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Maps the specified key to the specified value in this table.</span><br><span class=\"line\"> * Neither the key nor the value can be null.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;&#x2F;tt&gt; method</span><br><span class=\"line\"> * with a key that is equal to the original key.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param key key with which the specified value is to be associated</span><br><span class=\"line\"> * @param value value to be associated with the specified key</span><br><span class=\"line\"> * @return the previous value associated with &lt;tt&gt;key&lt;&#x2F;tt&gt;, or</span><br><span class=\"line\"> *         &lt;tt&gt;null&lt;&#x2F;tt&gt; if there was no mapping for &lt;tt&gt;key&lt;&#x2F;tt&gt;</span><br><span class=\"line\"> * @throws NullPointerException if the specified key or value is null</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    Segment&lt;K,V&gt; s;</span><br><span class=\"line\">    if (value &#x3D;&#x3D; null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    int hash &#x3D; hash(key);</span><br><span class=\"line\">    &#x2F;&#x2F; hash 值无符号右移 28位（初始化时获得），然后与 segmentMask&#x3D;15 做与运算</span><br><span class=\"line\">    &#x2F;&#x2F; 其实也就是把高4位与segmentMask（1111）做与运算</span><br><span class=\"line\">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class=\"line\">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class=\"line\">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class=\"line\">        &#x2F;&#x2F; 如果查找到的 Segment 为空，初始化</span><br><span class=\"line\">        s &#x3D; ensureSegment(j);</span><br><span class=\"line\">    return s.put(key, hash, value, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Returns the segment for the given index, creating it and</span><br><span class=\"line\"> * recording in segment table (via CAS) if not already present.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param k the index</span><br><span class=\"line\"> * @return the segment</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class=\"line\">    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;</span><br><span class=\"line\">    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset</span><br><span class=\"line\">    Segment&lt;K,V&gt; seg;</span><br><span class=\"line\">    &#x2F;&#x2F; 判断 u 位置的 Segment 是否为null</span><br><span class=\"line\">    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        Segment&lt;K,V&gt; proto &#x3D; ss[0]; &#x2F;&#x2F; use segment 0 as prototype</span><br><span class=\"line\">        &#x2F;&#x2F; 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br><span class=\"line\">        int cap &#x3D; proto.table.length;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br><span class=\"line\">        float lf &#x3D; proto.loadFactor;</span><br><span class=\"line\">        &#x2F;&#x2F; 计算扩容阀值</span><br><span class=\"line\">        int threshold &#x3D; (int)(cap * lf);</span><br><span class=\"line\">        &#x2F;&#x2F; 创建一个 cap 容量的 HashEntry 数组</span><br><span class=\"line\">        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class=\"line\">        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; recheck</span><br><span class=\"line\">            &#x2F;&#x2F; 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br><span class=\"line\">            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class=\"line\">            &#x2F;&#x2F; 自旋检查 u 位置的 Segment 是否为null</span><br><span class=\"line\">            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class=\"line\">                   &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 使用CAS 赋值，只会成功一次</span><br><span class=\"line\">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return seg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>\n<ol>\n<li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>\n</li>\n<li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p>\n<p><strong>初始化 Segment 流程：</strong></p>\n<ol>\n<li>检查计算得到的位置的 Segment 是否为null.</li>\n<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>\n<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>\n<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>\n<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>\n</ol>\n</li>\n<li><p>Segment.put 插入 key,value 值。</p>\n</li>\n</ol>\n<p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br><span class=\"line\">    V oldValue;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class=\"line\">        &#x2F;&#x2F; 计算要put的数据位置</span><br><span class=\"line\">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class=\"line\">        &#x2F;&#x2F; CAS 获取 index 坐标的值</span><br><span class=\"line\">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class=\"line\">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class=\"line\">            if (e !&#x3D; null) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br><span class=\"line\">                K k;</span><br><span class=\"line\">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class=\"line\">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class=\"line\">                    oldValue &#x3D; e.value;</span><br><span class=\"line\">                    if (!onlyIfAbsent) &#123;</span><br><span class=\"line\">                        e.value &#x3D; value;</span><br><span class=\"line\">                        ++modCount;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                e &#x3D; e.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br><span class=\"line\">                if (node !&#x3D; null)</span><br><span class=\"line\">                    node.setNext(first);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class=\"line\">                int c &#x3D; count + 1;</span><br><span class=\"line\">                &#x2F;&#x2F; 容量大于扩容阀值，小于最大容量，进行扩容</span><br><span class=\"line\">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">                    rehash(node);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    &#x2F;&#x2F; index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br><span class=\"line\">                    setEntryAt(tab, index, node);</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                count &#x3D; c;</span><br><span class=\"line\">                oldValue &#x3D; null;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>\n<ol>\n<li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p>\n</li>\n<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p>\n</li>\n<li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>\n<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>\n<ol>\n<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>\n<li>直接头插法插入。</li>\n</ol>\n<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>\n<ol>\n<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>\n<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>\n<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>\n<li>直接链表头插法插入。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>\n</li>\n</ol>\n<p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node &#x3D; null;</span><br><span class=\"line\">    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node</span><br><span class=\"line\">    &#x2F;&#x2F; 自旋获取锁</span><br><span class=\"line\">    while (!tryLock()) &#123;</span><br><span class=\"line\">        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below</span><br><span class=\"line\">        if (retries &lt; 0) &#123;</span><br><span class=\"line\">            if (e &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node</span><br><span class=\"line\">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class=\"line\">                retries &#x3D; 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (key.equals(e.key))</span><br><span class=\"line\">                retries &#x3D; 0;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                e &#x3D; e.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 自旋达到指定次数后，阻塞等到只到获取到锁</span><br><span class=\"line\">            lock();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;</span><br><span class=\"line\">            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed</span><br><span class=\"line\">            retries &#x3D; -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-扩容-rehash\"><a href=\"#4-扩容-rehash\" class=\"headerlink\" title=\"4. 扩容 rehash\"></a>4. 扩容 rehash</h3><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class=\"line\">    &#x2F;&#x2F; 老容量</span><br><span class=\"line\">    int oldCapacity &#x3D; oldTable.length;</span><br><span class=\"line\">    &#x2F;&#x2F; 新容量，扩大两倍</span><br><span class=\"line\">    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;</span><br><span class=\"line\">    &#x2F;&#x2F; 新的扩容阀值 </span><br><span class=\"line\">    threshold &#x3D; (int)(newCapacity * loadFactor);</span><br><span class=\"line\">    &#x2F;&#x2F; 创建新的数组</span><br><span class=\"line\">    HashEntry&lt;K,V&gt;[] newTable &#x3D; (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class=\"line\">    &#x2F;&#x2F; 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br><span class=\"line\">    int sizeMask &#x3D; newCapacity - 1;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 遍历老数组</span><br><span class=\"line\">        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class=\"line\">        if (e !&#x3D; null) &#123;</span><br><span class=\"line\">            HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class=\"line\">            &#x2F;&#x2F; 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span><br><span class=\"line\">            int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class=\"line\">            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F;  Single node on list</span><br><span class=\"line\">                &#x2F;&#x2F; 如果当前位置还不是链表，只是一个元素，直接赋值</span><br><span class=\"line\">                newTable[idx] &#x3D; e;</span><br><span class=\"line\">            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot</span><br><span class=\"line\">                &#x2F;&#x2F; 如果是链表了</span><br><span class=\"line\">                HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class=\"line\">                int lastIdx &#x3D; idx;</span><br><span class=\"line\">                &#x2F;&#x2F; 新的位置只可能是不便或者是老的位置+老的容量。</span><br><span class=\"line\">                &#x2F;&#x2F; 遍历结束后，lastRun 后面的元素位置都是相同的</span><br><span class=\"line\">                for (HashEntry&lt;K,V&gt; last &#x3D; next; last !&#x3D; null; last &#x3D; last.next) &#123;</span><br><span class=\"line\">                    int k &#x3D; last.hash &amp; sizeMask;</span><br><span class=\"line\">                    if (k !&#x3D; lastIdx) &#123;</span><br><span class=\"line\">                        lastIdx &#x3D; k;</span><br><span class=\"line\">                        lastRun &#x3D; last;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#x2F;&#x2F; ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br><span class=\"line\">                newTable[lastIdx] &#x3D; lastRun;</span><br><span class=\"line\">                &#x2F;&#x2F; Clone remaining nodes</span><br><span class=\"line\">                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class=\"line\">                    &#x2F;&#x2F; 遍历剩余元素，头插法到指定 k 位置。</span><br><span class=\"line\">                    V v &#x3D; p.value;</span><br><span class=\"line\">                    int h &#x3D; p.hash;</span><br><span class=\"line\">                    int k &#x3D; h &amp; sizeMask;</span><br><span class=\"line\">                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class=\"line\">                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 头插法插入新的节点</span><br><span class=\"line\">    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node</span><br><span class=\"line\">    node.setNext(newTable[nodeIndex]);</span><br><span class=\"line\">    newTable[nodeIndex] &#x3D; node;</span><br><span class=\"line\">    table &#x3D; newTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>\n<h3 id=\"5-get\"><a href=\"#5-get\" class=\"headerlink\" title=\"5. get\"></a>5. get</h3><p>到这里就很简单了，get 方法只需要两步即可。</p>\n<ol>\n<li>计算得到 key 的存放位置。</li>\n<li>遍历指定位置查找相同 key 的 value 值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class=\"line\">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    int h &#x3D; hash(key);</span><br><span class=\"line\">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class=\"line\">    &#x2F;&#x2F; 计算得到 key 的存放位置</span><br><span class=\"line\">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class=\"line\">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class=\"line\">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class=\"line\">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class=\"line\">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 如果是链表，遍历查找到相同 key 的 value。</span><br><span class=\"line\">            K k;</span><br><span class=\"line\">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class=\"line\">                return e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JDK1-8\"><a href=\"#JDK1-8\" class=\"headerlink\" title=\"JDK1.8\"></a>JDK1.8</h2><h3 id=\"1-存储结构-1\"><a href=\"#1-存储结构-1\" class=\"headerlink\" title=\"1. 存储结构\"></a>1. 存储结构</h3><p><img data-src=\"https://i.loli.net/2020/11/17/54tSzRX2UGPLWOk.png\" loading=\"lazy\"></p>\n<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>\n<h3 id=\"2-初始化-initTable\"><a href=\"#2-初始化-initTable\" class=\"headerlink\" title=\"2. 初始化 initTable\"></a>2. 初始化 initTable</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class=\"line\">    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        ／／　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br><span class=\"line\">        if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class=\"line\">            &#x2F;&#x2F; 让出 CPU 使用权</span><br><span class=\"line\">            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class=\"line\">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table &#x3D; tab &#x3D; nt;</span><br><span class=\"line\">                    sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                sizeCtl &#x3D; sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>\n<ol>\n<li>-1 说明正在初始化</li>\n<li>-N 说明有N-1个线程正在进行扩容</li>\n<li>表示 table 初始化大小，如果 table 没有初始化</li>\n<li>表示 table 容量，如果 table　已经初始化。</li>\n</ol>\n<h3 id=\"3-put-1\"><a href=\"#3-put-1\" class=\"headerlink\" title=\"3. put\"></a>3. put</h3><p>直接过一遍 put 源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    return putVal(key, value, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class=\"line\">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; key 和 value 不能为空</span><br><span class=\"line\">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class=\"line\">    int hash &#x3D; spread(key.hashCode());</span><br><span class=\"line\">    int binCount &#x3D; 0;</span><br><span class=\"line\">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; f &#x3D; 目标位置元素</span><br><span class=\"line\">        Node&lt;K,V&gt; f; int n, i, fh;&#x2F;&#x2F; fh 后面存放目标位置的元素 hash 值</span><br><span class=\"line\">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class=\"line\">            &#x2F;&#x2F; 数组桶为空，初始化数组桶（自旋+CAS)</span><br><span class=\"line\">            tab &#x3D; initTable();</span><br><span class=\"line\">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br><span class=\"line\">            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class=\"line\">                break;  &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class=\"line\">            tab &#x3D; helpTransfer(tab, f);</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            V oldVal &#x3D; null;</span><br><span class=\"line\">            &#x2F;&#x2F; 使用 synchronized 加锁加入节点</span><br><span class=\"line\">            synchronized (f) &#123;</span><br><span class=\"line\">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class=\"line\">                    &#x2F;&#x2F; 说明是链表</span><br><span class=\"line\">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">                        binCount &#x3D; 1;</span><br><span class=\"line\">                        &#x2F;&#x2F; 循环加入新的或者覆盖节点</span><br><span class=\"line\">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class=\"line\">                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal &#x3D; e.val;</span><br><span class=\"line\">                                if (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val &#x3D; value;</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class=\"line\">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, null);</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (f instanceof TreeBin) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; 红黑树</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount &#x3D; 2;</span><br><span class=\"line\">                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) !&#x3D; null) &#123;</span><br><span class=\"line\">                            oldVal &#x3D; p.val;</span><br><span class=\"line\">                            if (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val &#x3D; value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (binCount !&#x3D; 0) &#123;</span><br><span class=\"line\">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                if (oldVal !&#x3D; null)</span><br><span class=\"line\">                    return oldVal;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(1L, binCount);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>根据 key 计算出 hashcode 。</li>\n<li>判断是否需要进行初始化。</li>\n<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>\n<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>\n<li>如果都不满足，则利用 synchronized 锁写入数据。</li>\n<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>\n</ol>\n<h3 id=\"4-get\"><a href=\"#4-get\" class=\"headerlink\" title=\"4. get\"></a>4. get</h3><p>get 流程比较简单，直接过一遍源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class=\"line\">    &#x2F;&#x2F; key 所在的 hash 位置</span><br><span class=\"line\">    int h &#x3D; spread(key.hashCode());</span><br><span class=\"line\">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class=\"line\">        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 如果指定位置元素存在，头结点hash值相同</span><br><span class=\"line\">        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class=\"line\">            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                &#x2F;&#x2F; key hash 值相等，key值相同，直接返回元素 value</span><br><span class=\"line\">                return e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (eh &lt; 0)</span><br><span class=\"line\">            &#x2F;&#x2F; 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span><br><span class=\"line\">            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class=\"line\">        while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 是链表，遍历查找</span><br><span class=\"line\">            if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class=\"line\">                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                return e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下 get 过程：</p>\n<ol>\n<li>根据 hash 值计算位置。</li>\n<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>\n<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>\n<li>如果是链表，遍历查找之。</li>\n</ol>\n<p>总结：</p>\n<p>总的来说 ConcruuentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><p>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>\n<p>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>\n<p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p>\n<h4 id=\"1-ConcurrentHashMap-和-Hashtable-的区别\"><a href=\"#1-ConcurrentHashMap-和-Hashtable-的区别\" class=\"headerlink\" title=\"1.ConcurrentHashMap 和 Hashtable 的区别\"></a>1.ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。底层数据结构： JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现，JDK1.8 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采⽤ 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的；实现线程安全的⽅式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和CAS 来操作。（JDK1.6以后对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。</p>\n<h4 id=\"2-synchronized关键字\"><a href=\"#2-synchronized关键字\" class=\"headerlink\" title=\"2.synchronized关键字\"></a>2.synchronized关键字</h4><p>解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p>\n<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。<strong>庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯</strong>对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。J<strong>DK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</strong></p>\n<h4 id=\"3-synchronized-关键字和-volatile-关键字区别\"><a href=\"#3-synchronized-关键字和-volatile-关键字区别\" class=\"headerlink\" title=\"3.synchronized 关键字和 volatile 关键字区别\"></a>3.synchronized 关键字和 volatile 关键字区别</h4><p>synchronized 关键字和 volatile 关键字是两个互补的存在，⽽不是对⽴的存在！</p>\n<p>volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定⽐ synchronized 关键字要好。但是volatile 关键字只能⽤于变量⽽ synchronized 关键字可以修饰⽅法以及代码块。<strong>volatile 关键字能保证数据的可⻅性，但</strong>不能保证数据的原⼦性。<strong>synchronized 关键字两者都能保证。</strong></p>\n<p>volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性</p>\n<p>⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>\n<h4 id=\"4-ConcurrentHashmap不支持key或者value为null\"><a href=\"#4-ConcurrentHashmap不支持key或者value为null\" class=\"headerlink\" title=\"4.ConcurrentHashmap不支持key或者value为null\"></a>4.ConcurrentHashmap不支持key或者value为null</h4><p>ConcurrentHashmap HashMap和Hashtable都是key-value存储结构，但他们有一个不同点是 ConcurrentHashmap、Hashtable不支持key或者value为null，而HashMap是支持的。为什么会有这个区别？在设计上的目的是什么？</p>\n<p>ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。</p>\n<p>key不能为空，因为采用了fail-safe机制，这种机制会使得读取的数据不一定是最新的，使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，HashTable同理。故在入参时，若为 null 就报空指针异常，而且在取hashcode时，压根就没考虑空的情况。</p>\n<pre><code>/** Implementation for put and putIfAbsent */\nfinal V putVal(K key, V value, boolean onlyIfAbsent) &#123;\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    ......\n&#125;</code></pre>\n","categories":["集合"],"tags":["JUC"]},{"title":"Spring Boot原理（启动机制）","url":"/2020-11-18-Spring%20Boot%E5%8E%9F%E7%90%86%EF%BC%88%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%EF%BC%89.html","content":"<p>通常我们搭建一个基于spring的web应用，我们需要做以下工作：</p>\n<p>1、pom文件中引入相关jar包，包括spring、springmvc、redis、mybaits、log4j、mysql-connector-java 等等相关jar ...</p>\n<p>2、配置web.xml，Listener配置、Filter配置、Servlet配置、log4j配置、error配置 ...</p>\n<p>3、配置数据库连接、配置spring事务</p>\n<p>4、配置视图解析器</p>\n<p>5、开启注解、自动扫描功能</p>\n<p>6、配置完成后部署tomcat、启动调试</p>\n<p>......</p>\n<p>搭个初始项目不一会就一个小时甚至半天过去了。而用springboot后，一切都变得很简便快速。下来我们来一步步分析springboot的起步依赖与自动配置这两个核心原理。</p>\n<h3 id=\"启动依赖：\"><a href=\"#启动依赖：\" class=\"headerlink\" title=\"启动依赖：\"></a>启动依赖：</h3><p>在springboot中我们只需要引入下面简单的几步就可以完成一个ssm后台项目的初始搭建。</p>\n<p>1、引入jar</p>\n<ul>\n<li>spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，</li>\n<li>mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。</li>\n<li>spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。</li>\n</ul>\n<p>2、配置数据源（yml文件）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">     url: jdbc:mysql:<span class=\"comment\">//127.0.0.1:3306/mybatis_test</span></span><br><span class=\"line\">     username: root</span><br><span class=\"line\">     password: root</span><br><span class=\"line\">     driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\">     type: com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">     dbcp2:</span><br><span class=\"line\">       min-idle: <span class=\"number\">5</span></span><br><span class=\"line\">       initial-size: <span class=\"number\">5</span></span><br><span class=\"line\">       max-total: <span class=\"number\">5</span></span><br><span class=\"line\">       max-wait-millis: <span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n\n<p>stater机制帮我们完成了项目起步所需要的的相关jar包。那问题又来了，传统的spring应用中不是要在application.xml中配置很多bean的吗，比如dataSource的配置，transactionManager（事务管理器）的配置 ... springboot是如何帮我们完成这些bean的配置的？下面我们来分析这个过程</p>\n<h3 id=\"自动配置\"><a href=\"#自动配置\" class=\"headerlink\" title=\"自动配置\"></a>自动配置</h3><h4 id=\"基于java代码的bean配置\"><a href=\"#基于java代码的bean配置\" class=\"headerlink\" title=\"基于java代码的bean配置\"></a>基于java代码的bean配置</h4><p>以<strong>mybatis</strong>为例，我们发下mybatis-spring-boot-starter这个包帮我们引入了mybatis-spring-boot-autoconfigure这个包，里面有<strong>MybatisAutoConfiguration</strong>这个类，打开这个类看看有什么东西。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@org</span>.springframework.context.annotation.Configuration</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnBean(DataSource.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(MybatisProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MybatisProperties properties;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Interceptor[] interceptors;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ResourceLoader resourceLoader;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DatabaseIdProvider databaseIdProvider;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ConfigurationCustomizer&gt; configurationCustomizers;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MybatisAutoConfiguration</span><span class=\"params\">(MybatisProperties properties,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  ResourceLoader resourceLoader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.properties = properties;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.interceptors = interceptorsProvider.getIfAvailable();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resourceLoader = resourceLoader;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.databaseIdProvider = databaseIdProvider.getIfAvailable();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkConfigFileExists</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(<span class=\"keyword\">this</span>.properties.getConfigLocation())) &#123;</span><br><span class=\"line\">      Resource resource = <span class=\"keyword\">this</span>.resourceLoader.getResource(<span class=\"keyword\">this</span>.properties.getConfigLocation());</span><br><span class=\"line\">      Assert.state(resource.exists(), <span class=\"string\">&quot;Cannot find config location: &quot;</span> + resource</span><br><span class=\"line\">          + <span class=\"string\">&quot; (please add config file or check your Mybatis configuration)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    SqlSessionFactoryBean factory = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">sqlSessionTemplate</span><span class=\"params\">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorType executorType = <span class=\"keyword\">this</span>.properties.getExecutorType();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executorType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>里面主要就是这两个注解 @Configuration、@Bean</p>\n<p>@Configuration、@Bean这两个注解一起使用就可以创建一个基于java代码的配置类，可以用来替代相应的xml配置文件。</p>\n<p>@Configuration注解的类可以看作是能<strong>生产让Spring IoC容器管理的Bean实例的工厂。</strong></p>\n<p>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到spring容器中。</p>\n<p><strong>传统的基于xml的bean配置方法如下：</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;beans&gt;  </span><br><span class=\"line\">    &lt;bean id = <span class=\"string\">&quot;car&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;com.itpsc.Car&quot;</span>&gt;  </span><br><span class=\"line\">        &lt;property name=&quot;wheel&quot; ref = &quot;wheel&quot;&gt;&lt;/property&gt;  </span><br><span class=\"line\">    &lt;/bean&gt;  </span><br><span class=\"line\">    &lt;bean id = &quot;wheel&quot; class=&quot;com.itpsc.Wheel&quot;&gt;&lt;/bean&gt;  </span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>相当于用基于java代码的配置方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Conf</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Car <span class=\"title\">car</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        Car car = <span class=\"keyword\">new</span> Car();  </span><br><span class=\"line\">        car.setWheel(wheel());  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> car;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Wheel <span class=\"title\">wheel</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Wheel();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以上面的MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。</p>\n<h4 id=\"自动配置条件依赖\"><a href=\"#自动配置条件依赖\" class=\"headerlink\" title=\"自动配置条件依赖\"></a>自动配置条件依赖</h4><p>从MybatisAutoConfiguration这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span><br><span class=\"line\">@ConditionalOnBean(&#123;DataSource.class&#125;)</span><br><span class=\"line\">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span><br><span class=\"line\">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class=\"line\">public class MybatisAutoConfiguration &#123;</span><br><span class=\"line\">//....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些是springboot特有的，常见的条件依赖注解有：</p>\n<ul>\n<li>@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。</li>\n<li>@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。</li>\n<li>@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。</li>\n<li>@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。</li>\n<li>@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。</li>\n<li>@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。</li>\n<li>@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。</li>\n<li>@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。</li>\n</ul>\n<p>所以要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。</p>\n<p>进入DataSourceAutoConfiguration这个类，可以看到这个类属于这个包：org.springframework.boot.autoconfigure.jdbc</p>\n<p>这个包又属于spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包，自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。很多包需要我们引入相应jar后自动配置才生效。</p>\n<h4 id=\"bean参数获取\"><a href=\"#bean参数获取\" class=\"headerlink\" title=\"bean参数获取\"></a><strong>bean参数获取</strong></h4><p>到此我们已经知道了bean的配置过程，但是还没有看到springboot是如何读取yml或者properites配置文件的的属性来创建数据源的？</p>\n<p>在DataSourceAutoConfiguration类里面，我们注意到使用了EnableConfigurationProperties这个注解。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Configuration(proxyBeanMethods = false)</span><br><span class=\"line\">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span><br><span class=\"line\">@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)</span><br><span class=\"line\">@EnableConfigurationProperties(DataSourceProperties.class)</span><br><span class=\"line\">@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</span><br><span class=\"line\">public class DataSourceAutoConfiguration &#123;</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DataSourceProperties中封装了数据源的各个属性，且使用了注解ConfigurationProperties指定了配置文件的前缀。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceProperties</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanClassLoaderAware</span>, <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassLoader classLoader;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> generateUniqueName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String driverClassName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jndiName;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>@EnableConfigurationProperties与@ConfigurationProperties这两个注解又有什么用呢？</strong></p>\n<p>@ConfigurationProperties注解的作用是把yml或者properties配置文件转化为bean。</p>\n<p>@EnableConfigurationProperties注解的作用是使@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。</p>\n<p><strong>通过这种方式，把yml或者properties配置参数转化为bean，这些bean又是如何被发现与加载的？</strong></p>\n<h4 id=\"bean发现\"><a href=\"#bean发现\" class=\"headerlink\" title=\"bean发现\"></a>bean发现</h4><p>springboot默认扫描启动类所在的包下的主类与子类的所有组件，但并没有包括依赖包的中的类，那么依赖包中的bean是如何被发现和加载的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class=\"line\">\tString[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class=\"line\">\tString[] scanBasePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] scanBasePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@AliasFor(annotation = ComponentScan.class, attribute = &quot;nameGenerator&quot;)</span></span><br><span class=\"line\">\tClass&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class=\"keyword\">default</span> BeanNameGenerator.class;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@AliasFor(annotation = Configuration.class)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">proxyBeanethods</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">true</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>我们通常在启动类中加@SpringBootApplication这个注解</strong></p>\n<p>实际上重要的只有三个Annotation（注解）：</p>\n<ul>\n<li>@Configuration（@SpringBootConfiguration里面还是应用了@Configuration）</li>\n<li>@EnableAutoConfiguration</li>\n<li>@ComponentScan</li>\n</ul>\n<p>@Configuration的作用上面我们已经知道了，被注解的类将成为一个bean配置类。</p>\n<p>@ComponentScan的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。</p>\n<p>@EnableAutoConfiguration 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString ENABLED_OVERRIDE_PROPERTY = <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\">\tClass&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">\tString[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@EnableAutoConfiguration注解引入了@AutoConfigurationPackage和@Import这两个注解。</p>\n<p>@AutoConfigurationPackage的作用就是自动配置的包，@Import导入需要自动配置的组件。</p>\n<p>进入@AutoConfigurationPackage，发现也是引入了@Import注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> AutoConfigurationPackage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tString[] basePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">\tClass&lt;?&gt;[] basePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Registrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span>, <span class=\"title\">DeterminableImports</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">\t\t\tregister(registry, <span class=\"keyword\">new</span> PackageImports(metadata).getPackageNames().toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title\">determineImports</span><span class=\"params\">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Collections.singleton(<span class=\"keyword\">new</span> PackageImports(metadata));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>new PackageImports(metadata).getPackageNames().toArray(new String[0])</p>\n<p>new PackageImports(metadata)</p>\n<p>这两句代码的作用就是加载启动类所在的包下的主类与子类的所有组件注册到spring容器，这就是前文所说的springboot默认扫描启动类所在的包下的主类与子类的所有组件。</p>\n<p><strong>那问题又来了，要搜集并注册到spring容器的那些beans来自哪里？</strong></p>\n<p>进入 AutoConfigurationImportSelector类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoConfigurationImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">DeferredImportSelector</span>, <span class=\"title\">BeanClassLoaderAware</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t<span class=\"title\">ResourceLoaderAware</span>, <span class=\"title\">BeanFactoryAware</span>, <span class=\"title\">EnvironmentAware</span>, <span class=\"title\">Ordered</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class=\"keyword\">new</span> AutoConfigurationEntry()</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] NO_IMPORTS = &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(AutoConfigurationImportSelector.class);</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE = <span class=\"string\">&quot;spring.autoconfigure.exclude&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Environment environment;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ClassLoader beanClassLoader;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ResourceLoader resourceLoader;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ConfigurationClassFilter configurationClassFilter;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class=\"line\">\t\t\t\tgetBeanClassLoader());<span class=\"comment\">//调用</span></span><br><span class=\"line\">\t\tAssert.notEmpty(configurations, <span class=\"string\">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class=\"line\">\t\t\t\t+ <span class=\"string\">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> EnableAutoConfiguration.class;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;AutoConfigurationImportFilter&gt; <span class=\"title\">getAutoConfigurationImportFilters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, <span class=\"keyword\">this</span>.beanClassLoader);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;AutoConfigurationImportListener&gt; <span class=\"title\">getAutoConfigurationImportListeners</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class, <span class=\"keyword\">this</span>.beanClassLoader);</span><br><span class=\"line\">\t&#125;        </span><br></pre></td></tr></table></figure>\n\n<p>SpringFactoriesLoader.loadFactoryNames方法调用loadSpringFactories方法从所有的jar包中读取META-INF/spring.factories文件信息。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class=\"line\">       Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           HashMap result = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               Enumeration urls = classLoader.getResources(<span class=\"string\">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">while</span>(urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                   URL url = (URL)urls.nextElement();</span><br><span class=\"line\">                   UrlResource resource = <span class=\"keyword\">new</span> UrlResource(url);</span><br><span class=\"line\">                   Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class=\"line\">                   Iterator var6 = properties.entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">while</span>(var6.hasNext()) &#123;</span><br><span class=\"line\">                       Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class=\"line\">                       String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class=\"line\">                       String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class=\"line\">                       String[] var10 = factoryImplementationNames;</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> var11 = factoryImplementationNames.length;</span><br><span class=\"line\"></span><br><span class=\"line\">                       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var12 = <span class=\"number\">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class=\"line\">                           String factoryImplementationName = var10[var12];</span><br><span class=\"line\">                           ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; &#123;</span><br><span class=\"line\">                               <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">                           &#125;)).add(factoryImplementationName.trim());</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               result.replaceAll((factoryType, implementations) -&gt; &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               cache.put(classLoader, result);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (IOException var14) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var14);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>下面是spring-boot-autoconfigure这个jar中spring.factories文件部分内容，其中有一个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值定义了需要自动配置的bean，通过读取这个配置获取一组@Configuration类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class=\"line\"></span><br><span class=\"line\"># Auto Configuration Import Filters</span><br><span class=\"line\">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><br><span class=\"line\"></span><br><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\</span><br></pre></td></tr></table></figure>\n\n<p>每个xxxAutoConfiguration都是一个基于java的bean配置类。实际上，这些xxxAutoConfiguratio不是所有都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private static &lt;T&gt; T instantiateFactory(String instanceClassName, Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Class ex &#x3D; ClassUtils.forName(instanceClassName, classLoader);</span><br><span class=\"line\">            if(!factoryClass.isAssignableFrom(ex)) &#123;</span><br><span class=\"line\">                throw new IllegalArgumentException(&quot;Class [&quot; + instanceClassName + &quot;] is not assignable to [&quot; + factoryClass.getName() + &quot;]&quot;);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return ReflectionUtils.accessibleConstructor(ex, new Class[0]).newInstance(new Object[0]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Throwable var4) &#123;</span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Unable to instantiate factory class: &quot; + factoryClass.getName(), var4);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p> 如上代码段，通过反射机制将spring.factories中@Configuration类实例化为对应的java实列。到此我们已经知道怎么发现要自动配置的bean了，最后一步就是怎么样将这些bean加载到spring容器。</p>\n<h4 id=\"bean加载\"><a href=\"#bean加载\" class=\"headerlink\" title=\"bean加载\"></a>bean加载</h4><p>如果要让一个普通类交给Spring容器管理，通常有以下方法：</p>\n<p>1、使用 @Configuration与@Bean 注解</p>\n<p>2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描</p>\n<p>3、使用@Import 方法</p>\n<p>springboot中使用了@Import 方法</p>\n<p>@EnableAutoConfiguration注解中使用了@Import({AutoConfigurationImportSelector.class})注解，AutoConfigurationImportSelector实现了DeferredImportSelector接口，</p>\n<p>DeferredImportSelector接口继承了ImportSelector接口，ImportSelector接口有一个selectImports方法。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoConfigurationImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">DeferredImportSelector</span>, <span class=\"title\">BeanClassLoaderAware</span>,</span></span><br><span class=\"line\"><span class=\"class\">\t\t<span class=\"title\">ResourceLoaderAware</span>, <span class=\"title\">BeanFactoryAware</span>, <span class=\"title\">EnvironmentAware</span>, <span class=\"title\">Ordered</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> NO_IMPORTS;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tAutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">           ...</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DeferredImportSelector</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImportSelector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span> Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Group</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ImportSelector</span> </span>&#123;</span><br><span class=\"line\">    String[] selectImports(AnnotationMetadata var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Predicate&lt;String&gt; <span class=\"title\">getExclusionFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 我们先通过一个简单例子看看@Import注解是如何将bean导入到spring容器的。</p>\n<p>1、新建一个bean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class User &#123;</span><br><span class=\"line\">    private Long id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String password;</span><br><span class=\"line\">private String phone;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、创建一个ItpscSelector类继承ImportSelector接口并实现selectImports方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ItpscSelector implements ImportSelector &#123;</span><br><span class=\"line\">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class=\"line\">        return new String[]&#123;&quot;com.itpsc.entity.User&quot;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、创建ImportConfig类，使用@Configuration、@Import(ItpscSelector.class)注解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@Import(ItpscSelector.class)</span><br><span class=\"line\">public class ImportConfig &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、从容器获取bean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringRunner.class)</span><br><span class=\"line\">@SpringBootTest</span><br><span class=\"line\">public class ImportSelectorTests &#123;</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testSelectImport() &#123;</span><br><span class=\"line\">        ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(ImportConfig.class);</span><br><span class=\"line\">        String[] beanDefinitionNames &#x3D; ctx.getBeanDefinitionNames();</span><br><span class=\"line\">        for (String name : beanDefinitionNames) &#123;</span><br><span class=\"line\">            System.out.println(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class=\"line\">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class=\"line\">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class=\"line\">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class=\"line\">org.springframework.context.event.internalEventListenerProcessor</span><br><span class=\"line\">org.springframework.context.event.internalEventListenerFactory</span><br><span class=\"line\">importConfig</span><br><span class=\"line\">com.itpsc.entity.User</span><br></pre></td></tr></table></figure>\n\n<p>很直观，selectImports方法返回一组bean，@EnableAutoConfiguration注解借助@Import注解将这组bean注入到spring容器中，springboot正是通过这种机制来完成bean的注入的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>我们可以将自动配置的关键几步以及相应的注解总结如下：</p>\n<p>1、@Configuration与@Bean-&gt;基于java代码的bean配置</p>\n<p>2、@Conditional-&gt;设置自动配置条件依赖</p>\n<p>3、@EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。</p>\n<p>4、@EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。</p>\n","categories":["框架"],"tags":["Spring"]},{"title":"某米一面视频面","url":"/2020-11-19-%E6%9F%90%E7%B1%B3%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91%E9%9D%A2.html","content":"<p>某米面试</p>\n<p>视频面：</p>\n<p>面试官网很卡，用的牛客视频面，上来就是两个算法题</p>\n<p>然后介绍自己的项目，说说项目的难点及解决方案</p>\n<p>讲一下Spring架构</p>\n<p>面试官在面试过程中一再说明基础很重要，并且要有解决难点的能力，求支</p>\n<p>多线程并发用到了哪种方式，线程之间的通信、同步一般怎么做</p>\n<p>线程和进程通讯的区别</p>\n<p>ArrayList、LinkedLIst区别</p>\n<p>设计模式：观察者</p>\n<p>堆、栈的区别</p>\n<h3 id=\"1-讲一下Spring架构\"><a href=\"#1-讲一下Spring架构\" class=\"headerlink\" title=\"1.讲一下Spring架构\"></a>1.讲一下Spring架构</h3><p>轻量<br>框架的大小和运行开销都是轻量级的<br>Spring是非侵入式框架：应用中的对象不依赖于Spring框架中的类。</p>\n<p>控制反转<br>通过IOC容器实现控制反转促进松耦合<br>将依赖关系的管理从Java对象中解放出来,交给IOC容器完成,实现对象之间的关系解耦<br>将原来对象-对象的个关系,转化为对象-IOC容器-对象的关系<br>依赖对象会被动的由容器实现装载，不需要对象自己完成创建</p>\n<p>面向切面<br>通过AOP,以动态和非侵入式的方式来增强服务功能<br>应用的业务逻辑与系统级服务相分离,提高内聚性<br>应用对象只需实现业务逻辑即可,无需负责其他系统级关注点,例如日志和事务支持</p>\n<p>容器<br>Spring的Bean容器,包含并管理应用对象的配置和生命周期<br>如:可配置bean如何被创建(单例,原型及类之间的依赖关系)</p>\n<p>框架<br>Spring可以将简单的组件配置、组合成为复杂的应用。<br>例如:Spring中,对象可以在一个XML文件里被声明式的组合<br>例如:Spring框架下实现多个子框架的组合:<br>    这些子框架之间可以彼此独立，也可以使用其它的框架方案加以代替，<br>Spring提供了很多基础功能(如:事务管理、持久化框架集成等),而开发者只需要关注应用逻辑的开发</p>\n<p>1、Spring Core：主要组件是BeanFactory，创建JavaBean的工厂，使用控制反转（IOC） 模式，将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>\n<p>2、Spring AOP：集成了面向切面的编程功能（AOP把一个业务流程分成几部分，例如权限检查、业务处理、日志记录，每个部分单独处理，然后把它们组装成完整的业务流程。每个部分被称为切面），可以将声明性事物管理集成到应用程序中。</p>\n<p>3、Spring context：一个核心配置文件，为Spring框架提供上下文信息。</p>\n<p>4、Spring dao：Spring操作数据库的模块。</p>\n<p>5、Spring ORM：Spring集成了各种orm（object relationship mapping 对象关系映射）框架的模块，集成mybatis</p>\n<p>6、Spring web：集成各种优秀的web层框架的模块（Struts、Springmvc）</p>\n<p>7、Spring web mvc：Spring web层框架</p>\n<h3 id=\"2-进程之间的通信\"><a href=\"#2-进程之间的通信\" class=\"headerlink\" title=\"2.进程之间的通信\"></a>2.进程之间的通信</h3><p>进程间通信又称<code>IPC(Inter-Process Communication)</code>,指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:</p>\n<ul>\n<li>低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)</li>\n<li>高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等)。</li>\n</ul>\n<p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>\n<ol>\n<li>管道/匿名管道(Pipes) ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。</li>\n<li>有名管道(Names Pipes) : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘⽂件的⽅式存在，可以实现本机任意两个进程通信。</li>\n<li>信号(Signal) ：信号是⼀种⽐较复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；</li>\n<li>消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字 节流以及缓冲区⼤⼩受限等缺。</li>\n<li>信号量(Semaphores) ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</li>\n<li>共享内存(Shared memory) ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。</li>\n<li>套接字(Sockets) : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持TCP/IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h3 id=\"3-线程之间的通信\"><a href=\"#3-线程之间的通信\" class=\"headerlink\" title=\"3.线程之间的通信\"></a>3.线程之间的通信</h3><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>\n<p><strong>① 锁机制</strong></p>\n<p>互斥锁、条件变量、读写锁和自旋锁。</p>\n<ul>\n<li><code>互斥锁</code>确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。</li>\n<li><code>读写锁</code>当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。</li>\n<li><code>条件变量</code>可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\n<li><code>自旋锁</code>上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。</li>\n</ul>\n<p><strong>② 信号量机制(Semaphore)</strong></p>\n<p>包括无名线程信号量和命名线程信号量。线程的信号和进程的信号量类似，使用线程的信号量可以高效地完成基于线程的资源计数。信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。</p>\n<p><strong>③ 信号机制(Signal)</strong></p>\n<p>类似进程间的信号处理。</p>\n<p><strong>④ violate全局变量-共享内存</strong></p>\n<p>关于violate可以参考博文：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQvYXJ0aWNsZS9kZXRhaWxzLzg1MzE4MDc1\">多线程并发之volatile的底层实现原理<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><strong>⑤ wait/notify</strong></p>\n<p>阻塞/唤醒，关于这个参考博文：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQvYXJ0aWNsZS9kZXRhaWxzLzUyNzAwNDEz\">Thread入门与线程方法详解及多线程安全<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<h3 id=\"4-多线程\"><a href=\"#4-多线程\" class=\"headerlink\" title=\"4.多线程\"></a>4.多线程</h3><p><strong>01知识点汇总</strong></p>\n<p><img data-src=\"https://pic2.zhimg.com/80/v2-65315ef1db4e1baa4720e095f6cca761_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>多线程协作时，因为对资源的锁定与等待会产生死锁，需要了解产生死锁的四个基本条件，要明白竞争条件与临界区的概念，知道通过破坏造成死锁的4个条件来防止死锁。</p>\n<p>除了了解进程间的通信方式，还要知道线程的通信方式，通信主要指线程之间的协作机制，例如Wait、Notify</p>\n<p>另外需要知道Java为多线程提供的一些机制，例如Threadlocal用来保存线程独享的数据，Fork/Foin机制用于大任务的分割与汇总，Volatile对多线程数据可见性的保证以及线程的中断机制。</p>\n<p>其他还有: Threadlocal的实现机制。Fork/Join的工作窃取算法等内容。</p>\n<p><strong>02</strong>知识点详解</p>\n<p><strong>1、详解-线程的状态转换</strong></p>\n<p>先介绍线程状态转换。</p>\n<p>线程是Jvm执行任务的最小单元，理解线程的状态转换是理解后续多线程问题的基础。</p>\n<p>第一个详解知识点介绍线程状态转换。</p>\n<p>在Jvm运行中，线程一共有New、Runnable、Blocked、Waiting、Timed_waiting、Terminated六种状态，这些状态对应Thread.State枚举类中的状态。</p>\n<p>当创建一个线程的时候，线程处在New状态，运行Thread的Start方法后，线程进入Runnable可运行状态。</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-78af03b97e138fb44d14ce4ce273d21a_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>这个时候，所有可运行状态的线程并不能马上运行，而是需要先进入就绪状态等待线程调度，如图中间的Ready状态。在获取到Cpu后才能进入运行状态，如图中的Running。运行状态可以随着不同条件转换成除New以外的其他状态。</p>\n<p>先看左边，在运行态中的线程进入Synchronized同步块或者同步方法时，如果获取锁失败，则会进入到Blocked状态。当获取到锁后，会从Blocked状态恢复到就绪状态。</p>\n<p>再看右边，运行中的线程还会进入等待状态，这两个等待一个是有超时时间的等待，例如调用Object.wait、Thread.join等。另外一个时无超时的等待，例如调用Thread.join或者Locksupport.park。</p>\n<p>这两种等待都可以通过Notify或Unpark结束等待状态恢复到就绪状态。</p>\n<p>最后是线程运行完成结束时，如图下方，线程状态变成Terminated</p>\n<p><strong>2、详解-CAS与ABA问题</strong></p>\n<p>解决线程同步与互斥的主要方式是Cas、Synchronized、和Lock。</p>\n<p>Cas是属于乐观锁的一种实现，是一种轻量级锁，Juc中很多工具类的实现就是基于Cas。</p>\n<p>Cas操作是线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。</p>\n<p>比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。</p>\n<p>Cas容易出现Aba问题，如果线程T1读取值A之后，发生过两次写入，先由线程T2写回了b，又由T3写回了A，此时T1在写回比较时，值还是A，就无法判断是否发生过修改。</p>\n<p>Aba问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳。Juc工具包中提供了这样的类。</p>\n<p><strong>3、详解-Synchronized</strong></p>\n<p>Synchronized是最常用的线程同步手段之一，它是如何保证同一时刻只有一个线程可以进入临界区呢？</p>\n<p>我们知道Synchronized是对对象进行加锁，在Jvm中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向Monitor对象的起始地址。当Monitor被某个线程持有后，就会处于锁定状态，Owner部分会指向持有Monitor对象的线程。另外Monitor中还有两个队列，用来存放进入及等待获取锁的线程。</p>\n<p>Synchronized应用在方法上时，在字节码中是通过方法的AccCC_Synchronized标志来实现的，Synchronized应用在同步块上时，在字节码中是通过Monitorenter和Monitorexit实现的。</p>\n<p>针对Synchronized获取锁的方式，Jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一线程再次获取锁，如果失败，就升级为Cas轻量级锁，如果再失败会短暂自旋，防止线程被系统挂起。最后如果以上都失败就是升级为重量级锁。</p>\n<p><strong>4、详解-Aqs与Lock</strong></p>\n<p>在介绍Lock前，先介绍Aqs，也就是队列同步器，这是实现Lock的基础。</p>\n<p>Aqs有一个State标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。</p>\n<p>当获得锁的线程需要等待某个条件时，会进入Condition的等待队列，等待队列可以有多个。</p>\n<p>当Condition条件满足时，线程会从等待队列重新进入到同步队列进行获取锁的竞争。</p>\n<p>Reentrantlock就是基于Aqs实现的，Reentrantlock内部有公平锁和非公平锁两种实现，差别就在于新来的线程会不会比已经在同步队列中的等待线程更早获得锁。</p>\n<p>和Reentrantlock实现方式类似，Semaphore也是基于aqs，差别在于Reentrantlock是独占锁，Semaphore是共享锁。</p>\n<p><strong>5、详解-线程池</strong></p>\n<p>线程池通过复用线程，避免线程频繁创建和销毁。</p>\n<p>Java的Executors工具类中，提供了5种类型线程池的创建方法，它们的特点和适用场景如下：</p>\n<p><strong>第1种是：固定大小线程池</strong>，特点是线程数固定，使用无界队列，适用于任务数量不均匀的场景、对内存压力不敏感，但系统负载比较敏感的场景；</p>\n<p><strong>第2种是：Cached线程池</strong>，特点是不限制线程数，适用于要求低延迟的短期任务场景；</p>\n<p><strong>第3种是：单线程线程池</strong>，也就是一个线程的固定线程池，适用于需要异步执行但需要保证任务顺序的场景；</p>\n<p><strong>第4种是：Scheduled线程池</strong>，适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式；</p>\n<p><strong>第5种是：工作窃取线程池</strong>，使用的ForkJoinPool，是固定并行度的多任务队列，适合任务执行时长不均匀的场景。</p>\n<p><strong>6、详解-线程池参数介绍</strong></p>\n<p>前面提到的线程池，除了工作窃取线程池外，都是通过ThreadPoolExecutor的不同初始化参数来创建的。</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-19cb3e86c1812d7c1d98ac7b35e72956_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>第1个参数：</strong>设置核心线程数。默认情况下核心线程会一直存活。</p>\n<p><strong>第2个参数：</strong>设置最大线程数。决定线程池最多可以创建的多少线程。</p>\n<p><strong>第3个参数和第4个参数：</strong>用来设置线程空闲时间，和空闲时间的单位，当线程闲置超过空闲时间就会被销毁。可以通过AllowCoreThreadTimeOut方法来允许核心线程被回收。</p>\n<p><strong>第5个参数：</strong>设置缓冲队列，图中左下方的三个队列是设置线程池时常使用的缓冲队列。其中Array Blocking Queue是一个有界队列，就是指队列有最大容量限制。Linked Blocking Queue是无界队列，就是队列不限制容量。最后一个是Synchronous Queue，是一个同步队列，内部没有缓冲区。</p>\n<p><strong>第6个参数：</strong>设置线程池工厂方法，线程工厂用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的Group、线程名、优先级等。一般使用默认工厂类即可。</p>\n<p><strong>第7个参数：</strong>设置线程池满时的拒绝策略。如右下角所示有四种策略，abort策略在线程池满后，提交新任务时会抛出Rejected Execution Exception，这个也是默认的拒绝策略。</p>\n<p>Discard策略会在提交失败时对任务直接进行丢弃。CallerRuns策略会在提交失败时，由提交任务的线程直接执行提交的任务。Discard Oldest策略会丢弃最早提交的任务。</p>\n<p><strong>■前面的5种线程池都是使用怎样的参数来创建的呢？</strong></p>\n<p>固定大小线程池创建时核心和最大线程数都设置成指定的线程数，这样线程池中就只会使用固定大小的线程数。队列使用无界队列Linked Blocking Queue。</p>\n<p>Single线程池就是线程数设置为1的固定线程池。Cached线程池的核心线程数设置为0，最大线程数是Integer.Max_Value，主要是通过把缓冲队列设置成SynchronousQueue，这样只要没有空闲线程就会新建。scheduled线程池与前几种不同的是使用了Delayed Work Queue，这是一种按延迟时间获取任务的优先级队列。</p>\n<p><strong>7、详解-线程池执行流程</strong></p>\n<p>我们向线程提交任务时可以使用Execute和Submit，区别就是Submit可以返回一个Future对象，通过Future对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。Submit最终也是通过Execute执行的。</p>\n<p><strong>线程池提交任务时的执行顺序如下：</strong></p>\n<p>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</p>\n<ul>\n<li>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</li>\n<li>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</li>\n<li>如果已经达到了最大线程数，则执行指定的拒绝策略。这里需要注意队列的判断与最大线程数判断的顺序，不要搞反。</li>\n</ul>\n<p><strong>8、详解-JUC工具类</strong></p>\n<p>前面基础知识部分已经提到过，Juc是Java提供的用于多线程处理的工具类库，其中的常用工具类的作用如下：</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-0eff7d812a12f5b88cfbd71652aa2222_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>第一行的类都是基本数据类型的原子类：包括Atomicboolean、Atomiclong、Atomicinteger类。</p>\n<p>AtomicLong通过Unsafe类实现，基于Cas。Unsafe类是底层工具类，Juc中很多类的底层都使用到了Unsafe包中的功能。Unsafe类提供了类似C的指针操作，提供Cas等功能。Unsafe类中的所有方法都是Native修饰的；</p>\n<p>另外Longadder等四个类是Jdk1.8中提供的更高效的操作类。LongAdder基于Cell实现，使用分段锁思想，是一种空间换时间的策略，更适合高并发场景；</p>\n<p>LongAccumulator提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。</p>\n<p>第二行中的类提供了对对象的原子读写功能，后两个类Atomic Stamped Reference和Atomic Markable Reference是用来解决我们前面提到的Abs问题，分别基于时间戳和标记位来解决。</p>\n<p><strong>9、详解-JUC2</strong></p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-be70189f84bf14ce5957080bf4903912_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>这一页表格中，第一行的类主要是锁相关的类，例如我们前面介绍过的Reentrant重入锁。<br>与Reentrant Lock的独占锁不同，Semaphore是共享锁，允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如100个车辆要使用20个停车位，那么最多允许20个车占用停车位。</p>\n<p>Stamped Lock是1.8改进的读写锁，是使用一种Clh的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。</p>\n<p>第二行中主要是异步执行相关的类，这里可以重点了解jdk1.8中提供的CompletableFuture，可以支持流式调用，可以方便的进行多Future的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便的设置完成时间。</p>\n<p>另外一个是1.7中提供的ForkJoinPool，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。ForkJoinPool的特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。</p>\n<p><strong>10、详情-JUC3</strong></p>\n<p><img data-src=\"https://pic4.zhimg.com/80/v2-251dd271af2975a82836d6c64cb26e87_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>表格中第一行是常用的阻塞队列，刚才讲解线程池时已经简单介绍过了，这里在补充一点，Linked Blocking Deque是双端队列，也就是可以分别从队头和队尾操作入队、出队。<br>而Array Blocking Queue单端队列，只能从队尾入队，队头出队。</p>\n<p>第二行是控制多线程协作时使用的类。其中Count Down Latch实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。</p>\n<p>Cyclic Barrier可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。</p>\n<p>Semaphore前面已经介绍过，用来控制对共享资源的访问并发度。</p>\n<p>最后一行是比较常用的两个集合类，可以了解一下Copy On Write ArrayList，Cow通过在写入数据时进行Copy修改，然后在更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。</p>\n<p><strong>03面试考察点</strong></p>\n<p><strong>第1点：</strong>是要理解线程的同步与互斥的原理，包括临界资源、临界区的概念，知道重量级锁、轻量级锁、自旋锁、偏向锁、重入锁、读写锁的概念。</p>\n<p><strong>第2点：</strong>要掌握线程安全相关机制，例如 Cas、Synchronized、Lock三种同步方式的实现原理、要明白Threadlocal是每个线程独享的局部变量，了解Threadlocal使用弱引用的ThreadLocalMap保存不同的Threadlocal变量。</p>\n<p><strong>第3点：</strong>要了解Juc中的工具类的使用场景与主要的几种工具类的实现原理，例如Reentrantlock，Concurrenthashmap、Longadder等实现方式</p>\n<p><strong>第4点：</strong>要熟悉线程池的原理、使用场景、常用配置，例如大量短期任务的场景适合使用Cached线程池；系统资源比较紧张时，可以选择固定线程池。</p>\n<p>另外注意慎用无界队列，可能会有Oom的风险。</p>\n<p><strong>第5点：</strong>要深刻理解线程的同步与异步、阻塞与非阻塞，同步和异步的区别是任务是否是同一个线程执行，阻塞与非阻塞的区别是异步执行任务时，线程是不是会阻塞等待结果，还是会继续执行后续逻辑。</p>\n<p><strong>04面试加分项</strong></p>\n<p>掌握了上面这些内容，如果能做到这几点加分项，一定会给面试官留下更好的印象。</p>\n<p><strong>第1点：</strong>是可以结合实际项目经验或者实际案例介绍原理，例如介绍线程池设置时，可以提到自己的项目中有一个需要高吞吐量的场景，使用了Cached的线程池。</p>\n<p><strong>第2点：</strong>如果有过解决多线程问题的经验或者排查思路的话会获得面试加分</p>\n<p><strong>第3点：</strong>能够熟悉常用的线程分析工具与方法，例如会用Jstack分析线程的运行状态，查找锁对象持有状况等</p>\n<p><strong>第4点：</strong>了解Java8对Juc工具类做了哪些增强，例如提供了Longadder来替换Atomiclong，更适合并发度比较高的场景。</p>\n<p><strong>最后，</strong>可以了解一下Reactive异步编程思想，了解Back Pressure背压的概念与应用场景。</p>\n<p>相信研究完以上内容，你会对并发与多线程有一定了解，从容准备面试，祝你拿到心仪Offer。</p>\n<h3 id=\"5-堆栈区别\"><a href=\"#5-堆栈区别\" class=\"headerlink\" title=\"5.堆栈区别\"></a>5.堆栈区别</h3><p> Java把内存划分成两种：一种是堆内存，一种是栈内存。</p>\n<p>堆：主要用于存储实例化的对象，数组。由JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以共享数据的。</p>\n<p>栈：主要用于存储局部变量和对象的引用变量，每个线程都会有一个独立的栈空间，所以线程之间是不共享数据的。</p>\n<p>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p>\n<p>堆内存用来存放由new创建的对象和数组。  在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p>\n<p>二、栈与堆的共同点和优缺点</p>\n<p>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p>\n<p>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p>\n<p>Java中的数据类型有两种。</p>\n<p>一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。</p>\n<p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。</p>\n<p>假设我们同时定义<br> int a = 3; int b = 3；<br> 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。<br> 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p>\n<p>另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显式地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p>\n<p>三、Java堆和栈的区别</p>\n<p>java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别</p>\n<p>1、各司其职<br> 最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>\n<p>2、独有还是共享<br> 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>\n<p>3、异常错误<br> 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br> 而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p>\n<p>4、空间大小<br> 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。</p>\n<p>你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。</p>\n<p>这就是Java中堆和栈的区别。理解好这个问题的话，可以对你解决开发中的问题，分析堆内存和栈内存使用，甚至性能调优都有帮助。</p>\n<p>四、JVM中的堆和栈<br> JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. 从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p>\n<p>每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程 共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。<br> Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java <img data-src=\"https://img.javatt.com/18/184543bd25712d1e8ed8fc46149fb7b5.png\" alt=\"这里写图片描述\" loading=\"lazy\"></p>\n<p>会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</p>\n","categories":["面试"],"tags":["java"]},{"title":"redis缓存中数据和数据库中数据不一致的解决办法","url":"/2020-11-24-redis%E7%BC%93%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html","content":"<h2 id=\"为什么会发生数据库和缓存数据的不一致问题。\"><a href=\"#为什么会发生数据库和缓存数据的不一致问题。\" class=\"headerlink\" title=\"为什么会发生数据库和缓存数据的不一致问题。\"></a>为什么会发生数据库和缓存数据的不一致问题。</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</p>\n<h3 id=\"1-一性是什么，一致性包含了以下两种：\"><a href=\"#1-一性是什么，一致性包含了以下两种：\" class=\"headerlink\" title=\"1. 一性是什么，一致性包含了以下两种：\"></a>1. 一性是什么，一致性包含了以下两种：</h3><ol>\n<li>缓存中有数据，那么数据库的数据必须要和缓存的数据要一致。</li>\n<li>缓存中没有数据，在数据库值必须要是最新的数据。</li>\n</ol>\n<p>不符合以上两种情况的数据就是发生了数据不一致问题，对于读写缓存来说，就会发生这样的问题，此时我们要需要相应的策略去做做同步还是异步：</p>\n<ol>\n<li>同步写回策略：就是写入缓存时，必须要写入数据库，保证数据一致性。</li>\n<li>异步写回策略：想写入缓存，等到缓存失效或者淘汰的时候，再写入数据库，此时如果还没有写入数据库，缓存就挂了，这样数据就会丢失，数据库就没有最新的值了。</li>\n</ol>\n<p>对于读写缓存来说，要想数据一致性就要采用同步写回策略，如果数据不是必要的数据，可以采用数据的异步写回策略，比如电商商品的非重要参数。<br>如果我们采用同步写回策略，就要保证写入缓存和数据的数据能到保证原子性，也就是说，缓存和数据的数据要同时增删改，一起更新或者都不更新。</p>\n<h3 id=\"2-删除数据怎么保Redis和数据库的一致性问题\"><a href=\"#2-删除数据怎么保Redis和数据库的一致性问题\" class=\"headerlink\" title=\"2. 删除数据怎么保Redis和数据库的一致性问题\"></a>2. 删除数据怎么保Redis和数据库的一致性问题</h3><p>数据删除时，先选择删除数据库还是先选择缓存。 </p>\n<h4 id=\"一、选择先删除数据库。\"><a href=\"#一、选择先删除数据库。\" class=\"headerlink\" title=\"一、选择先删除数据库。\"></a>一、选择先删除数据库。</h4><ol>\n<li>当我们删除数据的时候，先选择删除数据库，后选择删除缓存时，会在一定事件内发生数据不一致问题，比如线程A和B还有其他，A在删除数据数据的时候，B和其他线程来读取数据，这个时候，B和其他线程会读取到旧值，当A线程删除完成删除缓存后就可以消除读取旧值问题。这个会造成一小段时间内会读取到旧值。</li>\n<li>当我们删除数据的时候，先选择删除数据库，在删除缓存时，删除缓存失败了，会造成旧数据一直会读取。比如线程A和B还有其他，A在删除数据库成功了，A和其他线程删除缓存失败。就会造成B和其他线程一直在读取旧值。<strong>解决方法选择删除数据库的时候，通过消息中间件MQ或者Kafka发送一条删除指令，在数据库删除完成之后启动一个线程去删除缓存，如果删除失败一直做删除操作，一直到删除成功。</strong></li>\n</ol>\n<h4 id=\"二、选择先删除缓存。\"><a href=\"#二、选择先删除缓存。\" class=\"headerlink\" title=\"二、选择先删除缓存。\"></a>二、选择先删除缓存。</h4><ol>\n<li>当我们删除数据的时候，先选择删除缓存，后选择删除数据库，会导致缓存出问题，比如线程A和B还有其他线程，A线程删除了缓存，还没有来及删除数据库（比如网络延迟），此时B和其他线程来读取消息，会发生缓存中没有数据，就会去数据库查询数据，数据库中的值还是以前的值，这样会造成缓存被重新更新为旧值，解决方法：<strong>可以使用缓存双删，可以把线程A休眠一段时间，这个时间是B线程读取数据被把数据写到缓存中的时间，这个时间还需要开发者在测试中找到比较准确的时间，来设置这个A线程的休眠时间。</strong></li>\n<li>当我们删除数据的时候，先选择删除缓存，后选择删除数据库时删除失败了，这样会造成缓存数据一直在数据库没有被删除，导致一直读取的时旧值，<strong>这样可以通过消息中间件去操作，直到数据库更新成功，在去删除缓存，这样的实现用到了缓存双删和消息中间件。</strong></li>\n</ol>\n<h4 id=\"三，自我认为还是选择先删除数据库在去删缓存。\"><a href=\"#三，自我认为还是选择先删除数据库在去删缓存。\" class=\"headerlink\" title=\"三，自我认为还是选择先删除数据库在去删缓存。\"></a>三，自我认为还是选择先删除数据库在去删缓存。</h4><ol>\n<li> 首先如果删除缓存，缓存缺失，会给数据库带来一定的压力。</li>\n<li> 如果业务中读数据和写缓存的时间控制的不好设置，那么双删的等待时间就不好设置。</li>\n</ol>\n<h4 id=\"四，如果业务中必须要准确的数据，保证数据一致性。\"><a href=\"#四，如果业务中必须要准确的数据，保证数据一致性。\" class=\"headerlink\" title=\"四，如果业务中必须要准确的数据，保证数据一致性。\"></a>四，如果业务中必须要准确的数据，保证数据一致性。</h4><ol>\n<li>当删除数据库的值时，其他客户端短暂把并发请求暂存，等数据库删除和缓存更新之后再去发起请求，从而保证数据的一致性。这样下来并发就减小了。</li>\n</ol>\n<h3 id=\"3-添加数据怎么保证Redis和数据库的一致性问题\"><a href=\"#3-添加数据怎么保证Redis和数据库的一致性问题\" class=\"headerlink\" title=\"3. 添加数据怎么保证Redis和数据库的一致性问题\"></a>3. 添加数据怎么保证Redis和数据库的一致性问题</h3><h4 id=\"一、选择先添加数据库。\"><a href=\"#一、选择先添加数据库。\" class=\"headerlink\" title=\"一、选择先添加数据库。\"></a>一、选择先添加数据库。</h4><ol>\n<li>当把数据先添加数据库时，添加缓存的操作出了问题，下一次查询数据导致缓存中没有数据，对数据库的压力较大。</li>\n</ol>\n<h4 id=\"二、选择先添加缓存。\"><a href=\"#二、选择先添加缓存。\" class=\"headerlink\" title=\"二、选择先添加缓存。\"></a>二、选择先添加缓存。</h4><ol>\n<li>当把数据先添加缓存时，添加数据库的操作出了问题，我们可以采用Mq或Kafka消息中间件发送添加指令，直到数据添加到数据库，则结束操作。</li>\n</ol>\n<h3 id=\"4-修改数据怎么保Redis和数据库的一致性问题\"><a href=\"#4-修改数据怎么保Redis和数据库的一致性问题\" class=\"headerlink\" title=\"4. 修改数据怎么保Redis和数据库的一致性问题\"></a>4. 修改数据怎么保Redis和数据库的一致性问题</h3><h4 id=\"一-选择先更新数据库，对于读写缓存的读写并发操作\"><a href=\"#一-选择先更新数据库，对于读写缓存的读写并发操作\" class=\"headerlink\" title=\"一.选择先更新数据库，对于读写缓存的读写并发操作\"></a>一.选择先更新数据库，对于读写缓存的读写并发操作</h4><ol>\n<li>当先更新数据到新数据库时，数据库更新完毕后，在更新缓存，当缓存更新失败，会导致访问命中的缓存一直都是旧值，直到这个缓存失效或者淘汰，才能得到新的数据。</li>\n<li>比如A和B其他线程，A线程更新数据库，数据库更新数据完毕后，更新缓存，当缓存更新失败，B和其他线程就会一直读取旧值，直到此数据失效或者淘汰之后，才能读取到新的值。</li>\n</ol>\n<h4 id=\"二-选择先更新缓存，对于读写缓存的读写并发操作\"><a href=\"#二-选择先更新缓存，对于读写缓存的读写并发操作\" class=\"headerlink\" title=\"二.选择先更新缓存，对于读写缓存的读写并发操作\"></a>二.选择先更新缓存，对于读写缓存的读写并发操作</h4><ol>\n<li>当先更新数据到缓存，数据更新完毕之后，在更新数据库，此时数据库跟新失败，会导致访问命中的缓存是最新值，当数据失效或者淘汰之后再去读取数据，还是读取的数据库的旧值，这样数据就会不一致。比如A和B其他线程，A线程先去更新缓存的值时，更新数据库的值失败之后，B和其他线程读取的时最新的数据，等到数据失效，B和其他线程读取的值就是旧值。</li>\n</ol>\n<p>解决以上两种修改操作，我们可以利用消息中间件可以做到，当失败了一直等到数据一致，保证数据库能更新，和缓存数据能够写进去，和删除的效果是一致的。</p>\n<h4 id=\"三-选择先更新数据库，对于读写缓存的写写并发操作\"><a href=\"#三-选择先更新数据库，对于读写缓存的写写并发操作\" class=\"headerlink\" title=\"三.选择先更新数据库，对于读写缓存的写写并发操作\"></a>三.选择先更新数据库，对于读写缓存的写写并发操作</h4><ol>\n<li>当先更新数据到数据库时，有两个线程A和B线程时，当A线程去修改数据库，B线程也去修改数据库，B线程去修改缓存，A线程在去修改缓存，会造成数据不一致问题。</li>\n</ol>\n<h4 id=\"四-选择先更新缓存，对于读写缓存的写写并发操作\"><a href=\"#四-选择先更新缓存，对于读写缓存的写写并发操作\" class=\"headerlink\" title=\"四.选择先更新缓存，对于读写缓存的写写并发操作\"></a>四.选择先更新缓存，对于读写缓存的写写并发操作</h4><ol>\n<li>当先更新数据到缓存时，有两个线程A和B线程时，当A线程去修改缓存，B线程也去修改缓存，B线程去修改数据库，A线程在去修改数据库，会造成数据不一致问题。</li>\n</ol>\n<p>解决以上两种方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。</p>\n<p>综上使用读写缓存读写并发的时候，可以使用消息中间件来维护数据不一致问题，在读写模式下对业务造成的影响不是很大。当使用读写缓存写写并发的时候，可以使用加分布式锁来维护数据不一致问题。</p>\n<p>另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。</p>\n<h3 id=\"5-具体解决办法\"><a href=\"#5-具体解决办法\" class=\"headerlink\" title=\"5.具体解决办法\"></a>5.具体解决办法</h3><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。</p>\n<p><strong>缓存和数据库一致性解决方案</strong></p>\n<h4 id=\"第一种方案：采用延时双删策略（双淘汰策略）\"><a href=\"#第一种方案：采用延时双删策略（双淘汰策略）\" class=\"headerlink\" title=\"第一种方案：采用延时双删策略（双淘汰策略）\"></a><strong>第一种方案：采用延时双删策略（双淘汰策略）</strong></h4><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>\n<p><strong>1.具体的步骤就是：</strong></p>\n<ol>\n<li>先删除缓存</li>\n<li>再写数据库</li>\n<li>休眠（一定的时间）毫秒：</li>\n<li>再次删除缓存</li>\n</ol>\n<p><strong>2.确定休眠时间</strong></p>\n<p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保<strong>读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。</p>\n<p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p>\n<h5 id=\"3-设置缓存过期时间\"><a href=\"#3-设置缓存过期时间\" class=\"headerlink\" title=\"3.设置缓存过期时间\"></a>3.设置缓存过期时间</h5><p>从理论上来说，给<strong>缓存设置过期时间，是保证最终一致性的解决方案</strong>。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p>\n<h5 id=\"4-该方案的弊端\"><a href=\"#4-该方案的弊端\" class=\"headerlink\" title=\"4.该方案的弊端\"></a>4.该方案的弊端</h5><p>结合<strong>双删策略+缓存超时</strong>设置，这样最差的情况就是在<strong>超时时间内数据存在不一致，而且又增加了写请求的耗时</strong>。</p>\n<h4 id=\"第二种方案：异步更新缓存-基于订阅binlog的同步机制\"><a href=\"#第二种方案：异步更新缓存-基于订阅binlog的同步机制\" class=\"headerlink\" title=\"第二种方案：异步更新缓存(基于订阅binlog的同步机制)\"></a><strong>第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></h4><p><strong>技术整体思路：</strong></p>\n<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>\n<p>1）读Redis：热数据基本都在Redis</p>\n<p>2）写MySQL:增删改都是操作MySQL</p>\n<p>3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis</p>\n<p>3.1）数据操作主要分为两大块：</p>\n<ul>\n<li>一个是全量(将全部数据一次写入到redis)</li>\n</ul>\n<ul>\n<li>一个是增量（实时更新）</li>\n</ul>\n<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>\n<p>3.2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p>\n<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>\n<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>\n<p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p>\n<p>最后： 我的理解是多个线程的读或写操作都放进了队列，这样可以保证写库并且删了缓存之后再执行下一个线程的读操作，通过这种方式保证了操作的原子性，另外只要异步消息处理的足够快，那么是不会有问题的</p>\n<h3 id=\"6-推荐解决方案\"><a href=\"#6-推荐解决方案\" class=\"headerlink\" title=\"6.推荐解决方案\"></a>6.推荐解决方案</h3><h4 id=\"一-解决不一致两种方法\"><a href=\"#一-解决不一致两种方法\" class=\"headerlink\" title=\"一.解决不一致两种方法:\"></a>一.解决不一致两种方法:</h4><ol>\n<li><p>CAP理论(Cache Aside Pattern):<strong>缓存</strong>+<strong>数据库</strong>读写的模式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</span><br><span class=\"line\">2.更新的时候，先更新数据库，然后再删除缓存。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读<strong>请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"二-CAP为什么是删除缓存，而不是更新缓存\"><a href=\"#二-CAP为什么是删除缓存，而不是更新缓存\" class=\"headerlink\" title=\"二.CAP为什么是删除缓存，而不是更新缓存\"></a>二.CAP为什么是删除缓存，而不是更新缓存</h4><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p>\n<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p>\n<p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？</p>\n<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>\n<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p>\n<h4 id=\"三-CAP可能会出现上述的数据库-缓存不一致的情况\"><a href=\"#三-CAP可能会出现上述的数据库-缓存不一致的情况\" class=\"headerlink\" title=\"三.CAP可能会出现上述的数据库+缓存不一致的情况\"></a>三.CAP可能会出现上述的数据库+缓存不一致的情况</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了</p>\n<h5 id=\"解决方案如下：\"><a href=\"#解决方案如下：\" class=\"headerlink\" title=\"解决方案如下：\"></a>解决方案如下：</h5><p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。</p>\n<p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>\n<p>这里有一个<strong>优化点</strong>，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>\n<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>\n<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>\n<h5 id=\"高并发的场景下，该解决方案要注意的问题：\"><a href=\"#高并发的场景下，该解决方案要注意的问题：\" class=\"headerlink\" title=\"高并发的场景下，该解决方案要注意的问题：\"></a>高并发的场景下，该解决方案要注意的问题：</h5><ul>\n<li><p>读请求长时阻塞<br>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p>\n<p>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p>\n<p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每隔库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。</p>\n<p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p>\n<p>如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p>\n<p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p>\n</li>\n<li><p>读请求并发量过高<br>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p>\n<p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p>\n</li>\n<li><p>多服务实例部署的请求路由<br>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，<strong>都通过 Nginx 服务器路由到相同的服务实例上</strong>。<br>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p>\n</li>\n<li><p>热点商品的路由问题，导致请求的倾斜<br>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>\n</li>\n</ul>\n","categories":["redis"],"tags":["数据不一致"]},{"title":"动态规划","url":"/2020-11-07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html","content":"<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>\n<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p>\n<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>\n<h2 id=\"一、斐波那契数列\"><a href=\"#一、斐波那契数列\" class=\"headerlink\" title=\"一、斐波那契数列\"></a>一、斐波那契数列</h2><h3 id=\"1-爬楼梯\"><a href=\"#1-爬楼梯\" class=\"headerlink\" title=\"1. 爬楼梯\"></a>1. 爬楼梯</h3><ol start=\"70\">\n<li>Climbing Stairs (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>\n<p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p>\n<p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>\n<p>即dp[i] = dp[i-1] + dp[i-2]</p>\n<p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： <span class=\"number\">2</span></span><br><span class=\"line\">输出： <span class=\"number\">2</span></span><br><span class=\"line\">解释： 有两种方法可以爬到楼顶。</span><br><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"number\">1</span> 阶 + <span class=\"number\">1</span> 阶</span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"number\">2</span> 阶</span><br><span class=\"line\">    </span><br><span class=\"line\">输入： <span class=\"number\">3</span></span><br><span class=\"line\">输出： <span class=\"number\">3</span></span><br><span class=\"line\">解释： 有三种方法可以爬到楼顶。</span><br><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"number\">1</span> 阶 + <span class=\"number\">1</span> 阶 + <span class=\"number\">1</span> 阶</span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"number\">1</span> 阶 + <span class=\"number\">2</span> 阶</span><br><span class=\"line\"><span class=\"number\">3.</span>  <span class=\"number\">2</span> 阶 + <span class=\"number\">1</span> 阶    </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre2=<span class=\"number\">1</span>; <span class=\"keyword\">int</span> pre1=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur=pre2+pre1;</span><br><span class=\"line\">            pre2=pre1;</span><br><span class=\"line\">            pre1=cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-强盗抢劫\"><a href=\"#2-强盗抢劫\" class=\"headerlink\" title=\"2. 强盗抢劫\"></a>2. 强盗抢劫</h3><ol start=\"198\">\n<li>House Robber (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>\n<p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</p>\n<p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p>\n<p>dp[i]=max(dp[i-2]+dp[i],dp[i-1])</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">解释：偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">1</span>) ，然后偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">3</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">1</span> + <span class=\"number\">3</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入：[<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"number\">12</span></span><br><span class=\"line\">解释：偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">2</span>), 偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">9</span>)，接着偷窃 <span class=\"number\">5</span> 号房屋 (金额 = <span class=\"number\">1</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">2</span> + <span class=\"number\">9</span> + <span class=\"number\">1</span> = <span class=\"number\">12</span> 。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre1=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur = Math.max(pre1+nums[i],pre2);</span><br><span class=\"line\">            pre1=pre2;</span><br><span class=\"line\">            pre2=cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-强盗在环形街区抢劫\"><a href=\"#3-强盗在环形街区抢劫\" class=\"headerlink\" title=\"3. 强盗在环形街区抢劫\"></a>3. 强盗在环形街区抢劫</h3><ol start=\"213\">\n<li>House Robber II (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，第一家和最后一家是连在一起的，求最大抢劫量。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：<span class=\"number\">3</span></span><br><span class=\"line\">解释：你不能先偷窃 <span class=\"number\">1</span> 号房屋（金额 = <span class=\"number\">2</span>），然后偷窃 <span class=\"number\">3</span> 号房屋（金额 = <span class=\"number\">2</span>）, 因为他们是相邻的。</span><br><span class=\"line\">    输入：nums = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">输入：nums = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]    </span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">解释：你可以先偷窃 <span class=\"number\">1</span> 号房屋（金额 = <span class=\"number\">1</span>），然后偷窃 <span class=\"number\">3</span> 号房屋（金额 = <span class=\"number\">3</span>）。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">1</span> + <span class=\"number\">3</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：nums = [<span class=\"number\">0</span>]</span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(rob(nums, <span class=\"number\">0</span>, n - <span class=\"number\">2</span>), rob(nums, <span class=\"number\">1</span>, n - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pre2 = <span class=\"number\">0</span>, pre1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur = Math.max(pre1, pre2 + nums[i]);</span><br><span class=\"line\">        pre2 = pre1;</span><br><span class=\"line\">        pre1 = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-信件错排\"><a href=\"#4-信件错排\" class=\"headerlink\" title=\"4. 信件错排\"></a>4. 信件错排</h3><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p>\n<p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>\n<ul>\n<li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li>\n<li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li>\n</ul>\n<p>综上所述，错误装信数量方式数量为：</p>\n<h2 id=\"二、矩阵路径\"><a href=\"#二、矩阵路径\" class=\"headerlink\" title=\"二、矩阵路径\"></a>二、矩阵路径</h2><h3 id=\"1-矩阵的最小路径和\"><a href=\"#1-矩阵的最小路径和\" class=\"headerlink\" title=\"1. 矩阵的最小路径和\"></a>1. 矩阵的最小路径和</h3><ol start=\"64\">\n<li>Minimum Path Sum (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小，且每次只能<strong>向右和向下</strong>移动，也就是求从矩阵的左上角到右下角的最小路径和。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出: <span class=\"number\">7</span></span><br><span class=\"line\">解释: 因为路径 <span class=\"number\">1</span>→<span class=\"number\">3</span>→<span class=\"number\">1</span>→<span class=\"number\">1</span>→<span class=\"number\">1</span> 的总和最小。</span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<p>由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>\n<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。<strong>由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</strong></p>\n<p>创建二维数组dp，与原始网格的大小相同，dp[i][j]表示从左上角出发到 (i,j)位置的最小路径和。显然，dp[0][0]=grid[0][0]。对于dp中的其余元素，通过以下状态转移方程计算元素值。</p>\n<p>当 i&gt;0 且j=0 时，dp[i][0]=dp[i-1][0]+grid[i][0]</p>\n<p>当i=0 且 j&gt;0 时，dp[0][j]=dp[0][j-1]+grid[0][j]</p>\n<p>当 i&gt;0 且 j&gt;0 时，dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]</p>\n<p>最后得到 dp[m-1][n-1] 的值即为从网格左上角到网格右下角的最小路径和。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minPathSum</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(grid==<span class=\"keyword\">null</span> &amp;&amp; grid.length==<span class=\"number\">0</span> &amp;&amp; grid[<span class=\"number\">0</span>].length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=grid.length; <span class=\"keyword\">int</span> m=grid[<span class=\"number\">0</span>].length;<span class=\"comment\">//注意二维数组取内的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][m];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>]=dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>]+grid[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j]=dp[<span class=\"number\">0</span>][j-<span class=\"number\">1</span>]+grid[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">                dp[i][j]=Math.min(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>])+grid[i][j];</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>][m-<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-矩阵的总路径数\"><a href=\"#2-矩阵的总路径数\" class=\"headerlink\" title=\"2. 矩阵的总路径数\"></a>2. 矩阵的总路径数</h3><ol start=\"62\">\n<li>Unique Paths (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p>\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p>解释：我们令 dp[i][j] 是到达 i, j 最多路径动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]，注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>\n<p>时间复杂度：O(m*n)O(m∗n)</p>\n<p>空间复杂度：O(m * n)O(m∗n)</p>\n<p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> dp[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">             dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">             dp[<span class=\"number\">0</span>][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">                 dp[i][j]=dp[i][j-<span class=\"number\">1</span>]+dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> dp[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    <span class=\"comment\">//优化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[]= <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);<span class=\"comment\">//填充数组中的数都为1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">               dp[j]+=dp[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                        <span class=\"comment\">//相当于我们每次只需要 dp[i-1][j],dp[i][j-1],哪[4][3]举例</span></span><br><span class=\"line\">                             <span class=\"comment\">//i=1 j=1 dp[1]=1+1=2</span></span><br><span class=\"line\">                             <span class=\"comment\">//     j=2 dp[2]=1+2=3</span></span><br><span class=\"line\">                             <span class=\"comment\">//i=2 j=1 dp[1]=2+1=3</span></span><br><span class=\"line\">                             <span class=\"comment\">//    j=2 dp[2]=3+3=6</span></span><br><span class=\"line\">                             <span class=\"comment\">//i=3 j=1 dp[1]=3+1=4</span></span><br><span class=\"line\">                             <span class=\"comment\">//    j=2 dp[2]=6+4=10</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三、数组区间\"><a href=\"#三、数组区间\" class=\"headerlink\" title=\"三、数组区间\"></a>三、数组区间</h2><h3 id=\"1-数组区间和\"><a href=\"#1-数组区间和\" class=\"headerlink\" title=\"1. 数组区间和\"></a>1. 数组区间和</h3><ol start=\"303\">\n<li>Range Sum Query - Immutable (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LWltbXV0YWJsZS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LWltbXV0YWJsZS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums = [-<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">2</span>, -<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">sumRange(<span class=\"number\">0</span>, <span class=\"number\">2</span>) -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">sumRange(<span class=\"number\">2</span>, <span class=\"number\">5</span>) -&gt; -<span class=\"number\">1</span></span><br><span class=\"line\">sumRange(<span class=\"number\">0</span>, <span class=\"number\">5</span>) -&gt; -<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：本题提供了有参的构造方法和调用方法，首先我们传进一个数组，然后输入数组的下标索引（初始，结束）包括本身，如果是（0，2）那就是前三个数相加，（1，2）第二个数和第三个数相加，综上我们可以算出每个数之和，也就是前几个数之和，再详细的就是[-2, 0, 3, -5, 2, -1]中0下标总数和sum[1]=-2，sum[2]=-2+0+3=1;sum[0]=0是因为我们算（1，2）是sum[3]-sum[1]=1-（-2）=3，（sum[3]=sum[1]+sum[2]+sum[3]）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumArray</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sum[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NumArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        sum = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length+<span class=\"number\">1</span>];<span class=\"comment\">//创建一个属数组装我们传进的数组，大小+1，因为做减法，第一个-0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length+<span class=\"number\">1</span>;i++)&#123;<span class=\"comment\">//=第一个的值</span></span><br><span class=\"line\">            sum[i]=sum[i-<span class=\"number\">1</span>]+nums[i-<span class=\"number\">1</span>];<span class=\"comment\">//循环遍历出从nums数组中的前i的数之和，从1开始</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[j+<span class=\"number\">1</span>]-sum[i];<span class=\"comment\">//下标大的+1 （0，2）-&gt;(3-1)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-数组中等差递增子区间的个数\"><a href=\"#2-数组中等差递增子区间的个数\" class=\"headerlink\" title=\"2. 数组中等差递增子区间的个数\"></a>2. 数组中等差递增子区间的个数</h3><ol start=\"413\">\n<li>Arithmetic Slices (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>\n<p>如果满足条件：</p>\n<p>元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q ；函数要返回数组 A 中所有为等差数组的子数组个数。则称子数组(P, Q)为等差数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：A = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span>: <span class=\"number\">6</span>, <span class=\"keyword\">for</span> <span class=\"number\">3</span> arithmetic slices in A:</span><br><span class=\"line\"></span><br><span class=\"line\">输出：[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">\t [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\"> \t [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">\t [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">\t [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">\t [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<p>解释:</p>\n<p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>\n<p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;规律...</span><br><span class=\"line\">dp[2] &#x3D; 1</span><br><span class=\"line\">    [0, 1, 2]</span><br><span class=\"line\">dp[3] &#x3D; dp[2] + 1 &#x3D; 2</span><br><span class=\"line\">    [0, 1, 2, 3], &#x2F;&#x2F; [0, 1, 2] 之后加一个 3</span><br><span class=\"line\">    [1, 2, 3]     &#x2F;&#x2F; 新的递增子区间</span><br><span class=\"line\">dp[4] &#x3D; dp[3] + 1 &#x3D; 3</span><br><span class=\"line\">    [0, 1, 2, 3, 4], &#x2F;&#x2F; [0, 1, 2, 3] 之后加一个 4</span><br><span class=\"line\">    [1, 2, 3, 4],    &#x2F;&#x2F; [1, 2, 3] 之后加一个 4</span><br><span class=\"line\">    [2, 3, 4]        &#x2F;&#x2F; 新的递增子区间</span><br></pre></td></tr></table></figure>\n\n<p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p>\n<p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfArithmeticSlices</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A==<span class=\"keyword\">null</span> &amp;&amp; A.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;A.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[i]-A[i-<span class=\"number\">1</span>]==A[i-<span class=\"number\">1</span>]-A[i-<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">                dp[i]=dp[i-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cnt:dp)&#123;</span><br><span class=\"line\">            sum+=cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、分割整数\"><a href=\"#四、分割整数\" class=\"headerlink\" title=\"四、分割整数\"></a>四、分割整数</h2><h3 id=\"1-分割整数的最大乘积\"><a href=\"#1-分割整数的最大乘积\" class=\"headerlink\" title=\"1. 分割整数的最大乘积\"></a>1. 分割整数的最大乘积</h3><ol start=\"343\">\n<li>Integer Break (Medim)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>\n<p>解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"number\">2</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br><span class=\"line\">解释: <span class=\"number\">2</span> = <span class=\"number\">1</span> + <span class=\"number\">1</span>, <span class=\"number\">1</span> × <span class=\"number\">1</span> = <span class=\"number\">1</span>。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: <span class=\"number\">10</span></span><br><span class=\"line\">输出: <span class=\"number\">36</span></span><br><span class=\"line\">解释: <span class=\"number\">10</span> = <span class=\"number\">3</span> + <span class=\"number\">3</span> + <span class=\"number\">4</span>, <span class=\"number\">3</span> × <span class=\"number\">3</span> × <span class=\"number\">4</span> = <span class=\"number\">36</span>。</span><br></pre></td></tr></table></figure>\n\n<p>解释1：</p>\n<p>对于正整数 n，当 n ≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。</p>\n<p>创建数组 dp，其中dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。</p>\n<p>当 i ≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j&lt;i），则有以下两种方案：</p>\n<p>将 i 拆分成 j 和 i-j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 (i-j)×j；</p>\n<p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 dp[i-j]×j。</p>\n<p>因此，当 j 固定时，有 dp[i]=max(j × (i-j),j × dp[i-j])。由于 j 的取值范围是 1 到 i-1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如下：</p>\n<p>dp[<em>i</em>]=1≤<em>j</em>&lt;<em>i</em>max{max(<em>j</em>×(<em>i</em>−<em>j</em>),<em>j</em>×dp[<em>i</em>−<em>j</em>])}</p>\n<p>最终得到 dp[n] 的值即为将正整数 n 拆分成至少两个正整数的和之后，这些正整数的最大乘积。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">integerBreak</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;i;j++)&#123;   </span><br><span class=\"line\">                cnt=Math.max(cnt,Math.max((j*(i-j)),j*dp[i-j]));</span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">            dp[i]=cnt;       </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//另一种方法</span></span><br><span class=\"line\">        <span class=\"comment\">//因为4可拆分2x2 5拆分2x3 6拆分3x3 7拆分成2x2x3 8拆分3x3x2最大，所以可以把转换成</span></span><br><span class=\"line\">        <span class=\"comment\">//2和3的，尽可能的满足3，然后剩下的满足2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n-<span class=\"number\">1</span>; <span class=\"comment\">//1-&gt;0 2-&gt;1 3-&gt;2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q1=n/<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q2=n%<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q2==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)Math.pow(<span class=\"number\">3</span>,q1); </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(q2==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)(Math.pow(<span class=\"number\">3</span>,q1-<span class=\"number\">1</span>)*<span class=\"number\">4</span>);<span class=\"comment\">//7%3=1 7/3=2 3x2x2 10%3=1 10/3=3 3x3x2x2</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)(Math.pow(<span class=\"number\">3</span>,q1)*<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-按平方数来分割整数\"><a href=\"#2-按平方数来分割整数\" class=\"headerlink\" title=\"2. 按平方数来分割整数\"></a>2. 按平方数来分割整数</h3><ol start=\"279\">\n<li>Perfect Squares(Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGVyZmVjdC1zcXVhcmVzL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVyZmVjdC1zcXVhcmVzL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给你一个整数n，求他的若干个完全平方数的最少数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = <span class=\"number\">12</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: <span class=\"number\">12</span> = <span class=\"number\">4</span> + <span class=\"number\">4</span> + <span class=\"number\">4.</span></span><br><span class=\"line\"></span><br><span class=\"line\">输入: n = <span class=\"number\">13</span></span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br><span class=\"line\">解释: <span class=\"number\">13</span> = <span class=\"number\">4</span> + <span class=\"number\">9.</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<p>思路：动态规划<br>首先初始化长度为 n+1 的数组 dp，每个位置都为 0<br>如果 n 为 0，则结果为 0<br>对数组进行遍历，下标为 i，每次都将当前数字先更新为最大的结果，即 dp[i]=i，比如 i=4，最坏结果为4=1+1+1+1 即为 4 个数字<br>动态转移方程为：dp[i] = MIN(dp[i], dp[i - j * j] + 1)，i 表示当前数字，j<em>j 表示平方数<br>时间复杂度：O(n</em>sqrt(n))，sqrt 为平方根</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numSquares</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];<span class=\"comment\">// 默认初始化值都为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            dp[i]=i;<span class=\"comment\">//最坏的情况就是每次+1，不变化本值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;i-j*j&gt;=<span class=\"number\">0</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//n=5</span></span><br><span class=\"line\">                <span class=\"comment\">//i=4时，4-2*2=0 dp[4]=d[0]+1=1 </span></span><br><span class=\"line\">                <span class=\"comment\">//i=5时,5-2*2=1 dp[1]=1+0=2   &lt; 5-1*1=3 dp[3]=3</span></span><br><span class=\"line\">                <span class=\"comment\">//所以取dp[n] 最少两个我完全平方数可以构成n(n=5)</span></span><br><span class=\"line\">                dp[i]=Math.min(dp[i],dp[i-j*j]+<span class=\"number\">1</span>);<span class=\"comment\">// 动态转移方程</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-分割整数构成字母字符串\"><a href=\"#3-分割整数构成字母字符串\" class=\"headerlink\" title=\"3. 分割整数构成字母字符串\"></a>3. 分割整数构成字母字符串</h3><ol start=\"91\">\n<li>Decode Ways (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVjb2RlLXdheXMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGVjb2RlLXdheXMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：Given encoded message &quot;12&quot;, it could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>\n<p>解释：</p>\n<p>这是一题典型的动态问题，但是需要考的情况较多：<br>dp数组表示长度为i的字符可以表示的解码次数；初始化 dp[0] = 1;<br>情况讨论：<br>1.当一个数为0时，结果肯定是0；<br>2.当长度为1时，肯定是1（此处排除了0）<br>3.当字符大于等于2时的情形：</p>\n<ul>\n<li>1.当前字符为0且上一个字符为0或者当前字符为0上一个字符大于2（即012，130，301）这种情况下不能解码，返回0</li>\n<li>2.当前字符为0，那么当前字符只能与前一个字符组成组合 dp[i] = dp[i-2]</li>\n<li>3.当前字符不是0，但前一个字符是，这种情况下，该字符只能独立解码，dp[i] = dp[i-1];</li>\n<li>4.常规情况，当前字符与上一个字符的和&gt;26(直接拼成string与26比较也可)，如果大于26，那么这2字符只能一组，dp[i] = dp[i-2],否则，dp[i] = dp[i-2]+dp[i-1]</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = s.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;0&#x27;</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(i-<span class=\"number\">1</span>) == <span class=\"string\">&#x27;1&#x27;</span> || s.charAt(i-<span class=\"number\">1</span>) == <span class=\"string\">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;<span class=\"string\">&#x27;7&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断第一位为1或2的第二位小于7的，以为第一位和二位不能超过27</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s.charAt(i) == <span class=\"string\">&#x27;0&#x27;</span>) dp[i + <span class=\"number\">1</span>] = dp[i - <span class=\"number\">1</span>];<span class=\"comment\">//如果第二位为0，只能和第一位组合</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i + <span class=\"number\">1</span>] = dp[i] + dp[i - <span class=\"number\">1</span>];<span class=\"comment\">//否则</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s.charAt(i) == <span class=\"string\">&#x27;0&#x27;</span>)&#123;<span class=\"comment\">//第一位不是2或1 且第二位&gt;7</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                dp[i + <span class=\"number\">1</span>] = dp[i];<span class=\"comment\">//否则就是正常情况</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、最长递增子序列\"><a href=\"#五、最长递增子序列\" class=\"headerlink\" title=\"五、最长递增子序列\"></a>五、最长递增子序列</h2><p>已知一个序列 {S1, S2,...,Sn}，取出若干数组成新的序列 {Si1, Si2,..., Sim}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p>\n<p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p>\n<p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,...,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,..., Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。</p>\n<p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>\n<p><a href=\"https://camo.githubusercontent.com/c6b76b65c1880a507bf1cb0250456121db57a1ab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65653939346461342d306663372d343433642d616335362d6330386361663030613230342e6a7067\"><img data-src=\"https://camo.githubusercontent.com/c6b76b65c1880a507bf1cb0250456121db57a1ab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65653939346461342d306663372d343433642d616335362d6330386361663030613230342e6a7067\" alt=\"img\" loading=\"lazy\"></a></p>\n<p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p>\n<h3 id=\"1-最长递增子序列\"><a href=\"#1-最长递增子序列\" class=\"headerlink\" title=\"1. 最长递增子序列\"></a>1. 最长递增子序列</h3><ol start=\"300\">\n<li>Longest Increasing Subsequence (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n<p>解释：</p>\n<p>定义 dp[i]dp[i] 为考虑前 ii 个元素，以第 ii 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p>\n<p>我们从小到大计算 dp[] 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：<br>dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</p>\n<p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个nums[i]。由于dp[j] 代表 nums[0…j] 中以nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p>\n<p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>,<span class=\"number\">18</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span> </span><br><span class=\"line\">解释: 最长的上升子序列是 [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>]，它的长度是 <span class=\"number\">4</span>。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> max=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class=\"line\">                    max=Math.max(max,dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i]=max;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ref=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">             ref=Math.max(ref,dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-一组整数对能够构成的最长链\"><a href=\"#2-一组整数对能够构成的最长链\" class=\"headerlink\" title=\"2. 一组整数对能够构成的最长链\"></a>2. 一组整数对能够构成的最长链</h3><ol start=\"646\">\n<li>Maximum Length of Pair Chain (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1sZW5ndGgtb2YtcGFpci1jaGFpbi9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1sZW5ndGgtb2YtcGFpci1jaGFpbi9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[<span class=\"number\">1</span>,<span class=\"number\">2</span>], [<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">3</span>,<span class=\"number\">4</span>]]</span><br><span class=\"line\">Output: <span class=\"number\">2</span></span><br><span class=\"line\">Explanation: The longest chain is [<span class=\"number\">1</span>,<span class=\"number\">2</span>] -&gt; [<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<p>解释 ：</p>\n<p>在一个长度为 k，以 pairs[i] 结尾的数对链中，如果 pairs[i][1] &lt; pairs[j][0]，则将该数对加入链中，数对链长度变为 k+1。</p>\n<p>根据数对的第一个数排序所有的数对，dp[i] 存储以 pairs[i] 结尾的最长链的长度。当 i &lt; j 且 pairs[i][1] &lt; pairs[j][0] 时，扩展数对链，更新 dp[j] = max(dp[j], dp[i] + 1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLongestChain</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] pairs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pairs==<span class=\"keyword\">null</span> &amp;&amp;pairs.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(pairs,Comparator.comparingInt(o-&gt;o[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[]=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[pairs.length];</span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;pairs.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pairs[j][<span class=\"number\">1</span>]&lt;pairs[i][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                   dp[i]=Math.max(dp[i],dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// int cnt=0;</span></span><br><span class=\"line\">        <span class=\"comment\">// for(int i=0;i&lt;pairs.length;i++)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     cnt = Math.max(cnt,dp[i]);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// return cnt;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.stream(dp).max().orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-最长摆动子序列\"><a href=\"#3-最长摆动子序列\" class=\"headerlink\" title=\"3. 最长摆动子序列\"></a>3. 最长摆动子序列</h3><ol start=\"376\">\n<li>Wiggle Subsequence (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>\n<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>\n<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。使用 O(N) 时间复杂度求解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,7,4,9,2,5]</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 整个序列均为摆动序列。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class=\"line\">输出: 7</span><br><span class=\"line\">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 第一个差存在正数或负数也是摆动序列</span><br></pre></td></tr></table></figure>\n\n<p>解释：相当于只有第二个数大小第一个数、紧接着下一个数小于前一个数才算时有3个摆动序列,例如[1,7,8,9,2,1] 7&gt;1 up=2, 8&gt;7 9&gt;8 -&gt;dp=1+1=2 , 然后2&lt;9  down=up+1=2+1=3, 最后1&lt;2 down=2+1=3 ;反之一样的道理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">wiggleMaxLength</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//O(n)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> up=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> down=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//相当于只有先时第二个数大小第一个数、紧接着下一个数小于前一个数才算时有3个摆动序列</span></span><br><span class=\"line\"><span class=\"comment\">//例如[1,7,8,9,2,1] 7&gt;1 up=2,8&gt;7 9&gt;8 -&gt;dp=2 然后2&lt;9 down=up+1=2+1=3,最后1&lt;2 down=2+1=3  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;nums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                up=down+<span class=\"number\">1</span>;  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]&lt;nums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                down=up+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(up,down);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、最长公共子序列\"><a href=\"#六、最长公共子序列\" class=\"headerlink\" title=\"六、最长公共子序列\"></a>六、最长公共子序列</h2><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>\n<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p>\n<ul>\n<li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li>\n<li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li>\n</ul>\n<p>综上，最长公共子序列的状态转移方程为：</p>\n<p><img data-src=\"https://i.loli.net/2020/11/14/NHAh5oIfcDZ2aLK.png\" loading=\"lazy\"></p>\n<p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p>\n<p>与最长递增子序列相比，最长公共子序列有以下不同点：</p>\n<ul>\n<li>针对的是两个序列，求它们的最长公共子序列。</li>\n<li>在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j。</li>\n<li>在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</li>\n</ul>\n<h3 id=\"1-最长公共子序列\"><a href=\"#1-最长公共子序列\" class=\"headerlink\" title=\"1. 最长公共子序列\"></a>1. 最长公共子序列</h3><ol start=\"143\">\n<li>Longest Common Subsequence</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定两个字符串 S1 和 S2，返回这两个字符串的最长公共子序列的长度。</p>\n<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text1 = <span class=\"string\">&quot;abcde&quot;</span>, text2 = <span class=\"string\">&quot;ace&quot;</span> </span><br><span class=\"line\">输出：<span class=\"number\">3</span>  </span><br><span class=\"line\">解释：最长公共子序列是 <span class=\"string\">&quot;ace&quot;</span>，它的长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">输入：text1 = <span class=\"string\">&quot;abc&quot;</span>, text2 = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">输出：<span class=\"number\">3</span></span><br><span class=\"line\">解释：最长公共子序列是 <span class=\"string\">&quot;abc&quot;</span>，它的长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">输入：text1 = <span class=\"string\">&quot;abc&quot;</span>, text2 = <span class=\"string\">&quot;def&quot;</span></span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=text1.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=text2.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;m+<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;n+<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1.charAt(i-<span class=\"number\">1</span>)==text2.charAt(j-<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                    dp[i][j]=dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i][j]=Math.max(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、0-1-背包\"><a href=\"#七、0-1-背包\" class=\"headerlink\" title=\"七、0-1 背包\"></a>七、0-1 背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>\n<p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>\n<ul>\n<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li>\n<li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li>\n</ul>\n<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>\n<p>dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);</p>\n","categories":["算法"],"tags":["动态规划"]},{"title":"JVM垃圾回收+多线程","url":"/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html","content":"<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"一、JVM\"><a href=\"#一、JVM\" class=\"headerlink\" title=\"一、JVM\"></a>一、JVM</h2><h3 id=\"1如何判断哪些对象已经死亡了，可以回收了？\"><a href=\"#1如何判断哪些对象已经死亡了，可以回收了？\" class=\"headerlink\" title=\"1如何判断哪些对象已经死亡了，可以回收了？\"></a>1如何判断哪些对象已经死亡了，可以回收了？</h3><p><strong>1.使用引用计数法</strong></p>\n<p>给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。</p>\n<p>总结：但是原始引用计数无法解决循环引用的问题</p>\n<p><strong>2.可达性分析算法</strong></p>\n<p>这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。</p>\n<p>在Java 语言中，可作为GC Roots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>\n<li>方法区中类静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n</ul>\n<h3 id=\"2-垃圾回收算法都有哪些？\"><a href=\"#2-垃圾回收算法都有哪些？\" class=\"headerlink\" title=\"2.垃圾回收算法都有哪些？\"></a>2.垃圾回收算法都有哪些？</h3><p><strong>1.标记-清除算法</strong></p>\n<p>该算法分为“标记”和“清除”两个阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的象。它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到的。</p>\n<p>这种垃圾收集算法会带来两个明显的问题：</p>\n<ul>\n<li>效率问题</li>\n<li>空间问题（标记清除后会产生大量不连续的碎片）</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/11/06/8LZ5c9TNjwvnHRF.png\" alt=\"图片\" loading=\"lazy\"></p>\n<p><strong>2.复制算法</strong></p>\n<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。</p>\n<p>优点：解决了效率低的问题</p>\n<p>缺点：造成空间的浪费，使用一块内存，真正只使用了他的一半</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/i3vfuLBRtVydUc4.png\" loading=\"lazy\"></p>\n<p><strong>3.标记-整理（压缩）算法</strong></p>\n<p>根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，<strong>⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。</strong></p>\n<p>优点：不会造成空间问题产生大量碎片</p>\n<p>缺点：但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/GuPFaKpw6iLcV7z.png\" loading=\"lazy\"></p>\n<p><strong>4.分代收集算法</strong></p>\n<p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收呢，来看一下对象的分配有啥规律。</p>\n<p><strong>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</strong></p>\n<p>细节问题（敲黑板，咳咳）：</p>\n<p>大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/jBbFgwu3Q5yfZsR.png\" loading=\"lazy\"></p>\n<p><strong>分代收集工作原理</strong></p>\n<p><strong>1、对象在新生代的分配与回收</strong></p>\n<ol>\n<li>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</li>\n<li>当 Eden 区将满时，触发 Minor GC</li>\n<li>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间</li>\n<li>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</li>\n<li>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</li>\n</ol>\n<p><strong>2、对象何时晋升老年代</strong></p>\n<ul>\n<li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li>\n<li>年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li>\n<li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li>\n<li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li>\n</ul>\n<p><strong>3、空间分配担保</strong></p>\n<p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p>\n<p><strong>4、Stop The World</strong></p>\n<p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p>\n<p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p>\n<p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p>\n<p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p>\n<p>由于 Full GC（或Minor GC） 会影响性能，<strong>所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，</strong>这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p>\n<ul>\n<li>循环的末尾</li>\n<li>方法返回前</li>\n<li>调用方法的 call 之后</li>\n<li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li>\n</ul>\n<h3 id=\"3-垃圾收集器都有哪些？\"><a href=\"#3-垃圾收集器都有哪些？\" class=\"headerlink\" title=\"3.垃圾收集器都有哪些？\"></a>3.垃圾收集器都有哪些？</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/epE8AaUqD1CYnj2.png\" loading=\"lazy\"></p>\n<ul>\n<li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li>\n<li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li>\n<li>同时在新老生代工作的垃圾回收器：G1</li>\n</ul>\n<p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p>\n<h4 id=\"Ⅰ-新生代垃圾回收器\"><a href=\"#Ⅰ-新生代垃圾回收器\" class=\"headerlink\" title=\"Ⅰ.新生代垃圾回收器\"></a>Ⅰ.新生代垃圾回收器</h4><p><strong>1.Serial 收集器</strong></p>\n<p>Serial收集器是工作在新生代的，<strong>单线程的垃圾收集器</strong>，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说<strong>在 GC 期间，此时的应用不可用。</strong></p>\n<p>但是Serial收集器有没有优于其他垃圾收集器的地⽅呢？</p>\n<p>当然有，它简单⽽⾼效（与其他收集器的单线程相⽐）。Serial收集器由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。Serial收集器对于运⾏在Client模式下的虚拟机来说是个不错的选择。</p>\n<p><strong>2.ParNew 收集器</strong> </p>\n<p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完全一样，在底层上，这两种收集器也共用了相当多的代码。</p>\n<p><strong>ParNew 主要工作在 Server 模式</strong>，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为<strong>除了 Serial  收集器，只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p>\n<p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p>\n<p><strong>3.Parallel Scavenge 收集器</strong> </p>\n<p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p>\n<p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 <strong>Parallel Scavenge 目标是达到一个可控制的吞吐量（</strong>吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 <strong>CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</strong></p>\n<p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p>\n<p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p>\n<h4 id=\"Ⅱ-老年代垃圾回收器\"><a href=\"#Ⅱ-老年代垃圾回收器\" class=\"headerlink\" title=\"Ⅱ.老年代垃圾回收器\"></a>Ⅱ.老年代垃圾回收器</h4><p><strong>1.Serial Old 收集器</strong> </p>\n<p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/CsQVw6y7xSzthai.png\" loading=\"lazy\"></p>\n<p><strong>2.Parallel Old 收集器</strong> </p>\n<p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/Q8jx3FaohNR5G4D.png\" loading=\"lazy\"></p>\n<p><strong>3.CMS 收集器</strong> </p>\n<p>CMS（Concurrent Mark Sweep）收集器是⼀种以<strong>获取最短回收停顿时间为⽬标的收集器</strong>。它⽽⾮常符合在注重⽤户体验的应⽤上使⽤。<br>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第⼀款真正意义上的并发收集器，它第⼀次实现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。</p>\n<p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤：</p>\n<ol>\n<li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>\n<li>并发标记：同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以GC线程⽆法保证可达性分析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。</li>\n<li>重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对象的标记记录，这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短</li>\n<li>并发清除：开启⽤户线程，同时GC线程开始对为标记的区域做清扫。</li>\n</ol>\n<p><img data-src=\"https://i.loli.net/2020/11/06/jHqgf4yWZR3unL7.png\" loading=\"lazy\"></p>\n<p>从它的名字就可以看出它是⼀款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下⾯三个明显的缺点：</p>\n<ul>\n<li>对CPU资源敏感；</li>\n<li>⽆法处理浮动垃圾；</li>\n<li>它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。</li>\n</ul>\n<p><strong>4.G1（Garbage First） 收集器</strong></p>\n<p>G1 (Garbage-First)是⼀款⾯向服务器的垃圾收集器,被称为驾驭一切的垃圾回收器；主要针对配备多颗处理器及⼤容量内存的机器以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征.</p>\n<p>G1 收集器的工作步骤如下</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ol>\n<p><img data-src=\"https://i.loli.net/2020/11/06/XLRkuels7qVa3SN.png\" loading=\"lazy\"></p>\n<p>G1收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的Region也就是它的名字Garbage-First的由来)。这种使⽤Region划分内存空间以及有优先级的区域回收⽅式保证了GF收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。</p>\n<h2 id=\"二、多线程\"><a href=\"#二、多线程\" class=\"headerlink\" title=\"二、多线程\"></a>二、多线程</h2><h3 id=\"1-什么是进程和线程？\"><a href=\"#1-什么是进程和线程？\" class=\"headerlink\" title=\"1.什么是进程和线程？\"></a>1.什么是进程和线程？</h3><p>进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</p>\n<p>线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。</p>\n<p>举个例子：进程和线程区别，用java内存区域来说；线程与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。</p>\n<h3 id=\"2-多线程是什么？\"><a href=\"#2-多线程是什么？\" class=\"headerlink\" title=\"2.多线程是什么？\"></a>2.多线程是什么？</h3><p>提到多线程这里要说两个概念，就是<strong>串行和并行</strong>，搞清楚这个我们才能更好的理解多线程。</p>\n<p>所谓串行其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子，我们下载多个文件，在串行中它是按照一定的顺序去进行下载的，也就是说必须等下载完A之后，才能开始下载B，它们在时间上是不可能发生重叠的。</p>\n<p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的在同一时刻发生的，并行在时间上是重叠的。</p>\n<p>了解了这两个概念之后我们再来说说什么是多线程，举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能，按照单线程来说，你想要清理垃圾还要病毒查杀，那么你必须先做完其中的一件事才能做下一件事，是有一个执行的顺序的，如果是多线程的话，我们其实在清理垃圾的时候还可以查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行的先后顺序。</p>\n<p><strong>所以：多线程就是一个进程运行中产生了多个线程</strong></p>\n<h3 id=\"3-什么是线程安全？线程安全级别有什么？\"><a href=\"#3-什么是线程安全？线程安全级别有什么？\" class=\"headerlink\" title=\"3.什么是线程安全？线程安全级别有什么？\"></a>3.什么是线程安全？线程安全级别有什么？</h3><p>既然是线程安全问题，那么毫无疑问所有的隐患都是出现在多个线程访问的情况下产生的，也就是我们要确保在多条线程访问的时候，<u>我们的程序还能按照我们预期的行为去执行</u>，<strong>也就是说：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。</strong></p>\n<p>线程安全级别：</p>\n<ol>\n<li><p>不可变：不变的对象绝对是线程安全的，不需要线程同步，如String、Long、BigInteger</p>\n</li>\n<li><p>绝对的线程安全：对象自身做了 足够的内部同步，也不需要外部同步，如 Random 、ConcurrentHashMap、Concurrent集合、atomic</p>\n</li>\n<li><p>相对的线程安全：对象的部分方法可以无条件安全使用，但是有些方法需要外部同步，需要Collections.synchronized；有条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器</p>\n</li>\n<li><p>线程兼容：对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如ArrayList HashMap</p>\n</li>\n<li><p>线程对立：即使外部进行了同步调用，也不能保证线程安全，这种情况非常少，如System.setOut()、System.runFinalizersOnExit()</p>\n</li>\n</ol>\n<h3 id=\"4-怎么保证线程安全？\"><a href=\"#4-怎么保证线程安全？\" class=\"headerlink\" title=\"4.怎么保证线程安全？\"></a>4.怎么保证线程安全？</h3><p><strong>当多个线程要共享一个实例对象的值得时候，那么在考虑安全的多线程并发编程时就要保证下面3个要素：</strong></p>\n<ul>\n<li>原子性（Synchronized, Lock）</li>\n<li>有序性(Volatile，Synchronized, Lock)</li>\n<li>可见性(Volatile，Synchronized,Lock)</li>\n</ul>\n<p>但是由于synchronized和Lock保证每个时刻只有一个线程执行同步代码，所以是线程安全的，也可以实现这一功能，<strong>但是由于线程是同步执行的，所以会影响效率。</strong></p>\n<p><strong>下面是对3个要素的详细解释：</strong></p>\n<ul>\n<li><strong>原子性</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，<strong>基本数据类型的变量的读取和赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</li>\n<li><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>\n<li><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</li>\n</ul>\n<p><strong>volatile的作用：保证数据的可见性和防止指令重排。</strong></p>\n<ul>\n<li>volatile仅能用在变量级别，而synchronized可用在变量和方法中。</li>\n<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取共享变量时，它会去内存中读取新值。</li>\n<li>普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li>\n<li>更新主存的步骤：当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效，然后当前线程将变量的值跟新到主存，更新成功后将其他线程的缓存行更新为新的主存地址</li>\n<li>其他线程读取变量时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</li>\n<li> 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li>\n</ul>\n<p><strong>1、使用安全类，比如 Java. util. concurrent</strong></p>\n<p><strong>2、使用synchronized关键字，自动锁</strong> </p>\n<p><strong>定义</strong>：synchronized关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</strong>当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用。</p>\n<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 <strong>Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销；主要解决以下三种场景:</strong></p>\n<ul>\n<li>只有一个线程进入临界区，偏向锁</li>\n<li>多线程未竞争，轻量级锁</li>\n<li>多线程竞争，重量级锁</li>\n</ul>\n<p>偏向锁→轻量级锁→重量级锁过程，<strong>锁可以升级但不能降级</strong>，这种策略是为了提高获得锁和释放锁的效率</p>\n<p><strong>底层原理：</strong></p>\n<p>① synchronized 同步语句块的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;synchronized 代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执⾏monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因)的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>\n<p>② synchronized 修饰⽅法的的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedDemo2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;synchronized ⽅法&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，JVM 通过该 ACC_SYNCHRONIZED 访问<br>标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。</p>\n<p><strong>3、使用Lock类，手动锁</strong></p>\n<p>先来说说它跟synchronized有什么区别吧，Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，什么意思？</p>\n<p>就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。我们先来看下一般是如何使用的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock(); <span class=\"comment\">// ReentrantLock是Lock的子类</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Thread thread)</span></span>&#123;</span><br><span class=\"line\">      lock.lock(); <span class=\"comment\">// 获取锁对象</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;线程名：&quot;</span>+thread.getName() + <span class=\"string\">&quot;获得了锁&quot;</span>);</span><br><span class=\"line\">          <span class=\"comment\">// Thread.sleep(2000);</span></span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;线程名：&quot;</span>+thread.getName() + <span class=\"string\">&quot;释放了锁&quot;</span>);</span><br><span class=\"line\">          lock.unlock(); <span class=\"comment\">// 释放锁对象</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-多线程的实现方式和区别\"><a href=\"#5-多线程的实现方式和区别\" class=\"headerlink\" title=\"5.多线程的实现方式和区别\"></a>5.多线程的实现方式和区别</h3><p>①继承Thread类</p>\n<p>②实现Rannable接口</p>\n<p>③使用Callable和Future创建线程</p>\n<ul>\n<li><p>上面的两种方式都有这两个问题;二第三个方法就是解决这两个问题的</p>\n<ul>\n<li>无法获取子线程的返回值</li>\n<li>run方法不可以抛出异常</li>\n</ul>\n</li>\n</ul>\n<p><strong>前三种实现多线程的比较：</strong></p>\n<p>第一种和后面两种的对比：</p>\n<ul>\n<li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li>\n<li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li>\n</ul>\n<p>第二种和第三种方式对比：</p>\n<ul>\n<li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li>\n<li>第三种方法有两个优点：有返回值、可以抛出异常</li>\n</ul>\n<h3 id=\"6-怎么启动多线程？\"><a href=\"#6-怎么启动多线程？\" class=\"headerlink\" title=\"6.怎么启动多线程？\"></a>6.怎么启动多线程？</h3><p>调用start()方法；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">threadTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tString name2 = Thread.currentThread().getName();</span><br><span class=\"line\">\t\tSystem.out.println(name2+<span class=\"string\">&quot;:你好啊 我是一个线程!&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;.start();;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tthreadTest();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没错就是这么简单,只需要<span class=\"keyword\">new</span> Thread()然后重写run方法就可以实现创建一个线程,使用start方法即可启动该线程.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-有几种线程池-是怎么实现的？\"><a href=\"#7-有几种线程池-是怎么实现的？\" class=\"headerlink\" title=\"7.有几种线程池,是怎么实现的？\"></a>7.有几种线程池,是怎么实现的？</h3><ol>\n<li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li>\n<li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n<li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li>\n<li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li>\n</ol>\n<p><strong>底层具体实现：</strong></p>\n<p>通过Executor 框架的⼯具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：</p>\n<ul>\n<li><strong>newSingleThreadExecutor</strong></li>\n<li><strong>newFixedThreadPool</strong></li>\n<li><strong>newCachedThreadPool</strong></li>\n</ul>\n<p>下⾯这些对创建 ⾮常重要，在后⾯使⽤线程池的过程中你⼀定会⽤到！所以，务必拿着⼩本本记清楚。</p>\n<p><strong>ThreadPoolExecutor构造函数重要参数分析</strong> </p>\n<ul>\n<li>corePoolSize : 核⼼线程数线程数定义了<strong>最⼩可以同时运⾏的线程数量</strong>。</li>\n<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数<br>量变为最⼤线程数。</li>\n<li>workQueue: 当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到<br>的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>ThreadPoolExecutor其他常⻅参数:</p>\n<ol>\n<li><p>keepAliveTime:当线程池中的线程数量⼤于 corePoolSize 的时候，如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁；</p>\n</li>\n<li><p>unit : keepAliveTime 参数的时间单位。</p>\n</li>\n<li><p>threadFactory :executor 创建新线程的时候会⽤到。</p>\n</li>\n<li><p>handler :饱和策略。关于饱和策略下⾯单独介绍⼀下。<br>ThreadPoolExecutor 饱和策略<br>ThreadPoolExecutor 饱和策略定义:<br>如果当前同时运⾏的线程数量达到最⼤线程数量并且队列也已经被放满了任时， ThreadPoolTaskExecutor 定义⼀些策略:ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。ThreadPoolExecutor.CallerRunsPolicy：调⽤执⾏⾃⼰的线程运⾏任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应⽤程序可以承受此延迟并且你不能任务丢弃任何⼀个任务请求的话，你可以选择这个策略。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, //线程池的核心线程数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize, //最大线程数。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          Long keepAliveTime,// 设置线程超时时间。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BLockingQueue&lt;Runnable&gt;workQueue,   //阻塞队列</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory, //线程工厂,线程池利用该工厂创建线程 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             RejectedExecutionHandLer handler)</span></span>&#123;<span class=\"comment\">//  线程任务拒绝策略。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-说说-sleep-⽅法和-wait-⽅法区别和共同点\"><a href=\"#8-说说-sleep-⽅法和-wait-⽅法区别和共同点\" class=\"headerlink\" title=\"8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?\"></a>8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h3><p>两者最主要的区别在于：sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</p>\n<ul>\n<li>两者都可以暂停线程的执⾏。</li>\n<li>Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</li>\n<li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者notifyAll() ⽅法。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。</li>\n<li>sleep() ⽅法执⾏完成后，线程会⾃动苏醒。</li>\n</ul>\n<h3 id=\"9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？\"><a href=\"#9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？\" class=\"headerlink\" title=\"9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？\"></a>9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</h3><p>这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都回答不上来！</p>\n<p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。</p>\n<p>总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。</p>\n","categories":["JVM"],"tags":["垃圾回收"]},{"title":"HashMap","url":"/2020-11-17-HashMap.html","content":"<p>HashMap</p>\n<h3 id=\"HashMap-概述\"><a href=\"#HashMap-概述\" class=\"headerlink\" title=\"HashMap 概述\"></a>HashMap 概述</h3><p>HashMap 是 Map 接口的实现，HashMap 允许空的 key-value 键值对，HashMap 被认为是 Hashtable 的增强版，HashMap 是一个非线程安全的容器，如果想构造线程安全的 Map 考虑使用 ConcurrentHashMap。HashMap 是无序的，因为 HashMap 无法保证内部存储的键值对的有序性。</p>\n<p>HashMap 的底层数据结构是数组 + 链表的集合体，数组在 HashMap 中又被称为<code>桶(bucket)</code>。遍历 HashMap 需要的时间损耗为 HashMap 实例桶的数量 + (key - value 映射) 的数量。因此，如果遍历元素很重要的话，不要把初始容量设置的太高或者负载因子设置的太低。</p>\n<p>HashMap 实例有两个很重要的因素，初始容量和负载因子，初始容量指的就是 hash 表桶的数量，负载因子是一种衡量哈希表填充程度的标准，当哈希表中存在足够数量的 entry，以至于超过了负载因子和当前容量，这个哈希表会进行 rehash 操作，内部的数据结构重新 rebuilt。</p>\n<p>注意 HashMap 不是线程安全的，如果多个线程同时影响了 HashMap ，并且至少一个线程修改了 HashMap 的结构，那么必须对HashMap 进行同步操作。可以使用 <code>Collections.synchronizedMap(new HashMap)</code> 来创建一个线程安全的 Map。</p>\n<p>HashMap 会导致除了迭代器本身的 remove 外，外部 remove 方法都可能会导致 fail-fast 机制，因此尽量要用迭代器自己的 remove 方法。如果在迭代器创建的过程中修改了 map 的结构，就会抛出 <code>ConcurrentModificationException</code> 异常。</p>\n<h3 id=\"1-HashMap-中的构造函数：\"><a href=\"#1-HashMap-中的构造函数：\" class=\"headerlink\" title=\"1.HashMap 中的构造函数：\"></a>1.HashMap 中的构造函数：</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal initial </span></span><br><span class=\"line\"><span class=\"string\">capacity: &quot;</span> + initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal load factor: &quot;</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    <span class=\"comment\">//最终也会调用到上面的构造函数，不过这个默认的负载因子就是 HashMap 的默认负载因子也就是 0.75f</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    <span class=\"comment\">//默认初始值为16</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class=\"comment\">//带有 Map 的构造函数，会直接把外部元素批量放入 HashMap 中。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">  putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;<span class=\"comment\">// 默认加载因子0.75；</span></span><br><span class=\"line\"><span class=\"comment\">//HashMap默认初始容量16，加载因子0.75，也就是说最多能放16*0.75=12个元素，当put第13个时，HashMap\t</span></span><br><span class=\"line\"><span class=\"comment\">//将发生rehash，rehash的一系列处理比较影响性能，所以当我们需要向HashMap存放较多元素时，最好指定合</span></span><br><span class=\"line\"><span class=\"comment\">//适的初始容量和加载因子，否则HashMap默认只能存12个元素，将会发生多次rehash操作。                                               </span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16;默认初始容量为16，</span></span><br><span class=\"line\"><span class=\"comment\">//这里是不是有个疑问？int 占用四个字节，按说最大容量应该是左移 31 位，为什么 HashMap 最大容量是左移 30 位呢？因为在数值计算中</span></span><br><span class=\"line\"><span class=\"comment\">//最高位也就是最左位的位 是代表着符号为，0 -&gt; 正数，1 -&gt; 负数，容量不可能是负数，所以 HashMap 最高位只能移位到 2 ^ 30 次幂。                                                                                                </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\"><a href=\"#2-HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\" class=\"headerlink\" title=\"2.HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩\"></a>2.HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩</h3><ol>\n<li>HashMap<strong>在确定数组下标Index的时候</strong>，采用的是( length-1) &amp; hash 的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，因为只要输入的Hash值本身分布均匀，Hash算法的结果就是均匀的。所以HashMap规定了其容量必须是2的n次方.</li>\n<li>由于HashMap规定了其<strong>容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小</strong>。使用位运算同时还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30，<strong>int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</strong></li>\n</ol>\n<p><strong>下⾯这个⽅法（tableSizeFor）保证了 HashMap 总是使⽤2的幂作为哈希表的⼤⼩，也就是说但你创建一个大小不是2的幂的大小，最后会给你返回一个离最近2的幂的大小的值</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY </span><br><span class=\"line\">: n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">\t<span class=\"comment\">/*  &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0</span></span><br><span class=\"line\"><span class=\"comment\">\t比如7的二进制是0111，7&gt;&gt;&gt;2表示右移2位，变成001，即为1</span></span><br><span class=\"line\"><span class=\"comment\">\tcap=8;n=7;n=0111  n|n&gt;&gt;&gt;1 = 0111 | 0011 = 0111 n|n&gt;&gt;&gt;2 0111 | 0001 = 0111</span></span><br><span class=\"line\"><span class=\"comment\">\tn|n&gt;&gt;&gt;4 0111 | 0000 = 0111 最后一步 return=n+1=8</span></span><br><span class=\"line\"><span class=\"comment\">\t综上可得，当hashMap指定初始值的时候，会调用tableSizeFor方法，总是返回2的n次方的值；</span></span><br><span class=\"line\"><span class=\"comment\">\t并且总是等于该算法接近该初始值并比它大的那个值;</span></span><br><span class=\"line\"><span class=\"comment\">\t就是让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。当指定初始值入参</span></span><br><span class=\"line\"><span class=\"comment\">\t为0时，返回实际容量为1。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;<span class=\"comment\">//最大容量为2的30次方\t </span></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-HashMap-的数据结构\"><a href=\"#3-HashMap-的数据结构\" class=\"headerlink\" title=\"3.HashMap 的数据结构\"></a>3.HashMap 的数据结构</h3><p>JDK1.7 中，HashMap 采用<code>数组（位桶） + 链表</code>的实现，即使用<code>链表</code>来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多（哈希冲突），即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。</p>\n<p>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。</p>\n<p><strong>解决哈希冲突的方法：</strong></p>\n<ol>\n<li><p>开放定址法：使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。</p>\n</li>\n<li><p>再哈希法：同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。这种方法不易产生聚集，但增加了计算时间。</p>\n</li>\n<li><p>链地址法：将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>\n</li>\n<li><p>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>\n<p><strong>红黑树：</strong></p>\n</li>\n</ol>\n<p>红黑树是AVL树的变种，红黑树通过一些着色法则确保没有一条路径会比其它路径长出两倍，因而达到接近平衡的目的。所谓红黑树，不仅是一个二叉搜索树，而且必须满足一下规则：<br>   1、每个节点不是红色就是黑色。<br>   2、根节点为黑色。<br>   3、如果节点为红色，其子节点必须为黑色。<br>   4、任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同。<br>上面的这些约束保证了这个树大致上是平衡的，这也决定了红黑树的插入、删除、查询等操作是比较快速的。 根据规则4，新增节点必须为红色；根据规则3，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形</p>\n<p><strong>链表：</strong></p>\n<p>HashMap中的链表是单链表</p>\n<p>jdk1.7: <strong>数组的每个元素都是一个单链表的头节点</strong></p>\n<p>jdk1.8: 树化操作的过程有点复杂，将原本的单链表转化为双向链表，再遍历这个双向链表转化为红黑树。</p>\n<h3 id=\"4-HashMap-的-put-过程\"><a href=\"#4-HashMap-的-put-过程\" class=\"headerlink\" title=\"4.HashMap 的 put 过程\"></a>4.HashMap 的 put 过程</h3><p>大致过程如下，首先会使用 hash 方法计算对象的哈希码，根据哈希码来确定在数组（桶）中存放的位置，如果桶中没有 Node 节点则直接进行 put，如果对应桶已经有 Node 节点，会对链表长度进行分析，判断长度是否大于 8，如果链表长度小于 8 ，在 JDK1.7 前会使用头插法，在 JDK1.8 之后更改为尾插法。如果链表长度大于 8 会进行树化操作（并且数组长度大于64），把链表转换为红黑树，在红黑树上进行存储。</p>\n<p>以 JDK 1.8 为基准进行分析，后面也是。先贴出整段代码，后面会逐行进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">  <span class=\"comment\">// 如果table 为null 或者没有为 table 分配内存，就resize一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    n = (tab = resize()).length;</span><br><span class=\"line\">  <span class=\"comment\">// 指定hash值节点为空则直接插入，这个(n - 1) &amp; hash才是表中真正的哈希</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">    <span class=\"comment\">// 计算表中的这个真正的哈希值与要插入的key.hash相比</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\">    <span class=\"comment\">// 若不同的话，并且当前节点已经在 TreeNode 上了</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">      <span class=\"comment\">// 采用红黑树存储方式</span></span><br><span class=\"line\">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">    <span class=\"comment\">// key.hash 不同并且也不再 TreeNode 上，在链表上找到 p.next==null</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在表尾插入</span></span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 新增节点后如果节点个数到达阈值，则进入 treeifyBin() 进行再次判断</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了同 hash、key 的节点，那么直接退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 p 指向下一节点</span></span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// map中含有旧值，返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">      afterNodeAccess(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// map调整次数 + 1</span></span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"comment\">// 键值对的数量达到阈值，需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    resize();</span><br><span class=\"line\">  afterNodeInsertion(evict);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先看一下 <code>putVal</code> 方法，这个方法是 final 的，如果你自已定义 HashMap 继承的话，是不允许你自己重写 put 方法的，然后这个方法涉及五个参数</p>\n<ul>\n<li>hash -&gt; put 放在桶中的位置，在 put 之前，会进行 hash 函数的计算。</li>\n<li>key -&gt; 参数的 key 值</li>\n<li>value -&gt; 参数的 value 值</li>\n<li>onlyIfAbsent -&gt; 是否改变已经存在的值，也就是是否进行 value 值的替换标志</li>\n<li>evict -&gt; 是否是刚创建 HashMap 的标志</li>\n</ul>\n<p>在调用到 putVal 方法时，<strong>首先会进行 hash 函数计算应该插入的位置</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>哈希函数的源码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//JDK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的</span></span><br><span class=\"line\">    <span class=\"comment\">//hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置</span></span><br><span class=\"line\"> \t<span class=\"comment\">//（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash</span></span><br><span class=\"line\">\t<span class=\"comment\">//值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span><br><span class=\"line\">\t<span class=\"comment\">//所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现</span></span><br><span class=\"line\">\t<span class=\"comment\">//⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。</span></span><br></pre></td></tr></table></figure>\n\n<p>首先先来理解一下 hash 函数的计算规则</p>\n<p>Hash 函数</p>\n<p>hash 函数会根据你传递的 key 值进行计算，首先计算 key 的 <code>hashCode</code> 值，然后再对 hashcode 进行无符号右移操作，最后再和 hashCode 进行<code>异或 ^</code> 操作。</p>\n<blockquote>\n<p><code>&gt;&gt;&gt;</code>: 无符号右移操作，它指的是 <strong>无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong> ，也就是不管是正数还是负数，右移都会在空缺位补 0 。</p>\n</blockquote>\n<p>在得到 hash 值后，就会进行 put 过程。</p>\n<p>首先会判断 HashMap 中的 Node 数组是否为 null，如果第一次创建 HashMap 并进行第一次插入元素，首先会进行数组的 resize，也就是<code>重新分配</code>，这里还涉及到一个 <code>resize()</code> 扩容机制源码分析，我们后面会介绍。</p>\n<p><strong>扩容完毕后，会计算出 HashMap 的存放位置，通过使用 ( n - 1 ) &amp; hash 进行计算得出。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t <span class=\"comment\">// 1. HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash \t     </span></span><br><span class=\"line\">\t <span class=\"comment\">//的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</span></span><br><span class=\"line\">\t <span class=\"comment\">// 2. 由于HashMap规定了其容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小。使用位运算同时\t </span></span><br><span class=\"line\">     <span class=\"comment\">//还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于\t           </span></span><br><span class=\"line\">     <span class=\"comment\">//HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运\t</span></span><br><span class=\"line\">     <span class=\"comment\">//算符表示就是 1 &lt;&lt; 30，int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</span></span><br></pre></td></tr></table></figure>\n\n<p>然后会把这个位置作为数组的下标作为存放元素的位置。如果不为空，那么计算表中的这个真正的哈希值与要插入的 key.hash 相比。如果哈希值相同，key-value 不一样，再判断是否是树的实例，如果是的话，那么就把它插入到树上。如果不是，就执行尾插法在 entry 链尾进行插入。</p>\n<h3 id=\"5-扩容机制\"><a href=\"#5-扩容机制\" class=\"headerlink\" title=\"5.扩容机制\"></a>5.扩容机制</h3><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。好在 HashMap 是一种自动扩容的数据结构，在这种基于变长的数据结构中，扩容机制是非常重要的。</p>\n<p>在 HashMap 中，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。HashMap 中的扩容机制是由 <code>resize()</code> 方法来实现的，下面我们就来一次认识下。</p>\n<p>HashMap 中有两个非常重要的变量，一个是 <code>loadFactor</code> ，一个是 <code>threshold</code> ，loadFactor 表示的就是负载因子，threshold 表示的是下一次要扩容的阈值，当 threshold = loadFactor * 数组长度时，数组长度扩大位原来的两倍，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  <span class=\"comment\">// 存储old table 的大小</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  <span class=\"comment\">// 存储扩容阈值</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果old table数据已达最大，那么threshold也被设置成最大</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">      threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 左移扩大二倍,</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">      <span class=\"comment\">// 扩容成原来二倍</span></span><br><span class=\"line\">      newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果oldThr                                                                                                                                               !&gt; 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">    newCap = oldThr;</span><br><span class=\"line\">  <span class=\"comment\">// 如果old table &lt;= 0 并且 存储的阈值 &lt;= 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">    newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果扩充阈值为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容阈值为 初始容量*负载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">              (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 重新给负载因子赋值</span></span><br><span class=\"line\">  threshold = newThr;</span><br><span class=\"line\">  <span class=\"comment\">// 获取扩容后的数组</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">  table = newTab;</span><br><span class=\"line\">  <span class=\"comment\">// 如果第一次进行table 初始化不会走下面的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 扩容之后需要重新把节点放在新扩容的数组中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt; e;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">          <span class=\"comment\">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class=\"line\">          ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">          Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; next;</span><br><span class=\"line\">          <span class=\"comment\">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">              loTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">              hiTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 将分组后的链表映射到新桶中</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j] = loHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>扩容机制源码比较长，我们耐心点进行拆分</p>\n<p>我们以 if...else if...else 逻辑进行拆分，上面代码主要做了这几个事情</p>\n<ul>\n<li>判断 HashMap 中的数组的长度，也就是 <code>(Node&lt;K,V&gt;[])oldTab.length()</code> ，再判断数组的长度是否比最大的的长度也就是 2^30 次幂要大，大的话直接取最大长度，否则利用位运算 <code>&lt;&lt;</code>扩容为原来的两倍</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135604592-1504962060.png\" alt=\"img\" loading=\"lazy\"></p>\n<ul>\n<li>如果数组长度不大于0 ，再判断扩容阈值 <code>threshold</code> 是否大于 0 ，也就是看有无外部指定的扩容阈值，若有则使用，这里需要说明一下 threshold 何时是 <code>oldThr &gt; 0</code>，因为 oldThr = threshold ，这里其实比较的就是 threshold，因为 HashMap 中的每个构造方法都会调用 <code>HashMap(initCapacity,loadFactor)</code> 这个构造方法，所以如果没有外部指定 initialCapacity，初始容量使用的就是 16，然后根据 <code>this.threshold = tableSizeFor(initialCapacity);</code> .</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135614686-238811487.png\" alt=\"img\" loading=\"lazy\"></p>\n<ul>\n<li>否则，直接使用默认的初始容量和扩容阈值，走 else 的逻辑是在 table 刚刚初始化的时候。</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135622150-1149800383.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>然后会判断 newThr 是否为 0 ，笔者在刚开始研究时发现 <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code> 一直以为这是常量做乘法，怎么会为 0 ，其实不是这部分的问题，在于上面逻辑判断中的扩容操作，可能会导致<code>位溢出</code>。</p>\n<p>导致位溢出的示例：oldCap = 2^28 次幂，threshold &gt; 2 的三次方整数次幂。在进入到 <code>float ft = (float)newCap * loadFactor;</code> 这个方法是 2^28 * 2^(3+n) 会直接 &gt; 2^31 次幂，导致全部归零。</p>\n<p><strong>在扩容后需要把节点放在新扩容的数组中，这里也涉及到三个步骤</strong></p>\n<ul>\n<li>循环桶中的每个 Node 节点，判断 Node[i] 是否为空，为空直接返回，不为空则遍历桶数组，并将键值对映射到新的桶数组中。</li>\n<li>如果不为空，再判断是否是树形结构，如果是树形结构则按照树形结构进行拆分，拆分方法在 <code>split</code> 方法中。</li>\n<li>如果不是树形结构，则遍历链表，并将链表节点按原顺序进行分组。</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135633904-751470058.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"6-讲一讲-get-方法全过程\"><a href=\"#6-讲一讲-get-方法全过程\" class=\"headerlink\" title=\"6.讲一讲 get 方法全过程\"></a>6.讲一讲 get 方法全过程</h3><p>我们上面讲了 HashMap 中的 put 方法全过程，下面我们来看一下 <code>get</code> 方法的过程</p>\n<p>首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找到真实的元素位置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 总是会check 一下第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">        ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是第一个元素，并且下一个元素不是空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否属于 TreeNode，如果是 TreeNode 实例，直接从 TreeNode.getTreeNode 取</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果还不是 TreeNode 实例，就直接循环数组元素，直到找到指定元素位置</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来简单介绍下吧，首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<p><code>getNode</code> 方法有一个比较重要的过程就是 <strong>(n - 1) &amp; hash</strong>，这段代码是确定需要查找的桶的位置的，那么，为什么要 (n - 1) &amp; hash 呢？</p>\n<p>n 就是 HashMap 中桶的数量，这句话的意思也就是说 (n - 1) &amp; hash 就是 (桶的容量 - 1) &amp; hash</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为什么 HashMap 的检索位置是 (table.size - 1) &amp; hash</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 49</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 50</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 51</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么每次算完之后的 (n - 1) &amp; hash ，依次为</p>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135651991-667806972.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>也就是 <strong>tab[(n - 1) &amp; hash]</strong> 算出的具体位置。</p>\n<h3 id=\"7-HashMap-的遍历方式\"><a href=\"#7-HashMap-的遍历方式\" class=\"headerlink\" title=\"7.HashMap 的遍历方式\"></a>7.HashMap 的遍历方式</h3><p>HashMap 的遍历，也是一个使用频次特别高的操作</p>\n<p>HashMap 遍历的基类是 <code>HashIterator</code>，它是一个 Hash 迭代器，它是一个 HashMap 内部的抽象类，它的构造比较简单，只有三种方法，<strong>hasNext 、 remove 和 nextNode</strong> 方法，其中 nextNode 方法是由三种迭代器实现的</p>\n<p>这三种迭代器就就是</p>\n<ul>\n<li><code>KeyIterator</code> ，对 key 进行遍历</li>\n<li><code>ValueIterator</code>，对 value 进行遍历</li>\n<li><code>EntryIterator</code>， 对 Entry 链进行遍历</li>\n</ul>\n<p>虽然说看着迭代器比较多，但其实他们的遍历顺序都是一样的，构造也非常简单，都是使用 <code>HashIterator</code> 中的 <code>nextNode</code> 方法进行遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().key; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().value; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntryIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Map.<span class=\"function\">Entry&lt;K,V&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HashIterator 中的遍历方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashIterator</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; next;        <span class=\"comment\">// 下一个 entry 节点</span></span><br><span class=\"line\">  Node&lt;K,V&gt; current;     <span class=\"comment\">// 当前 entry 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> expectedModCount;  <span class=\"comment\">// fail-fast 的判断标识</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> index;             <span class=\"comment\">// 当前槽</span></span><br><span class=\"line\"></span><br><span class=\"line\">  HashIterator() &#123;</span><br><span class=\"line\">    expectedModCount = modCount;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t = table;</span><br><span class=\"line\">    current = next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// advance to first entry</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">nextNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t;</span><br><span class=\"line\">    Node&lt;K,V&gt; e = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((next = (current = e).next) == <span class=\"keyword\">null</span> &amp;&amp; (t = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>next 和 current 分别表示下一个 Node 节点和当前的 Node 节点，HashIterator 在初始化时会遍历所有的节点。下面我们用图来表示一下他们的遍历顺序</p>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135703898-308748730.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>你会发现 <code>nextNode()</code> 方法的遍历方式和 HashIterator 的遍历方式一样，只不过判断条件不一样，构造 HashIterator 的时候判断条件是有没有链表，桶是否为 null，而遍历 nextNode 的判断条件变为下一个 node 节点是不是 null ，并且桶是不是为 null。</p>\n<h3 id=\"8-HashMap-中的移除方法\"><a href=\"#8-HashMap-中的移除方法\" class=\"headerlink\" title=\"8.HashMap 中的移除方法\"></a>8.HashMap 中的移除方法</h3><p>HashMap 中的移除方法也比较简单了，源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">    <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      node = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">              ((k = e.key) == key ||</span><br><span class=\"line\">               (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">            node = e;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          p = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                         (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">        tab[index] = node.next;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        p.next = node.next;</span><br><span class=\"line\">      ++modCount;</span><br><span class=\"line\">      --size;</span><br><span class=\"line\">      afterNodeRemoval(node);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remove 方法有很多，最终都会调用到 removeNode 方法，只不过传递的参数值不同，我们拿 remove(object) 来演示一下。</p>\n<p>首先会通过 hash 来找到对应的 bucket，然后通过遍历链表，找到键值相等的节点，然后把对应的节点进行删除。</p>\n<h3 id=\"9-HashMap-为啥线程不安全\"><a href=\"#9-HashMap-为啥线程不安全\" class=\"headerlink\" title=\"9.HashMap 为啥线程不安全\"></a>9.HashMap 为啥线程不安全</h3><p>HashMap 不是一个线程安全的容器，不安全性体现在多线程并发对 HashMap 进行 put 操作上。如果有两个线程 A 和 B ，首先 A 希望插入一个键值对到 HashMap 中，在决定好桶的位置进行 put 时，此时 A 的时间片正好用完了，轮到 B 运行，B 运行后执行和 A 一样的操作，只不过 B 成功把键值对插入进去了。如果 A 和 B 插入的位置（桶）是一样的，那么线程 A 继续执行后就会覆盖 B 的记录，造成了数据不一致问题。</p>\n<p>还有一点在于 HashMap 在扩容时，因 resize 方法会形成环，造成死循环，导致 CPU 飙高。</p>\n<h3 id=\"10-HashMap-是如何处理哈希碰撞的\"><a href=\"#10-HashMap-是如何处理哈希碰撞的\" class=\"headerlink\" title=\"10.HashMap 是如何处理哈希碰撞的\"></a>10.HashMap 是如何处理哈希碰撞的</h3><p>HashMap 底层是使用位桶 + 链表实现的，位桶决定元素的插入位置，位桶是由 hash 方法决定的，当多个元素的 hash 计算得到相同的哈希值后，HashMap 会把多个 Node 元素都放在对应的位桶中，形成链表，这种处理哈希碰撞的方式被称为链地址法。</p>\n<p>其他处理 hash 碰撞的方式还有 <strong>开放地址法、rehash 方法、建立一个公共溢出区</strong>这几种方法。</p>\n<h3 id=\"11-HashMap-线程安全的实现有哪些\"><a href=\"#11-HashMap-线程安全的实现有哪些\" class=\"headerlink\" title=\"11.HashMap 线程安全的实现有哪些\"></a>11.HashMap 线程安全的实现有哪些</h3><p>因为 HashMap 不是一个线程安全的容器，所以并发场景下推荐使用 <code>ConcurrentHashMap</code> ，或者使用线程安全的 HashMap，使用 <code>Collections</code> 包下的线程安全的容器，比如说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Collections.synchronizedMap(<span class=\"keyword\">new</span> HashMap());</span><br></pre></td></tr></table></figure>\n\n<p>还可以使用 HashTable ，它也是线程安全的容器，基于 key-value 存储，经常用 HashMap 和 HashTable 做比较就是因为 HashTable 的数据结构和 HashMap 相同。</p>\n<p>上面效率最高的就是 ConcurrentHashMap。</p>\n<h3 id=\"11-HashMap和Hashtable的区别\"><a href=\"#11-HashMap和Hashtable的区别\" class=\"headerlink\" title=\"11.HashMap和Hashtable的区别:\"></a>11.HashMap和Hashtable的区别:</h3><ol>\n<li><p>线程是否安全： HashMap 是⾮线程安全的，Hashtable 是线程安全的；<strong>Hashtable 内部的⽅法基本都经过 synchronized 修饰</strong>。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap吧！）；</p>\n</li>\n<li><p>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，Hashtable 基本被淘汰，不要在代码中使⽤它；</p>\n</li>\n<li><p>对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有⼀个 null，直接抛出 NullPointerException。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①<strong>创建时如果不指定容量初始值，Hashtable 默认的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后每次扩充（resize（）），容量变为原来的2倍</strong>。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 <strong>tableSizeFor</strong>()⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是2的幂次⽅。</li>\n<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</li>\n</ol>\n<h5 id=\"HashMap中的key可以是任何对象或数据类型吗\"><a href=\"#HashMap中的key可以是任何对象或数据类型吗\" class=\"headerlink\" title=\"HashMap中的key可以是任何对象或数据类型吗\"></a><strong>HashMap中的key可以是任何对象或数据类型吗</strong></h5><ul>\n<li><strong>可以为null，但不能是可变对象</strong>，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li>\n<li><strong>如果可变对象在 HashMap 中被用作键</strong>，<strong>那就要小心在改变对象状态的时候，不要改变它的哈希值了</strong>。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li>\n</ul>\n","categories":["集合"],"tags":["Map"]},{"title":"集合容器","url":"/2020-11-18-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8.html","content":"<h2 id=\"集合容器概述\"><a href=\"#集合容器概述\" class=\"headerlink\" title=\"集合容器概述\"></a>集合容器概述</h2><h3 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h3><p><strong>集合框架</strong>：用于存储数据的容器。</p>\n<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p>\n<p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>\n<p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p>\n<p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p>\n<p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。它减少了程序设计的辛劳。</p>\n<p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。<br>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p>\n<h3 id=\"集合的特点\"><a href=\"#集合的特点\" class=\"headerlink\" title=\"集合的特点\"></a>集合的特点</h3><p>集合的特点主要有如下两点：</p>\n<ul>\n<li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li>\n<li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li>\n</ul>\n<h3 id=\"集合和数组的区别\"><a href=\"#集合和数组的区别\" class=\"headerlink\" title=\"集合和数组的区别\"></a>集合和数组的区别</h3><ul>\n<li>数组是固定长度的；集合可变长度的。</li>\n<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>\n<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li>\n</ul>\n<p><strong>数据结构</strong>：就是容器中存储数据的方式。</p>\n<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p>\n<p>集合容器在不断向上抽取过程中，出现了集合体系。<strong>在使用一个体系的原则：参阅顶层内容。建立底层对象。</strong></p>\n<h3 id=\"使用集合框架的好处\"><a href=\"#使用集合框架的好处\" class=\"headerlink\" title=\"使用集合框架的好处\"></a>使用集合框架的好处</h3><ol>\n<li>容量自增长；</li>\n<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li>\n<li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li>\n<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>\n<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>\n</ol>\n<h3 id=\"常用的集合类有哪些？\"><a href=\"#常用的集合类有哪些？\" class=\"headerlink\" title=\"常用的集合类有哪些？\"></a>常用的集合类有哪些？</h3><p>Map接口和Collection接口是所有集合框架的父接口：</p>\n<ol>\n<li>Collection接口的子接口包括：Set接口和List接口</li>\n<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>\n<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>\n<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>\n</ol>\n<h3 id=\"List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？\"><a href=\"#List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？\" class=\"headerlink\" title=\"List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？\"></a>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</h3><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p>\n<p>Collection集合主要有List和Set两大接口</p>\n<ul>\n<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>\n<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>\n<li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</li>\n</ul>\n<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>\n<h3 id=\"集合框架底层数据结构\"><a href=\"#集合框架底层数据结构\" class=\"headerlink\" title=\"集合框架底层数据结构\"></a>集合框架底层数据结构</h3><p>Collection</p>\n<ol>\n<li>List</li>\n</ol>\n<ul>\n<li>Arraylist： Object数组</li>\n<li>Vector： Object数组</li>\n<li>LinkedList： 双向循环链表</li>\n</ul>\n<ol>\n<li>Set</li>\n</ol>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>\n</ul>\n<p>Map</p>\n<ul>\n<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，并且判断数组长度是否小于64，小于则扩容数组，否则将链表转化为红黑树，以减少搜索时间</li>\n<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>\n<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><ul>\n<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>\n<li>statck：堆栈类，先进后出。</li>\n<li>hashtable：就比hashmap多了个线程安全。</li>\n<li>enumeration：枚举，相当于迭代器。</li>\n</ul>\n<h3 id=\"Java集合的快速失败机制-“fail-fast”？\"><a href=\"#Java集合的快速失败机制-“fail-fast”？\" class=\"headerlink\" title=\"Java集合的快速失败机制 “fail-fast”？\"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>是java集合的一种错误检测机制，当多个线程对集合进行<strong>结构上的改变</strong>的操作时，有可能会产生 fail-fast 机制。</p>\n<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>\n<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>\n<p>解决办法：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>\n<li>使用CopyOnWriteArrayList来替换ArrayList</li>\n</ol>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list. add(<span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class=\"line\">clist. add(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// 运行时此行报错</span></span><br><span class=\"line\">System. out. println(list. size());</span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;String&gt; it = list. iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it. hasNext())&#123;</span><br><span class=\"line\">  String obj = it. next();</span><br><span class=\"line\">  System. out. println(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h4 id=\"如何边遍历边移除-Collection-中的元素？\"><a href=\"#如何边遍历边移除-Collection-中的元素？\" class=\"headerlink\" title=\"如何边遍历边移除 Collection 中的元素？\"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">   *<span class=\"comment\">// do something*</span></span><br><span class=\"line\">   it.remove();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<p>一种最常见的<strong>错误</strong>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Integer i : list)&#123;</span><br><span class=\"line\">   list.remove(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>\n<h4 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h4><ul>\n<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>\n<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>\n<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>\n</ul>\n<h4 id=\"遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？\"><a href=\"#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？\" class=\"headerlink\" title=\"遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？\"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><p>遍历方式有以下几种：</p>\n<ol>\n<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>\n<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>\n<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>\n<ul>\n<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>\n<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>\n</ul>\n<p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p>\n<h4 id=\"说一下-ArrayList-的优缺点\"><a href=\"#说一下-ArrayList-的优缺点\" class=\"headerlink\" title=\"说一下 ArrayList 的优缺点\"></a>说一下 ArrayList 的优缺点</h4><p>ArrayList的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>\n<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>\n</ul>\n<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// list to array</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">list.toArray();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// array to list</span></span><br><span class=\"line\">String[] array = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;123&quot;</span>,<span class=\"string\">&quot;456&quot;</span>&#125;;</span><br><span class=\"line\">Arrays.asList(array);</span><br><span class=\"line\"><span class=\"number\">123456789</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>\n<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>\n<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>\n</ul>\n<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>\n<p>补充：数据结构基础之双向链表</p>\n<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>\n<ul>\n<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>\n<li>性能：ArrayList 在性能方面要优于 Vector。</li>\n<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>\n</ul>\n<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>\n<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>\n<h4 id=\"插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？\"><a href=\"#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？\" class=\"headerlink\" title=\"插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？\"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>\n<p>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</p>\n<p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</p>\n<h4 id=\"多线程场景下如何使用-ArrayList？\"><a href=\"#多线程场景下如何使用-ArrayList？\" class=\"headerlink\" title=\"多线程场景下如何使用 ArrayList？\"></a>多线程场景下如何使用 ArrayList？</h4><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class=\"line\">synchronizedList.add(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">synchronizedList.add(<span class=\"string\">&quot;bbb&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class=\"line\">    System.out.println(synchronizedList.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么-ArrayList-的-elementData-加上-transient-修饰？\"><a href=\"#为什么-ArrayList-的-elementData-加上-transient-修饰？\" class=\"headerlink\" title=\"为什么 ArrayList 的 elementData 加上 transient 修饰？\"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 中的数组定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>再看一下 ArrayList 的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">     <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(java.io.ObjectOutputStream s)</span> <span class=\"keyword\">throws</span> java.io.IOException</span>&#123;</span><br><span class=\"line\">    *<span class=\"comment\">// Write out element count, and any hidden stuff*</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">    s.defaultWriteObject();</span><br><span class=\"line\">    *<span class=\"comment\">// Write out array length*</span></span><br><span class=\"line\">        s.writeInt(elementData.length);</span><br><span class=\"line\">    *<span class=\"comment\">// Write out all elements in the proper order.*</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;size; i++)</span><br><span class=\"line\">            s.writeObject(elementData[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123456789101112</span></span><br></pre></td></tr></table></figure>\n\n<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>\n<h4 id=\"List-和-Set-的区别\"><a href=\"#List-和-Set-的区别\" class=\"headerlink\" title=\"List 和 Set 的区别\"></a>List 和 Set 的区别</h4><p>List , Set 都是继承自Collection 接口</p>\n<p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p>\n<p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p>\n<p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p>\n<p>Set和List对比</p>\n<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p>\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"说一下-HashSet-的实现原理？\"><a href=\"#说一下-HashSet-的实现原理？\" class=\"headerlink\" title=\"说一下 HashSet 的实现原理？\"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n<h4 id=\"HashSet如何检查重复？HashSet是如何保证数据不可重复的？\"><a href=\"#HashSet如何检查重复？HashSet是如何保证数据不可重复的？\" class=\"headerlink\" title=\"HashSet如何检查重复？HashSet是如何保证数据不可重复的？\"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p>\n<p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p>\n<p>以下是HashSet 部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234567891011</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>hashCode（）与equals（）的相关规定</strong>：</p>\n<ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个equals方法返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>\n</ol>\n<p><strong>==与equals的区别</strong></p>\n<ol>\n<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>\n<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</li>\n</ol>\n<h4 id=\"HashSet与HashMap的区别\"><a href=\"#HashSet与HashMap的区别\" class=\"headerlink\" title=\"HashSet与HashMap的区别\"></a>HashSet与HashMap的区别</h4><table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现了Map接口</td>\n<td>实现Set接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用put（）向map中添加元素</td>\n<td>调用add（）方法向Set中添加元素</td>\n</tr>\n<tr>\n<td>HashMap使用键（Key）计算Hashcode</td>\n<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>\n</tr>\n<tr>\n<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>\n<td>HashSet较HashMap来说比较慢</td>\n</tr>\n</tbody></table>\n<h3 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h3><h4 id=\"BlockingQueue是什么？\"><a href=\"#BlockingQueue是什么？\" class=\"headerlink\" title=\"BlockingQueue是什么？\"></a>BlockingQueue是什么？</h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>\n<h4 id=\"在-Queue-中-poll-和-remove-有什么区别？\"><a href=\"#在-Queue-中-poll-和-remove-有什么区别？\" class=\"headerlink\" title=\"在 Queue 中 poll()和 remove()有什么区别？\"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><ul>\n<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>\n<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;String&gt;();</span><br><span class=\"line\">queue. offer(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// add</span></span><br><span class=\"line\">System. out. println(queue. poll());</span><br><span class=\"line\">System. out. println(queue. remove());</span><br><span class=\"line\">System. out. println(queue. size());</span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"说一下-HashMap-的实现原理？\"><a href=\"#说一下-HashMap-的实现原理？\" class=\"headerlink\" title=\"说一下 HashMap 的实现原理？\"></a>说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>\n<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>HashMap 基于 Hash 算法实现的</p>\n<ol>\n<li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li>\n<li>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li>\n<li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>\n<li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li>\n</ol>\n<p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p>\n<h3 id=\"HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现\"><a href=\"#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现\" class=\"headerlink\" title=\"HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现\"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；\\</strong>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法**的方式可以解决哈希冲突。</p>\n<h4 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h4><p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2019121422243983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"jdk1.7中HashMap数据结构\" loading=\"lazy\"></p>\n<h4 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20191214222452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"jdk1.8中HashMap数据结构\" loading=\"lazy\"></p>\n<h4 id=\"JDK1-7-VS-JDK1-8-比较\"><a href=\"#JDK1-7-VS-JDK1-8-比较\" class=\"headerlink\" title=\"JDK1.7 VS JDK1.8 比较\"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p>\n<ol>\n<li>resize 扩容优化</li>\n<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li>\n<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储结构</td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td>初始化方式</td>\n<td>单独函数：<code>inflateTable()</code></td>\n<td>直接集成到了扩容函数<code>resize()</code>中</td>\n</tr>\n<tr>\n<td>hash值计算方式</td>\n<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>\n<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td>存放数据的规则</td>\n<td>无冲突时，存放数组；冲突时，存放链表</td>\n<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>\n</tr>\n<tr>\n<td>插入数据方式</td>\n<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>\n<td>尾插法（直接插入到链表尾部/红黑树）</td>\n</tr>\n<tr>\n<td>扩容后存储位置的计算方式</td>\n<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>\n<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>\n</tr>\n</tbody></table>\n<h3 id=\"HashMap的put方法的具体流程？\"><a href=\"#HashMap的put方法的具体流程？\" class=\"headerlink\" title=\"HashMap的put方法的具体流程？\"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>\n<p>putVal方法执行流程图</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"putVal方法执行流程图\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Map.put和相关方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤①：tab为空则创建 </span></span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤②：计算index，并对null做处理  </span></span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤④：判断该链为红黑树 </span></span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 步骤⑤：该链为链表 </span></span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//判断该链表尾部指针是不是空的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">//链表结构转树形结构</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687</span></span><br></pre></td></tr></table></figure>\n\n<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>\n<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>\n<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>\n<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>\n<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>\n<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>\n<h3 id=\"HashMap的扩容操作是怎么实现的？\"><a href=\"#HashMap的扩容操作是怎么实现的？\" class=\"headerlink\" title=\"HashMap的扩容操作是怎么实现的？\"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>\n<p>②.每次扩展的时候，都是扩展2倍；</p>\n<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>\n<p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//oldTab指向hash桶数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class=\"comment\">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;<span class=\"comment\">//返回</span></span><br><span class=\"line\">        &#125;<span class=\"comment\">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold 双倍扩容阀值threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将该值赋给新的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新的threshold = 新的cap * 0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];<span class=\"comment\">//新建hash桶数组</span></span><br><span class=\"line\">    table = newTab;<span class=\"comment\">//将新数组的值复制给旧的hash桶数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历新数组的所有桶下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"comment\">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;             </span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class=\"line\">                                <span class=\"comment\">// 代表下标保持不变的链表的头元素</span></span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                </span><br><span class=\"line\">                                <span class=\"comment\">// loTail.next指向当前e</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            <span class=\"comment\">// loTail指向当前的元素e</span></span><br><span class=\"line\">                            <span class=\"comment\">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class=\"line\">                            <span class=\"comment\">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class=\"line\">                            <span class=\"comment\">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class=\"line\">                            loTail = e;                           </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap是怎么解决哈希冲突的？\"><a href=\"#HashMap是怎么解决哈希冲突的？\" class=\"headerlink\" title=\"HashMap是怎么解决哈希冲突的？\"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>\n<h4 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h4><p><strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）</strong>；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p>\n<p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p>\n<h4 id=\"什么是哈希冲突？\"><a href=\"#什么是哈希冲突？\" class=\"headerlink\" title=\"什么是哈希冲突？\"></a>什么是哈希冲突？</h4><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易</strong>；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化</p>\n<h4 id=\"hash-函数\"><a href=\"#hash-函数\" class=\"headerlink\" title=\"hash()函数\"></a>hash()函数</h4><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);<span class=\"comment\">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br></pre></td></tr></table></figure>\n\n<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<h4 id=\"JDK1-8新增红黑树\"><a href=\"#JDK1-8新增红黑树\" class=\"headerlink\" title=\"JDK1.8新增红黑树\"></a>JDK1.8新增红黑树</h4><p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTc5OGYxMzg3ZTNmOGRlOWEucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>通过上面的<strong>链地址法（使用散列表）\\</strong>和**扰动函数**我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>\n<p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p>\n<h3 id=\"能否使用任何类作为-Map-的-key？\"><a href=\"#能否使用任何类作为-Map-的-key？\" class=\"headerlink\" title=\"能否使用任何类作为 Map 的 key？\"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p>\n<ul>\n<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>\n<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>\n<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>\n<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>\n</ul>\n<h3 id=\"为什么HashMap中String、Integer这样的包装类适合作为K？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为K？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为K？\"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h3><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>\n<ol>\n<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>\n<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>\n</ol>\n<h3 id=\"如果使用Object作为HashMap的Key，应该怎么办呢？\"><a href=\"#如果使用Object作为HashMap的Key，应该怎么办呢？\" class=\"headerlink\" title=\"如果使用Object作为HashMap的Key，应该怎么办呢？\"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p>\n<ol>\n<li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>\n<li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>\n</ol>\n<h3 id=\"HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？\"><a href=\"#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？\" class=\"headerlink\" title=\"HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？\"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>\n<p><strong>那怎么解决呢？</strong></p>\n<ol>\n<li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li>\n<li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>\n</ol>\n<h3 id=\"HashMap-的长度为什么是2的幂次方\"><a href=\"#HashMap-的长度为什么是2的幂次方\" class=\"headerlink\" title=\"HashMap 的长度为什么是2的幂次方\"></a>HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>\n<p><strong>这个算法应该如何设计呢？</strong></p>\n<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>\n<p><strong>那为什么是两次扰动呢？</strong></p>\n<p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>\n<h3 id=\"HashMap-与-HashTable-有什么区别？\"><a href=\"#HashMap-与-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 与 HashTable 有什么区别？\"></a>HashMap 与 HashTable 有什么区别？</h3><ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>\n<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>\n<li>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>\n</ol>\n<h3 id=\"如何决定使用-HashMap-还是-TreeMap？\"><a href=\"#如何决定使用-HashMap-还是-TreeMap？\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap？\"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>\n<h3 id=\"HashMap-和-ConcurrentHashMap-的区别\"><a href=\"#HashMap-和-ConcurrentHashMap-的区别\" class=\"headerlink\" title=\"HashMap 和 ConcurrentHashMap 的区别\"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol>\n<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li>\n<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-和-Hashtable-的区别？\"><a href=\"#ConcurrentHashMap-和-Hashtable-的区别？\" class=\"headerlink\" title=\"ConcurrentHashMap 和 Hashtable 的区别？\"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）</strong>： ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>JDK1.7的ConcurrentHashMap：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>\n<h3 id=\"ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？\"><a href=\"#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？\"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><p><strong>JDK1.7</strong></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>\n<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>\n<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>\n</ol>\n<p><strong>JDK1.8</strong></p>\n<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>\n<p>结构如下：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>附加源码，有需要的可以看看</strong></p>\n<p>插入元素过程（建议去看看源码）：</p>\n<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br></pre></td></tr></table></figure>\n\n<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">        K ek;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((ek = e.key) == key ||</span><br><span class=\"line\">             (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">            oldVal = e.val;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                e.val = value;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>\n<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>\n</ol>\n<h2 id=\"辅助工具类\"><a href=\"#辅助工具类\" class=\"headerlink\" title=\"辅助工具类\"></a>辅助工具类</h2><h3 id=\"Array-和-ArrayList-有何区别？\"><a href=\"#Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"Array 和 ArrayList 有何区别？\"></a>Array 和 ArrayList 有何区别？</h3><ul>\n<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>\n<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>\n<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>\n</ul>\n<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>\n<h3 id=\"如何实现-Array-和-List-之间的转换？\"><a href=\"#如何实现-Array-和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现 Array 和 List 之间的转换？\"></a>如何实现 Array 和 List 之间的转换？</h3><ul>\n<li>Array 转 List： Arrays. asList(array) ；</li>\n<li>List 转 Array：List 的 toArray() 方法。</li>\n</ul>\n<h3 id=\"comparable-和-comparator的区别？\"><a href=\"#comparable-和-comparator的区别？\" class=\"headerlink\" title=\"comparable 和 comparator的区别？\"></a>comparable 和 comparator的区别？</h3><ul>\n<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>\n<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>\n</ul>\n<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>\n<h3 id=\"Collection-和-Collections-有什么区别？\"><a href=\"#Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别？\"></a>Collection 和 Collections 有什么区别？</h3><ul>\n<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>\n<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>\n</ul>\n<h3 id=\"TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？\"><a href=\"#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？\" class=\"headerlink\" title=\"TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？\"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p>\n<p>Collections 工具类的 sort 方法有两种重载的形式，</p>\n<p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p>\n<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>\n","categories":["集合"],"tags":["集合"]},{"title":"第二次面试（线上+线下）","url":"/2020-11-09-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%E5%A4%A9%E4%B8%A4%E5%AE%B6%E7%BA%BF%E4%B8%8B+%E7%BA%BF%E4%B8%8A%EF%BC%89.html","content":"<h2 id=\"第一个视频面\"><a href=\"#第一个视频面\" class=\"headerlink\" title=\"第一个视频面\"></a>第一个视频面</h2><h3 id=\"1-看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令\"><a href=\"#1-看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令\" class=\"headerlink\" title=\"1.看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令\"></a>1.看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令</h3><p>Servlet的生命周期和人类的参与次数是一样的1  1  n  1  1 次</p>\n<p>阶段 ：    加载         初始化（init)     服务（service）   销毁（destroy）     卸载</p>\n<h3 id=\"2-你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别\"><a href=\"#2-你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别\" class=\"headerlink\" title=\"2.你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别\"></a>2.你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别</h3><h5 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。<strong>JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序</strong>，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>\n<h5 id=\"便于理解：\"><a href=\"#便于理解：\" class=\"headerlink\" title=\"便于理解：\"></a>便于理解：</h5><p>Java -&gt; .java -&gt; .class</p>\n<p>Jsp和Servlet诞生的先后顺序？</p>\n<p>先有的Servlet，后有的Jsp</p>\n<p>​        Servlet :只有Servlet，可以完成页面视图的编写</p>\n<p>​        Jsp：优化Servlet视图编写时遇到的编写困难，效率低等问题</p>\n<ul>\n<li>Jsp在翻译阶段，从.jsp文件会被翻译成.java的Servlet</li>\n<li>编译阶段会将Jsp生成的Servlet编译成可执行的.class</li>\n</ul>\n<h5 id=\"普通Java类，Servlet和Jsp三者之间的关系：\"><a href=\"#普通Java类，Servlet和Jsp三者之间的关系：\" class=\"headerlink\" title=\"普通Java类，Servlet和Jsp三者之间的关系：\"></a>普通Java类，Servlet和Jsp三者之间的关系：</h5><ul>\n<li>Jsp是一个特殊的Servlet，专门用于进行视图呈现</li>\n<li>Servlet是一个特殊的Java类，可以进行对于网络相关功能的实现</li>\n</ul>\n<h5 id=\"jsp定义：\"><a href=\"#jsp定义：\" class=\"headerlink\" title=\"jsp定义：\"></a>jsp定义：</h5><p>jsp的完整形式是Java Server Pages。 它是一项允许开发支持动态内容的网页的技术。 JSP使开发人员可以使用特殊的JSP标记在HTML网页中插入Java代码，这些标记通常以*&lt;％*开头，以*％&gt;*结尾。</p>\n<h5 id=\"Servlet定义：\"><a href=\"#Servlet定义：\" class=\"headerlink\" title=\"Servlet定义：\"></a>Servlet定义：</h5><p>Servlet是一种纯粹是用Java编写的，在Web或应用程序服务器上运行的程序，充当来自Web浏览器或其他HTTP客户端的请求与HTTP服务器上的数据库或应用程序之间的中间层。</p>\n<h3 id=\"3-你用过mysql数据库吗，那么如何清空一张表\"><a href=\"#3-你用过mysql数据库吗，那么如何清空一张表\" class=\"headerlink\" title=\"3.你用过mysql数据库吗，那么如何清空一张表\"></a>3.你用过mysql数据库吗，那么如何清空一张表</h3><ul>\n<li><p>truncate table表名：清空数据表内容使用TRUNCATE语句，它会将您的整张表全部删除掉后再次创建一个新的表，表中没有任何的内容，而且这种操作还是不可逆的。TRUNCATE语句具体的语法为：truncate table表名。</p>\n<p>注意:要先选择好数据库、选择好表别误删 show databases-&gt;use 库名  show table -&gt;truncate table表名 </p>\n</li>\n<li><p>delete from 表名：delete 删除以后， 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p>\n</li>\n</ul>\n<h5 id=\"比-较：\"><a href=\"#比-较：\" class=\"headerlink\" title=\"比 较：\"></a>比 较：</h5><p>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件。</p>\n<h5 id=\"那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？\"><a href=\"#那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？\" class=\"headerlink\" title=\"那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？\"></a>那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？</h5><p><strong>解决该问题主要分两种情况：</strong></p>\n<p>如果不需要保留数据库中所有表的结构，那么答案很简单，执行命令drop database 数据库名  即可达到目的。</p>\n<p>但是如果需要保留该数据库中所有表的结构，只想删除所有表中的数据，又该怎么解决呢？有人会说可以多执行几次truncate操作就OK啦，没错，多执行几次truncate确实可以达到目的，但是，如果要删除的数据库中有很多张表，几十张上百张表，执行上百次truncate操作显然不是好的办法？至此，就是本文要说讲到的办法了。删除的办法其实还是执行truncat方法，只是不需要每次手动的输入truncate命令进行删除。通过sql命令的方式生成所有的truncate语句并写入到.sql脚本文件中，然后执行脚本即可完成删除操作，并且保留了表结构。</p>\n<h3 id=\"4-arraylist、linkedlist、vector的区别\"><a href=\"#4-arraylist、linkedlist、vector的区别\" class=\"headerlink\" title=\"4.arraylist、linkedlist、vector的区别\"></a>4.arraylist、linkedlist、vector的区别</h3><ol>\n<li><p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；vector是线程安全的，Vector类的所有⽅法都是同步的（每个方法都使用了synchronized关键字）。</p>\n</li>\n<li><p><strong>底层数据结构</strong>： Arraylist 底层使⽤的是 Object 数组；vector它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步； LinkedList 底层使⽤的是双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下⾯有介绍到！）</p>\n</li>\n<li><p><strong>插⼊和删除是否受元素位置的影响</strong>：</p>\n<p> ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e)⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插⼊和删除元素的话（ add(int index, E element)）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。</p>\n<p> ② LinkedList 采⽤链表存储，所以对于 add(E e)⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element)） 时间复杂度近似为 o(n))因为需要先移动到指定位置再插⼊。</p>\n</li>\n<li><p><strong>是否⽀持快速随机访问</strong>： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index)⽅法)。</p>\n</li>\n<li><p><strong>内存空间占⽤</strong>： ArrayList的空 间浪费主要体现在在list列表的结尾会预留⼀定的容量空间，⽽LinkedList的空间花费则体现在它的每⼀个元素都需要消耗⽐ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>\n</li>\n</ol>\n<h5 id=\"ArraryList的刨根问底：\"><a href=\"#ArraryList的刨根问底：\" class=\"headerlink\" title=\"ArraryList的刨根问底：\"></a>ArraryList的刨根问底：</h5><h5 id=\"ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\"><a href=\"#ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\" class=\"headerlink\" title=\"ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\"></a>ArrayList有用过吗？它是一个什么东西？可以用来干嘛？</h5><p>有用过；ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组Object[] elementData。</p>\n<p>与它类似的是LinkedList，和LinkedList相比，它的<strong>查找</strong>和<strong>访问</strong>元素的<strong>速度较快</strong>，但新增，删除的速度较慢。</p>\n<h5 id=\"ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？\"><a href=\"#ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？\" class=\"headerlink\" title=\"ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？\"></a>ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</h5><p>通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组**Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}**所以数组容量为0，只有真正对数据进行添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组</span></span><br><span class=\"line\"><span class=\"comment\">//Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;所以数组容量为0，只有真正对数据进行添加</span></span><br><span class=\"line\"><span class=\"comment\">//add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</span></span><br><span class=\"line\">\t </span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Default initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;<span class=\"comment\">//ArrayList默认的大小是10。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？\"><a href=\"#数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？\" class=\"headerlink\" title=\"数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？\"></a>数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？</h5><p>其实实现方式比较简单，他就是通过<strong>数组扩容</strong>的方式去实现的。</p>\n<p>就比如我们现在有一个长度为10的数组，现在我们要新增一个元素，发现已经满了，那ArrayList会怎么做呢？</p>\n<p>第一步他会重新定义一个长度为10+10/2的数组也就是新增一个长度为15的数组。</p>\n<p>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址换到新数组，ArrayList就这样完成了一次改头换面。</p>\n<h5 id=\"我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。\"><a href=\"#我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。\" class=\"headerlink\" title=\"我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。\"></a>我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。</h5><p>有指定index新增，也有直接新增的，在这之前他会有一步校验长度的判断<strong>ensureCapacityInternal</strong>，就是说如果长度不够，是需要扩容的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在扩容的时候，老版本的jdk和8以后的版本是有区别的，8之后的效率更高了，采用了位运算，<strong>右移</strong>一位，其实就是除以2这个操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);<span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>指定位置新增的时候，在校验之后的操作很简单，就是数组的copy，大家可以看下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                         size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如有下面这样一个数组我需要在index 5的位置去新增一个元素A</p>\n<p>1 2 3 4 5 6 7 8 9 _</p>\n<p>那从代码里面我们可以看到，他复制了一个数组，是从index 5的位置开始的，然后把它放在了index 5+1的位置</p>\n<p>1 2 3 4 _ 5 6 7 8 9</p>\n<p>给我们要新增的元素腾出了位置，然后在index的位置放入元素A就完成了新增的操作了</p>\n<p>1 2 3 4 A 5 6 7 8 9</p>\n<p>至于为啥说他效率低，我想我不说你也应该知道了，我这只是在一个这么小的List里面操作，要是我去一个几百几千几万大小的List新增一个元素，那就需要后面所有的元素都复制，然后如果再涉及到扩容啥的就更慢了不是嘛。</p>\n<h5 id=\"我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int-initialCapacity）会不会初始化数组大小？\"><a href=\"#我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int-initialCapacity）会不会初始化数组大小？\" class=\"headerlink\" title=\"我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int initialCapacity）会不会初始化数组大小？\"></a>我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int initialCapacity）会不会初始化数组大小？</h5><p><strong>答：不会初始化数组大小！</strong></p>\n<p>而且将构造函数与initialCapacity结合使用，然后使用set（）会抛出异常，尽管该数组已创建，但是大小设置不正确。</p>\n<p>使用sureCapacity（）也不起作用，因为它基于elementData数组而不是大小。</p>\n<p>还有其他副作用，这是因为带有sureCapacity（）的静态DEFAULT_CAPACITY。</p>\n<p>进行此工作的唯一方法是在使用构造函数后，根据需要使用add（）多次。</p>\n<p>大家可能有点懵，我直接操作一下代码，大家会发现我们虽然对ArrayList设置了初始大小，但是我们打印List大小的时候还是0，我们操作下标set值的时候也会报错，数组下标越界。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ArrayList插入删除一定慢么？\"><a href=\"#ArrayList插入删除一定慢么？\" class=\"headerlink\" title=\"ArrayList插入删除一定慢么？\"></a>ArrayList插入删除一定慢么？</h5><p>取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。</p>\n<h5 id=\"那他的删除怎么实现的呢？\"><a href=\"#那他的删除怎么实现的呢？\" class=\"headerlink\" title=\"那他的删除怎么实现的呢？\"></a>那他的删除怎么实现的呢？</h5><p>删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在copy一个数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">       rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">       modCount++;</span><br><span class=\"line\">       E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                            numMoved);</span><br><span class=\"line\">       elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续打个比方，我们现在要删除下面这个数组中的index5这个位置</p>\n<p>1 2 3 4 5 6 7 8 9 _</p>\n<p>那代码他就复制一个index5+1开始到最后的数组，然后把它放到index开始的位置</p>\n<p>1 2 3 4 6 7 8 9 _ _</p>\n<p>index5的位置就成功被”删除“了其实就是被覆盖了，给了你被删除的感觉。</p>\n<p>同理他的效率也低，因为数组如果很大的话，一样需要复制和移动的位置就大了。</p>\n<h5 id=\"ArrayList是线程安全的么？\"><a href=\"#ArrayList是线程安全的么？\" class=\"headerlink\" title=\"ArrayList是线程安全的么？\"></a>ArrayList是线程安全的么？</h5><p>当然不是，线程安全版本的数组容器是Vector。</p>\n<p>Vector的实现很简单，就是把所有的方法统统加上synchronized就完事了。</p>\n<p>你也可以不使用Vector，用Collections.synchronizedList把一个普通ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized。</p>\n<h5 id=\"ArrayList用来做队列合适么？\"><a href=\"#ArrayList用来做队列合适么？\" class=\"headerlink\" title=\"ArrayList用来做队列合适么？\"></a>ArrayList用来做队列合适么？</h5><p>队列一般是FIFO（先入先出）的，如果用ArrayList做队列，就需要在数组尾部追加数据，数组头部删除数组，反过来也可以。</p>\n<p>但是无论如何总会有一个操作会涉及到数组的数据搬迁，这个是比较耗费性能的。</p>\n<p><strong>结论</strong>：ArrayList不适合做队列。</p>\n<h5 id=\"那数组适合用来做队列么？\"><a href=\"#那数组适合用来做队列么？\" class=\"headerlink\" title=\"那数组适合用来做队列么？\"></a>那数组适合用来做队列么？</h5><p>数组是非常合适的。</p>\n<p>简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。</p>\n<h5 id=\"ArrayList的遍历和LinkedList遍历性能比较如何？\"><a href=\"#ArrayList的遍历和LinkedList遍历性能比较如何？\" class=\"headerlink\" title=\"ArrayList的遍历和LinkedList遍历性能比较如何？\"></a>ArrayList的遍历和LinkedList遍历性能比较如何？</h5><p>论遍历ArrayList要比LinkedList快得多，<strong>ArrayList遍历最大的优势在于内存的连续性</strong>，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>ArrayList就是动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了动态的增加和减少元素，实现了Collection和List接口，灵活的设置数组的大小等好处。</p>\n<p>面试里面问的时候没HashMap，ConcurrentHashMap啥的这么常问，但是也有一定概率问到的，还是那句话，<strong>不打没把握的仗</strong>。</p>\n<p>我们在源码阅读过程中，不需要全部都读懂，需要做的就是读懂核心的源码，加深自己对概念的理解就好了，用的时候不至于啥都不知道，不要为了用而用就好了。</p>\n<h3 id=\"补充内容：\"><a href=\"#补充内容：\" class=\"headerlink\" title=\"补充内容：\"></a>补充内容：</h3><h5 id=\"1-RandomAccess-接口：\"><a href=\"#1-RandomAccess-接口：\" class=\"headerlink\" title=\"1.RandomAccess 接口：\"></a>1.RandomAccess 接口：</h5><p>ArrayList 实现了 RandomAccess 接⼝， ⽽ LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ ArrayList 底层是数组，⽽ LinkedList 底层是链表。数组天然⽀持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不⽀持快速随机访问。， ArrayList 实现了 RandomAccess 接⼝，就表明了他具有快速随机访问功能。 RandomAccess 接⼝只是标识，并不是说 ArrayList 实现 RandomAccess 接⼝才具有快速随机访问功能的！</p>\n<h5 id=\"2-下⾯再总结⼀下-list-的遍历⽅式选择：\"><a href=\"#2-下⾯再总结⼀下-list-的遍历⽅式选择：\" class=\"headerlink\" title=\"2.下⾯再总结⼀下 list 的遍历⽅式选择：\"></a>2.下⾯再总结⼀下 list 的遍历⽅式选择：</h5><p>实现了 RandomAccess 接⼝的list，优先选择普通 for 循环 ，其次 foreach,未实现 RandomAccess接⼝的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），⼤size的数据，千万不要使⽤普通for循环</p>\n<h5 id=\"3-双向链表和双向循环链表\"><a href=\"#3-双向链表和双向循环链表\" class=\"headerlink\" title=\"3.双向链表和双向循环链表\"></a>3.双向链表和双向循环链表</h5><p>双向链表： 包含两个指针，⼀个prev指向前⼀个节点，⼀个next指向后⼀个节点。</p>\n<p>双向循环链表： 最后⼀个节点的 next 指向head，⽽ head 的prev指向最后⼀个节点，构成⼀个环。</p>\n<h3 id=\"5-说一说session和cookie，区别\"><a href=\"#5-说一说session和cookie，区别\" class=\"headerlink\" title=\"5.说一说session和cookie，区别\"></a>5.说一说session和cookie，区别</h3><p><strong>session和cookie，都是解决http无状态的问题</strong></p>\n<p><strong>Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样；</strong></p>\n<p>维基百科是这样定义 <strong>Cookie</strong> 的：Cookies是某些⽹站为了<strong>辨别⽤户身份⽽储存在⽤户本地终端上的数据</strong>（通常经过加密）。简单来说： Cookie 存放在客户端，⼀般⽤来保存⽤户信息。典型的场景是我们在 Cookie 中保存已经登录过的⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了。除此之外，Cookie 还能保存⽤户⾸选项，主题和其他设置信息。</p>\n<p><strong>Session</strong> 的主要作⽤就是通过<strong>服务端记录⽤户的状态</strong>。 典型的场景是购物⻋，当你要添加商品到购物<br>⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定<br>的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。</p>\n<h5 id=\"区别：-1\"><a href=\"#区别：-1\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p><strong>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端；session有效期相对cookie较短。</strong>相对来说 Session 安全性更⾼。如果使⽤ Cookie 的⼀些敏感信息不要写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。</p>\n<h3 id=\"补充内容：-1\"><a href=\"#补充内容：-1\" class=\"headerlink\" title=\"补充内容：\"></a>补充内容：</h3><h5 id=\"1-如何使⽤Session进⾏身份验证？\"><a href=\"#1-如何使⽤Session进⾏身份验证？\" class=\"headerlink\" title=\"1.如何使⽤Session进⾏身份验证？\"></a>1.如何使⽤Session进⾏身份验证？</h5><p>很多时候我们都是通过 SessionID 来实现特定的⽤户，SessionID ⼀般会选择存放在 Redis 中。举个例⼦：⽤户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当⽤户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证⽅式更详细的过程如下：</p>\n<ol>\n<li> ⽤户向服务器发送⽤户名和密码⽤于登陆系统。</li>\n<li> 服务器验证通过后，服务器为⽤户创建⼀个 Session，并将 Session信息存储 起来。</li>\n<li> 服务器向⽤户返回⼀个 SessionID，写⼊⽤户的 Cookie。</li>\n<li> 当⽤户保持登录状态时，Cookie 将与每个后续请求⼀起被发送出去。</li>\n<li> 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进⾏⽐较，以验证⽤户的身份，返回给⽤户客户端响应信息的时候会附带⽤户当前的状态。</li>\n</ol>\n<p>使⽤ Session 的时候需要注意下⾯⼏个点：</p>\n<ol>\n<li>依赖Session的关键业务⼀定要确保客户端开启了Cookie</li>\n<li>注意Session的过期时间</li>\n</ol>\n<h5 id=\"2-如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）\"><a href=\"#2-如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）\" class=\"headerlink\" title=\"2.如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）\"></a>2.如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）</h5><p>⼀般是通过 Cookie 来保存 SessionID ，假如你使⽤了 Cookie 保存 SessionID的⽅案的话， 如果客户端禁⽤了Cookie，那么Seesion就⽆法正常⼯作。例如：在访问网页端某东时禁用Cookie后就不能访问了。但是，并不是没有 Cookie 之后就不能⽤ Session 了，⽐如你可以将SessionID放在请求的 url ⾥⾯ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vP3Nlc3Npb25faWQ9eHh4\">https://javaguide.cn/?session_id=xxx<i class=\"fa fa-external-link-alt\"></i></span> 。这种⽅案的话可⾏，但是安全性和⽤户体验感降低。当然，为了你也可以对 SessionID 进⾏⼀次加密之后再传⼊后端。</p>\n<h5 id=\"3-为什么Cookie-⽆法防⽌CSRF攻击，⽽token可以？\"><a href=\"#3-为什么Cookie-⽆法防⽌CSRF攻击，⽽token可以？\" class=\"headerlink\" title=\"3.为什么Cookie ⽆法防⽌CSRF攻击，⽽token可以？\"></a>3.为什么Cookie ⽆法防⽌CSRF攻击，⽽token可以？</h5><p><strong>CSRF</strong>（Cross Site Request Forgery）⼀般被翻译为 <strong>跨站请求伪造</strong> 。那么什么是 跨站请求伪造 呢？说简单⽤你的身份去发送⼀些对你不友好的请求。举个简单的例⼦：</p>\n<p>⼩明登录了某⽹上银⾏，他来到了⽹上银⾏的帖⼦区，看到⼀个帖⼦下⾯有⼀个链接写着“科学理财，年盈利率过万”，⼩明好奇的点开了这个链接，&lt;a src=<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5teWJhbmsuY29tL1RyYW5zZmVyP2JhbmtJZD0xMSZhbXA7bW9uZXk9MTAwMDAmZ3Q7JUU3JUE3JTkxJUU1JUFEJUE2JUU3JTkwJTg2JUU4JUI0JUEyJUVGJUJDJThDJUU1JUI5JUI0JUU3JTlCJTg4JUU1JTg4JUE5JUU3JThFJTg3JUU4JUJGJTg3JUU0JUI4JTg3\">http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万<i class=\"fa fa-external-link-alt\"></i></span>&lt;/&gt;结果发现⾃⼰的账户少了10000元。这是这么回事呢？原来⿊客在链接中藏了⼀个请求，这个请求直接利⽤⼩壮的身份给银⾏发送了⼀个转账请求,也就是通过你的 Cookie 向银⾏发出请求。上⾯也提到过，进⾏Session 认证的时候，我们⼀般使⽤ Cookie 来存储 SessionId,当我们登陆后后端⽣成⼀个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储⼯具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个⼈。如果别⼈通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让⽤户误点攻击链接，达到攻击效果。但是，我们使⽤ token 的话就不会存在这个问题，<strong>在我们登录成功获得 token 之后，⼀般会选择存放在 local storage 中。</strong>然后我们在前端通过某些⽅式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了⾮法链接发送了请求到服务端，这个⾮法请求是不会携带 token 的，所以这个请求将是⾮法的。<strong>需要注意的是不论是 Cookie 还是 token 都⽆法避免跨站脚本攻击（Cross Site Scripting）XSS</strong>。跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading StyleSheets，CSS）的缩写混淆。因此，有⼈将跨站脚本攻击缩写为XSS。<strong>XSS中攻击者会⽤各种⽅式将恶意代码注⼊到其他⽤户的⻚⾯中。就可以通过脚本盗⽤信息⽐如cookie。</strong><br>推荐阅读：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMTAvMTEvZmUtc2VjdXJpdHktY3NyZi5odG1s\">如何防⽌CSRF攻击？——美团技术团队<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h5 id=\"4-什么是-Token-什么是-JWT-如何基于Token进⾏身份验证？\"><a href=\"#4-什么是-Token-什么是-JWT-如何基于Token进⾏身份验证？\" class=\"headerlink\" title=\"4.什么是 Token?什么是 JWT?如何基于Token进⾏身份验证？\"></a>4.什么是 Token?什么是 JWT?如何基于Token进⾏身份验证？</h5><p>Token：Token不需要⾃⼰存放 Session 信息就能实现身份验证的⽅式；</p>\n<p>JWT ：JWT （JSON Web Token） 就是这种⽅式的实现，通过这种⽅式服务器端就不需要保存 Session 数据了，只⽤在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。JWT  本质上就⼀段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p>\n<h5 id=\"JWT-由-3-部分构成\"><a href=\"#JWT-由-3-部分构成\" class=\"headerlink\" title=\"JWT 由 3 部分构成:\"></a>JWT 由 3 部分构成:</h5><ol>\n<li>Header :描述 JWT 的元数据。定义了⽣成签名的算法以及 Token 的类型。</li>\n<li>Payload（负载）:⽤来存放实际需要传递的数据</li>\n<li>Signature（签名）：服务器通过 Payload、 Header和⼀个密钥(secret)使⽤ Header ⾥⾯指定的签名算法（默认是 HMAC SHA256）⽣成。</li>\n</ol>\n<p><strong>实现原理</strong>：在基于 Token 进⾏身份验证的的应⽤程序中，服务器通过 Payload、 Header和⼀个密钥(secret)创建令牌（ Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage ⾥⾯，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie ⾥⾯⾃动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中： Authorization: Bearer Token。</p>\n<h5 id=\"具体过程：\"><a href=\"#具体过程：\" class=\"headerlink\" title=\"具体过程：\"></a>具体过程：</h5><ol>\n<li>⽤户向服务器发送⽤户名和密码⽤于登陆系统。</li>\n<li>身份验证服务响应并返回了签名的 JWT，上⾯包含了⽤户是谁的内容。</li>\n<li>⽤户以后每次向后端发请求都在Header中带上 JWT。</li>\n<li>服务端检查 JWT 并从中获取⽤户相关信息。</li>\n</ol>\n<h3 id=\"6-用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢\"><a href=\"#6-用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢\" class=\"headerlink\" title=\"6.用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢\"></a>6.用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢</h3><p><strong>HashMap</strong>不能保证元素的顺序,HashMap能够将键设为<strong>null (一个key,实现map接口)**，也可以将值设为</strong>null（多个null）<strong>。与之对应的是</strong>Hashtable**,(注意大小写：不是HashTable)，Hashtable不能将键和值设为null，否则运行时会报空指针异常错误。</p>\n<h5 id=\"原因：\"><a href=\"#原因：\" class=\"headerlink\" title=\"原因：\"></a>原因：</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HashMap的put</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    ....</span><br><span class=\"line\"><span class=\"comment\">//Hashtable的put</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Make sure the value is not null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别:\"></a>区别:</h5><ol>\n<li><p>线程是否安全： HashMap 是⾮线程安全的，Hashtable 是线程安全的；<strong>Hashtable 内部的⽅法基本都经过 synchronized 修饰</strong>。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap吧！）；</p>\n</li>\n<li><p>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，Hashtable 基本被淘汰，不要在代码中使⽤它；</p>\n</li>\n<li><p>对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有⼀个 null，直接抛出 NullPointerException。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①<strong>创建时如果不指定容量初始值，Hashtable 默认的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后每次扩充（resize（）），容量变为原来的2倍</strong>。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 <strong>tableSizeFor</strong>()⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是2的幂次⽅。</li>\n<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</li>\n</ol>\n<p><strong>HashMap中的key可以是任何对象或数据类型吗</strong></p>\n<ul>\n<li><strong>可以为null，但不能是可变对象</strong>，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li>\n<li><strong>如果可变对象在 HashMap 中被用作键</strong>，<strong>那就要小心在改变对象状态的时候，不要改变它的哈希值了</strong>。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li>\n</ul>\n<p><strong>HashMap 中的构造函数：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal initial </span></span><br><span class=\"line\"><span class=\"string\">capacity: &quot;</span> + initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal load factor: &quot;</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    <span class=\"comment\">//最终也会调用到上面的构造函数，不过这个默认的负载因子就是 HashMap 的默认负载因子也就是 0.75f</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class=\"comment\">//带有 Map 的构造函数，会直接把外部元素批量放入 HashMap 中。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">  putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;                                               </span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>下⾯这个⽅法（tableSizeFor）保证了 HashMap 总是使⽤2的幂作为哈希表的⼤⼩。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY </span><br><span class=\"line\">: n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//  &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  比如7的二进制是0111，7&gt;&gt;&gt;2表示右移2位，变成001，即为1</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  cap=8;n=7;n=0111  n|n&gt;&gt;&gt;1 = 0111 | 0011 = 0111 n|n&gt;&gt;&gt;2 0111 | 0001 = 0111</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//\tn|n&gt;&gt;&gt;4 0111 | 0000 = 0111 最后一步 return=n+1=8</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  综上可得，当hashMap指定初始值的时候，会调用tableSizeFor方法，总是返回2的n次方的值；</span></span><br><span class=\"line\">        <span class=\"comment\">//  并且总是等于该算法接近该初始值并比它大的那个值;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  就是让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。当指定初始值入参</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//\t为0时，返回实际容量为1。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;<span class=\"comment\">//最大容量为2的30次方\t </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        \t <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">     \t    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">   \t\t\t &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//DK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的</span></span><br><span class=\"line\">    <span class=\"comment\">//hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置</span></span><br><span class=\"line\"> \t<span class=\"comment\">//（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash</span></span><br><span class=\"line\">\t<span class=\"comment\">//值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span><br><span class=\"line\">\t<span class=\"comment\">//所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现</span></span><br><span class=\"line\">\t<span class=\"comment\">//⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t <span class=\"comment\">// 1. HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash \t     </span></span><br><span class=\"line\">\t <span class=\"comment\">//的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</span></span><br><span class=\"line\">\t <span class=\"comment\">// 2. 由于HashMap规定了其容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小。使用位运算同时\t </span></span><br><span class=\"line\">     <span class=\"comment\">//还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于\t           </span></span><br><span class=\"line\">     <span class=\"comment\">//HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运\t</span></span><br><span class=\"line\">     <span class=\"comment\">//算符表示就是 1 &lt;&lt; 30，int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16;</span></span><br><span class=\"line\">      <span class=\"comment\">// 默认初始容量为16，必须为2的幂</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;<span class=\"comment\">// 默认加载因子0.75；</span></span><br><span class=\"line\">\t<span class=\"comment\">//HashMap默认初始容量16，加载因子0.75，也就是说最多能放16*0.75=12个元素，当put第13个时，HashMap\t</span></span><br><span class=\"line\">    <span class=\"comment\">//将发生rehash，rehash的一系列处理比较影响性能，所以当我们需要向HashMap存放较多元素时，最好指定合   </span></span><br><span class=\"line\">    <span class=\"comment\">//适的初始容量和加载因子，否则HashMap默认只能存12个元素，将会发生多次rehash操作。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\"><a href=\"#HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\" class=\"headerlink\" title=\"HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩\"></a>HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩</h5><ol>\n<li>HashMap<strong>在确定数组下标Index的时候</strong>，采用的是( length-1) &amp; hash 的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</li>\n<li>由于HashMap规定了其<strong>容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小</strong>。使用位运算同时还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30，<strong>int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</strong></li>\n</ol>\n<h2 id=\"讲一讲-HashMap-put-的全过程\"><a href=\"#讲一讲-HashMap-put-的全过程\" class=\"headerlink\" title=\"讲一讲 HashMap put 的全过程\"></a>讲一讲 HashMap put 的全过程</h2><p>以 JDK 1.8 为基准进行分析，后面也是。先贴出整段代码，后面会逐行进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">  <span class=\"comment\">// 如果table 为null 或者没有为 table 分配内存，就resize一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    n = (tab = resize()).length;</span><br><span class=\"line\">  <span class=\"comment\">// 指定hash值节点为空则直接插入，这个(n - 1) &amp; hash才是表中真正的哈希</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">    <span class=\"comment\">// 计算表中的这个真正的哈希值与要插入的key.hash相比</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\">    <span class=\"comment\">// 若不同的话，并且当前节点已经在 TreeNode 上了</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">      <span class=\"comment\">// 采用红黑树存储方式</span></span><br><span class=\"line\">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">    <span class=\"comment\">// key.hash 不同并且也不再 TreeNode 上，在链表上找到 p.next==null</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在表尾插入</span></span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 新增节点后如果节点个数到达阈值，则进入 treeifyBin() 进行再次判断</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了同 hash、key 的节点，那么直接退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 p 指向下一节点</span></span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// map中含有旧值，返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">      afterNodeAccess(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// map调整次数 + 1</span></span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"comment\">// 键值对的数量达到阈值，需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    resize();</span><br><span class=\"line\">  afterNodeInsertion(evict);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先看一下 <code>putVal</code> 方法，这个方法是 final 的，如果你自已定义 HashMap 继承的话，是不允许你自己重写 put 方法的，然后这个方法涉及五个参数</p>\n<ul>\n<li>hash -&gt; put 放在桶中的位置，在 put 之前，会进行 hash 函数的计算。</li>\n<li>key -&gt; 参数的 key 值</li>\n<li>value -&gt; 参数的 value 值</li>\n<li>onlyIfAbsent -&gt; 是否改变已经存在的值，也就是是否进行 value 值的替换标志</li>\n<li>evict -&gt; 是否是刚创建 HashMap 的标志</li>\n</ul>\n<p><strong>在调用到 putVal 方法时，首先会进行 hash 函数计算应该插入的位置</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哈希函数的源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>hash 函数会根据你传递的 key 值进行计算，首先计算 key 的 <code>hashCode</code> 值，然后再对 hashcode 进行无符号右移操作，最后再和 hashCode 进行<code>异或 ^</code> 操作。</p>\n<ul>\n<li><code>&gt;&gt;&gt;</code>: 无符号右移操作，它指的是 <strong>无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong> ，也就是不管是正数还是负数，右移都会在空缺位补 0 。</li>\n</ul>\n<p>在得到 hash 值后，就会进行 put 过程。</p>\n<p>首先会判断 HashMap 中的 Node 数组是否为 null，如果第一次创建 HashMap 并进行第一次插入元素，首先会进行数组的 resize，也就是<code>重新分配</code>，这里还涉及到一个 <code>resize()</code> 扩容机制源码分析，我们后面会介绍。<strong>扩容完毕后，会计算出 HashMap 的存放位置，通过使用 ( n - 1 ) &amp; hash 进行计算得出。</strong></p>\n<p>然后会把这个位置作为数组的下标作为存放元素的位置。如果不为空，那么计算表中的这个真正的哈希值与要插入的 key.hash 相比。如果哈希值相同，key-value 不一样，再判断是否是树的实例，如果是的话，那么就把它插入到树上。如果不是，就执行尾插法在 entry 链尾进行插入。</p>\n<h3 id=\"扩容机制\"><a href=\"#扩容机制\" class=\"headerlink\" title=\"扩容机制\"></a>扩容机制</h3><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。好在 HashMap 是一种自动扩容的数据结构，在这种基于变长的数据结构中，扩容机制是非常重要的。</p>\n<p>在 HashMap 中，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。HashMap 中的扩容机制是由 <code>resize()</code> 方法来实现的，下面我们就来一次认识下。（贴出中文注释，便于复制）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  <span class=\"comment\">// 存储old table 的大小</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  <span class=\"comment\">// 存储扩容阈值</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果old table数据已达最大，那么threshold也被设置成最大</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">      threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 左移扩大二倍,</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">      <span class=\"comment\">// 扩容成原来二倍</span></span><br><span class=\"line\">      newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果oldThr                                                                                                                                               !&gt; 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">    newCap = oldThr;</span><br><span class=\"line\">  <span class=\"comment\">// 如果old table &lt;= 0 并且 存储的阈值 &lt;= 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">    newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果扩充阈值为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容阈值为 初始容量*负载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">              (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 重新给负载因子赋值</span></span><br><span class=\"line\">  threshold = newThr;</span><br><span class=\"line\">  <span class=\"comment\">// 获取扩容后的数组</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">  table = newTab;</span><br><span class=\"line\">  <span class=\"comment\">// 如果第一次进行table 初始化不会走下面的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 扩容之后需要重新把节点放在新扩容的数组中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt; e;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">          <span class=\"comment\">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class=\"line\">          ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">          Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; next;</span><br><span class=\"line\">          <span class=\"comment\">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">              loTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">              hiTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 将分组后的链表映射到新桶中</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j] = loHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们以 if...else if...else 逻辑进行拆分，上面代码主要做了这几个事情</p>\n<ul>\n<li>判断 HashMap 中的数组的长度，也就是 <code>(Node&lt;K,V&gt;[])oldTab.length()</code> ，再判断数组的长度是否比最大的的长度也就是 2^30 次幂要大，大的话直接取最大长度，否则利用位运算 <code>&lt;&lt;</code>扩容为原来的两倍</li>\n<li>如果数组长度不大于0 ，再判断扩容阈值 <code>threshold</code> 是否大于 0 ，也就是看有无外部指定的扩容阈值，若有则使用，这里需要说明一下 threshold 何时是 <code>oldThr &gt; 0</code>，因为 oldThr = threshold ，这里其实比较的就是 threshold，因为 HashMap 中的每个构造方法都会调用 <code>HashMap(initCapacity,loadFactor)</code> 这个构造方法，所以如果没有外部指定 initialCapacity，初始容量使用的就是 16，然后根据 <code>this.threshold = tableSizeFor(initialCapacity);</code> 求得 threshold 的值。</li>\n</ul>\n<p>然后会判断 newThr 是否为 0 ，笔者在刚开始研究时发现 <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code> 一直以为这是常量做乘法，怎么会为 0 ，其实不是这部分的问题，在于上面逻辑判断中的扩容操作，可能会导致<code>位溢出</code>。</p>\n<p>导致位溢出的示例：oldCap = 2^28 次幂，threshold &gt; 2 的三次方整数次幂。在进入到 <code>float ft = (float)newCap * loadFactor;</code> 这个方法是 2^28 * 2^(3+n) 会直接 &gt; 2^31 次幂，导致全部归零。</p>\n<p><strong>在扩容后需要把节点放在新扩容的数组中，这里也涉及到三个步骤</strong></p>\n<ul>\n<li>循环桶中的每个 Node 节点，判断 Node[i] 是否为空，为空直接返回，不为空则遍历桶数组，并将键值对映射到新的桶数组中。</li>\n<li>如果不为空，再判断是否是树形结构，如果是树形结构则按照树形结构进行拆分，拆分方法在 <code>split</code> 方法中。</li>\n<li>如果不是树形结构，则遍历链表，并将链表节点按原顺序进行分组。</li>\n</ul>\n<h3 id=\"讲一讲-get-方法全过程\"><a href=\"#讲一讲-get-方法全过程\" class=\"headerlink\" title=\"讲一讲 get 方法全过程\"></a>讲一讲 get 方法全过程</h3><p>我们上面讲了 HashMap 中的 put 方法全过程，下面我们来看一下 <code>get</code> 方法的过程，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找到真实的元素位置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 总是会check 一下第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">        ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是第一个元素，并且下一个元素不是空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否属于 TreeNode，如果是 TreeNode 实例，直接从 TreeNode.getTreeNode 取</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果还不是 TreeNode 实例，就直接循环数组元素，直到找到指定元素位置</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来简单介绍下吧，首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<p><code>getNode</code> 方法有一个比较重要的过程就是 <strong>(n - 1) &amp; hash</strong>，这段代码是确定需要查找的桶的位置的，那么，为什么要 (n - 1) &amp; hash 呢？</p>\n<p>n 就是 HashMap 中桶的数量，这句话的意思也就是说 (n - 1) &amp; hash 就是 (桶的容量 - 1) &amp; hash</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为什么 HashMap 的检索位置是 (table.size - 1) &amp; hash</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 49</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 50</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 51</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么每次算完之后的 (n - 1) &amp; hash ，依次为1 2 3 </p>\n<h3 id=\"HashMap-的遍历方式\"><a href=\"#HashMap-的遍历方式\" class=\"headerlink\" title=\"HashMap 的遍历方式\"></a>HashMap 的遍历方式</h3><p>HashMap 的遍历，也是一个使用频次特别高的操作</p>\n<p>HashMap 遍历的基类是 <code>HashIterator</code>，它是一个 Hash 迭代器，它是一个 HashMap 内部的抽象类，它的构造比较简单，只有三种方法，<strong>hasNext 、 remove 和 nextNode</strong> 方法，其中 nextNode 方法是由三种迭代器实现的</p>\n<p>这三种迭代器就就是</p>\n<ul>\n<li><code>KeyIterator</code> ，对 key 进行遍历</li>\n<li><code>ValueIterator</code>，对 value 进行遍历</li>\n<li><code>EntryIterator</code>， 对 Entry 链进行遍历</li>\n</ul>\n<p>虽然说看着迭代器比较多，但其实他们的遍历顺序都是一样的，构造也非常简单，都是使用 <code>HashIterator</code> 中的 <code>nextNode</code> 方法进行遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().key; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().value; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntryIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Map.<span class=\"function\">Entry&lt;K,V&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HashIterator 中的遍历方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashIterator</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; next;        <span class=\"comment\">// 下一个 entry 节点</span></span><br><span class=\"line\">  Node&lt;K,V&gt; current;     <span class=\"comment\">// 当前 entry 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> expectedModCount;  <span class=\"comment\">// fail-fast 的判断标识</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> index;             <span class=\"comment\">// 当前槽</span></span><br><span class=\"line\"></span><br><span class=\"line\">  HashIterator() &#123;</span><br><span class=\"line\">    expectedModCount = modCount;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t = table;</span><br><span class=\"line\">    current = next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// advance to first entry</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">nextNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t;</span><br><span class=\"line\">    Node&lt;K,V&gt; e = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((next = (current = e).next) == <span class=\"keyword\">null</span> &amp;&amp; (t = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>next 和 current 分别表示下一个 Node 节点和当前的 Node 节点，HashIterator 在初始化时会遍历所有的节点。下面我们用图来表示一下他们的遍历顺序</p>\n<p>你会发现 <code>nextNode()</code> 方法的遍历方式和 HashIterator 的遍历方式一样，只不过判断条件不一样，构造 HashIterator 的时候判断条件是有没有链表，桶是否为 null，而遍历 nextNode 的判断条件变为下一个 node 节点是不是 null ，并且桶是不是为 null。</p>\n<h3 id=\"HashMap-中的移除方法\"><a href=\"#HashMap-中的移除方法\" class=\"headerlink\" title=\"HashMap 中的移除方法\"></a>HashMap 中的移除方法</h3><p>HashMap 中的移除方法也比较简单了，源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">    <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      node = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">              ((k = e.key) == key ||</span><br><span class=\"line\">               (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">            node = e;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          p = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                         (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">        tab[index] = node.next;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        p.next = node.next;</span><br><span class=\"line\">      ++modCount;</span><br><span class=\"line\">      --size;</span><br><span class=\"line\">      afterNodeRemoval(node);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remove 方法有很多，最终都会调用到 removeNode 方法，只不过传递的参数值不同，我们拿 remove(object) 来演示一下。</p>\n<p>首先会通过 hash 来找到对应的 bucket，然后通过遍历链表，找到键值相等的节点，然后把对应的节点进行删除。</p>\n<h2 id=\"关于-HashMap-的面试题\"><a href=\"#关于-HashMap-的面试题\" class=\"headerlink\" title=\"关于 HashMap 的面试题\"></a>关于 HashMap 的面试题</h2><h3 id=\"HashMap-的数据结构\"><a href=\"#HashMap-的数据结构\" class=\"headerlink\" title=\"HashMap 的数据结构\"></a>HashMap 的数据结构</h3><p>JDK1.7 中，HashMap 采用<code>位桶 + 链表</code>的实现，即使用<code>链表</code>来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。</p>\n<p>所以，与 JDK 1.7 相比，JDK 1.8 在底层结构方面做了一些改变，当每个桶中元素大于 8 的时候，会转变为红黑树，目的就是优化查询效率。</p>\n<h3 id=\"HashMap-的-put-过程\"><a href=\"#HashMap-的-put-过程\" class=\"headerlink\" title=\"HashMap 的 put 过程\"></a>HashMap 的 put 过程</h3><p>大致过程如下，首先会使用 hash 方法计算对象的哈希码，根据哈希码来确定在 bucket 中存放的位置，如果 bucket 中没有 Node 节点则直接进行 put，如果对应 bucket 已经有 Node 节点，会对链表长度进行分析，判断长度是否大于 8，如果链表长度小于 8 ，在 JDK1.7 前会使用头插法，在 JDK1.8 之后更改为尾插法。如果链表长度大于 8 会进行树化操作，把链表转换为红黑树，在红黑树上进行存储。</p>\n<h3 id=\"HashMap-为啥线程不安全\"><a href=\"#HashMap-为啥线程不安全\" class=\"headerlink\" title=\"HashMap 为啥线程不安全\"></a>HashMap 为啥线程不安全</h3><p>HashMap 不是一个线程安全的容器，不安全性体现在多线程并发对 HashMap 进行 put 操作上。如果有两个线程 A 和 B ，首先 A 希望插入一个键值对到 HashMap 中，在决定好桶的位置进行 put 时，此时 A 的时间片正好用完了，轮到 B 运行，B 运行后执行和 A 一样的操作，只不过 B 成功把键值对插入进去了。如果 A 和 B 插入的位置（桶）是一样的，那么线程 A 继续执行后就会覆盖 B 的记录，造成了数据不一致问题。</p>\n<p>还有一点在于 HashMap 在扩容时，因 resize 方法会形成环，造成死循环，导致 CPU 飙高。</p>\n<h3 id=\"HashMap-是如何处理哈希（冲突）碰撞的\"><a href=\"#HashMap-是如何处理哈希（冲突）碰撞的\" class=\"headerlink\" title=\"HashMap 是如何处理哈希（冲突）碰撞的\"></a>HashMap 是如何处理哈希（冲突）碰撞的</h3><p>HashMap 底层是使用位桶 + 链表实现的，位桶决定元素的插入位置，位桶是由 hash 方法决定的，当多个元素的 hash 计算得到相同的哈希值后，HashMap 会把多个 Node 元素都放在对应的位桶中，形成链表，这种处理哈希碰撞的方式被称为链地址法。</p>\n<p>其他处理 hash 碰撞的方式还有 <strong>开放地址法、rehash 方法、建立一个公共溢出区</strong>这几种方法。</p>\n<h3 id=\"HashMap-是如何-get-元素的\"><a href=\"#HashMap-是如何-get-元素的\" class=\"headerlink\" title=\"HashMap 是如何 get 元素的\"></a>HashMap 是如何 get 元素的</h3><p>首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<h3 id=\"HashMap-和-HashTable-有什么区别\"><a href=\"#HashMap-和-HashTable-有什么区别\" class=\"headerlink\" title=\"HashMap 和 HashTable 有什么区别\"></a>HashMap 和 HashTable 有什么区别</h3><p>父类不同：HashMap 继承了 <code>AbstractMap</code> 类，而 HashTable 继承了 <code>Dictionary</code> 类</p>\n<p>空值不同：HashMap 允许空的 key 和 value 值，HashTable 不允许空的 key 和 value 值。HashMap 会把 Null key 当做普通的 key 对待。不允许 null key 重复。</p>\n<p>线程安全性：HashMap 不是线程安全的，如果多个外部操作同时修改 HashMap 的数据结构比如 add 或者是 delete，必须进行同步操作，仅仅对 key 或者 value 的修改不是改变数据结构的操作。可以选择构造线程安全的 Map 比如 <code>Collections.synchronizedMap</code> 或者是 <code>ConcurrentHashMap</code>。而 HashTable 本身就是线程安全的容器。</p>\n<p>性能方面：虽然 HashMap 和 HashTable 都是基于单链表的，但是 HashMap 进行 put 或者 get􏱤 操作，可以达到常数时间的性能；而 HashTable 的 put 和 get 操作都是加了 <code>synchronized</code> 锁的，所以效率很差。</p>\n<h3 id=\"HashMap-和-HashSet-的区别\"><a href=\"#HashMap-和-HashSet-的区别\" class=\"headerlink\" title=\"HashMap 和 HashSet 的区别\"></a>HashMap 和 HashSet 的区别</h3><p>HashSet 继承于 AbstractSet 接口，实现了 Set、Cloneable,、java.io.Serializable 接口。HashSet 不允许集合中出现重复的值。HashSet 底层其实就是 HashMap，所有对 HashSet 的操作其实就是对 HashMap 的操作。所以 HashSet 也不保证集合的顺序。</p>\n<h3 id=\"HashMap-是如何扩容的\"><a href=\"#HashMap-是如何扩容的\" class=\"headerlink\" title=\"HashMap 是如何扩容的\"></a>HashMap 是如何扩容的</h3><p>HashMap 中有两个非常重要的变量，一个是 <code>loadFactor</code> ，一个是 <code>threshold</code> ，loadFactor 表示的就是负载因子，threshold 表示的是下一次要扩容的阈值，当 threshold = loadFactor * 数组长度时，数组长度扩大位原来的两倍，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。</p>\n<h3 id=\"HashMap-的长度为什么是-2-的幂次方\"><a href=\"#HashMap-的长度为什么是-2-的幂次方\" class=\"headerlink\" title=\"HashMap 的长度为什么是 2 的幂次方\"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>这道题我想了几天，之前和群里小伙伴们探讨每日一题的时候，问他们为什么 length%hash == (n - 1) &amp; hash，它们说相等的前提是 length 的长度 2 的幂次方，然后我回了一句难道 length 还能不是 2 的幂次方吗？其实是我没有搞懂因果关系，因为 HashMap 的长度是 2 的幂次方，所以使用余数来判断在桶中的下标。如果 length 的长度不是 2 的幂次方，小伙伴们可以举个例子来试试</p>\n<blockquote>\n<p>例如长度为 9 时候，3 &amp; (9-1) = 0，2 &amp; (9-1) = 0 ，都在 0 上，碰撞了；</p>\n</blockquote>\n<p>这样会增大 HashMap 碰撞的几率。</p>\n<h3 id=\"HashMap-线程安全的实现有哪些\"><a href=\"#HashMap-线程安全的实现有哪些\" class=\"headerlink\" title=\"HashMap 线程安全的实现有哪些\"></a>HashMap 线程安全的实现有哪些</h3><p>因为 HashMap 不是一个线程安全的容器，所以并发场景下推荐使用 <code>ConcurrentHashMap</code> ，或者使用线程安全的 HashMap，使用 <code>Collections</code> 包下的线程安全的容器，比如说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Collections.synchronizedMap(<span class=\"keyword\">new</span> HashMap());</span><br></pre></td></tr></table></figure>\n\n<p>还可以使用 HashTable ，它也是线程安全的容器，基于 key-value 存储，经常用 HashMap 和 HashTable 做比较就是因为 HashTable 的数据结构和 HashMap 相同。</p>\n<p>上面效率最高的就是 ConcurrentHashMap。</p>\n<h3 id=\"7-说说你了解的springcloud-里面有什么组件呢\"><a href=\"#7-说说你了解的springcloud-里面有什么组件呢\" class=\"headerlink\" title=\"7.说说你了解的springcloud,里面有什么组件呢\"></a>7.说说你了解的springcloud,里面有什么组件呢</h3><p>SpringCloud：分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶</p>\n<p>Spring Cloud是一个微服务框架，相比Dubbo等RPC框架, <strong>Spring Cloud提供的全套的分布式系统解决方案</strong>。</p>\n<p>Spring Cloud对微服务基础框架Netflix的多个开源组件进行了封装，同时又实现了和云端平台以及和Spring Boot开发框架的集成。 </p>\n<p>Spring Cloud为微服务架构开发涉及的<strong>配置管理，服务治理，熔断机制，智能路由，微代理，控制总线，一次性token，全局一致性锁，leader选举，分布式session，集群状态</strong>管理等操作提供了一种简单的开发方式。</p>\n<p>Spring Cloud 为开发者提供了快速构建<strong>分布式系统的工具</strong>，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。  </p>\n<h4 id=\"常见组件\"><a href=\"#常见组件\" class=\"headerlink\" title=\"常见组件\"></a>常见组件</h4><ul>\n<li>Eureka：注册中心；各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</li>\n<li>Zuul、Gateway：网关；如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</li>\n<li>Ribbon：负载均衡；服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</li>\n<li>Feign：服务调用；基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</li>\n<li>Hystrix或Resilience4j：熔断器；发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/11/01/3u8IwCHq7N4Fvif.jpg\" loading=\"lazy\"></p>\n<h3 id=\"8-说说你了解的spring-Boot\"><a href=\"#8-说说你了解的spring-Boot\" class=\"headerlink\" title=\"8.说说你了解的spring Boot\"></a>8.说说你了解的spring Boot</h3><p>Spring Boot是Spring开源组织下的一个子项目，也是Spring组件一站式解决方案，主要是为了简化使用Spring框架的难度，简省繁重的配置。</p>\n<p>设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>\n<p>SpringBoot所具备的特征有：</p>\n<ol>\n<li>可以创建独立的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TcHJpbmcvODUwNjE=\">Spring<i class=\"fa fa-external-link-alt\"></i></span>应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</li>\n<li>内嵌Tomcat或Jetty等Servlet容器,Spring Boot 只要打成一个可执行的jar包就能独立运行，所有的依赖包都    在一个jar包内。</li>\n<li>提供自动配置的“starter”项目对象模型（POMS）以简化<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NYXZlbi82MDk0OTA5\">Maven<i class=\"fa fa-external-link-alt\"></i></span>配置；</li>\n<li>尽可能自动配置Spring容器；</li>\n<li>提供准备好的特性，如指标、健康检查和外部化配置；</li>\n<li>绝对没有代码生成，不需要XML配置。 </li>\n</ol>\n<p>SpringBoot框架中还有两个非常重要的策略：开箱即用和约定优于配置。开箱即用，Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。</p>\n<h2 id=\"第二个现场面试\"><a href=\"#第二个现场面试\" class=\"headerlink\" title=\"第二个现场面试\"></a>第二个现场面试</h2><p>问的很基础，具体我都快忘了，写这个时已经过好几天了；</p>\n<h3 id=\"1-java类和接口的理解\"><a href=\"#1-java类和接口的理解\" class=\"headerlink\" title=\"1.java类和接口的理解\"></a>1.java类和接口的理解</h3><p>java类只能单继承，扩展单一，但一个类可以实现多个接口；而接口可以进行多继承。</p>\n<h3 id=\"2-多线程\"><a href=\"#2-多线程\" class=\"headerlink\" title=\"2.多线程\"></a>2.多线程</h3><p>一个程序在运行开始会产生一个进程，一个进程可以产生多个线程，实现多线程的方法有继承Thread类、实现Runnable接口、使用Callable接口和Future接口。</p>\n<h3 id=\"3-io，怎么读一个文件，给你一个路径\"><a href=\"#3-io，怎么读一个文件，给你一个路径\" class=\"headerlink\" title=\"3.io，怎么读一个文件，给你一个路径\"></a>3.io，怎么读一个文件，给你一个路径</h3><p>我们可以根据文件类型，选择不同io子类来读取文件。</p>\n<p>如果是二进制文件，使用FileInputStream读取；如果是文本文件，使用FileReader读取；</p>\n<p>这两个类允许我们从文件开始至文件结尾一个字节或字符的读取文件，或者将读取的文件写入字节数组或字符数组。</p>\n<p>如果我们想随机的读取文件内容，可以使用RandomAccessFile。</p>\n<p><img data-src=\"https://i.loli.net/2020/11/01/o8iax6JsrGzPpT7.png\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个只是读文件</span></span><br><span class=\"line\">FileInputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> asc= -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//FileInputStream的read()返回的数字是ASCII码 //注意：其中包括着“\\r和\\n”两个字符(\\r:13,\\n:10)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>((asc=in.read())!=-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将char型强行转制为int型得到的是Ascii码//将int型强行转制为char型得到的是字符</span></span><br><span class=\"line\">    System.out.print((<span class=\"keyword\">char</span>)asc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> in.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取文件(字节流)</span></span><br><span class=\"line\">InputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//写入相应的文件</span></span><br><span class=\"line\">OutputStream out = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;d:\\\\2.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//读取数据</span></span><br><span class=\"line\"><span class=\"comment\">//一次性取多少字节</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2048</span>];</span><br><span class=\"line\"><span class=\"comment\">//接受读取的内容(返回的n是读入数组bytes[]的总字节数)</span></span><br><span class=\"line\"><span class=\"comment\">//read返回值是读入缓冲区的字节总数,如果因为已经到达文件末尾而没有更多的数据,则返回 -1.意思是已经到达末尾.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//循环取出数据</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ((n = in.read(bytes)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//转换成字符串</span></span><br><span class=\"line\">    String str = new String(bytes,0,n,&quot;GBK&quot;); #这里可以实现字节到字符串的转换，比较实用</span><br><span class=\"line\">    <span class=\"comment\">//String str = new String(bytes,&quot;GBK&quot;);//这个也行</span></span><br><span class=\"line\">    System.out.println(str);</span><br><span class=\"line\">    <span class=\"comment\">//写入相关文件</span></span><br><span class=\"line\">    out.write(bytes, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">    <span class=\"comment\">//out.write(bytes);//这个也行</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//把缓存在内存中残留的数据压入文件中，并清除缓存</span></span><br><span class=\"line\">out.flush();</span><br><span class=\"line\"><span class=\"comment\">//关闭流</span></span><br><span class=\"line\">in.close();</span><br><span class=\"line\">out.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取文件(缓存字节流)</span></span><br><span class=\"line\">BufferedInputStream in = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//写入相应的文件</span></span><br><span class=\"line\">BufferedOutputStream out = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;d:\\\\2.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//读取数据</span></span><br><span class=\"line\"><span class=\"comment\">//一次性取多少字节</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2048</span>];</span><br><span class=\"line\"><span class=\"comment\">//接受读取的内容(返回的n是读入数组bytes[]的总字节数)</span></span><br><span class=\"line\"><span class=\"comment\">//read返回值是读入缓冲区的字节总数,如果因为已经到达文件末尾而没有更多的数据,则返回 -1.意思是已经到达末尾.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//循环取出数据</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ((n = in.read(bytes)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//转换成字符串</span></span><br><span class=\"line\">    String str = <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    System.out.println(str);</span><br><span class=\"line\">    <span class=\"comment\">//写入相关文件</span></span><br><span class=\"line\">    out.write(bytes);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把缓存在内存中残留的数据压入文件中，并清除缓存</span></span><br><span class=\"line\">out.flush();</span><br><span class=\"line\"><span class=\"comment\">//关闭流</span></span><br><span class=\"line\">in.close();</span><br><span class=\"line\">out.close();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-mysql索引优化\"><a href=\"#4-mysql索引优化\" class=\"headerlink\" title=\"4.mysql索引优化\"></a>4.mysql索引优化</h3><h3 id=\"5-springcloud是什么\"><a href=\"#5-springcloud是什么\" class=\"headerlink\" title=\"5.springcloud是什么\"></a>5.springcloud是什么</h3><h3 id=\"6-冒泡排序原理\"><a href=\"#6-冒泡排序原理\" class=\"headerlink\" title=\"6.冒泡排序原理\"></a>6.冒泡排序原理</h3><h3 id=\"7-前端技术html，CSS，ajax，jquery，javascript是什么\"><a href=\"#7-前端技术html，CSS，ajax，jquery，javascript是什么\" class=\"headerlink\" title=\"7.前端技术html，CSS，ajax，jquery，javascript是什么\"></a>7.前端技术html，CSS，ajax，jquery，javascript是什么</h3><h5 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h5><p>HTML代表超文本标记语言（Hyper Text Markup Language），它不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。它是静态的。与之相对应的是jsp动态网页。</p>\n<p>作用</p>\n<p>静态网站是指全部由<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M\">HTML<i class=\"fa fa-external-link-alt\"></i></span>（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==\">标准通用标记语言<i class=\"fa fa-external-link-alt\"></i></span>的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种视觉动态效果，如GIF动画、FLASH动画、滚动字幕等，而网站主要是静态化的页面和代码组成，一般文件名均以<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9odG0vMzIxMzMzNg==\">htm<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9odG1sLzk3MDQ5\">html<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zaHRtbC81OTQ5MjE=\">shtml<i class=\"fa fa-external-link-alt\"></i></span>等为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEUlRTclQkMlODAvMTEwMTE2ODM=\">后缀<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<h5 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h5><p>CSS层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M\">HTML<i class=\"fa fa-external-link-alt\"></i></span>（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==\">标准通用标记语言<i class=\"fa fa-external-link-alt\"></i></span>的一个应用）或<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9YTUw=\">XML<i class=\"fa fa-external-link-alt\"></i></span>（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，**还可以配合各种脚本语言动态地对网页各元素进行格式化。 ** </p>\n<p>作用：</p>\n<p>丰富的样式、定义易于使用和修改、多页面应用、层叠、页面压缩</p>\n<h5 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h5><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>\n<p>Ajax不是一个技术，它实际上是几种技术，每种技术都有其独特这处，合在一起就成了一个功能强大的新技术</p>\n<p>Ajax包括： </p>\n<ul>\n<li>XHTML和CSS</li>\n<li>使用文档对象模型(DocumentObjectModel)作动态显示和交互 </li>\n<li>使用XML和XSLT做数据交互和操作 </li>\n<li>使用XMLHttpRequest进行异步数据接收 </li>\n<li>使用JavaScript将它们绑定在一起 </li>\n</ul>\n<p>作用：</p>\n<p>Ajax，异步JavaScript与XML，是使用客户端脚本与Web服务器交换数据的Web应用开发方法。这样，Web页面不用打断交互流程进行重新加裁，就可以动态地更新。使用Ajax，你可以创建接近本地桌面应用的，直接的、高可用的、更丰富的、更动态的Web用户接口界面。 </p>\n<h5 id=\"JQuery\"><a href=\"#JQuery\" class=\"headerlink\" title=\"JQuery\"></a>JQuery</h5><p>JQuery实际上就是对现有的JavaScript的一种扩展，它非常轻量级，压缩后大概32KB，它兼容于各种浏览器，这样就可以非常方便地添加适用于多种浏览器的特效。</p>\n<p>作用：</p>\n<p>jQuery本身是一个基于插件的JavaScript库，它的各种功能可以通过新的插件进行增强。jQuery为Web编程提供了一个抽象的层，使得它可以兼容于任何浏览器，并且大大简化了原先用JavaScript做的工作，总而言之， jQuery可以完成如下所示的工作。</p>\n<p>优点</p>\n<ul>\n<li><p>利用css的选择器提供高速的元素查找行为。</p>\n</li>\n<li><p>提供了一个抽象层来标准化各种常见的任务，可以解决各种浏览器的兼容问题。</p>\n</li>\n<li><p>将复杂的代码简化，提供连缀编程模式，大大简化了代码的操作。</p>\n</li>\n</ul>\n<h5 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h5><p>JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的是一种解释性脚本语言（代码不进行预编译）主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。</p>\n<h3 id=\"8-什么是redis\"><a href=\"#8-什么是redis\" class=\"headerlink\" title=\"8.什么是redis\"></a>8.什么是redis</h3><p>开源免费的，c编译的，是一个<strong>高效能的键值分布式内存数据库</strong>，<strong>基于内存运行并支持持久化的NOSQL数据库。</strong></p>\n","categories":["面试"],"tags":["java"]},{"title":"锁","url":"/2020-11-18-%E9%94%81.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Java中划分锁的方式不同，就产生了各种对锁的定义，如果不能清楚知道不同锁的特点那么就很容易将JUC中的锁弄混淆，在学习JUC方面知识之前先学习下锁的划分。</p>\n<h2 id=\"悲观锁、乐观锁\"><a href=\"#悲观锁、乐观锁\" class=\"headerlink\" title=\"悲观锁、乐观锁\"></a>悲观锁、乐观锁</h2><p>对于悲观锁和乐观锁划分关键是：是否默认在进行多线程操作时，总认为有其他线程会进行同步操作。</p>\n<p>悲观锁：顾名思义，每次去拿数据的时候都被认为别人会修改，所以每次在拿数据的时候都会被锁上，这样别人想拿这个数据就会block直到它拿到锁，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先锁上。</p>\n<p>java中的悲观锁是synchronized<strong>，AQS框架下的锁则是先尝试CAS乐观锁去获取，获取不到，才会转为悲观锁，如RetreenLock</strong></p>\n<p>乐观锁：每次去拿数据的时候都认为别人不会修改，<strong>所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号等机制</strong>。乐观锁适用于多度的应用类型，这样可以<strong>提高吞吐量</strong>。</p>\n<p>乐观锁策略：提交版本必须大于记录当前版本才能执行更新。java乐观锁基本都通过<code>CAS</code>操作实现的，<code>CAS</code>是一种依赖系统指令集实现原子操作，比较当前变量值与预期值是否一样,如果相同就使用系统原语进行更新。</p>\n<p>例如：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值大于前数据库中的 version 值时才更新，否则重试更新操作，直到更新成功。</p>\n<h3 id=\"排它锁、共享锁\"><a href=\"#排它锁、共享锁\" class=\"headerlink\" title=\"排它锁、共享锁\"></a>排它锁、共享锁</h3><p><code>排它锁</code>其实就是悲观锁机制实现的锁、<code>共享锁</code>就是乐观锁机制实现的锁。</p>\n<h2 id=\"可重入锁、不可重入锁\"><a href=\"#可重入锁、不可重入锁\" class=\"headerlink\" title=\"可重入锁、不可重入锁\"></a>可重入锁、不可重入锁</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">functionA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;iAmFunctionA&quot;</span>);</span><br><span class=\"line\">        functionB();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">functionB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;iAmFunctionB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345678910</span></span><br></pre></td></tr></table></figure>\n\n<p><code>可重入锁</code>：当线程拥有对象的同步方法锁后可访问其他同步方法 ，java中synchronized和ReentrantLock都是可重入锁<br><code>不可重入</code>：当线程拥有对象的同步方法锁后再访问其他同步方法也需要排队或等待</p>\n<h2 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h2><p><code>公平锁</code>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p>\n<p><code>非公平锁</code>不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁</p>\n<p>synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过构造函数进行设置</p>\n<h2 id=\"Synchronized锁的优化\"><a href=\"#Synchronized锁的优化\" class=\"headerlink\" title=\"Synchronized锁的优化\"></a>Synchronized锁的优化</h2><p>Synchronized</p>\n<p>在Java中<code>Synchronized</code>是我们常用的<code>同步互斥手段</code>，在早期版本中，它是一个<code>悲观锁</code>设计下的<code>独占锁</code>，并且<code>可重入</code>。<code>Synchronized在获取到同步锁后，其他线程将会阻塞，对于阻塞或者唤醒一个线程都需要操作系统来完成，这就需要从用户态切换到内核态，这样的操作就需要消耗很多处理器时间，具有很强的性能损耗</code>，因此Synchronized在1.6中做了很多的优化，减少频繁的切换到内核态。</p>\n<p>在1.6之中为了提高Synchronized的性能，增加了<code>自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等来高效地共享数据，解决竞争问题</code>。<br><code>自旋锁</code>:在多线程操作中共享数据的锁定可能是和短暂的，避免线程在很短的时间内做用户态的切换，那么在允许多线程并行的基础上，让后面请求锁的线程“等待一下”，等待过程不放弃处理器的执行时间，为了让线程等待只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br><code>自适应自旋</code>是对自旋锁的优化，自旋锁的缺点就是如果锁占用的时间很长，那么就会浪费处理器资源，并且还对处理器有要求。加入自适应自旋就是自旋的时间不再固定，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态决定，如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋很可能再次成功，应此可能允许等待时间更长；如果某一个锁上，很少自旋成功，那么将跳过自旋过程，避免资源浪费。虚拟机使用这一的策略和技术完成对Synchronized的一种优化</p>\n<p><code>锁消除</code>是指在虚拟机及时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除如：消除锁的判断主要来于逃逸分析的数据支持，如果判断在一段代码中，堆上的数据都不会逃逸出去从而被其他线程访问到，那么就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁就自热无效</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concatString</span><span class=\"params\">(String s1,String s2，String s3)</span></span>&#123;</span><br><span class=\"line\">\tStringBuffer sb=<span class=\"keyword\">new</span> SrringBuffer();</span><br><span class=\"line\">\tsb.append(s1);</span><br><span class=\"line\">\tsb.append(s2);</span><br><span class=\"line\">\tsb.append(s3);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n\n<p>对于上述代码，StringBuffer.append()方法都具有一个同步块，锁就是对象sb,但sb变量永远不会被其他线程所访问，其一直动态作用域被限制在concatString方法中，其他线程并不能访问。因此此处的锁可以被安全的消除掉。</p>\n<p><code>锁粗化</code>一段代码里面对同一个对象进行反复的加锁和解锁，那么也会带来性能的损耗，应该将锁同步范围扩展（粗化）到整个操作序列的外部。如上面代码就是扩展到第一个append()操作之前直至追后一个append()操作之后，这样就只需要加一次锁</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><p>轻量级锁的作用是在没有多线程的前提下，<code>减少重量级锁在使用操作系统互斥量产生的新能消耗</code>。在无竞争的情况下获取锁使用的是<code>CAS</code>操作。CAS操作主要是用于更新对象头中thread ID， 要理解轻量级锁，得先了解HotPost虚拟机的对象头部分，对象头中一部分保存这GC年龄代，哈希码等信息，官方称为Mark Work，在32位的HotPost下，PostMark Work的32bit存储空间中，有25bit用于存储对象哈希码，4bit用于存储对象的分代年龄，2bit用于存储锁标志位，1bit固定为0；</p>\n<table>\n<thead>\n<tr>\n<th>存储内容</th>\n<th>标志位</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对象哈希码、对象分代年龄</td>\n<td>01</td>\n<td>未锁定</td>\n</tr>\n<tr>\n<td>指向锁记录的指针</td>\n<td>00</td>\n<td>轻量级锁定</td>\n</tr>\n<tr>\n<td>指向重量级锁的指针</td>\n<td>10</td>\n<td>膨胀（重量级锁定）</td>\n</tr>\n<tr>\n<td>空、不需要记录信息</td>\n<td>11</td>\n<td>GC标记</td>\n</tr>\n<tr>\n<td>偏向锁ID、偏向时间戳、对象分代年龄</td>\n<td>01</td>\n<td>可偏向</td>\n</tr>\n</tbody></table>\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p><code>偏向锁</code>是<code>在无竞争的情况下把整个同步都消除掉</code>，偏向锁的意思是<code>同步锁会偏向第一次获得它的线程，如果在接下来的执行中，该锁没有其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</code>。使用偏向锁需要虚拟机默认支持，如果在没有设置的情况下将不支持偏向锁。接下来用一张图讲解轻量级锁和偏向锁的转换关系</p>\n<h3 id=\"轻量级锁、偏向锁的状态准换\"><a href=\"#轻量级锁、偏向锁的状态准换\" class=\"headerlink\" title=\"轻量级锁、偏向锁的状态准换\"></a>轻量级锁、偏向锁的状态准换</h3><p><img data-src=\"https://img-blog.csdnimg.cn/20190507233042199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oZWcyMDEw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"><br>首先根据<code>偏向锁可用</code>和<code>不可用</code>分为左右两种逻辑</p>\n<p><code>可偏向左边上面部分</code>：如果偏向锁可用，初始化的的对象标志位为01，那么这是一个未锁定、未偏向但是可偏向的对象</p>\n<p><code>可偏向左边下面部分</code>：当第一次线程获取到锁的时候，那么虚拟机将头中的标志位设置为<code>01</code>，<code>同时使用CAS操作将线程的thread ID写入到Mark Work中</code>，成功后，持有偏向锁的线程再进入这个锁的相关同步块时，都不用做同步操作。<br>对象Mark Work中写入了thread ID状态下，对象可能处于锁定状态或未锁定状态。如果是<code>在锁定</code>情况下，有另一个线程去获取这个锁时，偏向锁模式将结束，将回到轻量级锁定。<br>如果是在<code>没有锁定</code>状态下，有另一个线程去获取这个锁时，偏向锁模式将结束，将回到未锁定、未偏向但是可偏向状态，如果撤销偏向，将回到未锁定、不可偏向对象</p>\n<p><code>不可偏向右上部分</code>：如果偏向锁不可用，初始化的的对象标志位为<code>01</code>，那么这是一个未锁定、不可偏向对象</p>\n<p><code>不可偏向中间部分</code>：当有一个线程获取同步对象时，如果同步对象没有被锁定，那么在<code>当前线程的栈帧中开辟一个叫“Lock Record”的空间保存一份同步对象的Mark Word部分的拷贝，并且使用CAS操作将这个对象的Mark Word更新指向栈帧的“Lock Record”</code>，如果成功，那么将标志位改为<code>00</code>；如果更新失败，但当前线程已经拥有对象锁，那就直接运行同步块代码；否则说明有线程在争夺锁，那么轻量级锁就不再有效，要膨胀成重量级锁</p>\n<p><code>不可偏向下面部分</code>：当同步对象已经是轻量级锁，但有另一个线程在竞争锁资源时，轻量级锁将膨胀成重量级锁，锁的标志位状态值变为<code>“10”</code>，Mark Word中存储的指向重量级锁的指针，后面等待锁的线程也将进入阻塞状态。</p>\n<p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><h2 id=\"AQS-对资源的共享⽅式\"><a href=\"#AQS-对资源的共享⽅式\" class=\"headerlink\" title=\"AQS 对资源的共享⽅式\"></a>AQS 对资源的共享⽅式</h2><p>AQS定义两种资源共享⽅式</p>\n<p><strong>Exclusive（独占）</strong>：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：</p>\n<ul>\n<li><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p>\n</li>\n<li><p>⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的</p>\n</li>\n</ul>\n<p><strong>Share（共享）</strong>：多个线程可同时执⾏，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后⾯讲到。</p>\n<p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png\" alt=\"img\" loading=\"lazy\"></p>\n<h2 id=\"1-ReentrantLock\"><a href=\"#1-ReentrantLock\" class=\"headerlink\" title=\"1 ReentrantLock\"></a>1 ReentrantLock</h2><h3 id=\"1-1-ReentrantLock特性概览\"><a href=\"#1-1-ReentrantLock特性概览\" class=\"headerlink\" title=\"1.1 ReentrantLock特性概览\"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>下面通过伪代码，进行更加直观的比较：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; **************************Synchronized的使用方式**************************</span><br><span class=\"line\">&#x2F;&#x2F; 1.用于代码块</span><br><span class=\"line\">synchronized (this) &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 2.用于对象</span><br><span class=\"line\">synchronized (object) &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 3.用于方法</span><br><span class=\"line\">public synchronized void test () &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 4.可重入</span><br><span class=\"line\">for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">\tsynchronized (this) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; **************************ReentrantLock的使用方式**************************</span><br><span class=\"line\">public void test () throw Exception &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 1.初始化选择公平锁、非公平锁</span><br><span class=\"line\">\tReentrantLock lock &#x3D; new ReentrantLock(true);</span><br><span class=\"line\">\t&#x2F;&#x2F; 2.可用于代码块</span><br><span class=\"line\">\tlock.lock();</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 3.支持多种加锁方式，比较灵活; 具有可重入特性</span><br><span class=\"line\">\t\t\tif(lock.tryLock(100, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class=\"line\">\t\t&#125; finally &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 4.手动释放锁</span><br><span class=\"line\">\t\t\tlock.unlock()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; finally &#123;</span><br><span class=\"line\">\t\tlock.unlock();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-ReentrantLock与AQS的关联\"><a href=\"#1-2-ReentrantLock与AQS的关联\" class=\"headerlink\" title=\"1.2 ReentrantLock与AQS的关联\"></a>1.2 ReentrantLock与AQS的关联</h3><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5qUTVNVEk1T0E9PSZtaWQ9MjY1MTc0OTQzNCZpZHg9MyZzbj01ZmZhNjNhZDQ3ZmUxNjZmMmYxYTlmNjA0ZWQxMDA5MSZjaGtzbT1iZDEyYTU3NzhhNjUyYzYxNTA5ZDllNzE4YWIwODZmZjI3YWQ4NzY4NTg2ZWE5YjM4YzNkY2Y5ZTAxN2E4ZTQ5YmNhZTNkZjliY2M4JnNjZW5lPTM4I3dlY2hhdF9yZWRpcmVjdA==\">不可不说的Java“锁”事<i class=\"fa fa-external-link-alt\"></i></span>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p>\n<p>非公平锁源码中的加锁流程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock#NonfairSync</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 非公平锁</span><br><span class=\"line\">static final class NonfairSync extends Sync &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tfinal void lock() &#123;</span><br><span class=\"line\">\t\tif (compareAndSetState(0, 1))</span><br><span class=\"line\">\t\t\tsetExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tacquire(1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这块代码的含义为：</p>\n<ul>\n<li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li>\n<li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li>\n</ul>\n<p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p>\n<ul>\n<li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li>\n</ul>\n<p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p>\n<p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>\n<ul>\n<li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li>\n<li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li>\n<li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li>\n</ul>\n<p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock#FairSync</span><br><span class=\"line\"></span><br><span class=\"line\">static final class FairSync extends Sync &#123;</span><br><span class=\"line\">  ...  </span><br><span class=\"line\">\tfinal void lock() &#123;</span><br><span class=\"line\">\t\tacquire(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>\n<p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p>\n<p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p>\n<h2 id=\"2-AQS\"><a href=\"#2-AQS\" class=\"headerlink\" title=\"2 AQS\"></a>2 AQS</h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png\" alt=\"img\" loading=\"lazy\"></p>\n<ul>\n<li>上图中有颜色的为Method，无颜色的为Attribution。</li>\n<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>\n<li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>\n</ul>\n<p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"2-1-原理概览\"><a href=\"#2-1-原理概览\" class=\"headerlink\" title=\"2.1 原理概览\"></a>2.1 原理概览</h3><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>\n<p>主要原理图如下：</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>\n<h4 id=\"2-1-1-AQS数据结构\"><a href=\"#2-1-1-AQS数据结构\" class=\"headerlink\" title=\"2.1.1 AQS数据结构\"></a>2.1.1 AQS数据结构</h4><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>解释一下几个方法和属性值的含义：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法和属性值</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">waitStatus</td>\n<td align=\"left\">当前节点在队列中的状态</td>\n</tr>\n<tr>\n<td align=\"left\">thread</td>\n<td align=\"left\">表示处于该节点的线程</td>\n</tr>\n<tr>\n<td align=\"left\">prev</td>\n<td align=\"left\">前驱指针</td>\n</tr>\n<tr>\n<td align=\"left\">predecessor</td>\n<td align=\"left\">返回前驱节点，没有的话抛出npe</td>\n</tr>\n<tr>\n<td align=\"left\">nextWaiter</td>\n<td align=\"left\">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td>\n</tr>\n<tr>\n<td align=\"left\">next</td>\n<td align=\"left\">后继指针</td>\n</tr>\n</tbody></table>\n<p>线程两种锁的模式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SHARED</td>\n<td align=\"left\">表示线程以共享的模式等待锁</td>\n</tr>\n<tr>\n<td align=\"left\">EXCLUSIVE</td>\n<td align=\"left\">表示线程正在以独占的方式等待锁</td>\n</tr>\n</tbody></table>\n<p>waitStatus有下面几个枚举值：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">枚举</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">当一个Node被初始化的时候的默认值</td>\n</tr>\n<tr>\n<td align=\"left\">CANCELLED</td>\n<td align=\"left\">为1，表示线程获取锁的请求已经取消了</td>\n</tr>\n<tr>\n<td align=\"left\">CONDITION</td>\n<td align=\"left\">为-2，表示节点在等待队列中，节点线程等待唤醒</td>\n</tr>\n<tr>\n<td align=\"left\">PROPAGATE</td>\n<td align=\"left\">为-3，当前线程处在SHARED情况下，该字段才会使用</td>\n</tr>\n<tr>\n<td align=\"left\">SIGNAL</td>\n<td align=\"left\">为-1，表示线程已经准备好了，就等资源释放了</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-1-2-同步状态State\"><a href=\"#2-1-2-同步状态State\" class=\"headerlink\" title=\"2.1.2 同步状态State\"></a>2.1.2 同步状态State</h4><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private volatile int state;</span><br></pre></td></tr></table></figure>\n\n<p>下面提供了几个访问这个字段的方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">protected final int getState()</td>\n<td align=\"left\">获取State的值</td>\n</tr>\n<tr>\n<td align=\"left\">protected final void setState(int newState)</td>\n<td align=\"left\">设置State的值</td>\n</tr>\n<tr>\n<td align=\"left\">protected final boolean compareAndSetState(int expect, int update)</td>\n<td align=\"left\">使用CAS方式更新State</td>\n</tr>\n</tbody></table>\n<p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png\" alt=\"img\" loading=\"lazy\"><img data-src=\"https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p>\n<h2 id=\"2-2-AQS重要方法与ReentrantLock的关联\"><a href=\"#2-2-AQS重要方法与ReentrantLock的关联\" class=\"headerlink\" title=\"2.2 AQS重要方法与ReentrantLock的关联\"></a>2.2 AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">protected boolean isHeldExclusively()</td>\n<td align=\"left\">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>\n</tr>\n<tr>\n<td align=\"left\">protected boolean tryAcquire(int arg)</td>\n<td align=\"left\">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>\n</tr>\n<tr>\n<td align=\"left\">protected boolean tryRelease(int arg)</td>\n<td align=\"left\">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>\n</tr>\n<tr>\n<td align=\"left\">protected int tryAcquireShared(int arg)</td>\n<td align=\"left\">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>\n</tr>\n<tr>\n<td align=\"left\">protected boolean tryReleaseShared(int arg)</td>\n<td align=\"left\">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>\n</tr>\n</tbody></table>\n<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>\n<p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>加锁：</p>\n<ul>\n<li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li>\n<li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li>\n<li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li>\n<li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li>\n</ul>\n<p>解锁：</p>\n<ul>\n<li>通过ReentrantLock的解锁方法Unlock进行解锁。</li>\n<li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li>\n<li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>\n<li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li>\n</ul>\n<p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png\" alt=\"img\" loading=\"lazy\"></p>\n<h2 id=\"2-3-通过ReentrantLock理解AQS\"><a href=\"#2-3-通过ReentrantLock理解AQS\" class=\"headerlink\" title=\"2.3 通过ReentrantLock理解AQS\"></a>2.3 通过ReentrantLock理解AQS</h2><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p>\n<p>在非公平锁中，有一段这样的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class=\"line\"></span><br><span class=\"line\">static final class NonfairSync extends Sync &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tfinal void lock() &#123;</span><br><span class=\"line\">\t\tif (compareAndSetState(0, 1))</span><br><span class=\"line\">\t\t\tsetExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tacquire(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下这个Acquire是怎么写的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">public final void acquire(int arg) &#123;</span><br><span class=\"line\">\tif (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">\t\tselfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看一下tryAcquire方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">\tthrow new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p>\n<h3 id=\"2-3-1-线程加入等待队列\"><a href=\"#2-3-1-线程加入等待队列\" class=\"headerlink\" title=\"2.3.1 线程加入等待队列\"></a>2.3.1 线程加入等待队列</h3><h4 id=\"2-3-1-1-加入队列的时机\"><a href=\"#2-3-1-1-加入队列的时机\" class=\"headerlink\" title=\"2.3.1.1 加入队列的时机\"></a>2.3.1.1 加入队列的时机</h4><p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p>\n<h4 id=\"2-3-1-2-如何加入队列\"><a href=\"#2-3-1-2-如何加入队列\" class=\"headerlink\" title=\"2.3.1.2 如何加入队列\"></a>2.3.1.2 如何加入队列</h4><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private Node addWaiter(Node mode) &#123;</span><br><span class=\"line\">\tNode node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class=\"line\">\t&#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class=\"line\">\tNode pred &#x3D; tail;</span><br><span class=\"line\">\tif (pred !&#x3D; null) &#123;</span><br><span class=\"line\">\t\tnode.prev &#x3D; pred;</span><br><span class=\"line\">\t\tif (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">\t\t\tpred.next &#x3D; node;</span><br><span class=\"line\">\t\t\treturn node;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tenq(node);</span><br><span class=\"line\">\treturn node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class=\"line\">\treturn unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要的流程如下：</p>\n<ul>\n<li>通过当前的线程和锁模式新建一个节点。</li>\n<li>Pred指针指向尾节点Tail。</li>\n<li>将New中Node的Prev指针指向Pred。</li>\n<li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">static &#123;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tstateOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class=\"line\">\t\theadOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class=\"line\">\t\ttailOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class=\"line\">\t\twaitStatusOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class=\"line\">\t\tnextOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class=\"line\">\t&#125; catch (Exception ex) &#123; </span><br><span class=\"line\">    throw new Error(ex); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p>\n<ul>\n<li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private Node enq(final Node node) &#123;</span><br><span class=\"line\">\tfor (;;) &#123;</span><br><span class=\"line\">\t\tNode t &#x3D; tail;</span><br><span class=\"line\">\t\tif (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class=\"line\">\t\t\tif (compareAndSetHead(new Node()))</span><br><span class=\"line\">\t\t\t\ttail &#x3D; head;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tnode.prev &#x3D; t;</span><br><span class=\"line\">\t\t\tif (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">\t\t\t\tt.next &#x3D; node;</span><br><span class=\"line\">\t\t\t\treturn t;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p>\n<p>总结一下，线程获取锁的时候，过程大体如下：</p>\n<ol>\n<li>当没有线程获取到锁时，线程1获取锁成功。</li>\n<li>线程2申请锁，但是锁被线程1占有。</li>\n</ol>\n<p><img data-src=\"https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>如果再有线程要获取锁，依次在队列中往后排队即可。</li>\n</ol>\n<p>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class=\"line\"></span><br><span class=\"line\">public final boolean hasQueuedPredecessors() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class=\"line\">\t&#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class=\"line\">\t&#x2F;&#x2F; thread is first in queue.</span><br><span class=\"line\">\tNode t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class=\"line\">\tNode h &#x3D; head;</span><br><span class=\"line\">\tNode s;</span><br><span class=\"line\">\treturn h !&#x3D; t &amp;&amp; ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p>\n<blockquote>\n<p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><br><span class=\"line\"></span><br><span class=\"line\">if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class=\"line\">\tif (compareAndSetHead(new Node()))</span><br><span class=\"line\">\t\ttail &#x3D; head;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\tnode.prev &#x3D; t;</span><br><span class=\"line\">\tif (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">\t\tt.next &#x3D; node;</span><br><span class=\"line\">\t\treturn t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p>\n<h4 id=\"2-3-1-3-等待队列中线程出队列时机\"><a href=\"#2-3-1-3-等待队列中线程出队列时机\" class=\"headerlink\" title=\"2.3.1.3 等待队列中线程出队列时机\"></a>2.3.1.3 等待队列中线程出队列时机</h4><p>回到最初的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">public final void acquire(int arg) &#123;</span><br><span class=\"line\">\tif (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">\t\tselfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p>\n<p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>\n<p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 标记是否成功拿到资源</span><br><span class=\"line\">\tboolean failed &#x3D; true;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 标记等待过程中是否中断过</span><br><span class=\"line\">\t\tboolean interrupted &#x3D; false;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 开始自旋，要么获取锁，要么中断</span><br><span class=\"line\">\t\tfor (;;) &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 获取当前节点的前驱节点</span><br><span class=\"line\">\t\t\tfinal Node p &#x3D; node.predecessor();</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><br><span class=\"line\">\t\t\tif (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F; 获取锁成功，头指针移动到当前node</span><br><span class=\"line\">\t\t\t\tsetHead(node);</span><br><span class=\"line\">\t\t\t\tp.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class=\"line\">\t\t\t\tfailed &#x3D; false;</span><br><span class=\"line\">\t\t\t\treturn interrupted;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><br><span class=\"line\">\t\t\tif (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">\t\t\t\tinterrupted &#x3D; true;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; finally &#123;</span><br><span class=\"line\">\t\tif (failed)</span><br><span class=\"line\">\t\t\tcancelAcquire(node);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private void setHead(Node node) &#123;</span><br><span class=\"line\">\thead &#x3D; node;</span><br><span class=\"line\">\tnode.thread &#x3D; null;</span><br><span class=\"line\">\tnode.prev &#x3D; null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 靠前驱节点判断当前线程是否应该被阻塞</span><br><span class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 获取头结点的节点状态</span><br><span class=\"line\">\tint ws &#x3D; pred.waitStatus;</span><br><span class=\"line\">\t&#x2F;&#x2F; 说明头结点处于唤醒状态</span><br><span class=\"line\">\tif (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class=\"line\">\t\treturn true; </span><br><span class=\"line\">\t&#x2F;&#x2F; 通过枚举值我们知道waitStatus&gt;0是取消状态</span><br><span class=\"line\">\tif (ws &gt; 0) &#123;</span><br><span class=\"line\">\t\tdo &#123;</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F; 循环向前查找取消节点，把取消节点从队列中剔除</span><br><span class=\"line\">\t\t\tnode.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class=\"line\">\t\t&#125; while (pred.waitStatus &gt; 0);</span><br><span class=\"line\">\t\tpred.next &#x3D; node;</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 设置前任节点等待状态为SIGNAL</span><br><span class=\"line\">\t\tcompareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class=\"line\">    LockSupport.park(this);</span><br><span class=\"line\">    return Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述方法的流程图如下：</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>\n<ul>\n<li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li>\n<li>是在什么时间释放节点通知到被挂起的线程呢？</li>\n</ul>\n<h3 id=\"2-3-2-CANCELLED状态节点生成\"><a href=\"#2-3-2-CANCELLED状态节点生成\" class=\"headerlink\" title=\"2.3.2 CANCELLED状态节点生成\"></a>2.3.2 CANCELLED状态节点生成</h3><p>acquireQueued方法中的Finally代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class=\"line\">\tboolean failed &#x3D; true;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t\tfor (;;) &#123;</span><br><span class=\"line\">\t\t\tfinal Node p &#x3D; node.predecessor();</span><br><span class=\"line\">\t\t\tif (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t\tfailed &#x3D; false;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t&#125; finally &#123;</span><br><span class=\"line\">\t\tif (failed)</span><br><span class=\"line\">\t\t\tcancelAcquire(node);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private void cancelAcquire(Node node) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 将无效节点过滤</span><br><span class=\"line\">\tif (node &#x3D;&#x3D; null)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">  &#x2F;&#x2F; 设置该节点不关联任何线程，也就是虚节点</span><br><span class=\"line\">\tnode.thread &#x3D; null;</span><br><span class=\"line\">\tNode pred &#x3D; node.prev;</span><br><span class=\"line\">  &#x2F;&#x2F; 通过前驱节点，跳过取消状态的node</span><br><span class=\"line\">\twhile (pred.waitStatus &gt; 0)</span><br><span class=\"line\">\t\tnode.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class=\"line\">  &#x2F;&#x2F; 获取过滤后的前驱节点的后继节点</span><br><span class=\"line\">\tNode predNext &#x3D; pred.next;</span><br><span class=\"line\">  &#x2F;&#x2F; 把当前node的状态设置为CANCELLED</span><br><span class=\"line\">\tnode.waitStatus &#x3D; Node.CANCELLED;</span><br><span class=\"line\">  &#x2F;&#x2F; 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span><br><span class=\"line\">  &#x2F;&#x2F; 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span><br><span class=\"line\">\tif (node &#x3D;&#x3D; tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class=\"line\">\t\tcompareAndSetNext(pred, predNext, null);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tint ws;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span><br><span class=\"line\">    &#x2F;&#x2F; 如果1和2中有一个为true，再判断当前节点的线程是否为null</span><br><span class=\"line\">    &#x2F;&#x2F; 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span><br><span class=\"line\">\t\tif (pred !&#x3D; head &amp;&amp; ((ws &#x3D; pred.waitStatus) &#x3D;&#x3D; Node.SIGNAL || (ws &lt;&#x3D; 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread !&#x3D; null) &#123;</span><br><span class=\"line\">\t\t\tNode next &#x3D; node.next;</span><br><span class=\"line\">\t\t\tif (next !&#x3D; null &amp;&amp; next.waitStatus &lt;&#x3D; 0)</span><br><span class=\"line\">\t\t\t\tcompareAndSetNext(pred, predNext, next);</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span><br><span class=\"line\">\t\t\tunparkSuccessor(node);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnode.next &#x3D; node; &#x2F;&#x2F; help GC</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前的流程：</p>\n<ul>\n<li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li>\n<li>根据当前节点的位置，考虑以下三种情况：</li>\n</ul>\n<p>(1) 当前节点是尾节点。</p>\n<p>(2) 当前节点是Head的后继节点。</p>\n<p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p>\n<p>根据上述第二条，我们来分析每一种情况的流程。</p>\n<p>当前节点是尾节点。</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>当前节点是Head的后继节点。</p>\n<p><img data-src=\"https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>当前节点不是Head的后继节点，也不是尾节点。</p>\n<p><img data-src=\"https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p>\n<blockquote>\n<p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">do &#123;</span><br><span class=\"line\">\tnode.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class=\"line\">&#125; while (pred.waitStatus &gt; 0);</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"2-3-3-如何解锁\"><a href=\"#2-3-3-如何解锁\" class=\"headerlink\" title=\"2.3.3 如何解锁\"></a>2.3.3 如何解锁</h3><p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class=\"line\"></span><br><span class=\"line\">public void unlock() &#123;</span><br><span class=\"line\">\tsync.release(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，本质释放锁的地方，是通过框架来完成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">public final boolean release(int arg) &#123;</span><br><span class=\"line\">\tif (tryRelease(arg)) &#123;</span><br><span class=\"line\">\t\tNode h &#x3D; head;</span><br><span class=\"line\">\t\tif (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class=\"line\">\t\t\tunparkSuccessor(h);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.Sync</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 方法返回当前锁是不是没有被线程持有</span><br><span class=\"line\">protected final boolean tryRelease(int releases) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 减少可重入次数</span><br><span class=\"line\">\tint c &#x3D; getState() - releases;</span><br><span class=\"line\">\t&#x2F;&#x2F; 当前线程不是持有锁的线程，抛出异常</span><br><span class=\"line\">\tif (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class=\"line\">\t\tthrow new IllegalMonitorStateException();</span><br><span class=\"line\">\tboolean free &#x3D; false;</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br><span class=\"line\">\tif (c &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\t\tfree &#x3D; true;</span><br><span class=\"line\">\t\tsetExclusiveOwnerThread(null);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsetState(c);</span><br><span class=\"line\">\treturn free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来解释下述源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">public final boolean release(int arg) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><br><span class=\"line\">\tif (tryRelease(arg)) &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 获取头结点</span><br><span class=\"line\">\t\tNode h &#x3D; head;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><br><span class=\"line\">\t\tif (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class=\"line\">\t\t\tunparkSuccessor(h);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p>\n<blockquote>\n<p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p>\n<p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p>\n<p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p>\n</blockquote>\n<p>再看一下unparkSuccessor方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private void unparkSuccessor(Node node) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 获取头结点waitStatus</span><br><span class=\"line\">\tint ws &#x3D; node.waitStatus;</span><br><span class=\"line\">\tif (ws &lt; 0)</span><br><span class=\"line\">\t\tcompareAndSetWaitStatus(node, ws, 0);</span><br><span class=\"line\">\t&#x2F;&#x2F; 获取当前节点的下一个节点</span><br><span class=\"line\">\tNode s &#x3D; node.next;</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><br><span class=\"line\">\tif (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class=\"line\">\t\ts &#x3D; null;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><br><span class=\"line\">\t\tfor (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class=\"line\">\t\t\tif (t.waitStatus &lt;&#x3D; 0)</span><br><span class=\"line\">\t\t\t\ts &#x3D; t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果当前节点的下个节点不为空，而且状态&lt;&#x3D;0，就把当前节点unpark</span><br><span class=\"line\">\tif (s !&#x3D; null)</span><br><span class=\"line\">\t\tLockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p>\n<p>之前的addWaiter方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private Node addWaiter(Node mode) &#123;</span><br><span class=\"line\">\tNode node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class=\"line\">\t&#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class=\"line\">\tNode pred &#x3D; tail;</span><br><span class=\"line\">\tif (pred !&#x3D; null) &#123;</span><br><span class=\"line\">\t\tnode.prev &#x3D; pred;</span><br><span class=\"line\">\t\tif (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">\t\t\tpred.next &#x3D; node;</span><br><span class=\"line\">\t\t\treturn node;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tenq(node);</span><br><span class=\"line\">\treturn node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>\n<p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p>\n<h3 id=\"2-3-4-中断恢复后的执行流程\"><a href=\"#2-3-4-中断恢复后的执行流程\" class=\"headerlink\" title=\"2.3.4 中断恢复后的执行流程\"></a>2.3.4 中断恢复后的执行流程</h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class=\"line\">\tLockSupport.park(this);</span><br><span class=\"line\">\treturn Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class=\"line\">\tboolean failed &#x3D; true;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tboolean interrupted &#x3D; false;</span><br><span class=\"line\">\t\tfor (;;) &#123;</span><br><span class=\"line\">\t\t\tfinal Node p &#x3D; node.predecessor();</span><br><span class=\"line\">\t\t\tif (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">\t\t\t\tsetHead(node);</span><br><span class=\"line\">\t\t\t\tp.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class=\"line\">\t\t\t\tfailed &#x3D; false;</span><br><span class=\"line\">\t\t\t\treturn interrupted;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">\t\t\t\tinterrupted &#x3D; true;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125; finally &#123;</span><br><span class=\"line\">\t\tif (failed)</span><br><span class=\"line\">\t\t\tcancelAcquire(node);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果acquireQueued为True，就会执行selfInterrupt方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">static void selfInterrupt() &#123;</span><br><span class=\"line\">\tThread.currentThread().interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>\n<ol>\n<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>\n<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>\n</ol>\n<p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p>\n<h3 id=\"2-3-5-小结\"><a href=\"#2-3-5-小结\" class=\"headerlink\" title=\"2.3.5 小结\"></a>2.3.5 小结</h3><p>我们在1.3小节中提出了一些问题，现在来回答一下。</p>\n<blockquote>\n<p>Q：某个线程获取锁失败的后续流程是什么呢？</p>\n<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>\n<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>\n<p>A：是CLH变体的FIFO双端队列。</p>\n<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>\n<p>A：可以详细看下2.3.1.3小节。</p>\n<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>\n<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p>\n<p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p>\n<p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p>\n</blockquote>\n<h2 id=\"3-AQS应用\"><a href=\"#3-AQS应用\" class=\"headerlink\" title=\"3 AQS应用\"></a>3 AQS应用</h2><h3 id=\"3-1-ReentrantLock的可重入应用\"><a href=\"#3-1-ReentrantLock的可重入应用\" class=\"headerlink\" title=\"3.1 ReentrantLock的可重入应用\"></a>3.1 ReentrantLock的可重入应用</h3><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p>\n<p>公平锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span><br><span class=\"line\"></span><br><span class=\"line\">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\tif (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</span><br><span class=\"line\">\t\tsetExclusiveOwnerThread(current);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">\tint nextc &#x3D; c + acquires;</span><br><span class=\"line\">\tif (nextc &lt; 0)</span><br><span class=\"line\">\t\tthrow new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class=\"line\">\tsetState(nextc);</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非公平锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span><br><span class=\"line\"></span><br><span class=\"line\">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\tif (compareAndSetState(0, acquires))&#123;</span><br><span class=\"line\">\t\tsetExclusiveOwnerThread(current);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">\tint nextc &#x3D; c + acquires;</span><br><span class=\"line\">\tif (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class=\"line\">\t\tthrow new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class=\"line\">\tsetState(nextc);</span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class=\"line\"></span><br><span class=\"line\">private volatile int state;</span><br></pre></td></tr></table></figure>\n\n<p>接下来看State这个字段主要的过程：</p>\n<ol>\n<li>State初始化的时候为0，表示没有任何线程持有锁。</li>\n<li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li>\n<li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li>\n</ol>\n<h3 id=\"3-2-JUC中的应用场景\"><a href=\"#3-2-JUC中的应用场景\" class=\"headerlink\" title=\"3.2 JUC中的应用场景\"></a>3.2 JUC中的应用场景</h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">同步工具</th>\n<th align=\"left\">同步工具与AQS的关联</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ReentrantLock</td>\n<td align=\"left\">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>\n</tr>\n<tr>\n<td align=\"left\">Semaphore</td>\n<td align=\"left\">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td>\n</tr>\n<tr>\n<td align=\"left\">CountDownLatch</td>\n<td align=\"left\">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>\n</tr>\n<tr>\n<td align=\"left\">ReentrantReadWriteLock</td>\n<td align=\"left\">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td>\n</tr>\n<tr>\n<td align=\"left\">ThreadPoolExecutor</td>\n<td align=\"left\">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-3-自定义同步工具\"><a href=\"#3-3-自定义同步工具\" class=\"headerlink\" title=\"3.3 自定义同步工具\"></a>3.3 自定义同步工具</h3><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class LeeLock  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryAcquire (int arg) &#123;</span><br><span class=\"line\">            return compareAndSetState(0, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryRelease (int arg) &#123;</span><br><span class=\"line\">            setState(0);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean isHeldExclusively () &#123;</span><br><span class=\"line\">            return getState() &#x3D;&#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private Sync sync &#x3D; new Sync();</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void lock () &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void unlock () &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过我们自己定义的Lock完成一定的同步功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class LeeMain &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static int count &#x3D; 0;</span><br><span class=\"line\">    static LeeLock leeLock &#x3D; new LeeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main (String[] args) throws InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run () &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    leeLock.lock();</span><br><span class=\"line\">                    for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class=\"line\">                        count++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    leeLock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Thread thread1 &#x3D; new Thread(runnable);</span><br><span class=\"line\">        Thread thread2 &#x3D; new Thread(runnable);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        thread1.join();</span><br><span class=\"line\">        thread2.join();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。</p>\n<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。</p>\n<p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p>\n<p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，并返或true，否则返回false。整个比较并替换的操作是一个原子操作。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>上面源码分析时，提到最后调用了compareAndSwapInt方法，接着继续深入探讨该方法，该方法在Unsafe中对应的源码如下。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20180314222522710\" alt=\"img\" loading=\"lazy\"></p>\n<p>可以看到调用了“Atomic::cmpxchg”方法，“Atomic::cmpxchg”方法在linux_x86和windows_x86的实现如下。</p>\n<p><strong>linux_x86的实现：</strong></p>\n<p><img data-src=\"https://img-blog.csdn.net/20180314222533843\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>windows_x86的实现：</strong></p>\n<p><img data-src=\"https://img-blog.csdn.net/20180314222539318\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>Atomic::cmpxchg方法解析：</strong></p>\n<p>mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。</p>\n<ol>\n<li>如果当前系统是多处理器，该函数返回1。</li>\n<li>否则，返回0。</li>\n</ol>\n<p>LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。</p>\n<ol>\n<li>如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。</li>\n<li>否则，不加lock前缀。</li>\n</ol>\n<p>这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。</p>\n<h2 id=\"intel手册对lock前缀的说明如下：\"><a href=\"#intel手册对lock前缀的说明如下：\" class=\"headerlink\" title=\"intel手册对lock前缀的说明如下：\"></a>intel手册对lock前缀的说明如下：</h2><ol>\n<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>\n<li>禁止该指令与之前和之后的读和写指令重排序。</li>\n<li>把写缓冲区中的所有数据刷新到内存中。</li>\n</ol>\n<p>上面的第1点保证了CAS操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有volatile读和volatile写的内存语义。</p>\n<h2 id=\"CAS的缺点：\"><a href=\"#CAS的缺点：\" class=\"headerlink\" title=\"CAS的缺点：\"></a>CAS的缺点：</h2><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>\n<ol>\n<li>循环时间长开销很大。</li>\n<li>只能保证一个变量的原子操作。</li>\n<li>ABA问题。</li>\n</ol>\n<h2 id=\"循环时间长开销很大：\"><a href=\"#循环时间长开销很大：\" class=\"headerlink\" title=\"循环时间长开销很大：\"></a>循环时间长开销很大：</h2><p>CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>\n<h2 id=\"只能保证一个变量的原子操作：\"><a href=\"#只能保证一个变量的原子操作：\" class=\"headerlink\" title=\"只能保证一个变量的原子操作：\"></a>只能保证一个变量的原子操作：</h2><p>当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p>\n<h2 id=\"什么是ABA问题？ABA问题怎么解决？\"><a href=\"#什么是ABA问题？ABA问题怎么解决？\" class=\"headerlink\" title=\"什么是ABA问题？ABA问题怎么解决？\"></a>什么是ABA问题？ABA问题怎么解决？</h2><p>在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。 假设有以下顺序事件：</p>\n<blockquote>\n<p>1、线程1从内存位置V中取出A </p>\n<p>2、线程2从内存位置V中取出A </p>\n<p>3、线程2进行了写操作，将B写入内存位置V </p>\n<p>4、线程2将A再次写入内存位置V </p>\n<p>5、线程1进行CAS操作，发现V中仍然是A，交换成功</p>\n</blockquote>\n<p>尽管线程1的CAS操作成功，但线程1并不知道内存位置V的数据发生过改变</p>\n<p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。根据实际情况，判断是否处理ABA问题。如果ABA问题并不会影响我们的业务结果，可以选择性处理或不处理;如果ABA会影响我们的业务结果的，这时就必须处理ABA问题了。对于AtomicInteger等,没有什么可修改的属性;且我们只在意其结果值，所以对于这些类来说，本身就算发生了ABA现象，也不会对原线程的结果造成什么影响。</p>\n<p>这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类<strong>“AtomicStampedReference”</strong>，它可以通过<strong>控制变量值的版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><p>1.使⽤ volatile 修饰变量就可以<strong>禁⽌ JVM 的指令重排</strong>，保证在多线程环境下也能正常运⾏。 </p>\n<p>2.在 JDK1.2 之前，<strong>Java 的内存模型</strong>实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致。要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使⽤它都到主存中进⾏读取。所以，volatile 关键字 除了防⽌ JVM 的指令重排 ，还有⼀个重要的作⽤就是<strong>保证变量的可⻅性。</strong></p>\n<h1 id=\"内存屏蔽\"><a href=\"#内存屏蔽\" class=\"headerlink\" title=\"内存屏蔽\"></a>内存屏蔽</h1><h2 id=\"1-指令重排序\"><a href=\"#1-指令重排序\" class=\"headerlink\" title=\"1. 指令重排序\"></a>1. 指令重排序</h2><p>程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能。这种内存乱序问题主要是由两种原因引起的：</p>\n<ul>\n<li>编译器在编译时进行了编译优化，导致指令重排；</li>\n<li>在多cpu环境下，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。</li>\n</ul>\n<p><strong>为什么需要内存屏障</strong><br>我们知道，在多CPU（核）场景下，为了充分利用CPU，会通过流水线将指令并行进行。为了能并行执行，又需要将指令进行重排序以便进行并行执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则（如Happens Before 规则）之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性, 不能确保内存与CPU缓存数据一致性的指令也不能重排，<strong>内存屏障正是通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法</strong>。</p>\n<h2 id=\"2-java-内存模型中的happen-before原则\"><a href=\"#2-java-内存模型中的happen-before原则\" class=\"headerlink\" title=\"2. java 内存模型中的happen before原则\"></a>2. java 内存模型中的happen before原则</h2><p>JSR-1337制定了Java内存模型(Java Memory Model, JMM)中规定的hb原则大致有以下几点：</p>\n<ul>\n<li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li>\n<li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li>\n<li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li>\n<li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li>\n<li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li>\n<li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li>\n<li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li>\n<li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li>\n</ul>\n<p>jmm 对java语义的比较重要的两个扩展是：</p>\n<ul>\n<li>对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。</li>\n<li>对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（前提是没有this引用溢出）。</li>\n</ul>\n<h2 id=\"3-内存屏障-Memory-Barrier\"><a href=\"#3-内存屏障-Memory-Barrier\" class=\"headerlink\" title=\"3. 内存屏障(Memory Barrier)\"></a>3. 内存屏障(Memory Barrier)</h2><ul>\n<li>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。</li>\n<li>Memory barrier是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</li>\n<li>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。</li>\n</ul>\n<p>Memory Barrier可以被分为以下几种类型：</p>\n<ul>\n<li><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>\n</li>\n<li><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>\n</li>\n<li><p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>\n</li>\n<li><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>\n</li>\n<li><p><strong>Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序</strong>。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。具体用法可以看下disruptor的Sequence的set方法。</p>\n</li>\n<li><p>Intel 64/IA-32架构下写操作之间不会发生重排序，也就是说在处理器上操作的顺序是可以保证的，这时候使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。采用putOrderedObject可以解决这个问题。</p>\n</li>\n<li><p>即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。</p>\n</li>\n</ul>\n<h2 id=\"4-volatile语义中的内存屏障\"><a href=\"#4-volatile语义中的内存屏障\" class=\"headerlink\" title=\"4. volatile语义中的内存屏障\"></a>4. volatile语义中的内存屏障</h2><ul>\n<li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li>\n<li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li>\n</ul>\n<p>volatile的内存屏障策略非常严格保守，保证了线程可见性。</p>\n<h2 id=\"5-final语义中的内存屏障\"><a href=\"#5-final语义中的内存屏障\" class=\"headerlink\" title=\"5. final语义中的内存屏障\"></a>5. final语义中的内存屏障</h2><ul>\n<li>新建对象过程中，构造体中对final域的初始化写入(StoreStore屏障)和这个对象赋值给其他引用变量，这两个操作不能重排序；</li>\n<li>初次读包含final域的对象引用和读取这个final域（LoadLoad屏障），这两个操作不能重排序；</li>\n<li>Intel 64/IA-32架构下写操作之间不会发生重排序StoreStore会被省略，这种架构下也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li>\n</ul>\n<p><strong>常见的应用场景</strong></p>\n<p>（1）通过 Synchronized关键字包住的代码区域,当线程进入到该区域读取变量信息时,保证读到的是最新的值.这是因为在同步区内对变量的写入操作,在离开同步区时就将当前线程内的数据刷新到内存中,而对数据的读取也不能从缓存读取,只能从内存中读取,保证了数据的读有效性.这就是插入了StoreStore屏障；<br>（2）使用了volatile修饰变量,则对变量的写操作,会插入StoreLoad屏障；<br>（3）其余的操作,则需要通过Unsafe这个类来执行；</p>\n","categories":["锁的分类"],"tags":["锁"]},{"title":"404 Not Found：该页无法显示","url":"//404.html","content":"<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homepagename='返回主页' homepageurl=\"/\" charset=\"utf-8\"></script>"},{"title":"分类","url":"/categories/index.html","content":""},{"title":"标签","url":"/tags/index.html","content":""},{"url":"/js/cursor/candy.min.js","content":"class Circle{constructor({origin:t,speed:i,color:e,angle:s,context:n}){this.origin=t,this.position={...this.origin},this.color=e,this.speed=i,this.angle=s,this.context=n,this.renderCount=0}draw(){this.context.fillStyle=this.color,this.context.beginPath(),this.context.arc(this.position.x,this.position.y,2,0,2*Math.PI),this.context.fill()}move(){this.position.x=Math.sin(this.angle)*this.speed+this.position.x,this.position.y=Math.cos(this.angle)*this.speed+this.position.y+.3*this.renderCount,this.renderCount++}}class Boom{constructor({origin:t,context:i,circleCount:e=10,area:s}){this.origin=t,this.context=i,this.circleCount=e,this.area=s,this.stop=!1,this.circles=[]}randomArray(t){const i=t.length;return t[Math.floor(i*Math.random())]}randomColor(){const t=[\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"];return\"#\"+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)}randomRange(t,i){return(i-t)*Math.random()+t}init(){for(let t=0;t<this.circleCount;t++){const t=new Circle({context:this.context,origin:this.origin,color:this.randomColor(),angle:this.randomRange(Math.PI-1,Math.PI+1),speed:this.randomRange(1,6)});this.circles.push(t)}}move(){this.circles.forEach((t,i)=>{if(t.position.x>this.area.width||t.position.y>this.area.height)return this.circles.splice(i,1);t.move()}),0==this.circles.length&&(this.stop=!0)}draw(){this.circles.forEach(t=>t.draw())}}class CursorSpecialEffects{constructor(){this.computerCanvas=document.createElement(\"canvas\"),this.renderCanvas=document.createElement(\"canvas\"),this.computerContext=this.computerCanvas.getContext(\"2d\"),this.renderContext=this.renderCanvas.getContext(\"2d\"),this.globalWidth=window.innerWidth,this.globalHeight=window.innerHeight,this.booms=[],this.running=!1}handleMouseDown(t){const i=new Boom({origin:{x:t.clientX,y:t.clientY},context:this.computerContext,area:{width:this.globalWidth,height:this.globalHeight}});i.init(),this.booms.push(i),this.running||this.run()}handlePageHide(){this.booms=[],this.running=!1}init(){const t=this.renderCanvas.style;t.position=\"fixed\",t.top=t.left=0,t.zIndex=\"999999999999999999999999999999999999999999\",t.pointerEvents=\"none\",t.width=this.renderCanvas.width=this.computerCanvas.width=this.globalWidth,t.height=this.renderCanvas.height=this.computerCanvas.height=this.globalHeight,document.body.append(this.renderCanvas),window.addEventListener(\"mousedown\",this.handleMouseDown.bind(this)),window.addEventListener(\"pagehide\",this.handlePageHide.bind(this))}run(){if(this.running=!0,0==this.booms.length)return this.running=!1;requestAnimationFrame(this.run.bind(this)),this.computerContext.clearRect(0,0,this.globalWidth,this.globalHeight),this.renderContext.clearRect(0,0,this.globalWidth,this.globalHeight),this.booms.forEach((t,i)=>{if(t.stop)return this.booms.splice(i,1);t.move(),t.draw()}),this.renderContext.drawImage(this.computerCanvas,0,0,this.globalWidth,this.globalHeight)}}const cursorSpecialEffects=new CursorSpecialEffects;cursorSpecialEffects.init();"},{"url":"/js/cursor/fireworks.js","content":"class Circle {\n  constructor({ origin, speed, color, angle, context }) {\n    this.origin = origin\n    this.position = { ...this.origin }\n    this.color = color\n    this.speed = speed\n    this.angle = angle\n    this.context = context\n    this.renderCount = 0\n  }\n\n  draw() {\n    this.context.fillStyle = this.color\n    this.context.beginPath()\n    this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2)\n    this.context.fill()\n  }\n\n  move() {\n    this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x\n    this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3)\n    this.renderCount++\n  }\n}\n\nclass Boom {\n  constructor ({ origin, context, circleCount = 16, area }) {\n    this.origin = origin\n    this.context = context\n    this.circleCount = circleCount\n    this.area = area\n    this.stop = false\n    this.circles = []\n  }\n\n  randomArray(range) {\n    const length = range.length\n    const randomIndex = Math.floor(length * Math.random())\n    return range[randomIndex]\n  }\n\n  randomColor() {\n    const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n    return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range)\n  }\n\n  randomRange(start, end) {\n    return (end - start) * Math.random() + start\n  }\n\n  init() {\n    for(let i = 0; i < this.circleCount; i++) {\n      const circle = new Circle({\n        context: this.context,\n        origin: this.origin,\n        color: this.randomColor(),\n        angle: this.randomRange(Math.PI - 1, Math.PI + 1),\n        speed: this.randomRange(1, 6)\n      })\n      this.circles.push(circle)\n    }\n  }\n\n  move() {\n    this.circles.forEach((circle, index) => {\n      if (circle.position.x > this.area.width || circle.position.y > this.area.height) {\n        return this.circles.splice(index, 1)\n      }\n      circle.move()\n    })\n    if (this.circles.length == 0) {\n      this.stop = true\n    }\n  }\n\n  draw() {\n    this.circles.forEach(circle => circle.draw())\n  }\n}\n\nclass CursorSpecialEffects {\n  constructor() {\n    this.computerCanvas = document.createElement('canvas')\n    this.renderCanvas = document.createElement('canvas')\n\n    this.computerContext = this.computerCanvas.getContext('2d')\n    this.renderContext = this.renderCanvas.getContext('2d')\n\n    this.globalWidth = window.innerWidth\n    this.globalHeight = window.innerHeight\n\n    this.booms = []\n    this.running = false\n  }\n\n  handleMouseDown(e) {\n    const boom = new Boom({\n      origin: { x: e.clientX, y: e.clientY },\n      context: this.computerContext,\n      area: {\n        width: this.globalWidth,\n        height: this.globalHeight\n      }\n    })\n    boom.init()\n    this.booms.push(boom)\n    this.running || this.run()\n  }\n\n  handlePageHide() {\n    this.booms = []\n    this.running = false\n  }\n\n  init() {\n    const style = this.renderCanvas.style\n    style.position = 'fixed'\n    style.top = style.left = 0\n    style.zIndex = '999999999999999999999999999999999999999999'\n    style.pointerEvents = 'none'\n\n    style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth\n    style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight\n\n    document.body.append(this.renderCanvas)\n\n    window.addEventListener('mousedown', this.handleMouseDown.bind(this))\n    window.addEventListener('pagehide', this.handlePageHide.bind(this))\n  }\n\n  run() {\n    this.running = true\n    if (this.booms.length == 0) {\n      return this.running = false\n    }\n\n    requestAnimationFrame(this.run.bind(this))\n\n    this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n    this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n\n    this.booms.forEach((boom, index) => {\n      if (boom.stop) {\n        return this.booms.splice(index, 1)\n      }\n      boom.move()\n      boom.draw()\n    })\n    this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight)\n  }\n}\n\nconst cursorSpecialEffects = new CursorSpecialEffects()\ncursorSpecialEffects.init()\n"},{"url":"/js/cursor/love.min.js","content":"! function (e, t, a) {\n    function n() {\n        c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r()\n    }\n\n    function r() {\n        for (var e = 0; e < d.length; e++) d[e].alpha <= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = \"left:\" + d[e].x + \"px;top:\" + d[e].y + \"px;opacity:\" + d[e].alpha + \";transform:scale(\" + d[e].scale + \",\" + d[e].scale + \") rotate(45deg);background:\" + d[e].color + \";z-index:99999\");\n        requestAnimationFrame(r)\n    }\n\n    function o() {\n        var t = \"function\" == typeof e.onclick && e.onclick;\n        e.onclick = function (e) {\n            t && t(), i(e)\n        }\n    }\n\n    function i(e) {\n        var a = t.createElement(\"div\");\n        a.className = \"heart\", d.push({\n            el: a,\n            x: e.clientX - 5,\n            y: e.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: s()\n        }), t.body.appendChild(a)\n    }\n\n    function c(e) {\n        var a = t.createElement(\"style\");\n        a.type = \"text/css\";\n        try {\n            a.appendChild(t.createTextNode(e))\n        } catch (t) {\n            a.styleSheet.cssText = e\n        }\n        t.getElementsByTagName(\"head\")[0].appendChild(a)\n    }\n\n    function s() {\n        return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n    }\n    var d = [];\n    e.requestAnimationFrame = function () {\n        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {\n            setTimeout(e, 1e3 / 60)\n        }\n    }(), n()\n}(window, document);\n"},{"url":"/js/cursor/text.js","content":"/* 社会主体核心价值观效果 */\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    $(\"body\").click(function(e) {\n        // var a = new Array(\"❤富强❤\",\"❤民主❤\",\"❤文明❤\",\"❤和谐❤\",\"❤自由❤\",\"❤平等❤\",\"❤公正❤\",\"❤法治❤\",\"❤爱国❤\",\"❤敬业❤\",\"❤诚信❤\",\"❤友善❤\");\n        var a = new Array(\"富强\",\"民主\",\"文明\",\"和谐\",\"自由\",\"平等\",\"公正\",\"法治\",\"爱国\",\"敬业\",\"诚信\",\"友善\");\n        var $i = $(\"<span></span>\").text(a[a_idx]);\n        a_idx = (a_idx + 1) % a.length;\n        var x = e.pageX,\n        y = e.pageY;\n        $i.css({\n            \"z-index\": 999999999999999999999999999999999999999999999999999999999999999999999,\n            \"top\": y - 20,\n            \"left\": x,\n            \"position\": \"absolute\",\n            \"font-weight\": \"bold\",\n            \"color\": \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"\n        });\n        $(\"body\").append($i);\n        $i.animate({\n            \"top\": y - 180,\n            \"opacity\": 0\n        },\n        1500,\n        function() {\n            $i.remove();\n        });\n    });\n});"},{"url":"/js/src/jinrishici.js","content":"/**\n * 今日诗词V2 JS-SDK 1.2.2\n * 今日诗词API 是一个可以免费调用的诗词接口：https://www.jinrishici.com\n */\n!function(e){var n,t={},o=\"jinrishici-token\";function i(){return document.getElementById(\"jinrishici-sentence\")||0!=document.getElementsByClassName(\"jinrishici-sentence\").length}function c(){t.load(function(e){var n=document.getElementById(\"jinrishici-sentence\"),t=document.getElementsByClassName(\"jinrishici-sentence\");if(n&&(n.innerText=e.data.content),0!==t.length)for(var o=0;o<t.length;o++)t[o].innerText=e.data.content})}function r(e,n){var t=new XMLHttpRequest;t.open(\"get\",n),t.withCredentials=!0,t.send(),t.onreadystatechange=function(n){if(4===t.readyState){var o=JSON.parse(t.responseText);\"success\"===o.status?e(o):console.error(\"今日诗词API加载失败，错误原因：\"+o.errMessage)}}}t.load=function(n){return e.localStorage&&e.localStorage.getItem(o)?function(e,n){return r(e,\"https://v2.jinrishici.com/one.json?client=browser-sdk/1.2&X-User-Token=\"+encodeURIComponent(n))}(n,e.localStorage.getItem(o)):function(n){return r(function(t){e.localStorage.setItem(o,t.token),n(t)},\"https://v2.jinrishici.com/one.json?client=browser-sdk/1.2\")}(n)},e.jinrishici=t,i()?c():(n=function(){i()&&c()},\"loading\"!=document.readyState?n():document.addEventListener?document.addEventListener(\"DOMContentLoaded\",n):document.attachEvent(\"onreadystatechange\",function(){\"complete\"==document.readyState&&n()}))}(window);"},{"url":"/js/src/snow.min.js","content":"notMobile&&(()=>{let e={flakeCount:100,minDist:150,color:\"255, 255, 255\",size:2,speed:.5,opacity:.2,stepsize:.5};const t=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1e3/60)};window.requestAnimationFrame=t;const i=document.getElementById(\"snow\"),n=i.getContext(\"2d\"),o=e.flakeCount;let a=-100,s=-100,d=[];i.width=window.innerWidth,i.height=window.innerHeight;const h=()=>{n.clearRect(0,0,i.width,i.height);const r=e.minDist;for(let t=0;t<o;t++){let o=d[t];const h=a,m=s,w=o.x,c=o.y,p=Math.sqrt((h-w)*(h-w)+(m-c)*(m-c));if(p<r){const e=(h-w)/p,t=(m-c)/p,i=r/(p*p)/2;o.velX-=i*e,o.velY-=i*t}else o.velX*=.98,o.velY<o.speed&&o.speed-o.velY>.01&&(o.velY+=.01*(o.speed-o.velY)),o.velX+=Math.cos(o.step+=.05)*o.stepSize;n.fillStyle=\"rgba(\"+e.color+\", \"+o.opacity+\")\",o.y+=o.velY,o.x+=o.velX,(o.y>=i.height||o.y<=0)&&l(o),(o.x>=i.width||o.x<=0)&&l(o),n.beginPath(),n.arc(o.x,o.y,o.size,0,2*Math.PI),n.fill()}t(h)},l=e=>{e.x=Math.floor(Math.random()*i.width),e.y=0,e.size=3*Math.random()+2,e.speed=1*Math.random()+.5,e.velY=e.speed,e.velX=0,e.opacity=.5*Math.random()+.3};document.addEventListener(\"mousemove\",e=>{a=e.clientX,s=e.clientY}),window.addEventListener(\"resize\",()=>{i.width=window.innerWidth,i.height=window.innerHeight}),(()=>{for(let t=0;t<o;t++){const t=Math.floor(Math.random()*i.width),n=Math.floor(Math.random()*i.height),o=3*Math.random()+e.size,a=1*Math.random()+e.speed,s=.5*Math.random()+e.opacity;d.push({speed:a,velX:0,velY:a,x:t,y:n,size:o,stepSize:Math.random()/30*e.stepsize,step:0,angle:180,opacity:s})}h()})()})();"},{"url":"/js/src/time.js","content":"(function(){\n\n    var digit=\n     [\n         [\n             [0,0,1,1,1,0,0],\n             [0,1,1,0,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,0,1,1,0],\n             [0,0,1,1,1,0,0]\n         ],//0\n         [\n             [0,0,0,1,1,0,0],\n             [0,1,1,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [1,1,1,1,1,1,1]\n         ],//1\n         [\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,0,1,1,0,0,0],\n             [0,1,1,0,0,0,0],\n             [1,1,0,0,0,0,0],\n             [1,1,0,0,0,1,1],\n             [1,1,1,1,1,1,1]\n         ],//2\n         [\n             [1,1,1,1,1,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//3\n         [\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,1,0],\n             [0,0,1,1,1,1,0],\n             [0,1,1,0,1,1,0],\n             [1,1,0,0,1,1,0],\n             [1,1,1,1,1,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,1,1]\n         ],//4\n         [\n             [1,1,1,1,1,1,1],\n             [1,1,0,0,0,0,0],\n             [1,1,0,0,0,0,0],\n             [1,1,1,1,1,1,0],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//5\n         [\n             [0,0,0,0,1,1,0],\n             [0,0,1,1,0,0,0],\n             [0,1,1,0,0,0,0],\n             [1,1,0,0,0,0,0],\n             [1,1,0,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//6\n         [\n             [1,1,1,1,1,1,1],\n             [1,1,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,1,1,0,0,0],\n             [0,0,1,1,0,0,0],\n             [0,0,1,1,0,0,0],\n             [0,0,1,1,0,0,0]\n         ],//7\n         [\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//8\n         [\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,1,1,0,0,0,0]\n         ],//9\n         [\n             [0,0,0,0,0,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,0,0,0,0,0],\n             [0,0,0,0,0,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,0,0,0,0,0]\n         ]//:\n     ];\n \n var canvas = document.getElementById('canvas');\n \n if(canvas.getContext){\n     var cxt = canvas.getContext('2d');\n     //声明canvas的宽高\n     var H = 100,W = 700;\n     canvas.height = H;\n     canvas.width = W;\n     cxt.fillStyle = '#f00';\n     cxt.fillRect(10,10,50,50);\n \n     //存储时间数据\n     var data = [];\n     //存储运动的小球\n     var balls = [];\n     //设置粒子半径\n     var R = canvas.height/20-1;\n     (function(){\n         var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n         //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成\n         data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n     })();\n \n     /*生成点阵数字*/\n     function renderDigit(index,num){\n         for(var i = 0; i < digit[num].length; i++){\n             for(var j = 0; j < digit[num][i].length; j++){\n                 if(digit[num][i][j] == 1){\n                     cxt.beginPath();\n                     //cxt.fillStyle = '#f00';/*红色数字*/\n                     //cxt.fillStyle = '#fff';/*白色数字*/\n                     cxt.fillStyle = '#FAF0BB';/*代码黄数字*/\n                     cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);\n                     cxt.closePath();\n                     cxt.fill();\n                 }\n             }\n         }\n     }\n \n     /*更新时钟*/\n     function updateDigitTime(){\n         var changeNumArray = [];\n         var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n         var NewData = [];\n         NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n         for(var i = data.length-1; i >=0 ; i--){\n             //时间发生变化\n             if(NewData[i] !== data[i]){\n                 //将变化的数字值和在data数组中的索引存储在changeNumArray数组中\n                 changeNumArray.push(i+'_'+(Number(data[i])+1)%10);\n             }\n         }\n         //增加小球\n         for(var i = 0; i< changeNumArray.length; i++){\n             addBalls.apply(this,changeNumArray[i].split('_'));\n         }\n         data = NewData.concat();\n     }\n \n     /*更新小球状态*/\n     function updateBalls(){\n         for(var i = 0; i < balls.length; i++){\n             balls[i].stepY += balls[i].disY;\n             balls[i].x += balls[i].stepX;\n             balls[i].y += balls[i].stepY;\n             if(balls[i].x > W + R || balls[i].y > H + R){\n                 balls.splice(i,1);\n                 i--;\n             }\n         }\n     }\n \n     /*增加要运动的小球*/\n     function addBalls(index,num){\n         var numArray = [1,2,3];\n         var colorArray =  [\"#3BE\",\"#09C\",\"#A6C\",\"#93C\",\"#9C0\",\"#690\",\"#FB3\",\"#F80\",\"#F44\",\"#C00\"];\n         for(var i = 0; i < digit[num].length; i++){\n             for(var j = 0; j < digit[num][i].length; j++){\n                 if(digit[num][i][j] == 1){\n                     var ball = {\n                         x:14*(R+2)*index + j*2*(R+1)+(R+1),\n                         y:i*2*(R+1)+(R+1),\n                         stepX:Math.floor(Math.random() * 4 -2),\n                         stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],\n                         color:colorArray[Math.floor(Math.random()*colorArray.length)],\n                         disY:1\n                     };\n                     balls.push(ball);\n                 }\n             }\n         }\n     }\n \n     /*渲染*/\n     function render(){\n         //重置画布宽度，达到清空画布的效果\n         canvas.height = 100;\n         //渲染时钟\n         for(var i = 0; i < data.length; i++){\n             renderDigit(i,data[i]);\n         }\n         //渲染小球\n         for(var i = 0; i < balls.length; i++){\n             cxt.beginPath();\n             cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);\n             cxt.fillStyle = balls[i].color;\n             cxt.closePath();\n             cxt.fill();\n         }\n     }\n \n     clearInterval(oTimer);\n     var oTimer = setInterval(function(){\n         //更新时钟\n         updateDigitTime();\n         //更新小球状态\n         updateBalls();\n         //渲染\n         render();\n     },50);\n }\n \n })();"},{"url":"/js/src/word.js","content":"var binft =function (r) {function t() {return b[Math.floor(Math.random() *b.length)]\n}\nfunction e() {return String.fromCharCode(94 *Math.random() + 33)\n}\nfunction n(r) {for (var n =document.createDocumentFragment(),i =0;r >i;i++) {var l =document.createElement(\"span\");l.textContent =e(),l.style.color =t(),n.appendChild(l)\n}\nreturn n\n}\nfunction i() {var t =o[c.skillI];c.step ?c.step-- :(c.step =g,c.prefixP < l.length ?(c.prefixP >=0 &&(c.text +=l[c.prefixP]),c.prefixP++) :\"forward\" ===c.direction ?c.skillP < t.length ?(c.text +=t[c.skillP],c.skillP++) :c.delay ?c.delay-- :(c.direction =\"backward\",c.delay =a) :c.skillP >0 ?(c.text =c.text.slice(0,-1),c.skillP--) :(c.skillI =(c.skillI + 1) % o.length,c.direction =\"forward\")),r.textContent =c.text,r.appendChild(n(c.prefixP < l.length ?Math.min(s,s + c.prefixP) :Math.min(s,t.length - c.skillP))),setTimeout(i,d)\n}\nvar l =\"\",o =[\"山有木兮木有枝，心悦君兮君不知。\",\"人生若只如初见，何事秋风悲画扇。\",\"十年生死两茫茫，不思量，自难忘。\",\"曾经沧海难为水，除却巫山不是云。\",\"洛中何郁郁，冠带自相索。\",\"只愿君心似我心，定不负相思意。\",\"愿得一心人，白头不相离。\",\"入我相思门，知我相思苦。\"].map(function (r) {return r + \"\"\n}),a =2,g =1,s =5,d =75,b =[\"rgb(110,64,170)\",\"rgb(150,61,179)\",\"rgb(191,60,175)\",\"rgb(228,65,157)\",\"rgb(254,75,131)\",\"rgb(255,94,99)\",\"rgb(255,120,71)\",\"rgb(251,150,51)\",\"rgb(226,183,47)\",\"rgb(198,214,60)\",\"rgb(175,240,91)\",\"rgb(127,246,88)\",\"rgb(82,246,103)\",\"rgb(48,239,130)\",\"rgb(29,223,163)\",\"rgb(26,199,194)\",\"rgb(35,171,216)\",\"rgb(54,140,225)\",\"rgb(76,110,219)\",\"rgb(96,84,200)\"],c ={text:\"\",prefixP:-s,skillI:0,skillP:0,direction:\"forward\",delay:a,step:g\n};i()\n};binft(document.getElementById('binft'));"},{"url":"/js/tw_cn.js","content":"var defaultEncoding = 2; // 网站默认语言，1: 繁體中文, 2: 简体中文\nvar translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0\nvar cookieDomain = \"https://tding.top/\"; //更改为你的博客网址\nvar msgToTraditionalChinese = \"繁體\"; //此处可以更改为你想要显示的文字\nvar msgToSimplifiedChinese = \"简体\"; //同上，但两处均不建议更改\nvar translateButtonId = \"translateLink\"; //默认互换id\nvar currentEncoding = defaultEncoding;\nvar targetEncodingCookie = \"targetEncoding\" + cookieDomain.replace(/\\./g, \"\");\nvar targetEncoding = (getCookie(targetEncodingCookie) == null ? defaultEncoding: getCookie(targetEncodingCookie));\nvar translateButtonObject;\nfunction translateText(txt) {\n\tif (txt == \"\" || txt == null) return \"\";\n\tif (currentEncoding == 1 && targetEncoding == 2) return Simplized(txt);\n\telse if (currentEncoding == 2 && targetEncoding == 1) return Traditionalized(txt);\n\telse return txt\n}\nfunction translateBody(fobj) {\n\tif (typeof(fobj) == \"object\") var objs = fobj.childNodes;\n\telse var objs = document.body.childNodes;\n\tfor (var i = 0; i < objs.length; i++) {\n\t\tvar obj = objs.item(i);\n\t\tif (\"||BR|HR|TEXTAREA|\".indexOf(\"|\" + obj.tagName + \"|\") > 0 || obj == translateButtonObject) continue;\n\t\tif (obj.title != \"\" && obj.title != null) obj.title = translateText(obj.title);\n\t\tif (obj.alt != \"\" && obj.alt != null) obj.alt = translateText(obj.alt);\n\t\tif (obj.tagName == \"INPUT\" && obj.value != \"\" && obj.type != \"text\" && obj.type != \"hidden\") obj.value = translateText(obj.value);\n\t\tif (obj.nodeType == 3) obj.data = translateText(obj.data);\n\t\telse translateBody(obj)\n\t}\n}\nfunction translatePage() {\n\tif (targetEncoding == 1) {\n\t\tcurrentEncoding = 1;\n\t\ttargetEncoding = 2;\n\t\ttranslateButtonObject.innerHTML = msgToTraditionalChinese;\n\t\tsetCookie(targetEncodingCookie, targetEncoding, 7);\n\t\ttranslateBody()\n\t} else if (targetEncoding == 2) {\n\t\tcurrentEncoding = 2;\n\t\ttargetEncoding = 1;\n\t\ttranslateButtonObject.innerHTML = msgToSimplifiedChinese;\n\t\tsetCookie(targetEncodingCookie, targetEncoding, 7);\n\t\ttranslateBody()\n\t}\n}\nfunction JTPYStr() {\n\treturn '万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾鼋鼌鼍鼗鼹齄齐齑齿龀龁龂龃龄龅龆龇龈龉龊龋龌龙龚龛龟志制咨只里系范松没尝尝闹面准钟别闲干尽脏拼'\n}\nfunction FTPYStr() {\n\treturn '萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽黿鼂鼉鞀鼴齇齊齏齒齔齕齗齟齡齙齠齜齦齬齪齲齷龍龔龕龜誌製谘隻裡係範鬆冇嚐嘗鬨麵準鐘彆閒乾儘臟拚'\n}\nfunction Traditionalized(cc) {\n\tvar str = '';\n\tvar ss = JTPYStr();\n\tvar tt = FTPYStr();\n\tfor (var i = 0; i < cc.length; i++) {\n\t\tif (cc.charCodeAt(i) > 10000 && ss.indexOf(cc.charAt(i)) != -1) str += tt.charAt(ss.indexOf(cc.charAt(i)));\n\t\telse str += cc.charAt(i)\n\t}\n\treturn str\n}\nfunction Simplized(cc) {\n\tvar str = '';\n\tvar ss = JTPYStr();\n\tvar tt = FTPYStr();\n\tfor (var i = 0; i < cc.length; i++) {\n\t\tif (cc.charCodeAt(i) > 10000 && tt.indexOf(cc.charAt(i)) != -1) str += ss.charAt(tt.indexOf(cc.charAt(i)));\n\t\telse str += cc.charAt(i)\n\t}\n\treturn str\n}\nfunction setCookie(name, value, days) {\n\tif (days) {\n\t\tvar date = new Date();\n\t\tdate.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n\t\tvar expires = \"; expires=\" + date.toGMTString()\n\t} else var expires = \"\";\n\tdocument.cookie = name + \"=\" + value + expires + \"; path=/\"\n}\nfunction getCookie(name) {\n\tvar nameEQ = name + \"=\";\n\tvar ca = document.cookie.split(';');\n\tfor (var i = 0; i < ca.length; i++) {\n\t\tvar c = ca[i];\n\t\twhile (c.charAt(0) == ' ') c = c.substring(1, c.length);\n\t\tif (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length)\n\t}\n\treturn null\n}\nfunction translateInitilization() {\n\ttranslateButtonObject = document.getElementById(translateButtonId);\n\tif (translateButtonObject) {\n\t\twith(translateButtonObject) {\n\t\t\tif (typeof(document.all) != \"object\") {\n\t\t\t\thref = \"javascript:translatePage();\"\n\t\t\t} else {\n\t\t\t\thref = \"#\";\n\t\t\t\tonclick = new Function(\"translatePage(); return false;\")\n\t\t\t}\n\t\t}\n\t\tif (currentEncoding != targetEncoding) {\n\t\t\tsetTimeout(\"translateBody()\", translateDelay);\n\t\t\tif (targetEncoding == 1) translateButtonObject.innerHTML = msgToSimplifiedChinese;\n\t\t\telse translateButtonObject.innerHTML = msgToTraditionalChinese\n\t\t}\n\t}\n}\n"}]