[{"title":"最方便的 Hexo 部署","url":"/2.html","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: git</span><br><span class=\"line\">    repo:</span><br><span class=\"line\">      github:</span><br><span class=\"line\">        url: https:&#x2F;&#x2F;github.com:name&#x2F;name.git</span><br><span class=\"line\">        branch: master</span><br><span class=\"line\">        token: GitHub_Personal_Access_Token</span><br><span class=\"line\">    name: name</span><br><span class=\"line\">    email: email@163.com</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuY2YvMy5odG1s\">获取 GitHub Personal Access Token 方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<a id=\"more\"></a>\n\n\n\n","categories":["Hexo"],"tags":["Next"]},{"title":"枯燥的学习","url":"/2020-10-02-%E6%9E%AF%E7%87%A5%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%AD.html","content":"<h1 id=\"面对生活\"><a href=\"#面对生活\" class=\"headerlink\" title=\"面对生活\"></a>面对生活</h1><p>一个人最好的生活状态： 该看书时看书，该玩时尽情玩； 看见优秀的人欣赏，看见落魄的人也不轻视； 有自己的小生活和小情趣， 不用去想改变世界，努力去活出自己； 没有人爱时专注自己，有人爱时有能力拥抱彼此。</p>\n","categories":["生活"],"tags":["加油"]},{"title":"JAVA 基础笔试题","url":"/2020-10-27-java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98.html","content":"<p>1.笔试题：Java中子类和父类相关方法的执行顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sup</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是父类中的无参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sup</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是父类中的有参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;代码块_父类sup&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;static_sup&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">p</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sup</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sub</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是子类中的无参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sub</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;我是子类中的有参构造方法&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;代码块_子类sub&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;static_sub&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">p</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Sup s = new Sup();</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t Sup s = <span class=\"keyword\">new</span> Sup();</span><br><span class=\"line\">\t\t  Sub s2 = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">\t\t  System.out.println(s2.p());</span><br><span class=\"line\">\t\t  System.out.println(s.p());</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t <span class=\"comment\">// Sup s1 = new Sub();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sub s3 = new Sub(3);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sup s4 = new Sup(3);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sub s5 = new Sub(5);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Sup s6 = new Sub(6);</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//System.out.println(s.p());</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    结果</span><br><span class=\"line\">        static_sup</span><br><span class=\"line\">        static_sub</span><br><span class=\"line\">        代码块_父类sup</span><br><span class=\"line\">        我是父类中的无参构造方法</span><br><span class=\"line\">        代码块_父类sup</span><br><span class=\"line\">        我是父类中的有参构造方法</span><br><span class=\"line\">        代码块_子类sub</span><br><span class=\"line\">        我是子类中的无参构造方法</span><br><span class=\"line\">        <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结</p>\n<p>new一个类对象，类中各部分执行顺序：静态代码块—非静态代码块—构造函数—一般方法。</p>\n<p>子类继承父类各部分执行顺序为：父静态代码块–子静态代码块–父非静态代码–父无参构造函数–子静态代码块–子构造函数–方法。</p>\n<p>注意：创建子类对象调用子类的构造方法的时候会先调用父类的构造方法，在子类的构造方法中调用父类的构造方法是用super()，如果没有写super()，则默认调用父类的无参构造方法。</p>\n","categories":["笔试题"],"tags":["java"]},{"title":"单例模式","url":"/2020-10-28-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html","content":"<p>感觉现在网上介绍的单例模式大部分都很不全面，要不是种类不够，就是写的不够深，介绍的都不全面，所以我会花大量时间写一个单例模式的全面解析，包括介绍、优缺点、多线程下安全与否、模拟攻击单例模式。</p>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p>​        单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>​        单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个 Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。</p>\n<p>​        总之，选择单例模式就是为了避免不一致状态。 </p>\n<h3 id=\"1-饿汉式\"><a href=\"#1-饿汉式\" class=\"headerlink\" title=\"1.饿汉式\"></a>1.饿汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 饿汉式（立即加载）</span></span><br><span class=\"line\"><span class=\"comment\">\t * 饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的</span></span><br><span class=\"line\"><span class=\"comment\">\t * （事实上，通过 反射机制是能够实例化构造方法为 的类的，会使 单例实现失效） </span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton single=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> single;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton.getInstance().hashCode());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSingletonTest singleton = <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">\t\tSingletonTest singleton1 = <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">\t\tsingleton.start();</span><br><span class=\"line\">\t\tsingleton1.start();</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">  </span><br><span class=\"line\">\t线程Thread-<span class=\"number\">0</span>@<span class=\"number\">366712642</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">1</span>@<span class=\"number\">366712642</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-懒汉式\"><a href=\"#2-懒汉式\" class=\"headerlink\" title=\"2.懒汉式\"></a>2.懒汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 懒汉式（延迟加载）：</span></span><br><span class=\"line\"><span class=\"comment\">\t * 该示例虽然用延迟加载方式实现了懒汉式单例，但在多线程环境下会产生多个 对象  是不安全的</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  Singleton s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">                s = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程&quot;</span>+currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton.getInstance().hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SingletonTest s = <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">        SingletonTest s1= <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">        SingletonTest s2= <span class=\"keyword\">new</span> SingletonTest();</span><br><span class=\"line\">        s.start();</span><br><span class=\"line\">        s1.start();</span><br><span class=\"line\">        s2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">    线程Thread-<span class=\"number\">0</span>@<span class=\"number\">1089813737</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">2</span>@<span class=\"number\">2056467717</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">1</span>@<span class=\"number\">431309546</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-懒汉式（加同步锁、使之安全）\"><a href=\"#3-懒汉式（加同步锁、使之安全）\" class=\"headerlink\" title=\"3.懒汉式（加同步锁、使之安全）\"></a>3.懒汉式（加同步锁、使之安全）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton3</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * 同步锁（解决线程安全问题）： </span></span><br><span class=\"line\"><span class=\"comment\">\t\t在方法上加 synchronized 同步锁或是用同步代码块对类加同步锁，此种方式虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程</span></span><br><span class=\"line\"><span class=\"comment\">\t\t想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。 </span></span><br><span class=\"line\"><span class=\"comment\">\t */</span>\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton3 instance=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton3 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (Singleton3.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">\t                instance=<span class=\"keyword\">new</span> Singleton3();</span><br><span class=\"line\">\t            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t                e.printStackTrace();</span><br><span class=\"line\">\t            &#125; </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton3.getInstance().hashCode());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSingletonTest3 s1 = <span class=\"keyword\">new</span> SingletonTest3();</span><br><span class=\"line\">\t\tSingletonTest3 s2 = <span class=\"keyword\">new</span> SingletonTest3();</span><br><span class=\"line\">\t\tSingletonTest3 s3 = <span class=\"keyword\">new</span> SingletonTest3();</span><br><span class=\"line\">\t\ts1.start();</span><br><span class=\"line\">\t\ts2.start();</span><br><span class=\"line\">\t\ts3.start();</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果：</span><br><span class=\"line\">    线程Thread-<span class=\"number\">2</span>@<span class=\"number\">280481333</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">0</span>@<span class=\"number\">280481333</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">1</span>@<span class=\"number\">280481333</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-双重检查锁（提高同步锁的效率）\"><a href=\"#4-双重检查锁（提高同步锁的效率）\" class=\"headerlink\" title=\"4.双重检查锁（提高同步锁的效率）\"></a>4.双重检查锁（提高同步锁的效率）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton4</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 双重检查锁（提高同步锁的效率）： </span></span><br><span class=\"line\"><span class=\"comment\">\t\t使用双重检查锁进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率。</span></span><br><span class=\"line\"><span class=\"comment\">        这里还用到了volatile关键字来修饰singleton，其最关键的作用是防止指令重排</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton4 instance=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton4 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (Singleton4.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t instance=<span class=\"keyword\">new</span> Singleton4();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不加volatile；问题会出现在创建对象的语句<code>instance=new Singleton4();</code> 上，在java中创建一个对象并非是一个原子操作，可以被分解成三行伪代码：</p>\n<ol>\n<li>分配内存空间</li>\n<li>初始化对象</li>\n<li>将对象指向刚分配的内存空间</li>\n</ol>\n<p>但是有些编译器为了性能的原因，可能会将第二步和第三步进行<strong>重排序（指令重排）</strong>，执行顺序可能就成了：</p>\n<ol>\n<li>分配内存空间</li>\n<li>将对象指向刚分配的内存空间（原第3步）</li>\n<li>初始化对象（原第2步）</li>\n</ol>\n<p>在单线程程序下，重排序不会对最终结果产生影响，但是并发的情况下，可能会导致某些线程访问到未初始化的变量。</p>\n<p>模拟一个2个线程创建单例的场景，如下表：现在考虑重排序后，两个线程发生了以下调用：</p>\n<table>\n<thead>\n<tr>\n<th>Time</th>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>T1</td>\n<td>检查到<code>instance</code>为空</td>\n<td></td>\n</tr>\n<tr>\n<td>T2</td>\n<td>获取锁</td>\n<td></td>\n</tr>\n<tr>\n<td>T3</td>\n<td>再次检查到<code>instance</code>为空</td>\n<td></td>\n</tr>\n<tr>\n<td>T4</td>\n<td>为<code>instance</code>分配内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>T5</td>\n<td>将<code>instance</code>指向已分配的内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>T6</td>\n<td></td>\n<td>检查到<code>instance</code>不为空</td>\n</tr>\n<tr>\n<td>T7</td>\n<td></td>\n<td>访问<code>instance</code>的数据（此时<code>uniqueSingleton</code>对象还未完成初始化）</td>\n</tr>\n<tr>\n<td>T8</td>\n<td>初始化<code>instance</code></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在这种情况下，T7时刻线程B对<code>instance</code>进行的访问，访问的是一个<strong>初始化未完成</strong>的对象，就产生了重大安全隐患。</p>\n<p>按照这样的顺序执行，线程B将会获得一个未初始化的对象，并且自始至终，线程B无需获取锁！</p>\n<h3 id=\"5-静态内部类\"><a href=\"#5-静态内部类\" class=\"headerlink\" title=\"5.静态内部类\"></a>5.静态内部类</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton5</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 静态内部类： </span></span><br><span class=\"line\"><span class=\"comment\">\t\t这种方式引入了一个内部静态类（static class），静态内部类只有在调用时才会加载，它保证了Singleton 实例的延迟初始化，又保证了实例的唯一性。</span></span><br><span class=\"line\"><span class=\"comment\">\t\t它把singleton 的实例化操作放到一个静态内部类中，在第一次调用getInstance() 方法时，JVM 才会去加载InnerObject 类，同时初始化singleton 实例，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t所以能让 getInstance() 方法线程安全。 </span></span><br><span class=\"line\"><span class=\"comment\">\t\t特点是：即能延迟加载，也能保证线程安全。 </span></span><br><span class=\"line\"><span class=\"comment\">\t\t静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerObject</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton5 instance = <span class=\"keyword\">new</span> Singleton5(); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton5 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> InnerObject.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonTest5</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;@&quot;</span>+Singleton5.getInstance().hashCode());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSingletonTest5 s1 = <span class=\"keyword\">new</span> SingletonTest5();</span><br><span class=\"line\">\t\tSingletonTest5 s2 = <span class=\"keyword\">new</span> SingletonTest5();</span><br><span class=\"line\">\t\tSingletonTest5 s3 = <span class=\"keyword\">new</span> SingletonTest5();</span><br><span class=\"line\">\t\ts1.start();</span><br><span class=\"line\">\t\ts2.start();</span><br><span class=\"line\">\t\ts3.start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//反射攻击</span></span><br><span class=\"line\">\t\tSingleton5 singleton = Singleton5.getInstance();</span><br><span class=\"line\">\t    Constructor&lt;Singleton5&gt; constructor = Singleton5.class.getDeclaredConstructor();</span><br><span class=\"line\">\t    constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t    Singleton5 newSingleton = constructor.newInstance();</span><br><span class=\"line\">\t    System.out.println(singleton == newSingleton);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果：</span><br><span class=\"line\">    线程Thread-<span class=\"number\">1</span>@<span class=\"number\">1311878651</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">2</span>@<span class=\"number\">1311878651</span></span><br><span class=\"line\">\t线程Thread-<span class=\"number\">0</span>@<span class=\"number\">1311878651</span></span><br><span class=\"line\">    flase</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-枚举类实现（防止反射攻击）\"><a href=\"#6-枚举类实现（防止反射攻击）\" class=\"headerlink\" title=\"6.枚举类实现（防止反射攻击）\"></a>6.枚举类实现（防止反射攻击）</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String objName;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getObjName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> objName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObjName</span><span class=\"params\">(String objName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.objName = objName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 单例测试</span></span><br><span class=\"line\">        Singleton firstSingleton = Singleton.INSTANCE;</span><br><span class=\"line\">        firstSingleton.setObjName(<span class=\"string\">&quot;firstName&quot;</span>);</span><br><span class=\"line\">        System.out.println(firstSingleton.getObjName());</span><br><span class=\"line\">        Singleton secondSingleton = Singleton.INSTANCE;</span><br><span class=\"line\">        secondSingleton.setObjName(<span class=\"string\">&quot;secondName&quot;</span>);</span><br><span class=\"line\">        System.out.println(firstSingleton.getObjName());</span><br><span class=\"line\">        System.out.println(secondSingleton.getObjName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 反射获取实例测试</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Singleton enumConstant : enumConstants) &#123;</span><br><span class=\"line\">                System.out.println(enumConstant.getObjName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">    firstName</span><br><span class=\"line\">\tsecondName</span><br><span class=\"line\">\tsecondName</span><br><span class=\"line\">\tsecondName</span><br></pre></td></tr></table></figure>\n\n<p>最后一种还不算太会，等会了在说！！！</p>\n","categories":["设计模式"],"tags":["单例设计"]},{"title":"冒泡排序","url":"/2020-11-11-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html","content":"<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p><strong>原理：</strong>冒泡排序法是对一组数据进行两两比较，也就是说第一个元素和第二个元素进行比较，如果第一个元素大于第二个元素，两个元素就交换位置，然后第二个元素再和第三个元素进行比较、交换位置，以此类推到倒数第二个元素结束和倒数第一个元素比较交换。这样经过一次遍历就会得到一组数据中的最大元素，然后再进行一组遍历又会得到剩下元素中最大的元素，直到遍历到排序完成。</p>\n<p><strong>得名：</strong>因为每一次遍历都是从第一个元素开始，中间可能会进行多次两两交换，直到遍历结束获得最大的元素。将元素形象的比作气泡，交换到最后的元素就是这组数据中的最大元素也就是最后浮出水面的气泡，因此得名冒泡排序法。</p>\n<ul>\n<li><strong>时间复杂度（平均）：</strong>O(n²) ；最好O(n)，最差O(n²)</li>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTklQkElRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYvOTY2NDI1Nz9mcj1hbGFkZGlu\">空间复杂度<i class=\"fa fa-external-link-alt\"></i></span>：</strong>O(1)</li>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlOTIlRTUlQkElOEYlRTclQUUlOTclRTYlQjMlOTUlRTclQTglQjMlRTUlQUUlOUElRTYlODAlQTcvOTc2MzI1MA==\">稳定性<i class=\"fa fa-external-link-alt\"></i></span>：</strong>稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">publiv <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[])</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;data.length-i-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(data[j]&gt;data[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">               <span class=\"keyword\">int</span> temp=data[j];</span><br><span class=\"line\">               data[j]=data[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">               data[j+<span class=\"number\">1</span>]=temp;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.bubbleSort(data);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length;i++)&#123;</span><br><span class=\"line\">\t   \t\t System.out.print(data[i]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">9</span> <span class=\"number\">18</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> </span><br></pre></td></tr></table></figure>\n\n<p><strong>优化：</strong>看上面的测试可知，在第5次排序时就已经排好序了，但是程序自己不知道，还会一层一层的比较。所以我们可以进行一下优化，设置一个标志位让程序知道什么时候已经排好序了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> []data)</span></span>&#123;</span><br><span class=\"line\">   \t\t <span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">     \t\t   <span class=\"keyword\">return</span> ;</span><br><span class=\"line\"> \t\t\t   &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t   <span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;data.length-i-<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span>(data[j]&gt;data[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">int</span> temp=data[j];</span><br><span class=\"line\">\t\t                data[j]=data[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t                data[j+<span class=\"number\">1</span>]=temp;</span><br><span class=\"line\">\t\t                flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t       &#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t    \t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">6</span> <span class=\"number\">9</span> <span class=\"number\">18</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> </span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["排序算法"],"tags":["简单排序"]},{"title":"插入排序","url":"/2020-11-11-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html","content":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p><strong>原理：</strong>插入排序法就是先选定一个待插入的元素，然后将待插入的元素插入到已经有序的一组数据中。当开始进行遍历时，待插入的元素会和前一个元素进行比较，如果前一个元素大于待插入的元素，就会进行交换元素位置或进行位置移动，直到遇到前一个元素小于当前元素，才会结束当前遍历。继续选定待插入元素继续遍历，当所有待插入元素都已经插入到有序的序列中时排序完成。</p>\n<p><strong>得名：</strong>因为每一次都是将待插入元素插入到一个有序的一组数据中，故得名插入排序法。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(n²)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data[j - <span class=\"number\">1</span>] &gt; data[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = data[j];</span><br><span class=\"line\">                    data[j] = data[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    data[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  \t    <span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">77</span>,<span class=\"number\">88</span>,<span class=\"number\">99</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.insertSorting(data);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length;i++)&#123;</span><br><span class=\"line\">\t    \tSystem.out.print(data[i]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">4</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">4</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">4</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n<p>优化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> []data)</span></span>&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> cur=data[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> per =i;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">while</span>(per &gt;=<span class=\"number\">0</span> &amp;&amp; data[per]&gt;cur)&#123;</span><br><span class=\"line\">\t\t    \t   data[per+<span class=\"number\">1</span>]=data[per];</span><br><span class=\"line\">\t\t    \t   per--;</span><br><span class=\"line\">\t\t       &#125;</span><br><span class=\"line\">\t\t       data[per+<span class=\"number\">1</span>]= cur;</span><br><span class=\"line\">\t\t       System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["简单排序"]},{"title":"希尔排序","url":"/2020-11-12-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html","content":"<p><strong>原理：</strong>希尔排序法就是将一组无序的数据分割成若干个小的子序列分别进行插入排序的方法。因此希尔排序首先要选定一个增量值作为分组的依据，通过增量值的间隔来得到不同的插入排序组，然后对每一组的数据进行插入排序，但增量值要不断地进行递减才能达到排序的目的。</p>\n<p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>\n<p><strong>说明：</strong>希尔排序法的本质是插入排序法，通过递减增量值的方式使得排序变得更加高效，因此希尔排序法也可以叫做缩小增量法。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = data.length/<span class=\"number\">2</span>;<span class=\"comment\">//每次的最大的增量是数组长度的一半，一直到1后排序完成并结束       </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (h &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = h; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i - h; j &gt;= <span class=\"number\">0</span>; j -= h) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (data[j] &gt; data[i]) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> temp = data[i];</span><br><span class=\"line\">                        data[i] = data[j];</span><br><span class=\"line\">                        data[j] = temp;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;h等于&quot;</span>+h+<span class=\"string\">&quot;排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">            h /= <span class=\"number\">2</span>;            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">测试：</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\tDemo_Sort.shellSorting(data);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">h等于<span class=\"number\">5</span>排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>]</span><br><span class=\"line\">h等于<span class=\"number\">2</span>排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">h等于<span class=\"number\">1</span>排序[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"选择排序","url":"/2020-11-11-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html","content":"<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p><strong>原理：</strong>选择排序法就是在遍历一组数据之前先选择一个元素，如果后面的元素小于选择的元素，则将后面的元素与选择的元素进行交换，直到遍历到最后一个元素，这样经过一次遍历后就会得到这组数据的最小的元素也就是有序数据的第一个元素。按照这样的方式继续选择元素继续遍历，直到遍历到这组数据完全有序。</p>\n<p><strong>得名：</strong>因为每一次遍历前都要选择一个元素作为基准，跟后面的元素进行比较后交换元素位置，故得名选择排序法。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(n²)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;data.length;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(data[i]&gt;data[j])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp=data[i];</span><br><span class=\"line\">                data[i]=data[j];</span><br><span class=\"line\">                data[j]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">77</span>,<span class=\"number\">88</span>,<span class=\"number\">99</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.selectSort(data);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length;i++)&#123;</span><br><span class=\"line\">\t   \t\t System.out.print(data[i]+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">36</span>, <span class=\"number\">31</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n<p><strong>优化：</strong>在排序过程中可能会出现这种情况，当我们进行一趟排序的过程中找到的最小数字就是当前需要交换的位置，也就是说当前位置就是当躺最小的值，就不需要在比较了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort1</span><span class=\"params\">(<span class=\"keyword\">int</span> []data)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(data==<span class=\"keyword\">null</span> &amp;&amp; data.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;data.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> selectminindex=i;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;data.length;j++)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span>(data[j]&lt;data[selectminindex])&#123;</span><br><span class=\"line\">\t\t            \tselectminindex=j;</span><br><span class=\"line\">                    &#125;\t </span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">\t\t       <span class=\"keyword\">if</span>(selectminindex!=i)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">int</span> temp=data[i];</span><br><span class=\"line\">\t\t            data[i]=data[selectminindex];</span><br><span class=\"line\">\t\t            data[selectminindex]=temp;</span><br><span class=\"line\">\t\t       &#125;</span><br><span class=\"line\">\t\t       System.out.println(<span class=\"string\">&quot;第&quot;</span>+i+<span class=\"string\">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">第<span class=\"number\">0</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">1</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>, <span class=\"number\">36</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序[<span class=\"number\">4</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">77</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>]</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">22</span> <span class=\"number\">31</span> <span class=\"number\">36</span> <span class=\"number\">55</span> <span class=\"number\">66</span> <span class=\"number\">77</span> <span class=\"number\">88</span> <span class=\"number\">99</span> </span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["排序算法"],"tags":["简单排序"]},{"title":"归并排序","url":"/2020-11-12-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html","content":"<p><strong>原理：</strong>进行归并排序法时首先将一组数据尽可能的拆分成两个个数均等的子组，然后对两个子组继续进行拆分，直到将每个子组的元素个数拆分到1为止，然后开始对相邻的两个子组进行归并，重复归并操作直至所有子组归并为一组时排序完成。</p>\n<p><strong>说明：</strong>归并排序法就是将一组数据先进行连续的拆分后再进行连续的归并，类似于快速排序法也是一种“分治法”的体现。</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(n)</li>\n<li><strong>稳定性：</strong>稳定</li>\n<li><strong>排序位置：</strong>非原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSorting</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        assist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[data.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> low = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> high = data.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        sort(data, low, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] assist;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> low     指向数组第一个元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> high      指向数组最后一个元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (low &gt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid =(high + low) / <span class=\"number\">2</span>; <span class=\"comment\">//取中间的数，进行拆分</span></span><br><span class=\"line\">        sort(data, low, mid);<span class=\"comment\">//左边的数不断进行拆分</span></span><br><span class=\"line\">        sort(data, mid + <span class=\"number\">1</span>, high); <span class=\"comment\">//右边的数不断进行拆分</span></span><br><span class=\"line\">        merge(data, low, mid, high);<span class=\"comment\">//合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = low;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p1 = low;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[p1] &gt; data[p2]) &#123;</span><br><span class=\"line\">                assist[i++] = data[p2++];                </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                assist[i++] = data[p1++];               </span><br><span class=\"line\">            &#125;        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 &lt;= mid) &#123;</span><br><span class=\"line\">            assist[i++] = data[p1++];           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p2 &lt;= high) &#123;</span><br><span class=\"line\">            assist[i++] = data[p2++];            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 把新数组中的数覆盖原data数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = low; index &lt;= high; index++) &#123;</span><br><span class=\"line\">        \tdata[index] = assist[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\tDemo_Sort.mergeSorting(data);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]    </span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"SSM中的过滤器和拦截器","url":"/2020-11-13-SSM%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.html","content":"<h3 id=\"过滤器-Filter-和拦截器-Interceptor\"><a href=\"#过滤器-Filter-和拦截器-Interceptor\" class=\"headerlink\" title=\"过滤器(Filter)和拦截器(Interceptor)\"></a>过滤器(Filter)和拦截器(Interceptor)</h3><p>过滤器(Filter)和拦截器(Interceptor)都是可以作用于若干种不同的请求路径的组件，都可以对某种请求进行阻止，不允许继续向后执行，也可以选择放行，按照原本设定的处理流程继续执行！并且，在同一个项目中，允许同时存在若干个过滤器或拦截器，以形成过滤器链或拦截器链，如果某个请求涉及多个过滤器或拦截器，必须每个过滤器或拦截器都放行，才可以继续执行！</p>\n<h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><ol>\n<li>过滤器是Java EE中的组件，而拦截器是SpringMVC中的组件！只要是Java EE(web)项目，都可以使用过滤器，但是，只有使用了SpringMVC框架，才可以使用拦截器，并且，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！</li>\n<li>过滤器和拦截器的执行时间节点、执行的方法的数量都不相同，过滤器是在所有Servlet组件之前执行的！而拦截器的第1次执行是在DispatcherServlet之后，且在Controller组件之前执行的，而且，当拦截器选择“放行”时，在Controller执行之后，和执行最终的响应之前，还会各执行1次！</li>\n<li>过滤器和拦截器的配置也不相同，过滤器是在<strong>web.xml</strong>中配置的，在配置过程中，可以配置若干个请求路径，也可以使用星号(*)作为通配符，但是，无法配置例外路径（白名单），而拦截器是在Spring的配置文件中进行配置的，其配置方式非常灵活，可以配置若干个请求路径，也可以使用通配符，还可以配置若干个例外路径！</li>\n</ol>\n<p>在一般情况下，我们更关注项目的管理，由于过滤器和拦截器都会出现在真正处理请求的组件之前，所以，都可以实现“阻止”和“放行”的效果，那么，哪个简单、易用、功能更强大，就使用哪个！所以，更优先推荐使用拦截器解决项目中的问题！但是，这也并不代表拦截器就可以完全取代过滤器，例如，某些处理过程应该出现在更早的执行时间节点，就必须使用过滤器，而不能使用拦截器！</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>\n<p>过滤器</p>\n<ul>\n<li>servlet规范中的一部分，任何java web工程都可以使用</li>\n<li>在url-pattern中配置了/*之后，可以对<strong>所有要访问的资源</strong>进行拦截</li>\n</ul>\n<p>拦截器</p>\n<ul>\n<li>拦截器是springMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>\n<li>拦截器只会<strong>拦截访问的控制器方法</strong>，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！，如果访问的是jsp/html/css/image/js是不会进行拦截</li>\n</ul>\n","categories":["框架"],"tags":["过滤器和拦截器"]},{"title":"快速排序","url":"/2020-11-12-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html","content":"<p><strong>原理：</strong>快速排序法就是通过一次排序将待排序的一组数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程采用递归的方式进行，以此达到所有数据变成有序的序列。</p>\n<p><strong>说明：</strong>快速排序是一种“分治法”的体现，将原本的问题进行拆分成两个子问题，然后再分别的去解决这两个子问题，达到“分而治之”的效果。 </p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(logn)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> data[],<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i,j,temp,t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(low&gt;high)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ti=low;</span><br><span class=\"line\">\t\tj=high;</span><br><span class=\"line\">\t\ttemp=data[low];<span class=\"comment\">//选中的基准数  选左面第一位为基准数 一定要从右面先动</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;基准位&quot;</span>+temp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//先看右边</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(temp&lt;=data[j] &amp;&amp; i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//后看左边</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(temp&gt;=data[i] &amp;&amp; i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果满足条件则交换</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&lt;j)&#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;交换数据:&quot;</span>+data[i]+<span class=\"string\">&quot;和&quot;</span>+data[j]);</span><br><span class=\"line\">\t\t\t\tt=data[j];</span><br><span class=\"line\">\t\t\t\tdata[j]=data[i];</span><br><span class=\"line\">\t\t\t\tdata[i]=t;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//最后将基准位与i和j相等的位置交换</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;基准位&quot;</span>+temp+<span class=\"string\">&quot;和i、j相遇的位置&quot;</span>+data[i]+<span class=\"string\">&quot;交换&quot;</span>);</span><br><span class=\"line\">\t\tdata[low]=data[i];</span><br><span class=\"line\">\t\tdata[i]=temp;</span><br><span class=\"line\">\t\tSystem.out.println(java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用左半边数组</span></span><br><span class=\"line\">\t\tquickSort(data, low, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用右半边数组</span></span><br><span class=\"line\">\t\tquickSort(data, j+<span class=\"number\">1</span>, high);</span><br><span class=\"line\">\t\t\t&#125;\t\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">\t\tdemo1_01 d =<span class=\"keyword\">new</span> demo1_01();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\td.quickSort(data, <span class=\"number\">0</span>, data.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">基准位<span class=\"number\">36</span></span><br><span class=\"line\">交换数据:<span class=\"number\">55</span>和<span class=\"number\">9</span></span><br><span class=\"line\">[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">9</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">交换数据:<span class=\"number\">66</span>和<span class=\"number\">18</span></span><br><span class=\"line\">[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">36</span>和i、j相遇的位置<span class=\"number\">6</span>交换</span><br><span class=\"line\">[<span class=\"number\">6</span>, <span class=\"number\">22</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">6</span></span><br><span class=\"line\">交换数据:<span class=\"number\">22</span>和<span class=\"number\">4</span></span><br><span class=\"line\">[<span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">6</span>和i、j相遇的位置<span class=\"number\">4</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">4</span></span><br><span class=\"line\">基准位<span class=\"number\">4</span>和i、j相遇的位置<span class=\"number\">4</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">9</span></span><br><span class=\"line\">基准位<span class=\"number\">9</span>和i、j相遇的位置<span class=\"number\">9</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">18</span></span><br><span class=\"line\">基准位<span class=\"number\">18</span>和i、j相遇的位置<span class=\"number\">18</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">31</span>, <span class=\"number\">22</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">31</span></span><br><span class=\"line\">基准位<span class=\"number\">31</span>和i、j相遇的位置<span class=\"number\">22</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">22</span></span><br><span class=\"line\">基准位<span class=\"number\">22</span>和i、j相遇的位置<span class=\"number\">22</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">66</span>, <span class=\"number\">55</span>]</span><br><span class=\"line\">基准位<span class=\"number\">66</span></span><br><span class=\"line\">基准位<span class=\"number\">66</span>和i、j相遇的位置<span class=\"number\">55</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">基准位<span class=\"number\">55</span></span><br><span class=\"line\">基准位<span class=\"number\">55</span>和i、j相遇的位置<span class=\"number\">55</span>交换</span><br><span class=\"line\">[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"堆排序","url":"/2020-11-13-%E5%A0%86%E6%8E%92%E5%BA%8F.html","content":"<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p><strong>原理：</strong>堆排序法顾名思义采用了堆的数据结构来进行排序。堆排序法就是把堆顶的元素与最后一个元素交换，因为交换后破坏了堆的特性，因此需要把堆中剩余的元素重建成一个满足堆的性质的堆，然后再把堆顶的元素与倒数第二个元素交换，再次进行堆的重建，以此类推直至堆中仅剩最后一个元素排序完成</p>\n<ul>\n<li><strong>时间复杂度：</strong>O(nlogn)</li>\n<li><strong>空间复杂度：</strong>O(1)</li>\n<li><strong>稳定性：</strong>不稳定</li>\n<li><strong>排序位置：</strong>原地排序</li>\n</ul>\n<p><strong>堆：</strong>因为堆顶的元素是一个最值，当堆是大顶堆时堆顶就是最大值，采用堆排序法时可将数据进行升序排列；若堆为小顶堆则堆顶就是最小值，采用堆排序法时可将数据进行降序排列。</p>\n<ul>\n<li>堆中节点的值总是大于或小于其父节点的值</li>\n<li>堆总是一棵完全二叉树</li>\n</ul>\n<p><strong>堆的数组实现：</strong></p>\n<ul>\n<li>下标为i的节点的父节点下标为：(i-1)/2</li>\n<li>下标为i的节点的左孩子下标为：i*2+1</li>\n<li>下标为i的节点的右孩子下标为：i*2+2</li>\n</ul>\n<p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p>\n<p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p>\n<p><img data-src=\"https://i.loli.net/2020/11/13/Zf13XhilSju7T5y.png\" alt=\"堆\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span> || data.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = data.length;</span><br><span class=\"line\">        <span class=\"comment\">//创建大顶堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//从第一个非叶子节点从下到上，从右到左调整结构</span></span><br><span class=\"line\">            standardization(data, n, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = data[<span class=\"number\">0</span>];</span><br><span class=\"line\">            data[<span class=\"number\">0</span>] = data[i];</span><br><span class=\"line\">            data[i] = temp;</span><br><span class=\"line\">            <span class=\"comment\">//重新对堆进行调整,因为第一次已经调成大顶堆了，所以在调只需要在1、2中找一个最大的</span></span><br><span class=\"line\">            standardization(data, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">standardization</span><span class=\"params\">(<span class=\"keyword\">int</span>[] data, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> largest = i;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftSon = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightSon = i * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftSon &lt; n &amp;&amp; data[leftSon] &gt; data[largest]) &#123;</span><br><span class=\"line\">            largest = leftSon;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rightSon &lt; n &amp;&amp; data[rightSon] &gt; data[largest]) &#123;</span><br><span class=\"line\">            largest = rightSon;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = data[i];</span><br><span class=\"line\">            data[i] = data[largest];</span><br><span class=\"line\">            data[largest] = temp;</span><br><span class=\"line\">            <span class=\"comment\">//保证下一层也是大顶堆的情况</span></span><br><span class=\"line\">            standardization(data, n, largest);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>  data[]=&#123;<span class=\"number\">36</span>,<span class=\"number\">22</span>,<span class=\"number\">55</span>,<span class=\"number\">66</span>,<span class=\"number\">31</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">18</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t\tDemo_Sort.heapSort(data);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\"></span><br><span class=\"line\">排序前[<span class=\"number\">36</span>, <span class=\"number\">22</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>, <span class=\"number\">31</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">18</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">排序后[<span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">18</span>, <span class=\"number\">22</span>, <span class=\"number\">31</span>, <span class=\"number\">36</span>, <span class=\"number\">55</span>, <span class=\"number\">66</span>]</span><br></pre></td></tr></table></figure>\n\n","categories":["排序算法"],"tags":["高级排序"]},{"title":"http status 301/302 & java重定向/转发","url":"/2020-11-17-http-status-301302-&-java%E9%87%8D%E5%AE%9A%E5%90%91%E8%BD%AC%E5%8F%91.html","content":"<h2 id=\"一、301-302\"><a href=\"#一、301-302\" class=\"headerlink\" title=\"一、301/302\"></a><strong>一、301/302</strong></h2><h3 id=\"1、什么是301转向-什么是301重定向\"><a href=\"#1、什么是301转向-什么是301重定向\" class=\"headerlink\" title=\"1、什么是301转向?什么是301重定向?\"></a>1、什么是301转向?什么是301重定向?</h3><p>　　301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p>\n<h3 id=\"2、什么是302重定向\"><a href=\"#2、什么是302重定向\" class=\"headerlink\" title=\"2、什么是302重定向?\"></a>2、什么是302重定向?</h3><p>　　302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向(temporary redirect)，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服 务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</p>\n<h3 id=\"3、301重定向与302重定向的区别\"><a href=\"#3、301重定向与302重定向的区别\" class=\"headerlink\" title=\"3、301重定向与302重定向的区别\"></a>3、301重定向与302重定向的区别</h3><p>　　302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>\n<p>　　301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>\n<h3 id=\"4、为什么302-重定向和网址劫持有关联\"><a href=\"#4、为什么302-重定向和网址劫持有关联\" class=\"headerlink\" title=\"4、为什么302 重定向和网址劫持有关联\"></a>4、为什么302 重定向和网址劫持有关联</h3><p>　　从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL 劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</p>\n<p>　　比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>\n<p>　　302 重定向所造成的网址URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>\n<h2 id=\"二、重定向-转发\"><a href=\"#二、重定向-转发\" class=\"headerlink\" title=\"二、重定向/转发\"></a><strong>二、重定向/转发</strong></h2><h3 id=\"1、什么是重定向\"><a href=\"#1、什么是重定向\" class=\"headerlink\" title=\"1、什么是重定向?\"></a>1、什么是重定向?</h3><p>​      服务器向浏览器发送一个302状态码及一个Location消息头(该消息头的值是一个地址)。浏览器在收到之后，会立即向这个地址发送请求。</p>\n<p>如果是按照通俗一点的按照流程里说就是这样：发送请求 --&gt;服务器处理请求--&gt;响应请求，返回给浏览器一个新的地址与响应码（302状态 码）--&gt;浏览器根据响应码（302状态码），判定该响应为重定向，自动发送一个新的请求给服务器，请求地址为之前返回的地址--&gt;服务器运 行--&gt;响应请求给浏览器</p>\n<p>在编程的时候怎么写：</p>\n<p> response.sendRedirect(String url);很简单的一句代码就行了。但是有两个问题是要注意的：</p>\n<ul>\n<li>①重定向之前，不能够有任何的输出，否则会发生错误。</li>\n<li>②重定向之前，会先清空response中缓存的数据。 </li>\n</ul>\n<p>特点是：</p>\n<ul>\n<li>①重定向的地址是任意的。</li>\n<li>②重定向之后，浏览器地址栏的地址会变成Location所指定的地址。</li>\n</ul>\n<h3 id=\"2、什么是转发\"><a href=\"#2、什么是转发\" class=\"headerlink\" title=\"2、什么是转发?\"></a>2、什么是转发?</h3><p>​    一个web组件(servlet/jsp) 将未完成的处理交给另外一个web组件继续完成。</p>\n<p>​    一般应用的场合：一个servlet处理请求之后，将处理结果交给一个jsp，让jsp依据处理结果生成相应的界面。如果是按照通俗一点的按照流程里说就是这样：发送请求 --&gt;服务器处理请求--&gt;进行请求的重新设置，例如通过 request.setAttribute(name,value)--&gt;根据转发的地址，获取该地址的jsp网页--&gt;响应请求给浏览器。<br>编程的时候怎么写？这个比重定向要复杂一点：</p>\n<p>① 将处理结果绑订定到request对象上。request.setAttribute(String name,Object obj);//如果name对应的值不存在，则返回null。Object request.getAttribute(String name);request.removeAttribute(String name);</p>\n<p>② 获得转发器</p>\n<p>//uri:是要转发的目的地，目的地只能是同一个应用的内部。RequestDispatcher rd = request.getRequestDispatcher(String uri);</p>\n<p>③ 转发</p>\n<p>rd.forward(request,response);需要注意的是：转发之前，不要有任何的刷新操作，否则会出错。转发之前，如果response当中缓存有数据，会先清空。</p>\n<p><strong>转发的特点</strong></p>\n<p>① 转发的目的地只能是同一个应用内部的各个组件之间。</p>\n<p>② 转发之后，浏览器地址栏的地址不会变。</p>\n<p>综合上面解说：总结下重定向和转发的区别：</p>\n<p>区别①：</p>\n<p>重定向时，浏览器上的网址改变</p>\n<p>转发时，浏览器上的网址不变</p>\n<p>区别②：</p>\n<p>重定向实际上产生了两次请求</p>\n<p>转发只有一次请求</p>\n<p>区别③：</p>\n<p>重定向的时候网址可以是任何的网址</p>\n<p>转发的网址只能是本站点的网址</p>\n<p>根据上面的分析，所以说，用重定向和转发不是一个习惯不习惯的问题，而是在什么情况下必须用的问题。</p>\n","categories":["java"],"tags":["重定向/转发"]},{"title":"链表","url":"/2020-11-17-%E9%93%BE%E8%A1%A8.html","content":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p><strong>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）</strong>。</p>\n<h3 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h3><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值（NULL）。单向链表只可向一个方向遍历。查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。也可以提前把一个节点的位置另外保存起来，然后直接访问。</p>\n<p>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</p>\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a><strong>双向链表</strong></h3><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。第一个节点的&quot;前连接&quot;指向NULL，最后一个节点的&quot;后连接&quot;指向NULL。这样可以从任何一个节点访问前一个节点，也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。</p>\n<p>单链表只有一个指向下一结点的指针，也就是只能next.<br>双链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</p>\n<h4 id=\"单链表和双向链表区别\"><a href=\"#单链表和双向链表区别\" class=\"headerlink\" title=\"单链表和双向链表区别\"></a>单链表和<strong>双向链表</strong>区别</h4><p>1、因为在双向链表中，我们可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表。</p>\n<p>所以删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样的，指针的总的移动操作都会有2*i次。而如果用双向链表，则不需要定位前驱结点。因此指针总的移动操作为i次。</p>\n<p>2、查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍。</p>\n<p>可是为什么市场上单链表的使用多余双链表呢？</p>\n<p>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</p>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a><strong>循环链表</strong></h3><p>在一个循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。循环链表可以被视为&quot;无头无尾&quot;。</p>\n<p>循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大。</p>\n<p>在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。</p>\n<p><strong>对于循环链表来说唯一的区别是循环结束的条件改为是否指向头指针。</strong></p>\n<h4 id=\"单向循环链表：\"><a href=\"#单向循环链表：\" class=\"headerlink\" title=\"单向循环链表：\"></a>单向循环链表：</h4><p>如果把单链表的最后一个节点的指针指向链表头部，而不是指向NULL，那么就构成了一个单向循环链表，通俗讲就是把尾节点的下一跳指向头结点。</p>\n<h4 id=\"双向循环链表：\"><a href=\"#双向循环链表：\" class=\"headerlink\" title=\"双向循环链表：\"></a>双向循环链表：</h4><p>双（向）链表中有两条方向不同的链，即每个结点中除next域存放后继结点地址外，还增加一个指向其直接前趋的指针域prior。</p>\n<h3 id=\"联系：\"><a href=\"#联系：\" class=\"headerlink\" title=\"联系：\"></a>联系：</h3><h4 id=\"LinkedList用的是单链表还是双链表？\"><a href=\"#LinkedList用的是单链表还是双链表？\" class=\"headerlink\" title=\"LinkedList用的是单链表还是双链表？\"></a>LinkedList用的是单链表还是双链表？</h4><p>JDK1.6之前为循环双向链表，JDK1.7取消了循环。</p>\n<h4 id=\"双向链表和双向循环链表的区别\"><a href=\"#双向链表和双向循环链表的区别\" class=\"headerlink\" title=\"双向链表和双向循环链表的区别\"></a>双向链表和双向循环链表的区别</h4><p>双向链表： 包含两个指针，⼀个prev指向前⼀个节点，⼀个next指向后⼀个节点。</p>\n<p>双向循环链表： 最后⼀个节点的 next 指向head，⽽ head 的prev指向最后⼀个节点，构成⼀个环</p>\n<h4 id=\"LinkedList-为什么不用单链表，而是用双链表？\"><a href=\"#LinkedList-为什么不用单链表，而是用双链表？\" class=\"headerlink\" title=\"LinkedList 为什么不用单链表，而是用双链表？\"></a>LinkedList 为什么不用单链表，而是用双链表？</h4><h4 id=\"LinkedList-删除元素，默认是删除最后一个还是第一个元素？\"><a href=\"#LinkedList-删除元素，默认是删除最后一个还是第一个元素？\" class=\"headerlink\" title=\"LinkedList 删除元素，默认是删除最后一个还是第一个元素？\"></a>LinkedList 删除元素，默认是删除最后一个还是第一个元素？</h4><h3 id=\"链表跟数组的区别？\"><a href=\"#链表跟数组的区别？\" class=\"headerlink\" title=\"链表跟数组的区别？\"></a>链表跟数组的区别？</h3><ol>\n<li>数组静态分配内存，链表动态分配内存；</li>\n<li>数组在内存中连续，链表不连续；</li>\n<li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</li>\n<li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li>\n</ol>\n<h4 id=\"数组的优点\"><a href=\"#数组的优点\" class=\"headerlink\" title=\"数组的优点\"></a>数组的优点</h4><ul>\n<li>随机访问性强（通过下标进行快速定位）</li>\n<li>查找速度快</li>\n</ul>\n<h4 id=\"数组的缺点\"><a href=\"#数组的缺点\" class=\"headerlink\" title=\"数组的缺点\"></a>数组的缺点</h4><ul>\n<li>插入和删除效率低（插入和删除需要移动数据）</li>\n<li>可能浪费内存（因为是连续的，所以每次申请数组之前必须规定数组的大小，如果大小不合理，则可能会浪费内存）</li>\n<li>内存空间要求高，必须有足够的连续内存空间。</li>\n<li>数组大小固定，不能动态拓展</li>\n</ul>\n<h4 id=\"链表的优点\"><a href=\"#链表的优点\" class=\"headerlink\" title=\"链表的优点\"></a>链表的优点</h4><ul>\n<li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li>\n<li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li>\n<li>大小没有固定，拓展很灵活。</li>\n</ul>\n<h4 id=\"链表的缺点\"><a href=\"#链表的缺点\" class=\"headerlink\" title=\"链表的缺点\"></a>链表的缺点</h4><ul>\n<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>\n</ul>\n","categories":["数据结构"],"tags":["链表"]},{"title":"JUC容器","url":"/2020-11-18-JUC%E5%AE%B9%E5%99%A8.html","content":"<p><code>juc</code>是java中<code>java.util.concurrent</code>包的简称.这个包里面的东西就是<code>Doug Lea</code>写的,它主要包括<code>atomic</code>支持原子操作类相关代码,<code>locks</code>java中锁相关代码,还有其他并发容器相关代码.</p>\n<h2 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h2><p>这个包里面提供了许多支持原子相关操作类的代码,例如:<code>AtomicBoolean</code>,<code>AtomicInteger</code>...等等.这些类就是通过<code>CAS</code>来提供原子操作支持的.</p>\n<h2 id=\"locks\"><a href=\"#locks\" class=\"headerlink\" title=\"locks\"></a>locks</h2><p>这个包主要提供了很多java中的锁.例如:<code>ReentrantLock</code>,<code>ReentrantReadWriteLock</code>...等等.这些类就是通过<code>AQS</code>来实现的.</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>在<code>java.util.concurrent</code>下的其他类主要提供了并发容器相关类,例如:<code>ConcurrentHashMap</code>,<code>ConcurrentLinkedQueue</code>...等等相关类.还有线程池相关类,例如:<code>ThreadPoolExecutor</code>,<code>ScheduledThreadPoolExecutor</code>...等等.</p>\n<p>CopyOnWriteArrayList，底层使用到了重入锁，在写的时候加锁，在读的时候不加锁。写的时候复制一份要操作的数组，之后再设置回去。而这个数组用volatile保证内存可见性。</p>\n","categories":["集合"],"tags":["JUC"]},{"title":"Spring 原理","url":"/2020-11-18-Spring-%E5%8E%9F%E7%90%86.html","content":"<h3 id=\"1、什么是Spring-Bean类\"><a href=\"#1、什么是Spring-Bean类\" class=\"headerlink\" title=\"1、什么是Spring Bean类\"></a><strong>1、什么是Spring Bean类</strong></h3><p>Spring Bean是事物处理组件类和实体类（POJO）对象的总称，Spring Bean被Spring IOC容器初始化，装配和管理。</p>\n<h3 id=\"2、Bean类的配置项\"><a href=\"#2、Bean类的配置项\" class=\"headerlink\" title=\"2、Bean类的配置项\"></a><strong>2、Bean类的配置项</strong></h3><p>Spring IOC容器管理Bean时，需要了解Bean的类名、名称、依赖项、属性、生命周期及作用域等信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。</p>\n<ul>\n<li>① class: 该配置项是强制项，用于指定创建Bean实例的Bean类的路径。</li>\n<li>② name: 该配置项是强制项，用于指定Bean唯一的标识符，在基于 XML 的配置项中，可以使用 id和或 name 属性来指定 Bean唯一 标识符。</li>\n<li>③ scope: 该配置项是可选项，用于设定创建Bean对象的作用域。</li>\n<li>④ constructor-arg: 该配置项是可选项，用于<strong>指定通过构造函数注入依赖数据到Bean</strong>。</li>\n<li>⑤ properties: 该配置项是可选项，用于<strong>指定通过set方法注入依赖数据到Bean</strong>。</li>\n<li>⑥ autowiring mode: 该配置项是可选项，用于<strong>指定通过自动依赖方法注入依赖数据到Bean</strong>。</li>\n<li>⑦ lazy-initialization mode: 该配置项是可选项，用于<strong>指定IOC容器延迟创建Bean</strong>，在用户请求时创建Bean，而不要在启动时就创建Bean。</li>\n<li>⑧ initialization: 该配置项是可选项，用于<strong>指定IOC容器完成Bean必要的创建后，调用Bean类提供的回调方法对Bean实例进一步处理</strong>。</li>\n<li>⑨ destruction: 该配置项是可选项，用于<strong>指定IOC容器在销毁Bean时，调用Bean类提供的回调方法</strong>。</li>\n</ul>\n<p><strong>3、将Bean类添加到Spring IOC容器</strong></p>\n<p>将Bean类添加到Spring IOC容器有三种方式。</p>\n<ul>\n<li>一种方式是基于XML的配置文件；</li>\n<li>一种方式是基于注解的配置；</li>\n<li>一种方式是基于Java的配置。</li>\n</ul>\n<p>下面主要介绍基于XML的配置方式，基于注解和基于Java的配置放在后面进行讨论，放在后面讨论的原因是一些其它重要的Spring概念还需要掌握。</p>\n<p><strong>（1）XML配置文件的创建与存储</strong></p>\n<p><strong>（2）Spring配置文件的加载</strong></p>\n<p>加载Spring的配置文件有多种方式，比较常用的是在web.xml加载配置文件。</p>\n<p>① 使用ContextLoaderListener加载配置文件</p>\n<p>ContextLoaderListener类在启动Web容器时，自动加载Spring applicationContext.xml的配置信息。</p>\n<p>② 加载自命名的配置文件</p>\n<p>③ 通过配置目录加载配置文件</p>\n<p><strong>（3）在Spring配置文件中定义Bean</strong></p>\n<p><bean>标签用于定义Bean，各属性说明如下：</p>\n<p>① id：Bean的唯一标识，ApplicationContext对象可以通过id获取该Bean的实例。</p>\n<p>② calss：Bean类的存储路径。</p>\n<p><property>标签用于从外部注入Bean的属性值， <property>标签各属性说明如下：</p>\n<p>① name：Bean类的属性名称。</p>\n<p>② value：name所值属性的值。</p>\n","categories":["框架"],"tags":["Spring"]},{"title":"索引优化","url":"/2020-11-18-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96.html","content":"<h3 id=\"1-索引是什么？\"><a href=\"#1-索引是什么？\" class=\"headerlink\" title=\"1.索引是什么？\"></a>1.索引是什么？</h3><p>排好序的快速查找的数据结构；</p>\n<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p>\n<p>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p>\n<h3 id=\"2-sql执行顺序\"><a href=\"#2-sql执行顺序\" class=\"headerlink\" title=\"2.sql执行顺序\"></a><strong>2.sql执行顺序</strong></h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。下面是经常出现的查询顺序：</p>\n<p><strong>手写：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">\t&lt;<span class=\"keyword\">select</span> <span class=\"keyword\">list</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\t&lt;<span class=\"keyword\">left</span> <span class=\"keyword\">table</span>&gt; &lt;<span class=\"keyword\">join</span> <span class=\"keyword\">type</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span>&lt; <span class=\"keyword\">right</span> <span class=\"keyword\">table</span>&gt; <span class=\"keyword\">ON</span> &lt;<span class=\"keyword\">join</span> condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\t&lt;where_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\t&lt;group_by_list&gt;</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span></span><br><span class=\"line\">\t&lt;having_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\t&lt;order_by_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>机读：</strong>从from开始做笛卡尔积计算，然后on 保留主表，然后同时做join和where判断，然后GROUP BY 、HAVING，然乎在select，最后用ORDER BY排序 、LIMIT限</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM &lt;left_table&gt;</span><br><span class=\"line\">ON&lt;join_condition&gt;</span><br><span class=\"line\">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class=\"line\">WHERE &lt;where_condition&gt;</span><br><span class=\"line\">GROUP BY &lt;group_by_list&gt;</span><br><span class=\"line\">HAVING &lt;having_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\"><span class=\"keyword\">DISTINCT</span> &lt;select_list&gt;</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> &lt;order_by_condition&gt;</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-索引的种类\"><a href=\"#3-索引的种类\" class=\"headerlink\" title=\"3.索引的种类\"></a>3.索引的种类</h3><ul>\n<li>主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引，主键索引不允许为空</li>\n<li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值</li>\n<li>复合索引：即一个索引包含多个列；在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)当表的行数远大于索引列的数目时可以使用复合索引</li>\n</ul>\n<h4 id=\"索引建立成哪种索引类型？\"><a href=\"#索引建立成哪种索引类型？\" class=\"headerlink\" title=\"索引建立成哪种索引类型？\"></a>索引建立成哪种索引类型？</h4><p>根据数据引擎类型自动选择的索引类型；除开 innodb 引擎主键默认为聚簇索引 外。 innodb 的索引都采用的 B+TREE；myisam 则都采用的 B-TREE索引</p>\n<h4 id=\"B-Tree与B-Tree-的区别？\"><a href=\"#B-Tree与B-Tree-的区别？\" class=\"headerlink\" title=\"B+Tree与B-Tree 的区别？\"></a>B+Tree与B-Tree 的区别？</h4><p>结论在内存有限的情况下，B+TREE 永远比 B-TREE好。无限内存则后者方便。</p>\n<p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)<br>　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是<strong>减少磁盘访问次数</strong>。尽管B+树找到一个记录所需的比较次数要比B-树多，但是<strong>一次磁盘访问的时间相当于成百上千次内存比较的时间</strong>，因此实际中B+树的性能可能还会好些，<strong>而且B+树的叶子节点使用指针连接在一起，方便顺序遍历</strong>（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br>　<br>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p>\n<ol>\n<li>B+树的磁盘读写代价更低<br>　　<strong>B+树的内部结点并没有指向关键字具体信息的指针</strong>。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。<strong>相对来说IO读写次数也就降低了。</strong> </li>\n<li>B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。<strong>所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</strong></li>\n</ol>\n<h3 id=\"4-使用索引但索引失效的场景（复合索引）\"><a href=\"#4-使用索引但索引失效的场景（复合索引）\" class=\"headerlink\" title=\"4.使用索引但索引失效的场景（复合索引）\"></a>4.使用索引但索引失效的场景（复合索引）</h3><h4 id=\"如何创建显示删除复合索引？\"><a href=\"#如何创建显示删除复合索引？\" class=\"headerlink\" title=\"如何创建显示删除复合索引？\"></a>如何创建显示删除复合索引？</h4><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">INDEX</span> idx_id_name_age <span class=\"keyword\">ON</span> <span class=\"string\">`user`</span>(<span class=\"keyword\">id</span>,<span class=\"keyword\">name</span>,age)</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">FROM</span> <span class=\"string\">`user`</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> idx_id_name_age <span class=\"keyword\">ON</span> <span class=\"string\">`user`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EXPLAIN-是用来干什么的，怎么用？\"><a href=\"#EXPLAIN-是用来干什么的，怎么用？\" class=\"headerlink\" title=\"EXPLAIN 是用来干什么的，怎么用？\"></a>EXPLAIN 是用来干什么的，怎么用？</h4><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p>\n<p>能干什么：</p>\n<ul>\n<li>表的读取顺序</li>\n<li>哪些索引可以使用</li>\n<li>数据读取操作的操作类型</li>\n<li>哪些索引被实际使用</li>\n<li>表之间的引用</li>\n<li>每张表有多少行被优化器查询</li>\n</ul>\n<p>怎么样：</p>\n<ul>\n<li>Explain + SQL语句</li>\n<li>执行计划包含的信息</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/11/24/U4dLfojQNkxAX7u.png\" loading=\"lazy\"></p>\n<ul>\n<li>id:  select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序;<strong>id相同，执行顺序由上至下;id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行;id相同不同，同时存在。</strong></li>\n<li>select_type:  查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</li>\n<li>table:  显示这一行的数据是关于哪张表的。</li>\n<li>type:  type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是: system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL;一般来说，得保证查询至少达到range级别，最好能达到ref。</li>\n<li>possible_keys:  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</li>\n<li>key:  实际使用的索引。如果为NULL，则没有使用索引；查询中若使用了覆盖索引，则该索引和查询的select字段重叠</li>\n<li>key_len:  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</li>\n<li>ref:  显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</li>\n<li>rows:  rows列显示MySQL认为它执行查询时必须检查的行数。越少越好</li>\n<li>Extra:  包含不适合在其他列中显示但十分重要的额外信息</li>\n</ul>\n<p>Extra又包含：</p>\n<ul>\n<li><p><strong>Using filesort ：</strong> 说明mysql会对数据使用一个<strong>外部的索引排序</strong>，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。<strong>九死一生的,相当于是你在查找时从一楼直接让你上三楼，你自己只能自寻办法，不能走楼梯上去</strong></p>\n</li>\n<li><p><strong>Using temporary：</strong>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。<strong>十死无生的，相当于让你去二楼，然后没给你一楼，空中楼阁</strong></p>\n</li>\n<li><p><strong>USING index：</strong>表示相应的select操作中使用了**覆盖索引(Covering Index)**，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。比较好的！！</p>\n<p>覆盖索引（Covering Index）也叫索引覆盖。理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。</p>\n</li>\n<li><p>Using where：表明使用了where过滤</p>\n</li>\n<li><p>using join buffer：使用了连接缓存</p>\n</li>\n<li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p>\n</li>\n<li><p>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p>\n</li>\n</ul>\n<p>type又包含：<img data-src=\"https://i.loli.net/2020/11/24/rNUu1ex6acyA2I8.png\" loading=\"lazy\"></p>\n<ul>\n<li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li>\n<li>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li>\n<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行；本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，<br>它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li>\n<li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>\n<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</li>\n<li>all：Full Table Scan，将遍历全表以找到匹配的行</li>\n</ul>\n<p><strong>索引失效的场景</strong>：----------------------------------------------------------------------------------------------------------------------</p>\n<p>最好的索引是全值索引，创建的索引都用到了（按序用的）</p>\n<ol>\n<li><strong>最佳左前缀法则：</strong>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。但是有前提条件：1. and 忽略左右关系。即使没有没有按顺序 由于优化器的存在，会自动优化。2. 建立索引CREATE INDEX idx_name_age ON <code>user</code>(name,age)，id为主键；<strong>当使用覆盖索引的方式时</strong>，(select name,age,id from <code>user</code> where age=23(后面没有其他没有索引的字段条件))，即使不是以 name 开头，也会使用 dx_name_age 索引。但是看rows 字段信息搜索的行数是全表的行数，type字段 是index。<strong>第二条是重点！！！</strong></li>\n<li><strong>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</strong></li>\n<li><strong>存储引擎不能使用索引中范围条件右边的列:</strong>  范围 若有索引则能使用到索引，范围条件右边的索引会失效,本身不会失效(范围条件右边与范围条件使用的同一个组合索引，右边的才会失效。若是不同索引则不会失效)</li>\n<li>*<em>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select **</em></li>\n<li><strong>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</strong>：使用 != 和 &lt;&gt; 的字段索引失效( != 针对数值类型。 &lt;&gt; 针对字符类型；前提 where and 后的字段在混合索引中的位置比当前字段靠后  where age != 10 and name=&#39;xxx&#39;  ,这种情况下，mysql自动优化，将 name=&#39;xxx&#39; 放在 age ！=10 之前，name 依然能使用索引。只是 age 的索引失效)</li>\n<li><strong>is not null 也无法使用索引,但是is null是可以使用索引的</strong></li>\n<li><strong>like以通配符开头(&#39;%abc...&#39;)，mysql索引失效会变成全表扫描的操作</strong>：like ‘%abc%’  type 类型会变成 all；like ‘abc%’  type 类型为 range ，算是范围，可以使用索引</li>\n<li><strong>字符串不加单引号索引失效</strong>：底层进行转换使索引失效，使用了函数造成索引失效</li>\n<li><strong>少用or,用它来连接时会索引失效</strong></li>\n</ol>\n","categories":["Mysql"],"tags":["索引"]},{"title":"某东实习一面","url":"/2020-11-20-%E6%9F%90%E4%B8%9C%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2.html","content":"<h4 id=\"1-谈谈Spring框架\"><a href=\"#1-谈谈Spring框架\" class=\"headerlink\" title=\"1.谈谈Spring框架\"></a>1.谈谈Spring框架</h4><p>Spring是一个优秀的轻量级框架，大大的提高了项目的开发管理与维护。spring的轻量级是是从它的大小和开销来说的，完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。3</p>\n<p>Spring是非侵入式的,spring的api是不会出现在业务逻辑上出现的，对于应用而言，业务逻辑可以从当前应用剥离出来，实现复用，对于框架而言，业务逻辑也可以从spring框架中快速的移植到别的框架</p>\n<p>spring提供容器功能，容器可以管理对象的生命周期，对象和对象之间的依赖关系等。通常我们都是可以写一个配置文件，在上面定义对象的名字等，在容器启动以后，这些对象就被实例化好了，我们可以直接去用。而且依赖关系也建立好了。</p>\n<p>Spring有两个核心模块。一个是IOC，一个是AOP。</p>\n<p>IOC:　就是控制反转的意思，指的是我们将对象的控制权从应用代码本身转移到外部容器。通过IOC容器在程序运行期间基于JAVA反射机制</p>\n<p>动态的创建对象，配置对象，建立对象之间的依赖关系，管理对象的生命周期。<strong>而DI作为依赖注入，是实现IOC控制反转的一种手段。</strong>常见的依赖注入方式有:set方式注入、构造器方式注入、接口注入、注解注入。通过依赖注入在程序运行期间动态的注入依赖对象，建立对象之间的依赖关系，降低对象之间的耦合度。</p>\n<p>AOP:面向切面编程，是对面向对象编程的补充。我们将通用的业务功能代码块封装起来作为切面，通过指定切入点，也就是指定切面作用的目标方法，</p>\n<p>最后通过不同类型的通知，告诉容器在调用目标方法的什么时机插入切面代码块。像Spring的声明式事物管理就是基于AOP，在程序运行期间，通过动态代理技术给service层的bean追加事物管理，保证事物的ACID特性。我们可以通过AOP将一些任务单独封装，通过动态代理技术，在不改变原有代码的情况下追加功能，提高代码的复用和简化编程。</p>\n<h4 id=\"2-bean的作用域\"><a href=\"#2-bean的作用域\" class=\"headerlink\" title=\"2.bean的作用域\"></a>2.bean的作用域</h4><p>Spring Bean 中所说的作用域，在配置文件中即是“<strong>scope</strong>”，在面向对象程序设计中<strong>作用域一般指对象或变量之间的可见范围。</strong></p>\n<p>而在Spring容器中<strong>是指其创建的Bean对象相对于其他Bean对象的请求可见范围</strong>。</p>\n<ul>\n<li>singleton:  Spring的默认作用域，容器里拥有唯一的Bean实例</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>prototype：针对每个getBean请求，容器都会创建一个Bean实例</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; prototype &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>request：会为每个Http请求创建一个Bean实例,而且该Bean只在当前request内是有效的</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; request &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>session：会为每个session创建一个Bean实例,而且该Bean只在当前http session内是有效的。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; session &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效.Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span>scope=“globalSession<span class=\"string\">&quot;&gt;&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-aop实现原理\"><a href=\"#3-aop实现原理\" class=\"headerlink\" title=\"3.aop实现原理\"></a>3.aop实现原理</h4><p>Spring采用的方式，通过动态代理的方式，实现简单（运行时织入）</p>\n<h4 id=\"4-在你的项目中那个场景用到了aop\"><a href=\"#4-在你的项目中那个场景用到了aop\" class=\"headerlink\" title=\"4.在你的项目中那个场景用到了aop\"></a>4.在你的项目中那个场景用到了aop</h4><h4 id=\"5-常用的集合类，hashmap、hashtable区别\"><a href=\"#5-常用的集合类，hashmap、hashtable区别\" class=\"headerlink\" title=\"5.常用的集合类，hashmap、hashtable区别\"></a>5.常用的集合类，hashmap、hashtable区别</h4><h4 id=\"6-开发过程中常用的IO操作\"><a href=\"#6-开发过程中常用的IO操作\" class=\"headerlink\" title=\"6.开发过程中常用的IO操作\"></a>6.开发过程中常用的IO操作</h4><h4 id=\"7-左连接、右连接、内连接的区别\"><a href=\"#7-左连接、右连接、内连接的区别\" class=\"headerlink\" title=\"7.左连接、右连接、内连接的区别\"></a>7.左连接、右连接、内连接的区别</h4><h4 id=\"8-mysql的存储引擎都有哪些\"><a href=\"#8-mysql的存储引擎都有哪些\" class=\"headerlink\" title=\"8.mysql的存储引擎都有哪些\"></a>8.mysql的存储引擎都有哪些</h4><h4 id=\"9-INNODB下，行锁-情况下对每行进行updata-没有加where条件他锁的是什么-，或是加了where没有走索引会有什么问题\"><a href=\"#9-INNODB下，行锁-情况下对每行进行updata-没有加where条件他锁的是什么-，或是加了where没有走索引会有什么问题\" class=\"headerlink\" title=\"9.INNODB下，行锁 情况下对每行进行updata 没有加where条件他锁的是什么 ，或是加了where没有走索引会有什么问题\"></a>9.INNODB下，行锁 情况下对每行进行updata 没有加where条件他锁的是什么 ，或是加了where没有走索引会有什么问题</h4><h4 id=\"10-mybatis-和-的区别\"><a href=\"#10-mybatis-和-的区别\" class=\"headerlink\" title=\"10.mybatis #{}和${}的区别\"></a>10.mybatis #{}和${}的区别</h4><ul>\n<li><p>${}是 Properties ⽂件中的变量占位符，它可以⽤于标签属性值和 sql 内部，属于静态⽂本替换，⽐如${driver}会被静态替换为 com.mysql.jdbc.Driver。</p>\n</li>\n<li><p>#{}是 sql 的参数占位符，mybatis在处理#{}时，会将sql中的#{}替换为 ?，调用PreparedStatement的set方法来赋值，按序给 sql 的?号占位符设置参数值；使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</p>\n</li>\n</ul>\n<p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;select id&#x3D;&quot;selectPerson&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;hashmap&quot;&gt;</span><br><span class=\"line\">  SELECT * FROM PERSON WHERE ID &#x3D; #&#123;id&#125;</span><br><span class=\"line\">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p>\n<p>注意参数符号：#{id}</p>\n<p>这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 近似的 JDBC 代码，非 MyBatis 代码...</span><br><span class=\"line\">String selectPerson &#x3D; &quot;SELECT * FROM PERSON WHERE ID &#x3D; ?&quot;;</span><br><span class=\"line\">PreparedStatement ps &#x3D; conn.prepareStatement(selectPerson);</span><br><span class=\"line\">ps.setInt(1,id);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用：\"><a href=\"#引用：\" class=\"headerlink\" title=\"引用：\"></a><strong>引用：</strong></h3><h4 id=\"什么是MySql注入\"><a href=\"#什么是MySql注入\" class=\"headerlink\" title=\"什么是MySql注入\"></a><strong>什么是MySql注入</strong></h4><blockquote>\n<p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p>\n</blockquote>\n<p>简单说，就是我们在拼接sql的时候，没有过滤用户的非法sql，导致查询结果和我们预想的不一样。</p>\n<p><strong>举个简单例子来帮助理解（实际开发中可能不存在这种简单的错误）</strong></p>\n<p><strong>比如我们要根据用户名和密码进行登录，我们后台sql这样写</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username = ? <span class=\"keyword\">and</span> <span class=\"keyword\">password</span> = ?</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们预想的：用户输入 username：张三，password：123456</strong></p>\n<p><strong>但实际人家黑客这样输入： username：张三，password： &quot; or 1 = 1 --</strong></p>\n<p><strong>根据黑客输入的参数，我们的sql将变成这样了</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username = <span class=\"string\">&quot;张三&quot;</span> <span class=\"keyword\">and</span> <span class=\"keyword\">password</span> = <span class=\"string\">&quot;&quot;</span> <span class=\"keyword\">or</span> <span class=\"number\">1</span> = <span class=\"number\">1</span> <span class=\"comment\">-- &quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>后面这个 -- 就是注释，它注释了后面的其它内容，整个sql就变成下面这样，因为 or 1 = 1，所以怎么都会出结果</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username = <span class=\"string\">&quot;张三&quot;</span> <span class=\"keyword\">and</span> <span class=\"keyword\">password</span> = <span class=\"string\">&quot;&quot;</span> <span class=\"keyword\">or</span> <span class=\"number\">1</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>当然了上面只是一个简单的sql注入，有人说实际开发中，我们根本不会这样去做。当然了实际情况中黑客也比我牛批一亿倍，这个例子是为了让你简单理解什么是sql注入。</p>\n<h4 id=\"防止Sql注入攻击\"><a href=\"#防止Sql注入攻击\" class=\"headerlink\" title=\"防止Sql注入攻击\"></a>防止Sql注入攻击</h4><p><strong>1.（简单又有效的方法）PreparedStatement</strong></p>\n<p> 采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。</p>\n<p> 使用好处：</p>\n<ol>\n<li><p> 代码的可读性和可维护性.</p>\n</li>\n<li><p>PreparedStatement尽最大可能提高性能.</p>\n</li>\n<li><p>最重要的一点是极大地提高了安全性.</p>\n<p>原理：</p>\n<p>sql注入只对sql语句的准备(编译)过程有破坏作用</p>\n<p>而PreparedStatement已经准备好了,执行阶段只是把输入串作为数据处理, 而不再对sql语句进行解析准备,因此也就避免了sql注入问题.</p>\n</li>\n</ol>\n<p><strong>2.使用正则表达式过滤传入的参数</strong></p>\n<p><strong>3.字符串过滤</strong></p>\n<p><strong>4.jsp中调用该函数检查是否包函非法字符</strong></p>\n<p> 防止SQL从URL注入：</p>\n<p><strong>5.JSP页面判断代码：</strong></p>\n<p> 使用<span class=\"exturl\" data-url=\"aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2phdmFzY3JpcHQ=\">JavaScript<i class=\"fa fa-external-link-alt\"></i></span>在客户端进行不安全字符屏蔽</p>\n<p> 功能介绍：检查是否含有”‘”,”\\”,”/”</p>\n<p> 参数说明：要检查的字符串</p>\n<p> 返回值：0：是1：不是</p>\n<p> 总的说来，防范一般的SQL注入只要在代码规范上下点功夫就可以了。</p>\n<p> 凡涉及到执行的SQL中有变量时，用JDBC（或者其他数据持久层）提供的如：<strong>PreparedStatement</strong>就可以 ，切记不要用拼接字符串的方法就可以了。</p>\n","categories":["面试"],"tags":["应届面试"]},{"title":"深演智能一面视频","url":"/2020-11-20-%E6%B7%B1%E6%BC%94%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91.html","content":"<p>linux 下查内存命令</p>\n<p>jscri 中怎么用隐藏的标签（就是怎么把vlaue值隐藏）</p>\n<p>spring 中事务在项目中怎么用的 配置文件了吗</p>\n<p>mybatis 开启一级和二级缓存 怎么保证删除数据库中的文件后缓存中数据的一致性</p>\n<p>怎么看自己项目的gc</p>\n<p>怎么解决oom</p>\n<p>linux 查看文件名称包含哪个字符串怎么查找</p>\n<p>inux 下查剩余内存命令</p>\n<p>数据库limit的使用</p>\n<p>索引失效的举例</p>\n","categories":["面试"],"tags":["应届面试"]},{"title":"linux下查看剩余内存、查看文件根据文件名字符串","url":"/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%89%A9%E4%BD%99%E5%86%85%E5%AD%98%E3%80%81%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2.html","content":"<h2 id=\"linux下查看剩余内存\"><a href=\"#linux下查看剩余内存\" class=\"headerlink\" title=\"linux下查看剩余内存\"></a>linux下查看剩余内存</h2><p>看linux系统中空闲内存/物理内存使用/剩余内存</p>\n<p>查看系统内存有很多方法，<strong>但主要的是用top命令和free 命令</strong> 当执行top命令看到结果，要怎么看呢？</p>\n<p>这里说明一下： Mem: 666666k total, 55555k used,并不是代表你的应用程序已经使用了55555k的内存,这55555k是包含了:应用程序内存 + 缓冲 + 缓存的内存的。 </p>\n<p><strong>1.用free命令查看更直接： 下面是一个例子(单位是MB):</strong> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@linuxzgf ~]# free -m</span><br><span class=\"line\">                    total       used       free     shared    buffers     cached</span><br><span class=\"line\">Mem:          <span class=\"number\">7982</span>       <span class=\"number\">6811</span>       <span class=\"number\">1171</span>          <span class=\"number\">0</span>        <span class=\"number\">350</span>       <span class=\"number\">5114</span></span><br><span class=\"line\">-<span class=\"regexp\">/+ buffers/</span>cache:       <span class=\"number\">1346</span>       <span class=\"number\">6636</span></span><br><span class=\"line\">Swap:        <span class=\"number\">16935</span>         <span class=\"number\">11</span>      <span class=\"number\">16924</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.  一些简单的计算方法：  物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M</p>\n<p>物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存 </p>\n<p>应用程序可用空闲内存 = 总物理内存 - 实际已用内存 </p>\n<p>应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存</p>\n<p><strong>2.top命令的结果详解 top命令 是Linux下常用的性能 分析工具 ，能够实时显示系统 中各个进程的资源占用状况，类似于Windows的任务管理 器。下面详细介绍它的使用方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">top - <span class=\"number\">0</span>2:<span class=\"number\">53</span>:<span class=\"number\">32</span> up <span class=\"number\">16</span> days,  <span class=\"number\">6</span>:<span class=\"number\">34</span>, <span class=\"number\">17</span> users,  load average: <span class=\"number\">0.24</span>, <span class=\"number\">0.21</span>, <span class=\"number\">0.24</span></span><br><span class=\"line\">Tasks: <span class=\"number\">481</span> total,   <span class=\"number\">3</span> running, <span class=\"number\">474</span> sleeping,   <span class=\"number\">0</span> stopped,   <span class=\"number\">4</span> zombie</span><br><span class=\"line\">Cpu(s): <span class=\"number\">10.3</span>%us,  <span class=\"number\">1.8</span>%sy,  <span class=\"number\">0.0</span>%ni, <span class=\"number\">86.6</span>%id,  <span class=\"number\">0.5</span>%wa,  <span class=\"number\">0.2</span>%hi,  <span class=\"number\">0.6</span>%si,  <span class=\"number\">0.0</span>%st</span><br><span class=\"line\">Mem:   <span class=\"number\">4042764</span>k total,  <span class=\"number\">4001096</span>k used,    <span class=\"number\">41668</span>k free,   <span class=\"number\">383536</span>k buffers</span><br><span class=\"line\">Swap:  <span class=\"number\">2104472</span>k total,     <span class=\"number\">7900</span>k used,  <span class=\"number\">2096572</span>k free,  <span class=\"number\">1557040</span>k cached</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class=\"line\"><span class=\"number\">32497</span> jacky     <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">669</span>m <span class=\"number\">222</span>m  <span class=\"number\">31</span>m R   <span class=\"number\">10</span>  <span class=\"number\">5.6</span>       <span class=\"number\">29</span>:<span class=\"number\">27.62</span> firefox</span><br><span class=\"line\"> <span class=\"number\">4788</span> yiuwing   <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">257</span>m  <span class=\"number\">18</span>m  <span class=\"number\">13</span>m S    <span class=\"number\">5</span>  <span class=\"number\">0.5</span>          <span class=\"number\">5</span>:<span class=\"number\">42.44</span> konsole</span><br><span class=\"line\"> <span class=\"number\">5657</span> Liuxiaof  <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">585</span>m <span class=\"number\">159</span>m  <span class=\"number\">30</span>m S    <span class=\"number\">4</span>  <span class=\"number\">4.0</span>          <span class=\"number\">5</span>:<span class=\"number\">25.06</span> firefox</span><br><span class=\"line\"> <span class=\"number\">4455</span> xiefc      <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">542</span>m  <span class=\"number\">124</span>m  <span class=\"number\">30</span>m R    <span class=\"number\">4</span>  <span class=\"number\">3.1</span>         <span class=\"number\">7</span>:<span class=\"number\">23.03</span> firefox</span><br><span class=\"line\"> <span class=\"number\">6188</span> Liuxiaof  <span class=\"number\">20</span>   <span class=\"number\">0</span>  <span class=\"number\">191</span>m   <span class=\"number\">17</span>m  <span class=\"number\">13</span>m S    <span class=\"number\">4</span>  <span class=\"number\">0.5</span>          <span class=\"number\">0</span>:<span class=\"number\">0</span>1<span class=\"number\">.16</span> konsole</span><br></pre></td></tr></table></figure>\n\n","categories":["linux"],"tags":["内存查询"]},{"title":"linux下查看文件内容、实时查看","url":"/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B.html","content":"<h2 id=\"Linux下查看文件内容的命令\"><a href=\"#Linux下查看文件内容的命令\" class=\"headerlink\" title=\"Linux下查看文件内容的命令\"></a>Linux下查看文件内容的命令</h2><p>查看文件内容的命令：</p>\n<p>cat   由第一行开始显示内容，并将所有内容输出</p>\n<p>tac   从最后一行倒序显示内容，并将所有内容输出</p>\n<p>more   根据窗口大小，一页一页的现实文件内容</p>\n<p>less   和more类似，但其优点可以往前翻页，而且进行可以搜索字符</p>\n<p>head   只显示头几行</p>\n<p>tail   只显示最后几行</p>\n<p>nl    类似于cat -n，显示时输出行号</p>\n<p>tailf  类似于tail -f </p>\n<h3 id=\"1-cat-与-tac\"><a href=\"#1-cat-与-tac\" class=\"headerlink\" title=\"1.cat 与 tac\"></a><strong>1.cat 与 tac</strong></h3><p>cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。但是cat并不常用，原因是当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。</p>\n<p>cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</p>\n<p>tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令也不常用。</p>\n<p>tac语法：tac 文件名。</p>\n<h3 id=\"2-more和less（常用）\"><a href=\"#2-more和less（常用）\" class=\"headerlink\" title=\"2.more和less（常用）\"></a>2.more和less（常用）</h3><p>more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</p>\n<p>more的语法：more 文件名</p>\n<p>Enter 向下n行，需要定义，默认为1行； </p>\n<p>Ctrl f 向下滚动一屏； </p>\n<p>空格键 向下滚动一屏； </p>\n<p>Ctrl b 返回上一屏； </p>\n<p>= 输出当前行的行号； </p>\n<p>:f 输出文件名和当前行的行号； </p>\n<p>v 调用vi编辑器； </p>\n<p>! 命令 调用Shell，并执行命令； </p>\n<p>q 退出more</p>\n<p>less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</p>\n<p>less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</p>\n<p>less的语法：less 文件名</p>\n<p>less还有一个功能，可以在文件中进行搜索你想找的内容，假设你想在passwd文件中查找有没有weblogic字符串，那么你可以这样来做：</p>\n<p>[root@redhat etc]# less passwd</p>\n<p>然后输入：</p>\n<p>/weblogic</p>\n<p>回车</p>\n<p>此时如果有weblogic字符串，linux会把该字符已高亮方式显示。</p>\n<p>退出查看页面，请按“q”键。</p>\n<h3 id=\"3-head和tail\"><a href=\"#3-head和tail\" class=\"headerlink\" title=\"3.head和tail\"></a>3.head和tail</h3><p>head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</p>\n<p>head的语法：head [n number] 文件名 (number 显示行数)</p>\n<p>tail的功能恰好和head相反，只显示最后几行内容</p>\n<p>tail的语法:tail [-n number] 文件名</p>\n<h3 id=\"4-nl\"><a href=\"#4-nl\" class=\"headerlink\" title=\"4.nl\"></a>4.nl</h3><p>nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</p>\n<p>nl的语法：nl 文件名 </p>\n<h3 id=\"5-tailf\"><a href=\"#5-tailf\" class=\"headerlink\" title=\"5.tailf\"></a>5.tailf</h3><p>　tailf命令几乎等同于tail -f，严格说来应该与tail --follow=name更相似些。当文件改名之后它也能继续跟踪，特别适合于日志文件的跟踪（follow the growth of a log file）。与tail -f不同的是，如果文件不增长，它不会去访问磁盘文件（It is similar to tail -f but does not access the file when it is not growing. This has the side effect of not updating the access time for the file, so a filesystem flush does not occur periodically when no log activity is happening.）。tailf特别适合那些便携机上跟踪日志文件，因为它能省电，因为减少了磁盘访问嘛（tailf is extremely useful for monitoring log files on a laptop when logging is infrequent and the user desires that the hard disk spin down to conserve battery life.）。tailf命令不是个脚本，而是一个用C代码编译后的二进制执行文件，某些Linux安装之后没有这个命令，本文提供了怎么编译安装tailf命令的方法。</p>\n<h2 id=\"面就谈谈二者的区别：\"><a href=\"#面就谈谈二者的区别：\" class=\"headerlink\" title=\"面就谈谈二者的区别：\"></a>面就谈谈二者的区别：</h2><ol>\n<li><p>tailf 总是从文件开头一点一点的读， 而tail -f 则是从文件尾部开始读</p>\n</li>\n<li><p>tailf check文件增长时，使用的是文件名， 用stat系统调用；而tail -f 则使用的是已打开的文件描述符； 注：tail 也可以做到类似跟踪文件名的效果； 但是tail总是使用fstat系统调用，而不是stat系统调用；结果就是：默认情况下，当tail的文件被偷偷删除时，tail是不知道的，而tailf是知道的。</p>\n<p>常用参数</p>\n</li>\n</ol>\n<p>格式：tailf logfile</p>\n<p>动态跟踪日志文件logfile，最初的时候打印文件的最后10行内容。</p>\n<p>watch -n 1 aa.txt  #每个1秒显示aa.txt的内容</p>\n<h3 id=\"Linux下实时显示文件内容\"><a href=\"#Linux下实时显示文件内容\" class=\"headerlink\" title=\"Linux下实时显示文件内容\"></a>Linux下实时显示文件内容</h3><ol>\n<li><p> watch -n 1 aa.txt    #每个1秒显示aa.txt的内容</p>\n</li>\n<li><p>tail -f  ***.log</p>\n</li>\n</ol>\n<p>Linux shell中有一个tail命令，常用来显示一个文件的最后n行文档内容</p>\n<p>但更多情况下，我们要在服务器端运行程序，并且需要实时监控运行日志，这时候有什么办法实时滚动显示log文件内容？</p>\n<p>这里可以利用tail命令加参数f实现，具体用法如下：</p>\n<p>tail -f  ***.log</p>\n<p>参数说明-f, --follow[={name|descriptor}]：output appended data as the file grows; -f, --follow, and --follow=descriptor are equivalent</p>\n<p>用法：tail  (-10f)  test ：（-10f）可选，tail  -10f server.xml    </p>\n<p>tail  (-10f)  test：中间-10f为可选，不输入该属性时，显示文件的全部内容；如-10f，显示当前文件的最后10行内容，10为显示文件的行数，可变，如果不输入中间参数例如10的时候，我们直接tail -f  server.xml查看实时内容。</p>\n<p>tail其它参数运行 man tail 查看</p>\n","categories":["linux"],"tags":["查看内容"]},{"title":"redis常见问题","url":"/2020-11-24-redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html","content":"<h1 id=\"一、Redis雪崩、穿透、击穿、并发等难题解决方案\"><a href=\"#一、Redis雪崩、穿透、击穿、并发等难题解决方案\" class=\"headerlink\" title=\"一、Redis雪崩、穿透、击穿、并发等难题解决方案\"></a>一、Redis雪崩、穿透、击穿、并发等难题解决方案</h1><p><strong>使用缓存的主要目是提升查询速度和减轻数据库压力。而缓存最常见的问题是缓存穿透、击穿和雪崩，在高并发下这三种情况都会有大量请求落到数据库，导致数据库资源占满，引起数据库故障。</strong></p>\n<h2 id=\"1-缓存雪崩\"><a href=\"#1-缓存雪崩\" class=\"headerlink\" title=\"1.缓存雪崩\"></a>1.缓存雪崩</h2><p>定义：在高并发下，缓存（key）在同⼀时间内⼤⾯积的失效，所以后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。</p>\n<p>雪崩过程：</p>\n<ol>\n<li>redis集群大面积故障</li>\n<li>缓存失效，但依然大量请求访问缓存服务redis</li>\n<li>redis大量失效后，大量请求转向到mysql数据库</li>\n<li>mysql的调用量暴增，很快就扛不住了，甚至直接宕机</li>\n<li>由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>事前：①<strong>保证redis高可用</strong>，配置redis集群，如果发现有宕机的尽快补上；这种方案就是在发生雪崩前对缓存集群实现高可用，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。②选择合适的<strong>内存淘汰策略</strong>，让缓存失效的时间点尽量均匀。③<strong>数据预热</strong>，数据预热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中；在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>\n<li>事中：<strong>使用本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</strong>；使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster （集群）完全不可用的时候，ehcache 本地缓存还能够支撑一阵。使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。</li>\n<li>事后：<strong>利⽤ redis 持久化机制保存的数据尽快恢复缓存</strong>；一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</li>\n</ol>\n<h2 id=\"2-缓存穿透\"><a href=\"#2-缓存穿透\" class=\"headerlink\" title=\"2.缓存穿透\"></a>2.缓存穿透</h2><p>定义：缓存穿透就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这⼀层，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。。</p>\n<p>穿透过程：</p>\n<ol>\n<li>请求的key首先到达redis缓存中，发现不存在，访问数据库；如果是正常访问，存在就直接返回数据了。</li>\n<li>然后请求到达数据库，然后数据库中还不存在，直接返回结果；如果存在则把数据缓存到redis中，并返回数据。</li>\n</ol>\n<blockquote>\n<p>⼀般MySQL 默认的最⼤连接数在 150 左右，这个可以通过 show variables like &#39;%max_connections%&#39;;命令来查看。最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹络等⽆⼒条件都是其运⾏指标，这些指标都会限制其并发能⼒！所以，⼀般 3000 个并发请求就能打死⼤部分数据库了。</p>\n</blockquote>\n<p>解决办法：</p>\n<p>最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的数据库 id 不能⼩于 0、传⼊的邮箱格式不正确的时候直接返回错误消息给客户端等等。</p>\n<ol>\n<li>缓存⽆效 key :  如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时间，具体命令如下： SET key value EX 10086。这种⽅式可以解决请求的 key 变化不频繁的情况，如果⿊客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存⼤量⽆效的 key 。很明显，这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key的过期时间设置短⼀点⽐如 1 分钟。另外，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。</li>\n<li>布隆过滤器：布隆过滤器是⼀个⾮常神奇的<strong>数据结构</strong>，<strong>通过它我们可以⾮常⽅便地判断⼀个给定数据是否存在与海量数据中</strong>。我们需要的就是判断 key 是否合法，<strong>拦截对 不存在数据的请求</strong>。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会⾛下⾯的流程。<strong>使用：</strong>将数据库中所有的查询条件，放入布隆过滤器中，当一个查询请求过来时，先经过布隆过滤器进行查看，如果判断请求查询值存在，则继续查；如果判断请求查询不存在，直接丢弃。</li>\n</ol>\n<p>布隆过滤器这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</p>\n<blockquote>\n<h3 id=\"布隆过滤器的原理介绍\"><a href=\"#布隆过滤器的原理介绍\" class=\"headerlink\" title=\"布隆过滤器的原理介绍\"></a>布隆过滤器的原理介绍</h3><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>\n<ol>\n<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>\n<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>\n</ol>\n<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>\n<ol>\n<li>对给定元素再次进行相同的哈希计算；</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>\n</ol>\n<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>\n<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>\n<p><strong>应用场景</strong></p>\n<ol>\n<li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li>\n<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li>\n</ol>\n</blockquote>\n<h2 id=\"3-缓存击穿\"><a href=\"#3-缓存击穿\" class=\"headerlink\" title=\"3.缓存击穿\"></a>3.缓存击穿</h2><p>定义：在高并发下，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。会造成某一时刻数据库请求量过大，压力剧增。这种现象我们称为<strong>缓存击穿</strong>。</p>\n<p>解决办法：</p>\n<ol>\n<li>使用锁，单机用synchronized,lock等，分布式用分布式锁：上<strong>面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它；其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</strong></li>\n<li>缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。</li>\n<li>在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。</li>\n<li>设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存</li>\n</ol>\n<h2 id=\"4-Redis为什么时高并发的、快速的\"><a href=\"#4-Redis为什么时高并发的、快速的\" class=\"headerlink\" title=\"4.Redis为什么时高并发的、快速的\"></a>4.Redis为什么时高并发的、快速的</h2><p>1.redis是基于内存的，内存的读写速度非常快；</p>\n<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>\n<p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>\n<p>下面重点介绍单线程设计和IO多路复用核心设计快的原因。</p>\n<p><strong>为什么Redis是单线程的？</strong></p>\n<p><strong>1.官方答案</strong></p>\n<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p><strong>2.性能指标</strong></p>\n<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p><strong>3.详细原因</strong></p>\n<p><strong>1）不需要各种锁的性能消耗</strong></p>\n<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>\n<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>\n<p><strong>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</strong></p>\n<p><strong>2）单线程多进程集群方案</strong></p>\n<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>\n<p><strong>所以单线程、多进程的集群不失为一个好的解决方案。</strong></p>\n<p><strong>3）CPU消耗</strong></p>\n<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>\n<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>\n<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>\n<p>Redis单线程的优劣势</p>\n<p><strong>单进程单线程优势</strong></p>\n<ul>\n<li>代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU</li>\n</ul>\n<p><strong>单进程单线程弊端</strong></p>\n<ul>\n<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>\n</ul>\n<p><strong>IO多路复用技术</strong></p>\n<p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p>\n<p>多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。</p>\n<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>\n<p><strong>Redis高并发快总结</strong></p>\n<ol>\n<li><p>Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</p>\n</li>\n<li><p>再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</p>\n</li>\n<li><p>Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p>\n</li>\n<li><p>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p>\n</li>\n<li><p>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p>\n</li>\n</ol>\n<blockquote>\n<p>什么是上下⽂切换?<br>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。<br>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。<strong>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</strong></p>\n</blockquote>\n","categories":["redis"],"tags":["雪崩等"]},{"title":"索引种类","url":"/2020-11-24%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB.html","content":"<h1 id=\"MySql\"><a href=\"#MySql\" class=\"headerlink\" title=\"MySql\"></a>MySql</h1><h2 id=\"MySQL索引种类\"><a href=\"#MySQL索引种类\" class=\"headerlink\" title=\"MySQL索引种类\"></a>MySQL索引种类</h2><p>在 InnoDB 中，有聚簇索引和普通索引之分，聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，根据主键查询可以直接利用聚簇索引定位到所在记录。而普通索引根据申明这个索引时候的列来构建，叶子节点存放的是这一行记录对应的主键的值，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。如果我们查询一整行记录的话，一定要去聚簇索引上查找，而如果我们只需要根据普通索引查询主键的值，由于这些值在普通索引上已经存在，所以并不需要回表，这个称为索引覆盖，在一定程度上可以提高查询效率。</p>\n<ol>\n<li>普通索引</li>\n<li>唯一索引</li>\n<li>主键索引</li>\n<li>组合索引</li>\n<li>全文索引</li>\n</ol>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a><strong>语句</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE table_name[col_name data type]</span><br><span class=\"line\">[unique|fulltext][index|key][index_name](col_name[length])[asc|desc]</span><br></pre></td></tr></table></figure>\n\n<p>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引<br>2.index和key为同义词，两者作用相同，用来指定创建索引<br>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择<br>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值<br>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度<br>6.asc或desc指定升序或降序的索引值存储</p>\n<h4 id=\"1-普通索引\"><a href=\"#1-普通索引\" class=\"headerlink\" title=\"1.普通索引\"></a>1.普通索引</h4><p>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p>\n<p>（2）修改表结构的方式添加索引</p>\n<p>（3）创建表的时候同时创建索引</p>\n<h4 id=\"2-唯一索引\"><a href=\"#2-唯一索引\" class=\"headerlink\" title=\"2.唯一索引\"></a>2.唯一索引</h4><p>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p>\n<p>（2）修改表结构</p>\n<p>（3）创建表的时候直接指定</p>\n<h4 id=\"3-主键索引\"><a href=\"#3-主键索引\" class=\"headerlink\" title=\"3.主键索引\"></a>3.主键索引</h4><p>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</p>\n<h4 id=\"4-组合索引\"><a href=\"#4-组合索引\" class=\"headerlink\" title=\"4.组合索引\"></a>4.组合索引</h4><p>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>\n<h4 id=\"5-全文索引\"><a href=\"#5-全文索引\" class=\"headerlink\" title=\"5.全文索引\"></a>5.全文索引</h4><p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br>（1）创建表的适合添加全文索引</p>\n<p>（2）修改表结构添加全文索引</p>\n<p>（3）直接创建索引</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1.虽然索引大大提高了查询速度，<strong>同时却会降低更新表的速度</strong>，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。</p>\n<p>2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。</p>\n<p>索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>使用索引时，有以下一些技巧和注意事项：</p>\n<p>1.最佳左前缀法则</p>\n<p>2.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一至）），减少select *</p>\n<p>3.索引列排序</p>\n<p>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>\n<p>4.like语句操作<br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>\n<p>5.不要在列上进行运算（函数）<br>这将导致索引失效而进行全表扫描，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name WHERE YEAR(column_name)&lt;2017;</span><br></pre></td></tr></table></figure>\n\n<p>6.不使用！=和&lt;&gt;操作</p>\n","categories":["Mysql"],"tags":["索引"]},{"title":"SpringBoot整合Redis","url":"/2020-11-25-SpringBoot%E6%95%B4%E5%90%88Redis.html","content":"<p><strong>Redis</strong></p>\n<p>基于内存进行存储，支持key-value的存储形式，底层是用C语言写的。</p>\n<p>基于key-value形式的数据字典，结构非常简单，没有数据表的概念，直接用键值对的形式完成数据的管理，支持5种数据类型：</p>\n<ul>\n<li>字符串String</li>\n<li>列表List</li>\n<li>集合Set</li>\n<li>有序集合zSet</li>\n<li>哈希hash</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">offCOPY&#x2F;&#x2F;Redis启动批处理程序</span><br><span class=\"line\">title redis-server</span><br><span class=\"line\">set ENV_HOME&#x3D;&quot;C:\\redis&quot;</span><br><span class=\"line\">C:</span><br><span class=\"line\">color 0F</span><br><span class=\"line\">cd %ENV_HOME%</span><br><span class=\"line\">redis-server redis.windows.conf</span><br><span class=\"line\">exit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-Boot-整合-Redis\"><a href=\"#Spring-Boot-整合-Redis\" class=\"headerlink\" title=\"Spring Boot 整合 Redis\"></a>Spring Boot 整合 Redis</h3><p>实际上使用Spring Data Redis操作Redis，</p>\n<p>1、创建maven工程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class=\"line\">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;com.hhzhu&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;redis_practice&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class=\"line\">    &lt;&#x2F;parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;!--连接池 redis客户端需要的支持--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;!--简化实体类的开发--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">        &lt;&#x2F;dependency&gt;</span><br><span class=\"line\">    &lt;&#x2F;dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、创建实体类，实现序列化接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.hhzhu.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">import java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@Data</span><br><span class=\"line\">&#x2F;&#x2F;实现序列化接口，否则无法存入redis，因为redis是存在内存中的</span><br><span class=\"line\">public class Student implements Serializable &#123;</span><br><span class=\"line\">    private Integer id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private Double score;</span><br><span class=\"line\">    private Date birthday;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、创建控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYpackage com.hhzhu.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.hhzhu.pojo.Student;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class StudentHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;&#x2F;set&quot;)</span><br><span class=\"line\">    &#x2F;&#x2F;Request将json数据转换成java对象</span><br><span class=\"line\">    public void set(@RequestBody Student student)&#123;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(&quot;student&quot;,student);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、创建配置文件appliacation.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYspring:</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    database: 0</span><br><span class=\"line\">    host: localhost</span><br><span class=\"line\">    port: 6379</span><br></pre></td></tr></table></figure>\n\n<p>5、创建启动类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYpackage com.hhzhu;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class Application &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(Application.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6、CRUD</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYpackage com.hhzhu.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.hhzhu.pojo.Student;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Description:</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author ZhuHh</span><br><span class=\"line\"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class StudentHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;&#x2F;set&quot;)</span><br><span class=\"line\">    &#x2F;&#x2F;Request将json数据转换成java对象</span><br><span class=\"line\">    public void set(@RequestBody Student student)&#123;</span><br><span class=\"line\">        redisTemplate.opsForValue().set(&quot;student&quot;,student);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(&quot;&#x2F;get&#x2F;&#123;key&#125;&quot;)</span><br><span class=\"line\">    public Student get(@PathVariable(&quot;key&quot;) String key)&#123;</span><br><span class=\"line\">        return (Student) redisTemplate.opsForValue().get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @DeleteMapping(&quot;&#x2F;delete&#x2F;&#123;key&#125;&quot;)</span><br><span class=\"line\">    public boolean delete(@PathVariable(&quot;key&quot;) String key)&#123;</span><br><span class=\"line\">        redisTemplate.delete(key);</span><br><span class=\"line\">        return redisTemplate.hasKey(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redis-5种数据类型\"><a href=\"#Redis-5种数据类型\" class=\"headerlink\" title=\"Redis 5种数据类型\"></a>Redis 5种数据类型</h3><ul>\n<li><p><strong>字符串</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;string&quot;)</span><br><span class=\"line\">public String stringTest()&#123;</span><br><span class=\"line\">    redisTemplate.opsForValue().set(&quot;str&quot;,&quot;Hello world&quot;);</span><br><span class=\"line\">    &#x2F;&#x2F;System.out.println(redisTemplate.opsForValue().get(&quot;str&quot;));</span><br><span class=\"line\">    String str &#x3D; (String) redisTemplate.opsForValue().get(&quot;str&quot;);</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>列表</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;list&quot;)</span><br><span class=\"line\">public List&lt;String&gt; listTest()&#123;</span><br><span class=\"line\">    ListOperations&lt;String,String&gt; listOperations &#x3D; redisTemplate.opsForList();</span><br><span class=\"line\">    listOperations.leftPush(&quot;list&quot;,&quot;hello&quot;);</span><br><span class=\"line\">    listOperations.leftPush(&quot;list&quot;,&quot;world&quot;);</span><br><span class=\"line\">    listOperations.rightPush(&quot;list&quot;,&quot;java&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">    List&lt;String&gt; list &#x3D; listOperations.range(&quot;list&quot;,0,2);</span><br><span class=\"line\">    return list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>集合(set)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;set&quot;)</span><br><span class=\"line\">public Set&lt;String&gt; setTest()&#123;</span><br><span class=\"line\">    SetOperations&lt;String,String&gt; setOperations &#x3D; redisTemplate.opsForSet();</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;Hello&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;Hello&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;world&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;world&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;java&quot;);</span><br><span class=\"line\">    setOperations.add(&quot;set&quot;,&quot;java&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">    Set&lt;String&gt; set &#x3D; setOperations.members(&quot;set&quot;);</span><br><span class=\"line\">    return set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>有序集合</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;zset&quot;)</span><br><span class=\"line\">public Set&lt;String&gt; zsetTest()&#123;</span><br><span class=\"line\">    ZSetOperations&lt;String,String&gt; zSetOperations &#x3D; redisTemplate.opsForZSet();</span><br><span class=\"line\">    zSetOperations.add(&quot;zset&quot;,&quot;Hello&quot;,1);</span><br><span class=\"line\">    zSetOperations.add(&quot;zset&quot;,&quot;world&quot;,2);</span><br><span class=\"line\">    zSetOperations.add(&quot;zset&quot;,&quot;java&quot;,3);</span><br><span class=\"line\">  </span><br><span class=\"line\">    Set&lt;String&gt; set &#x3D; zSetOperations.range(&quot;zset&quot;,0,2);</span><br><span class=\"line\">    return set;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>哈希</strong></p>\n<p>Hash：key value</p>\n<p>HashOperations：key hashkey value</p>\n<p>key是每一组数据的ID，hashkey和value是一组完整的HashMap数据，通过key来区分不同的HashMap</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPYHashMap hashMap &#x3D; new HashMap();</span><br><span class=\"line\">hashMap.put(key1,value1);</span><br><span class=\"line\">HashMap hashMap &#x3D; new HashMap();</span><br><span class=\"line\">hashMap.put(key2,value2);</span><br><span class=\"line\">HashMap hashMap &#x3D; new HashMap();</span><br><span class=\"line\">hashMap.put(key3,value3);</span><br><span class=\"line\"></span><br><span class=\"line\">HashOperations&lt;String,String,String&gt; hashOperation &#x3D; redisTemplate.opsForHash();</span><br><span class=\"line\">hashOperation.put(hashMap1,key1,value1);</span><br><span class=\"line\">hashOperation.put(hashMap2,key2,value2);</span><br><span class=\"line\">hashOperation.put(hashMap3,key3,value3);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY@GetMapping(&quot;&#x2F;hash&quot;)</span><br><span class=\"line\">public void hashTest()&#123;</span><br><span class=\"line\">    HashOperations&lt;String,String,String&gt; hashOperations &#x3D; redisTemplate.opsForHash();</span><br><span class=\"line\">    hashOperations.put(&quot;key&quot;,&quot;hashKey&quot;,&quot;Hello&quot;);</span><br><span class=\"line\">    System.out.println(hashOperations.get(&quot;key&quot;,&quot;hashKey&quot;));</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":["Redis"]},{"title":"Mysql的关联查询","url":"/2021-01-09-join%20.html","content":"<h4 id=\"1、join-on-后面用-and和where的区别-：\"><a href=\"#1、join-on-后面用-and和where的区别-：\" class=\"headerlink\" title=\"1、join on 后面用 and和where的区别 ：\"></a>1、join on 后面用 and和where的区别 ：</h4><p>在右连接时，and作为匹配条件，无论是否匹配，右连接要输出的东西都会显示，where条件是在临时表生成好后，再对临时表进行过滤的条件，也就没有right join 的含义了，不满足条件就会过滤掉。</p>\n<h4 id=\"2、join的7种连接\"><a href=\"#2、join的7种连接\" class=\"headerlink\" title=\"2、join的7种连接\"></a>2、join的7种连接</h4><ol>\n<li><p>内连接：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>左连接（左外连接）：</p>\n<p><strong>A、B两表共有+A表独有</strong> </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id;</span><br></pre></td></tr></table></figure>\n\n<p><strong>A表独有</strong> </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id <span class=\"keyword\">Where</span> B.id <span class=\"keyword\">is</span> <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>右连接（右外连接）：</p>\n<p><strong>A、B两表共有+B表独有</strong> </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id;</span><br></pre></td></tr></table></figure>\n\n<p><strong>B表独有</strong> </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id <span class=\"keyword\">Where</span> A.id <span class=\"keyword\">is</span> <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>全连接（全外连接）：</p>\n<p><strong>A、B两表全有</strong> ：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">FULL</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id;</span><br></pre></td></tr></table></figure>\n\n<p>注意：MySQL不支持FULL  JOIN，可采用如下方法代替   ;    UNION可去除重复数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id</span><br></pre></td></tr></table></figure>\n\n<p><strong>A表独有+B表独有</strong> ：</p>\n<p>SELECT <select_list> FROM tb_a A FULL JOIN tb_b B ON A.bId = B.id WHERE A.bId IS NULL OR B.id IS NULL;</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id <span class=\"keyword\">WHERE</span> B.id <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> &lt;select_list&gt; <span class=\"keyword\">FROM</span> tb_a A <span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> tb_b B <span class=\"keyword\">ON</span> A.bId = B.id <span class=\"keyword\">WHERE</span> A.bId <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>左连接和左外连接：在我看来两者本质相同，只是写法上存在差异：LEFT JOIN 左连接、LEFT OUTER JOIN 左外连接，都是同样的查询效果，但是将用法融会贯通后叫什么连接也就无关紧要了。</p>\n</blockquote>\n<h4 id=\"3-group-by-分组应用\"><a href=\"#3-group-by-分组应用\" class=\"headerlink\" title=\"3.group by  分组应用\"></a>3.group by  分组应用</h4><p>现在有一个需求，有10名学生，每名学生自己有若干门课程（不尽一样），现在用一条sql语句查看课程成绩都大于60的学生；</p>\n<p>student  id，name，score </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span>,<span class=\"keyword\">min</span>(score) <span class=\"keyword\">as</span> F <span class=\"keyword\">from</span> test_student <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">name</span> <span class=\"keyword\">having</span> F&gt;<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p> 根据name分组，如果你</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select id,name,min(score) as F from test_student group by name having F&gt;60</span><br></pre></td></tr></table></figure>\n\n<p>就会报错，解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select id,name,min(score) as F from test_student group by id,name having F&gt;60</span><br></pre></td></tr></table></figure>\n\n<p>后面的分组要求数要必须 &gt;= 前面的，但是一般分组就是按照一个维度分组 不然意义不大，具体分业务场景</p>\n<h4 id=\"4-sql练习\"><a href=\"#4-sql练习\" class=\"headerlink\" title=\"4.sql练习\"></a>4.sql练习</h4><h5 id=\"1-用一条SQL-语句-查询出每门课都大于80-分的学生姓名\"><a href=\"#1-用一条SQL-语句-查询出每门课都大于80-分的学生姓名\" class=\"headerlink\" title=\"1.用一条SQL 语句 查询出每门课都大于80 分的学生姓名\"></a>1.用一条SQL 语句 查询出每门课都大于80 分的学生姓名</h5><p>name course grade<br>张三 语文 81<br>张三 数学 75<br>李四 语文 76<br>李四 数学 90<br>王五 语文 81<br>王五 数学 100<br>王五 英语 90</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">name</span> <span class=\"keyword\">HAVING</span> <span class=\"keyword\">MIN</span>(grade)&gt;<span class=\"number\">80</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h5>","categories":["Mysql"],"tags":["join"]},{"title":"java类反射","url":"/2021-03-14-java%E7%B1%BB%E5%8F%8D%E5%B0%84.html","content":"<h3 id=\"1、java类反射\"><a href=\"#1、java类反射\" class=\"headerlink\" title=\"1、java类反射\"></a>1、java类反射</h3><h4 id=\"1-什么是类反射\"><a href=\"#1-什么是类反射\" class=\"headerlink\" title=\"1.什么是类反射\"></a>1.什么是类反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p><strong>反射就是把java类中的各种成分映射成一个个的Java对象。</strong></p>\n<p>例如：一个类有 -&gt; 成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>\n<p>加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>\n<p>并且在进行类加载的时候，类加载器会先检查这个类的Class对象是否已经加载，如果还未加载，则默认的类加载器就会根据类名查找.class文件(这里不一定都是从文件系统中获取，可以从数据库读取字节码或者接受网络中传输过来的字节码)。这些字节码在被加载的时候，会检查验证保证它们没有被破坏。一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。</p>\n<h4 id=\"2-获取Class对象的三种方式\"><a href=\"#2-获取Class对象的三种方式\" class=\"headerlink\" title=\"2.获取Class对象的三种方式\"></a>2.获取Class对象的三种方式</h4><p>与传统的通过new 来获取对象的方式不同 ；反射机制，会先拿到 获取类 的“类对象”, 然后通过类对象获取“构造器对象”，再通过构造器对象创建一个对象</p>\n<p><strong>获取类对象有3种方式</strong></p>\n<ul>\n<li>Object ——&gt; getClass();</li>\n<li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性</li>\n<li>通过Class类的静态方法：forName（String  className）(常用)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> fanshe;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取Class对象的三种方式</span></span><br><span class=\"line\"><span class=\"comment\"> * 1 Object ——&gt; getClass();</span></span><br><span class=\"line\"><span class=\"comment\"> * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</span></span><br><span class=\"line\"><span class=\"comment\"> * 3 通过Class类的静态方法：forName（String  className）(常用)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fanshe</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一种方式获取Class对象  </span></span><br><span class=\"line\">\t\tStudent stu1 = <span class=\"keyword\">new</span> Student();<span class=\"comment\">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class=\"line\">\t\tClass stuClass = stu1.getClass();<span class=\"comment\">//获取Class对象</span></span><br><span class=\"line\">\t\tSystem.out.println(stuClass.getName());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//第二种方式获取Class对象</span></span><br><span class=\"line\">\t\tClass stuClass2 = Student.class;</span><br><span class=\"line\">\t\tSystem.out.println(stuClass == stuClass2);<span class=\"comment\">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//第三种方式获取Class对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tClass stuClass3 = Class.forName(<span class=\"string\">&quot;fanshe.Student&quot;</span>);<span class=\"comment\">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class=\"line\">\t\t\tSystem.out.println(stuClass3 == stuClass2);<span class=\"comment\">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在运行期间，一个类，只有一个Class对象产生。</strong> </p>\n<p>三种方式常用第三种</p>\n<p>第一种对象都有了还要反射干什么。</p>\n<p>第二种需要导入类的包，依赖太强，不导包就抛编译错误。</p>\n<p>一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>\n<h4 id=\"3-获取完对象后，用类反射中相应的方法调用\"><a href=\"#3-获取完对象后，用类反射中相应的方法调用\" class=\"headerlink\" title=\"3.获取完对象后，用类反射中相应的方法调用\"></a>3.获取完对象后，用类反射中相应的方法调用</h4><p>1.获取构造方法：<br>  1).批量的方法：<br>public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法<br>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p>\n<p>  2).获取单个的方法，并调用：<br>public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：<br>public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</p>\n<p> 调用构造方法：<br>Constructor--&gt;newInstance(Object... initargs)</p>\n<p>2、 newInstance是 Constructor类的方法（管理构造函数的类）<br>newInstance(Object... initargs)，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<br>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用<br>3、获取成员变量并调用<br>getMethod() 获取所有的方法，包括私有的</p>\n<p>getDeclaredMethods 获取所有的”公有“方法</p>\n<p>还可以指定方法名，getMethod(&quot;show1&quot;, String.class)</p>\n<h4 id=\"4-反射方法的其它使用\"><a href=\"#4-反射方法的其它使用\" class=\"headerlink\" title=\"4.反射方法的其它使用\"></a>4.反射方法的其它使用</h4><h5 id=\"1-通过反射运行配置文件内容\"><a href=\"#1-通过反射运行配置文件内容\" class=\"headerlink\" title=\"1. 通过反射运行配置文件内容\"></a>1. 通过反射运行配置文件内容</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">student类：</span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\">\tpublic void show()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;is show()&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置文件以txt文件为例子（pro.txt）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">className &#x3D; cn.fanshe.Student</span><br><span class=\"line\">methodName &#x3D; show</span><br></pre></td></tr></table></figure>\n\n<p>测试类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import java.io.FileNotFoundException;</span><br><span class=\"line\">import java.io.FileReader;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.util.Properties;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\"></span><br><span class=\"line\"> * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span><br><span class=\"line\"></span><br><span class=\"line\"> * 我们只需要将新类发送给客户端，并修改配置文件即可</span><br><span class=\"line\">   *&#x2F;</span><br><span class=\"line\">   public class Demo &#123;</span><br><span class=\"line\">   public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">   \t&#x2F;&#x2F;通过反射获取Class对象</span><br><span class=\"line\">   \tClass stuClass &#x3D; Class.forName(getValue(&quot;className&quot;));&#x2F;&#x2F;&quot;cn.fanshe.Student&quot;</span><br><span class=\"line\">   \t&#x2F;&#x2F;2获取show()方法</span><br><span class=\"line\">   \tMethod m &#x3D; stuClass.getMethod(getValue(&quot;methodName&quot;));&#x2F;&#x2F;show</span><br><span class=\"line\">   \t&#x2F;&#x2F;3.调用show()方法</span><br><span class=\"line\">   \tm.invoke(stuClass.getConstructor().newInstance());</span><br><span class=\"line\">   \t</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;此方法接收一个key，在配置文件中获取相应的value</span><br><span class=\"line\">   public static String getValue(String key) throws IOException&#123;</span><br><span class=\"line\">   \tProperties pro &#x3D; new Properties();&#x2F;&#x2F;获取配置文件的对象</span><br><span class=\"line\">   \tFileReader in &#x3D; new FileReader(&quot;pro.txt&quot;);&#x2F;&#x2F;获取输入流</span><br><span class=\"line\">   \tpro.load(in);&#x2F;&#x2F;将流加载到配置文件对象中</span><br><span class=\"line\">   \tin.close();</span><br><span class=\"line\">   \treturn pro.getProperty(key);&#x2F;&#x2F;返回根据key获取的value值</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">控制台输出：</span><br><span class=\"line\">is show()</span><br></pre></td></tr></table></figure>\n\n\n","categories":["JVM"],"tags":["类反射"]},{"title":"Git开发流程","url":"/2021-03-18-Git%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.html","content":"<h2 id=\"1、Git开发流程\"><a href=\"#1、Git开发流程\" class=\"headerlink\" title=\"1、Git开发流程\"></a>1、Git开发流程</h2><p>1、首先，你需要在远程仓库创建一个新的项目（github、gitee或是你自己的远程服务器），这个新的项目默认会有一个主分支 <strong>master</strong></p>\n<p>2、然后使用git命令<strong>git clone</strong>到一个空的文件夹</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\1595954514-5a7096cb66f79_fix732.png\" alt=\"1595954514-5a7096cb66f79_fix732\" loading=\"lazy\"></p>\n<p>3、现在你需要新建一个 <strong>dev</strong> 分支，这个dev分支就是所谓的主战场，在以后的开发中，就在这个<strong>dev</strong>以及<strong>dev</strong>下的分支进行开发。第一个开发人员进来了，他在本地创建一个develop分支，并且提交到远程.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch  develop</span><br><span class=\"line\">git push -u origin develop</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>git branch dev</strong>创建名为dev的分支，创建分支时需要是最新的环境，创建分支但依然停留在当前分支</p>\n<p><strong>git checkout -b dev</strong> 如果分支存在则只切换分支，若不存在则创建并切换到dev分支</p>\n</blockquote>\n<p>克隆下来的这个项目相当于你在远程创建的那个项目的镜像，所以现在你本地的项目里也有个<strong>dev</strong>分支，当然也有<strong>master</strong>分支，现在切换到dev分支 <strong>git checkout dev</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\2405201435-5a7097cc32ac1_fix732.png\" alt=\"2405201435-5a7097cc32ac1_fix732\" loading=\"lazy\"></p>\n<p>4、现在就可以在这个dev分支上新建自己的分支愉快的开发了，命令 <strong>git checkout -b dev1</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\3543293189-5a70986e71bf3_fix732.png\" alt=\"3543293189-5a70986e71bf3_fix732\" loading=\"lazy\"></p>\n<p>5、由于是多人开发，另一个人也可以以同样的方式（经历2、3、4步骤后）新建一个自己的分支<strong>dev2</strong> 命令<strong>git checkout -b dev2</strong></p>\n<p>6、在dev1 或 dev2 开发完成后，需要提交到本地仓库，在dev1分支下使用命令 git add . 和 git commit -a -m &#39;commit msg&#39;</p>\n<blockquote>\n<p>git commit -m用于提交暂存区的文件，git commit -am用于提交跟踪过的文件（git commit -am可以写成git commit -a -m，但不能写成git commit -m -a）</p>\n<p>git add命令是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</p>\n<p>我们需要用git add命令来跟踪新文件，但如果使用git commit -am可以省略使用git add命令将已跟踪文件放到暂存区的功能</p>\n</blockquote>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\4123338765-5a709a35af484_fix732.png\" alt=\"4123338765-5a709a35af484_fix732\" loading=\"lazy\"></p>\n<p>7、提交完之后，需要汇总到<strong>dev</strong>分支上，先切回<strong>dev</strong>分支，命令<strong>git checkout dev</strong>，这个时候是没有你在dev1上修改或添加的东西的，需要合并之后才会有；</p>\n<p>8、合并 在<strong>dev</strong>分支下使用命令 <strong>git merge dev1</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\2951887473-5a709b473e6b5_fix732.png\" alt=\"2951887473-5a709b473e6b5_fix732\" loading=\"lazy\"></p>\n<p>现在就可以在dev分支下看到你在dev1分支下修改的东西了</p>\n<p>9、提交 合并到dev分支之后就是提交到远程仓库的dev分支，可以先看一下现在都有什么分支，命令 <strong>git branch -a</strong>,列出所有本地分支和远程分支  不加-a 只列出本地分支</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\2801559402-5a709bd6696a7_fix732.png\" alt=\"2801559402-5a709bd6696a7_fix732\" loading=\"lazy\"></p>\n<p>10、提交到远程dev 命令 <strong>git push origin dev</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\450013528-5a709c4b85921_fix732.png\" alt=\"450013528-5a709c4b85921_fix732\" loading=\"lazy\"></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\2641156376-5a709c725ad53_fix732.png\" loading=\"lazy\"></p>\n<blockquote>\n<p><strong>git push origin</strong> :将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<p><strong>git push</strong> :如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>\n<p><strong>git push -u origin master</strong>:</p>\n<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。</p>\n<p>本地master上传到远程仓库分支下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class=\"line\">git push origin master:djs</span><br><span class=\"line\"># origin为设置的远程仓库别名, master为本地分支名, djs为远程分支名</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>11、现在远程仓库的dev分支上已经是最新的代码了；最后再把远程的dev分支合并到远程的master主分支上就可以了。一般主分支主要是存放比较稳定版本的版本，dev分支才是最活跃的。</p>\n<h4 id=\"1-需要注意的\"><a href=\"#1-需要注意的\" class=\"headerlink\" title=\"1.需要注意的\"></a>1.需要注意的</h4><p>在多人开发统一分支时，在提代码前需要先拉取一下代码，保证不会出现冲突</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git pull  拉取代码</span><br></pre></td></tr></table></figure>\n\n","categories":["开发工具"],"tags":["Git"]},{"title":"Java开发需掌握的常用Linux命令","url":"/2021-03-18-java%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E5%91%BD%E4%BB%A4.html","content":"<h2 id=\"Java开发需掌握的常用Linux命令\"><a href=\"#Java开发需掌握的常用Linux命令\" class=\"headerlink\" title=\"Java开发需掌握的常用Linux命令\"></a>Java开发需掌握的常用Linux命令</h2><h3 id=\"1-查找文件\"><a href=\"#1-查找文件\" class=\"headerlink\" title=\"1.查找文件\"></a>1.查找文件</h3><p>find / -name filename.txt 根据名称查找/目录下的filename.txt文件。</p>\n<p>find . -name &quot;*.xml&quot; 递归查找所有的xml文件</p>\n<p>find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件</p>\n<p>grep -H &#39;spring&#39; *.xml 查找所以有的包含spring的xml文件</p>\n<p>find ./ -size 0 | xargs rm -f &amp; 删除文件大小为零的文件</p>\n<p>ls -l | grep &#39;.jar&#39; 查找当前目录中的所有jar文件</p>\n<p>grep &#39;test&#39; d* 显示所有以d开头的文件中包含test的行。</p>\n<p>grep &#39;test&#39; aa bb cc 显示在aa，bb，cc文件中匹配test的行。</p>\n<p>grep &#39;[a-z]{5}&#39; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p>\n<h3 id=\"2-查看一个程序是否运行\"><a href=\"#2-查看一个程序是否运行\" class=\"headerlink\" title=\"2.查看一个程序是否运行\"></a>2.查看一个程序是否运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps –ef|grep tomcat  查看所有有关tomcat的进程</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-查看端口占用情况\"><a href=\"#3-查看端口占用情况\" class=\"headerlink\" title=\"3.查看端口占用情况\"></a>3.查看端口占用情况</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -tln | grep 8080 查看端口8080的使用情况</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-查看端口属于哪个程序\"><a href=\"#4-查看端口属于哪个程序\" class=\"headerlink\" title=\"4.查看端口属于哪个程序\"></a>4.查看端口属于哪个程序</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-查看进程\"><a href=\"#5-查看进程\" class=\"headerlink\" title=\"5.查看进程\"></a>5.查看进程</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps aux|grep java 查看java进程</span><br><span class=\"line\">ps aux 查看所有进程</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-查看文件，包含隐藏文件\"><a href=\"#6-查看文件，包含隐藏文件\" class=\"headerlink\" title=\"6.查看文件，包含隐藏文件\"></a>6.查看文件，包含隐藏文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls -al</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-查看文件头10行\"><a href=\"#7-查看文件头10行\" class=\"headerlink\" title=\"7.查看文件头10行\"></a>7.查看文件头10行</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">head -n 10 example.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-查看文件尾10行\"><a href=\"#8-查看文件尾10行\" class=\"headerlink\" title=\"8.查看文件尾10行\"></a>8.查看文件尾10行</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tail -n 10 example.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9查看日志类型文件\"><a href=\"#9查看日志类型文件\" class=\"headerlink\" title=\"9查看日志类型文件\"></a>9查看日志类型文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tail -f exmaple.log &#x2F;&#x2F;这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-9查看文件中的内容\"><a href=\"#9-9查看文件中的内容\" class=\"headerlink\" title=\"9.9查看文件中的内容\"></a>9.9查看文件中的内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-终止线程\"><a href=\"#10-终止线程\" class=\"headerlink\" title=\"10.终止线程\"></a>10.终止线程</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kill -9 19979 终止线程号位19979的进程</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-当前工作目录\"><a href=\"#11-当前工作目录\" class=\"headerlink\" title=\"11.当前工作目录\"></a>11.当前工作目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-复制文件\"><a href=\"#12-复制文件\" class=\"headerlink\" title=\"12.复制文件\"></a>12.复制文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp source dest 复制文件</span><br><span class=\"line\">cp -r sourceFolder targetFolder 递归复制整个文件夹</span><br><span class=\"line\">scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-创建目录\"><a href=\"#13-创建目录\" class=\"headerlink\" title=\"13.创建目录\"></a>13.创建目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir newfolder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-删除目录\"><a href=\"#14-删除目录\" class=\"headerlink\" title=\"14.删除目录\"></a>14.删除目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rmdir deleteEmptyFolder 删除空目录 </span><br><span class=\"line\">rm -rf deleteFile 递归删除目录中所有内容</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-移动文件\"><a href=\"#15-移动文件\" class=\"headerlink\" title=\"15.移动文件\"></a>15.移动文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mv &#x2F;temp&#x2F;movefile &#x2F;targetFolder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-切换用户\"><a href=\"#16-切换用户\" class=\"headerlink\" title=\"16.切换用户\"></a>16.切换用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">su -username</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"17-修改文件权限\"><a href=\"#17-修改文件权限\" class=\"headerlink\" title=\"17.修改文件权限\"></a>17.修改文件权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod 777 file.java &#x2F;&#x2F;file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"18-压缩文件\"><a href=\"#18-压缩文件\" class=\"headerlink\" title=\"18.压缩文件\"></a>18.压缩文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -czf test.tar.gz &#x2F;test_one &#x2F;test_two</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"19-列出压缩文件列表\"><a href=\"#19-列出压缩文件列表\" class=\"headerlink\" title=\"19.列出压缩文件列表\"></a>19.列出压缩文件列表</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -tzf test.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-解压文件\"><a href=\"#20-解压文件\" class=\"headerlink\" title=\"20.解压文件\"></a>20.解压文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -xvzf test.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-使用超级管理员身份执行命令\"><a href=\"#21-使用超级管理员身份执行命令\" class=\"headerlink\" title=\"21.使用超级管理员身份执行命令\"></a>21.使用超级管理员身份执行命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm a.txt 使用管理员身份删除文件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"22-以树状图列出目录的内容\"><a href=\"#22-以树状图列出目录的内容\" class=\"headerlink\" title=\"22.以树状图列出目录的内容\"></a>22.以树状图列出目录的内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tree a</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"23-文件下载\"><a href=\"#23-文件下载\" class=\"headerlink\" title=\"23.文件下载\"></a>23.文件下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;file.tgz</span><br><span class=\"line\">curl http:&#x2F;&#x2F;file.tgz</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"24-网络检测\"><a href=\"#24-网络检测\" class=\"headerlink\" title=\"24.网络检测\"></a>24.网络检测</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping www.just-ping.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"25-远程登录\"><a href=\"#25-远程登录\" class=\"headerlink\" title=\"25.远程登录\"></a>25.远程登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh userName@ip</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"26-切换工作目录\"><a href=\"#26-切换工作目录\" class=\"headerlink\" title=\"26.切换工作目录\"></a>26.切换工作目录</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span>   进入用户主目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~ 进入用户主目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span> - 返回进入此目录之前所在的目录</span><br><span class=\"line\"><span class=\"built_in\">cd</span> .. 返回上级目录（若当前目录为“/“，则执行完后还在“/<span class=\"string\">&quot;；&quot;</span>..<span class=\"string\">&quot;为上级目录的意思）</span></span><br><span class=\"line\"><span class=\"string\">cd ../.. 返回上两级目录</span></span><br><span class=\"line\"><span class=\"string\">cd !$ 把上个命令的参数作为cd参数使用</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"27-查看ip地址\"><a href=\"#27-查看ip地址\" class=\"headerlink\" title=\"27.查看ip地址\"></a>27.查看ip地址</h3><p>ipconfig </p>\n","categories":["linux"]},{"title":"linux下查内存/cpu命令","url":"/2021-03-18-linux%E4%B8%8B%E6%9F%A5%E5%86%85%E5%AD%98%20%E5%92%8C%20cpu%E5%91%BD%E4%BB%A4.html","content":"<h1 id=\"1、linux下查内存-cpu命令\"><a href=\"#1、linux下查内存-cpu命令\" class=\"headerlink\" title=\"1、linux下查内存/cpu命令\"></a>1、linux下查内存/cpu命令</h1><p>使用 <strong>top</strong> 命令</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\16027-20160520170518201-1978471079.png\" alt=\"16027-20160520170518201-1978471079\" loading=\"lazy\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">第一行：</span><br><span class=\"line\">    10:08:45 — 当前系统时间</span><br><span class=\"line\">    10 days, 3:05 — 系统已经运行了10天3小时5分钟（在这期间没有重启过）</span><br><span class=\"line\">    1 users — 当前有1个用户登录系统</span><br><span class=\"line\">    load average: 0.00, 0.00, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</span><br><span class=\"line\"></span><br><span class=\"line\">load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</span><br></pre></td></tr></table></figure>\n\n<pre><code>第二行：\nTasks — 任务（进程），系统现在共有135个进程，其中处于运行中的有1个，134个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">第三行：cpu状态</span><br><span class=\"line\">0.3% us — 用户空间占用CPU的百分比。</span><br><span class=\"line\">0.0% sy — 内核空间占用CPU的百分比。</span><br><span class=\"line\">0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class=\"line\">99.7% id — 空闲CPU百分比</span><br><span class=\"line\">0.0% wa — IO等待占用CPU的百分比</span><br><span class=\"line\">0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class=\"line\">0.0% si — 软中断（Software Interrupts）占用CPU的百分比</span><br></pre></td></tr></table></figure>\n\n<p>在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。</p>\n<pre><code>第四行：内存状态\n3808060k total — 物理内存总量（4GB）\n3660048k used — 使用中的内存总量（3.6GB）\n148012k free — 空闲内存总量（148M）\n359760k buffers — 缓存的内存量 （359M）</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">第五行：swap交换分区</span><br><span class=\"line\">4184924k total — 交换区总量（4G）</span><br><span class=\"line\">0k used — 使用的交换区总量（0M）</span><br><span class=\"line\">4184924k free — 空闲交换区总量（4G）</span><br><span class=\"line\">2483956k cached — 缓冲的交换区总量（2483M）</span><br></pre></td></tr></table></figure>\n\n<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p>\n<p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：148M+259M+2483M = 2990M。</p>\n<p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>\n<p> 第六行是空行</p>\n<pre><code>第七行以下：各进程（任务）的状态监控\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\nCOMMAND — 进程名称（命令名/命令行）</code></pre>\n<p>多核CPU监控</p>\n<p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p>\n<p>  <img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\16027-20160520170601998-947560755.png\" alt=\"16027-20160520170601998-947560755\" loading=\"lazy\"></p>\n<p>观察上图，服务器有4个逻辑CPU，实际上是1个物理CPU。</p>\n<p>如果不按1，则在top视图里面显示的是所有cpu的平均值。</p>\n<blockquote>\n<p>使用权限：所有使用者 </p>\n<p>　　使用方式：top [-] [d delay] [q] [c] [S] [s] [i] [n] [b] </p>\n<p>　　说明：实时显示 process 的动态 </p>\n<p>　　参数： </p>\n<p>　　d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s </p>\n<p>　　q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行 </p>\n<p>　　c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称</p>\n<p>​        S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来 </p>\n<p>　　s : 安全模式，将交谈式指令取消, 避免潜在的危机 </p>\n<p>　　i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程 </p>\n<p>　　n : 更新的次数，完成后将会退出 top </p>\n<p>　　b : 批次档模式，搭配 &quot;n&quot; 参数一起使用，可以用来将 top 的结果输出到档案内 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">s – 改变画面更新频率</span><br><span class=\"line\">l – 关闭或开启第一部分第一行 top 信息的表示</span><br><span class=\"line\">t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示</span><br><span class=\"line\">m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示</span><br><span class=\"line\">N – 以 PID 的大小的顺序排列表示进程列表</span><br><span class=\"line\">P – 以 CPU 占用率大小的顺序排列进程列表</span><br><span class=\"line\">M – 以内存占用率大小的顺序排列进程列表</span><br><span class=\"line\">h – 显示帮助</span><br><span class=\"line\">n – 设置在进程列表所显示进程的数量</span><br><span class=\"line\">q – 退出 top</span><br><span class=\"line\">s – 改变画面更新周期</span><br></pre></td></tr></table></figure>\n\n<p>范例： </p>\n<p>　　显示更新十次后退出 ; </p>\n<p>　　 top -n 10 </p>\n<p>　　 使用者将不能利用交谈式指令来对行程下命令 : </p>\n<p>　　 top -s </p>\n<p>　　将更新显示二次的结果输入到名称为 top.log 的档案里 : </p>\n<p>　　 top -n 2 -b &lt; top.log</p>\n<p>注意：</p>\n<p>运行top命令之后，如果想退出该命令，键入q即可或按ctrl c</p>\n</blockquote>\n<h3 id=\"CPU问题\"><a href=\"#CPU问题\" class=\"headerlink\" title=\"CPU问题\"></a>CPU问题</h3><p>例：线上事故，es集群出了点问题，没法写，最后出现线上几十台机器，全部因为这一行代码，全体cpu 100%，卡死了</p>\n<p>（1）定位耗费cpu的进程</p>\n<p>top -c，就可以显示进程列表，然后输入P，按照cpu使用率排序，你会看到类似下面的东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PID  USER  PR NI VIRT  RES  SHR  S %CPU  %MEM  TIME+  COMMAND</span><br><span class=\"line\"></span><br><span class=\"line\">43987 root 20  0 28.2g 4.5g 68m  S  99.0  24.0 44333.4 java-Xms。。。</span><br></pre></td></tr></table></figure>\n\n<p>大概类似上面这样，能看到哪个进程，CPU负载最高，还有启动这个进程的命令，比如一般就是java啥啥的。</p>\n<p>（2）定位耗费cpu的线程</p>\n<p>top -Hp 43987，就是输入那个进程id就好了，然后输入P，按照cpu使用率排序，你会看到类似下面的东西</p>\n<p><img data-src=\"https://note.youdao.com/yws/public/resource/aa65a1a3c4b26d8d8362ba3ecb0b0b4e/xmlnote/3eabc81903a21ae7e76bc082736cdbd3/5953\" alt=\"0\" loading=\"lazy\"></p>\n<p>大概类似上面那样，你就可以看到这个进程里的哪个线程耗费cpu最高</p>\n<p>（3）定位哪段代码导致的cpu过高</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">printf “%x\\n” 16872，把线程pid转换成16进制，比如41e8</span><br><span class=\"line\"></span><br><span class=\"line\">jstack 43987 | grep ‘0x41e8’ -C5 --color</span><br></pre></td></tr></table></figure>\n\n<p>这个就是用jstack打印进程的堆栈信息，而且通过grep那个线程的16进制的pid，找到那个线程相关的东西，这个时候就可以在打印出的代码里，看到是哪个类的哪个方法导致的这个cpu 100%的问题</p>\n<h3 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h3><p>top 命令下显示的视图</p>\n<p>第四行：内存状态<br>3808060k total — 物理内存总量（4GB）<br>3660048k used — 使用中的内存总量（3.6GB）<br>148012k free — 空闲内存总量（148M）<br>359760k buffers — 缓存的内存量 （359M）</p>\n<p>第五行：swap交换分区<br>4184924k total — 交换区总量（4G）<br>0k used — 使用的交换区总量（0M）<br>4184924k free — 空闲交换区总量（4G）<br>2483956k cached — 缓冲的交换区总量（2483M）</p>\n<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p>\n<p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：148M+259M+2483M = 2990M。</p>\n<p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>\n","categories":["linux"]},{"title":"mybatis 之数据库 include refid =\"xxxx\"","url":"/2021-03-21-mybatis.html","content":"<h3 id=\"1-mybatis-之数据库-include-refid-quot-xxxx-quot\"><a href=\"#1-mybatis-之数据库-include-refid-quot-xxxx-quot\" class=\"headerlink\" title=\"1.mybatis 之数据库 include refid =&quot;xxxx&quot;\"></a>1.mybatis 之数据库 include refid =&quot;xxxx&quot;</h3><p><include refid=\"Base_Column_List\" > *<em>这个在MyBatis查询数据库的sql中经常会出现。它的在上面已经定义，作用相当于 * ，*</em></p>\n<p>*<em>Base_Column_List是固定的几个字段，而用</em>号的话会降低查询效率，因为后期数据库的字段会不断增加。**</p>\n<p><sql>用来封装SQL语句, <include>来调用</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;sql id=&quot;KjRealFeeDetail_columns&quot;&gt;</span><br><span class=\"line\">        fd.id,fd.wj_code,fd.supplier_name,realfd.buss_id,DATE_FORMAT(fd.fee_time,&#x27;%Y-%m-%d&#x27;) fee_time,</span><br><span class=\"line\">        fd.fee_amount loan_amount,fd.charge_amount,realfd.charge_amount real_charge_amount,</span><br><span class=\"line\">        realfd.outer_dp_charge_amount real_outer_dp_charge_amount,realfd.outer_sc_charge_amount real_outer_sc_charge_amount</span><br><span class=\"line\">    &lt;/sql&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;select id=&quot;findByPage&quot; resultMap=&quot;KjRealFeeDetailResultMap&quot;&gt;</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    &lt;<span class=\"keyword\">include</span> refid=<span class=\"string\">&quot;KjRealFeeDetail_columns&quot;</span>&gt;&lt;/<span class=\"keyword\">include</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> kj_fee_detail fd</span><br><span class=\"line\">    <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> kj_real_fee_detail realfd</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> realfd.charge_type = <span class=\"number\">1</span> <span class=\"keyword\">AND</span> realfd.wj_code = fd.wj_code <span class=\"keyword\">AND</span> <span class=\"keyword\">DATE_FORMAT</span>(fd.fee_time,<span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>) = <span class=\"keyword\">DATE_FORMAT</span>(realfd.fee_time,<span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> fd.supplier_name = realfd.supplier_name</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> realfd.is_delete = <span class=\"number\">0</span></span><br><span class=\"line\">    &lt;<span class=\"keyword\">include</span> refid=<span class=\"string\">&quot;KjRealFeeDetail_where&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">select</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p><include refid=\"KjRealFeeDetail_columns\" > 这个在MyBatis查询数据库的sql中经常会出现。它的在上面已经定义，作用相当于 *** ，**</p>\n<p>KjRealFeeDetail_columns是固定的几个字段，而用*号的话会降低查询效率，因为后期数据库的字段会不断增加。</p>\n<h3 id=\"2-mybatis-之-trim\"><a href=\"#2-mybatis-之-trim\" class=\"headerlink\" title=\"2..mybatis 之 trim\"></a>2..mybatis 之 trim</h3><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>prefix:在trim标签内sql语句加上前缀。</p>\n<p>suffix:在trim标签内sql语句加上后缀。</p>\n<p>prefixOverrides:指定去除多余的前缀内容</p>\n<p>suffixOverrides:指定去除多余的后缀内容，如：suffixOverrides=&quot;,&quot;，去除trim标签内sql语句多余的后缀&quot;,&quot;。</p>\n<p>应用场景：inser into </p>\n<blockquote>\n<p>插入数据时  假设没有指定 suffixOverrides=&quot;,&quot;</p>\n<p>执行的sql语句也许是这样的：insert into cart (id,user_id,deal_id,) values(1,2,1,);显然是错误的</p>\n<p>指定之后语句就会变成insert into cart (id,user_id,deal_id) values(1,2,1);这样就将“，”去掉了。前缀也是一个道理</p>\n</blockquote>\n<h3 id=\"3-Mybatis中用OGNL表达式处理动态sql\"><a href=\"#3-Mybatis中用OGNL表达式处理动态sql\" class=\"headerlink\" title=\"3.Mybatis中用OGNL表达式处理动态sql\"></a>3.Mybatis中用OGNL表达式处理动态sql</h3><ol>\n<li>if 语句 (简单的条件判断)<ol start=\"2\">\n<li>choose (when,otherwize) ,相当于java 语言中的 switch ,与 jstl 中的choose 很类似.<ol start=\"3\">\n<li>trim (对包含的内容加上 prefix,或者 suffix 等，前缀，后缀)<ol start=\"4\">\n<li>where (主要是用来简化sql语句中where条件判断的，能智能的处理 and or ,不必担心多余导致语法错误)<ol start=\"5\">\n<li>set (主要用于更新时)<ol start=\"6\">\n<li>foreach (在实现 mybatis in 语句查询时特别有用)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","categories":["框架"],"tags":["Mybatis"]},{"title":"jdbc数据库连接","url":"/2021-03-19-jdbc%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5.html","content":"<h3 id=\"1-jdbc数据库连接\"><a href=\"#1-jdbc数据库连接\" class=\"headerlink\" title=\"1.jdbc数据库连接\"></a>1.jdbc数据库连接</h3><p>1.加载数据库驱动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>2.获取对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Connection conn &#x3D; DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;shen&quot;;</span><br><span class=\"line\">String username &#x3D; &quot;shen&quot;;</span><br><span class=\"line\">String password &#x3D; &quot;Anxin062039&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>3.执行sql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Statement st &#x3D; null;</span><br><span class=\"line\">&#x2F;&#x2F;3.获取用于向数据库发送sql语句的statement</span><br><span class=\"line\">st &#x3D; conn.createStatement();</span><br><span class=\"line\">&#x2F;&#x2F;4.向数据库发sql</span><br><span class=\"line\">String sql &#x3D; &quot;select id,name,password,email,birthday from users&quot;;</span><br><span class=\"line\">st.executeQuery(sql);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PreperedStatement st &#x3D; null;</span><br><span class=\"line\">String sql &#x3D; &quot;select * from users where name&#x3D;? and password&#x3D;?&quot;;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F;3.获取用于向数据库发送sql语句的Preperedstatement</span><br><span class=\"line\">st &#x3D; conn.preparedStatement(sql);&#x2F;&#x2F;在此次传入，进行预编译</span><br><span class=\"line\">st.setString(1, username);</span><br><span class=\"line\">st.setString(2, password);</span><br><span class=\"line\">&#x2F;&#x2F;4.向数据库发sql</span><br><span class=\"line\">st.executeQuery();&#x2F;&#x2F;在这里不需要传入sql</span><br></pre></td></tr></table></figure>\n\n<p>比较：相对于Statement对象而言</p>\n<ul>\n<li>PreperedStatement可以避免SQL注入的问题。</li>\n</ul>\n","categories":["Mysql"],"tags":["连接数据库"]},{"title":"jsp、servlet 和 spring MVC的一些问题","url":"/2021-03-20-jsp%E3%80%81servlet%20%E5%92%8C%20spring%20MVC%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html","content":"<h2 id=\"jsp、servlet-和-spring-MVC的一些问题\"><a href=\"#jsp、servlet-和-spring-MVC的一些问题\" class=\"headerlink\" title=\"jsp、servlet 和 spring MVC的一些问题\"></a>jsp、servlet 和 spring MVC的一些问题</h2><h3 id=\"1、jsp和servlet的区别\"><a href=\"#1、jsp和servlet的区别\" class=\"headerlink\" title=\"1、jsp和servlet的区别\"></a>1、jsp和servlet的区别</h3><ol>\n<li>jsp经翻译后就变成了Servlet.<br>(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类)</li>\n<li>jsp更擅长表现于页面显示,servlet更擅长于逻辑控制；Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑；Servlet更多的是类似于一个Controller，用来做控制。</li>\n<li>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到.</li>\n</ol>\n<p>JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。</p>\n<h3 id=\"2、通过MVC合理利用自身长处\"><a href=\"#2、通过MVC合理利用自身长处\" class=\"headerlink\" title=\"2、通过MVC合理利用自身长处\"></a>2、通过MVC合理利用自身长处</h3><p>既然JSP和Servlet都有自身的适用环境，那么能否扬长避短，让它们发挥各自的优势呢？答案是肯定的——MVC(Model-View-Controller)模式非常适合解决这一问题。</p>\n<p>MVC模式（Model-View-Controller）是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vemgud2lraXBlZGlhLm9yZy93aWtpLyVFOCVCRCVBRiVFNCVCQiVCNiVFNSVCNyVBNSVFNyVBOCU4Qg==\">软件工程<i class=\"fa fa-external-link-alt\"></i></span>中的一种<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vemgud2lraXBlZGlhLm9yZy93aWtpLyVFOCVCRCVBRiVFNCVCQiVCNiVFNiU5RSVCNiVFNiU5RSU4NA==\">软件架构<i class=\"fa fa-external-link-alt\"></i></span>模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）：</p>\n<ul>\n<li>Controller——负责转发请求，对请求进行处理</li>\n<li>View——负责界面显示</li>\n<li>Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现</li>\n</ul>\n<p>在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示：</p>\n<p><img data-src=\"D:\\yuhaicheng5\\Desktop\\自己的文件\\Typora\\file\\记事本\\pictures\\1047129-20181228133651363-2082050510.png\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发）</li>\n<li>Controller(Servlet)调用核心业务逻辑——Model部分，获得结果</li>\n<li>Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容</li>\n<li>动态生成的HTML内容返回到浏览器显示</li>\n</ol>\n<p>MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</p>\n<h3 id=\"3、Sprng-MVC-的工作机制\"><a href=\"#3、Sprng-MVC-的工作机制\" class=\"headerlink\" title=\"3、Sprng MVC 的工作机制\"></a>3、Sprng MVC 的工作机制</h3><p>前端jsp页面进行请求到对应的servlet(springmvc)去处理，如果想要springmvc去处理，而不是普通的servlet，需要去web.xml文件去配置DispatcherServlet</p>\n<p><strong>服务器是如何查找处理请求用的Servlet的呢？</strong></p>\n<p>客户端-&gt;发出请求-&gt;服务器接收请求-&gt;web.xml-&gt;寻找与请求匹配的-&gt;当前中的同级的值-&gt;利用该值寻找;与该配对的的的值-&gt;获取中的完整类路径</p>\n<h4 id=\"具体工作流程\"><a href=\"#具体工作流程\" class=\"headerlink\" title=\"具体工作流程\"></a>具体工作流程</h4><ol>\n<li>客户端（浏览器）发送请求，直接请求到DispatcherServlet（前端控制器）。</li>\n<li>DispatcherServlet根据请求信息调用HandlerMapping处理器映射器,解析请求对应的Handler。</li>\n<li>解析到对应的Handler后，开始由HandlerAdapter处理器适配器处理。</li>\n<li>HandlerAdapter适配器会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>\n<li>处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View</li>\n<li>DispatcherServlet在ViewResolver（视图解析器）会根据逻辑上的View查找实际的View</li>\n<li>DispatcherServlt把返回的Model数据对象传给View（进行视图渲染）</li>\n<li>把View返回给请求者（浏览器）</li>\n</ol>\n","categories":["框架"],"tags":["MVC"]},{"title":"mysql的主从复制原理和读写分离","url":"/2021-03-22-mysql%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html","content":"<h2 id=\"mysql的主从复制原理和读写分离\"><a href=\"#mysql的主从复制原理和读写分离\" class=\"headerlink\" title=\"mysql的主从复制原理和读写分离\"></a>mysql的主从复制原理和读写分离</h2><h3 id=\"一、主从复制\"><a href=\"#一、主从复制\" class=\"headerlink\" title=\"一、主从复制\"></a>一、主从复制</h3><h4 id=\"1、为什么需要主从复制\"><a href=\"#1、为什么需要主从复制\" class=\"headerlink\" title=\"1、为什么需要主从复制\"></a>1、为什么需要主从复制</h4><ol>\n<li><p>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p>\n</li>\n<li><p>做数据的热备</p>\n</li>\n<li><p>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p>\n</li>\n</ol>\n<h4 id=\"2、什么是主从复制\"><a href=\"#2、什么是主从复制\" class=\"headerlink\" title=\"2、什么是主从复制\"></a>2、什么是主从复制</h4><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器<strong>主节点</strong>复制到一个或多个<strong>从节点</strong>。MySQL 默认<strong>采用异步复制</strong>方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>\n<blockquote>\n<p>注：</p>\n<p>MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，</p>\n</blockquote>\n<h4 id=\"3、实现的原理\"><a href=\"#3、实现的原理\" class=\"headerlink\" title=\"3、实现的原理\"></a>3、实现的原理</h4><p>（1）master服务器将数据的<strong>改变</strong>记录到二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；（串行写入顺序）</p>\n<p>（2）slave服务器会在一定时间间隔内对master二进制日志进行<strong>探测</strong>其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，这里是以二进制事件维度进行转储的。</p>\n<p>（3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p>\n<blockquote>\n<p>小总结：</p>\n<ul>\n<li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li>\n<li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li>\n<li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li>\n<li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li>\n</ul>\n</blockquote>\n<p>注意：Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</p>\n<h4 id=\"4、具体步骤\"><a href=\"#4、具体步骤\" class=\"headerlink\" title=\"4、具体步骤\"></a>4、具体步骤</h4><ol>\n<li><p>从库通过手工执行change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）； start slave</p>\n</li>\n<li><p>从库的IO线程和主库的dump线程建立连接。</p>\n</li>\n<li><p>从库根据change master to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</p>\n</li>\n<li><p>主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</p>\n</li>\n<li><p>从库IO线程接收binlog events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中。</p>\n</li>\n<li><p>从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge。</p>\n</li>\n</ol>\n<h4 id=\"5、mysql主从同步延时分析\"><a href=\"#5、mysql主从同步延时分析\" class=\"headerlink\" title=\"5、mysql主从同步延时分析\"></a><strong>5、mysql主从同步延时分析</strong></h4><p>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是<strong>顺序写</strong>，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</p>\n<p>（从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。）</p>\n<p>解决方案：</p>\n<p>1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</p>\n<p>2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</p>\n<p>3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</p>\n<h3 id=\"二、读写分离，主写从读\"><a href=\"#二、读写分离，主写从读\" class=\"headerlink\" title=\"二、读写分离，主写从读\"></a>二、读写分离，主写从读</h3><h4 id=\"1、为什么要读写分离\"><a href=\"#1、为什么要读写分离\" class=\"headerlink\" title=\"1、为什么要读写分离\"></a>1、为什么要读写分离</h4><p>数据库写入效率要低于读取效率，一般系统中数据读取频率高于写入频率，单个数据库实例在写入的时候会影响读取性能，这是做读写分离的原因。</p>\n<h4 id=\"2、实现的原理\"><a href=\"#2、实现的原理\" class=\"headerlink\" title=\"2、实现的原理\"></a>2、实现的原理</h4><p>实现方式主要基于mysql的主从复制，通过路由的方式使应用对数据库的写请求只在master上进行，读请求在slave上进行。</p>\n<h4 id=\"3、具体实现方式\"><a href=\"#3、具体实现方式\" class=\"headerlink\" title=\"3、具体实现方式\"></a>3、具体实现方式</h4><p><strong>1.代理</strong><br>在应用和数据库之间增加代理层，代理层接收应用对数据库的请求，根据不同请求类型转发到不同的实例，在实现读写分离的同时可以实现负载均衡。目前常用的mysql的读写分离中间件有amoeba，MySQL-Proxy</p>\n<p><strong>2.应用内路由</strong><br>在应用程序中实现，针对不同的请求类型去不同的实例执行sql</p>\n<p>基于springboot、 mybatis实现。<br>思路：实现mybatis数据源的动态切换。用aop来拦截dao层方法，根据方法名称就可以判断要执行的sql类型，动态切换主从数据源。</p>\n<h4 id=\"4、延时同步的问题\"><a href=\"#4、延时同步的问题\" class=\"headerlink\" title=\"4、延时同步的问题\"></a>4、延时同步的问题</h4><p>由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>\n<p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了</p>\n<p><strong>解决办法：</strong></p>\n<ul>\n<li>一个是半同步复制，用来<strong>解决主库数据丢失</strong>问题</li>\n</ul>\n<p>semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了</p>\n<ul>\n<li>一个是并行复制，用来<strong>解决主从同步延时</strong>问题。</li>\n</ul>\n<p>指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，<strong>这是库级别的并行。</strong></p>\n","categories":["Mysql"],"tags":["主从复制和读写分离"]},{"title":"MySql中count、limit、order by、group by的用法","url":"/2021-03-23-Mysql%E4%B8%ADMySql%E4%B8%ADcount%E3%80%81limit%E3%80%81order%20by%E3%80%81group%20by%E7%9A%84%E7%94%A8%E6%B3%95.html","content":"<h1 id=\"1、count-1-、count-、count（字段）的区别\"><a href=\"#1、count-1-、count-、count（字段）的区别\" class=\"headerlink\" title=\"1、count(1)、count(*)、count（字段）的区别\"></a>1、count(1)、count(*)、count（字段）的区别</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、COUNT有几种用法？</span><br><span class=\"line\">2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？</span><br><span class=\"line\">3、COUNT(1)和COUNT(*)之间有什么不同？</span><br><span class=\"line\">4、COUNT(1)和COUNT(*)之间的效率哪个更高？</span><br><span class=\"line\">5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)</span><br><span class=\"line\">6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？</span><br><span class=\"line\">7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？</span><br><span class=\"line\">8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？</span><br><span class=\"line\">9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？</span><br><span class=\"line\">10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</span><br></pre></td></tr></table></figure>\n\n<p>以上10道题，如果可以全部准确无误的回答的话，那说明你真的很了解<code>COUNT</code>函数了。</p>\n<h2 id=\"1-初识COUNT\"><a href=\"#1-初识COUNT\" class=\"headerlink\" title=\"1.初识COUNT\"></a>1.初识COUNT</h2><p>1、<code>COUNT(expr)</code> ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个<code>BIGINT</code>值。</p>\n<p>2、如果查询结果没有命中任何记录，则返回0</p>\n<p>3、但是，值得注意的是，<code>COUNT(*)</code> 的统计结果中，会包含值为NULL的行数。</p>\n<p>除了<code>COUNT(id)</code>和<code>COUNT(*)</code>以外，还可以使用<code>COUNT(常量)</code>（如<code>COUNT(1)</code>）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 <code>COUNT(列名)</code>或 <code>COUNT(常量)</code>来替代 <code>COUNT(*)</code>呢？</p>\n<h2 id=\"2-COUNT-字段-、COUNT-常量-和COUNT-之间的区别\"><a href=\"#2-COUNT-字段-、COUNT-常量-和COUNT-之间的区别\" class=\"headerlink\" title=\"2.COUNT(字段)、COUNT(常量)和COUNT(*)之间的区别\"></a>2.COUNT(字段)、COUNT(常量)和COUNT(*)之间的区别</h2><p><code>COUNT(常量)</code> 和 <code>COUNT(*)</code> 表示的是直接查询符合条件的数据库表的行数。</p>\n<p>而<code>COUNT(列名)</code>表示的是查询符合条件的列的值不为<strong>NULL</strong>的行数(这里的空不是只空字符串或者0，而是表示null)。</p>\n<p><code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化。</p>\n<blockquote>\n<p>SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</p>\n</blockquote>\n<h2 id=\"3-COUNT-的优化\"><a href=\"#3-COUNT-的优化\" class=\"headerlink\" title=\"3.COUNT(*)的优化\"></a>3.COUNT(*)的优化</h2><p><code>MySQL</code>主要使用2种执行引擎：</p>\n<ul>\n<li>InnoDB引擎</li>\n<li>MyISAM引擎</li>\n</ul>\n<p><strong>MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。</strong></p>\n<h3 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h3><p>MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行<code>count(*)</code>时可以直接返回，<u>前提是不能有where</u>条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。</p>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。</p>\n<p>但是，InnoDB还是针对COUNT(*)语句做了些优化的。</p>\n<p>通过低成本的<strong>索引</strong>进行扫表，而不关注表的具体内容。</p>\n<p>InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p>\n<p><strong>MySQL会优先选择最小的非聚簇索引来扫表。</strong></p>\n<p><u>优化的前提是查询语句中不包含where条件和group by条件。</u></p>\n<h2 id=\"4-COUNT-和COUNT-1\"><a href=\"#4-COUNT-和COUNT-1\" class=\"headerlink\" title=\"4.COUNT(*)和COUNT(1)\"></a>4.COUNT(*)和COUNT(1)</h2><p>MySQL官方文档这么说：</p>\n<blockquote>\n<p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p>\n</blockquote>\n<p>所以，对于<code>count(1)</code>和<code>count(*)</code>，MySQL的优化是完全一样的，根本不存在谁更快！</p>\n<p>但依旧建议使用<code>count(*)</code>，因为这是SQL92定义的标准统计行数的语法。</p>\n<h2 id=\"5-COUNT-字段\"><a href=\"#5-COUNT-字段\" class=\"headerlink\" title=\"5.COUNT(字段)\"></a>5.COUNT(字段)</h2><p>进行全表扫描，判断指定字段的值是否为<code>NULL</code>，不为<code>NULL</code>则累加。</p>\n<p>性能比<code>count(1)</code>和<code>count(*)</code>慢。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h2><p><code>COUNT</code>函数的用法，主要用于统计表行数。主要用法有<code>COUNT(*)</code>、<code>COUNT(字段)</code>和<code>COUNT(1)</code>。</p>\n<p>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供<code>COUNT(*)</code>查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。<strong>当然，这些优化的前提都是没有进行where和group的条件查询。</strong></p>\n<p>在InnoDB中<code>COUNT(*)</code>和<code>COUNT(1)</code>实现上没有区别，而且效率一样，但是<code>COUNT(字段)</code>需要进行字段的非NULL判断，所以效率会低一些。</p>\n<p>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用<code>COUNT(*)</code>查询表的行数！</p>\n<h1 id=\"2、Mysql的limit用法\"><a href=\"#2、Mysql的limit用法\" class=\"headerlink\" title=\"2、Mysql的limit用法\"></a>2、Mysql的limit用法</h1><p>在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure>\n\n<p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。**初始记录行的偏移量是 0(而不是 1)**： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p>\n<ol>\n<li><p>mysql&gt; <strong>SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</strong>  </p>\n<p>//为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：  </p>\n</li>\n<li><p>mysql&gt; <strong>SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last</strong>  </p>\n<p>//如果只给定一个参数，它表示返回最大的记录行数目：  </p>\n</li>\n<li><p>mysql&gt; <strong>SELECT * FROM table LIMIT 5; //检索前 5 个记录行</strong>  </p>\n<p>//换句话说，LIMIT n 等价于 LIMIT 0,n。 </p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： </span><br><span class=\"line\">mysql&gt; SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last.</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;如果只给定一个参数，它表示返回最大的记录行数目： 换句话说，LIMIT n 等价于 LIMIT 0,n。</span><br><span class=\"line\">mysql&gt; SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"需要特别注意的\"><a href=\"#需要特别注意的\" class=\"headerlink\" title=\"需要特别注意的\"></a>需要特别注意的</h2><p>1.比如差的这张表只有两条数据，而我们写sql limit 2，1 的时候会返回一条记录都为<strong>空</strong>的记录，不是0和null。</p>\n<p>2.limit 后写两个参数时，第一个是偏移量，是从<strong>0</strong>开始的，想要从第一条记录开始必须从0，第二个参数是条数。</p>\n<h1 id=\"3、order-by\"><a href=\"#3、order-by\" class=\"headerlink\" title=\"3、order by\"></a>3、order by</h1><h2 id=\"1-order-by的用法\"><a href=\"#1-order-by的用法\" class=\"headerlink\" title=\"1.order by的用法\"></a>1.order by的用法</h2><p>使用order by，一般是用来，依照查询结果的某一列（或多列）属性，进行排序（升序：ASC；降序：DESC；默认为升序）。</p>\n<p>当排序列含空值时：</p>\n<p>ASC：排序列为空值的元组最后显示。</p>\n<p>DESC：排序列为空值的元组最先显示。</p>\n<p>为了好记忆，我的理解是，可以把null值看做<strong>无穷大</strong>，因为不知道具体为多少。然后去考虑排序，asc升序null肯定在最后，而desc降序，null肯定在最前面。</p>\n<p>1》单一列属性排序</p>\n<p>举例1：默认排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from s</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901014959861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from s order by sno desc</span><br></pre></td></tr></table></figure>\n\n<p>按照sno降序：</p>\n<p><img data-src=\"https://img-blog.csdn.net/20150901015222489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>2》多个列属性排序</p>\n<p>选择多个列属性进行排序，然后排序的顺序是，<strong>从左到右</strong>，依次排序。</p>\n<p>如果前面列属性有些是一样的话，再按后面的列属性排序。（前提一定要满足前面的属性排序，因为在前面的优先级高）。</p>\n<p>举例2：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> s  </span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> sname <span class=\"keyword\">desc</span>, sage <span class=\"keyword\">desc</span></span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901015819710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>首先按照sname降序排序，然后出现了xx一样的，在按照sage降序排序。（默认sage是升序）。</p>\n<p>如果最开始使用sno排序,</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> s </span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> sno <span class=\"keyword\">desc</span>,  sage <span class=\"keyword\">asc</span></span><br></pre></td></tr></table></figure>\n\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901020349238?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>必须先满足前面列属性的排序（sno在前优先级高）。才会去考虑后续列属性的排序。</p>\n<p><strong>注意：group by 必须放在 order by 和 limit之前</strong></p>\n<h1 id=\"4、group-by的用法\"><a href=\"#4、group-by的用法\" class=\"headerlink\" title=\"4、group by的用法\"></a>4、group by的用法</h1><p><strong>group by按照查询结果集中的某一列（或多列），进行分组，值相等的为一组。</strong></p>\n<p>1》细化集函数（count，sum，avg，max，min）的作用对象：</p>\n<p>未对查询结果分组，集函数将作用于整个查询结果。</p>\n<p>对查询结果分组后，集函数将分别作用于每个组。</p>\n<p>例子1：</p>\n<p>求各个课程号及相应的选课人数：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> cno,<span class=\"keyword\">count</span>(sno) <span class=\"keyword\">from</span> sc</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901020802381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>对整个表进行count。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> cno,<span class=\"keyword\">count</span>(sno) <span class=\"keyword\">from</span> sc <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> cno</span><br></pre></td></tr></table></figure>\n\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901021021720?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>对分组的表进行count</p>\n<p>sc表内容如下：</p>\n<p><img data-src=\"https://img-blog.csdn.net/20150901021101360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>2》GROUP BY子句的作用对象是查询的中间结果表</p>\n<p>分组方法：按指定的一列或多列值分组，值相等的为一组。</p>\n<p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性（比如：sno）和集函数（比如：count（））。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select sno,count(cno) from sc group by sno</span><br></pre></td></tr></table></figure>\n\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901021443417?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>3》多个列属性进行分组举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select cno,grade,count(cno) from sc group by cno,grade</span><br></pre></td></tr></table></figure>\n\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901021646837?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>cno为1且成绩为66的，有3个</p>\n<p>4》使用HAVING短语筛选最终输出结果</p>\n<p>只有满足HAVING短语指定条件的组才输出。</p>\n<h2 id=\"HAVING短语与WHERE子句的区别\"><a href=\"#HAVING短语与WHERE子句的区别\" class=\"headerlink\" title=\"HAVING短语与WHERE子句的区别\"></a><strong>HAVING短语与WHERE子句的区别</strong></h2><p>作用对象不同</p>\n<p>1》WHERE子句作用于<strong>基表或视图</strong>，从中选择满足条件的<strong>元组</strong>。</p>\n<p>2》HAVING短语作用于<strong>组</strong>，从中选择满足条件的<strong>组</strong>。</p>\n<p>举例：</p>\n<p>查询选修了3门以上课程的学生学号：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> sno <span class=\"keyword\">from</span> sc <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> sno <span class=\"keyword\">having</span> <span class=\"keyword\">count</span>(cno)&gt;<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901021926006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<p>举例：</p>\n<p>查询选修了3门以上课程，且<strong>所有课程</strong>成绩都高于60分的学生学号及课程数</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> sno , <span class=\"keyword\">count</span>(cno)</span><br><span class=\"line\"><span class=\"keyword\">from</span> sc </span><br><span class=\"line\"><span class=\"keyword\">where</span> grade &gt; <span class=\"number\">60</span>  </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> sno <span class=\"keyword\">having</span> <span class=\"keyword\">count</span>(cno) &gt; <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n\n<p><img data-src=\"https://img-blog.csdn.net/20150901022048618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"img\" loading=\"lazy\"></p>\n<h1 id=\"5、DISTINCT\"><a href=\"#5、DISTINCT\" class=\"headerlink\" title=\"5、DISTINCT\"></a>5、DISTINCT</h1><p>在 MySQL 查询中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p>\n<p>关键词 DISTINCT 用于返回唯一不同的值，就是<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2FjYWRlbXkvdGFnLyVFNSU4RSVCQiVFOSU4NyU4RA==\">去重<i class=\"fa fa-external-link-alt\"></i></span>啦。用法也很简单：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> * <span class=\"keyword\">FROM</span> tableName</span><br></pre></td></tr></table></figure>\n\n<p>DISTINCT 这个关键字来过滤掉多余的重复记录只保留一条。</p>\n<p>另外，如果要对某个字段去重，并且保留别的字段可以试下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *, <span class=\"keyword\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> nowamagic) <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> nowamagic</span><br></pre></td></tr></table></figure>\n\n<p>这个用法，<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2FjYWRlbXkvdGFnL015U1FM\">MySQL<i class=\"fa fa-external-link-alt\"></i></span>的版本不能太低。</p>\n<p>注意：</p>\n<ul>\n<li>DISTINCT不能用在where后面，DISTINCT必须放在开头</li>\n<li>select distinct name, id from table ;作用两个字段时，也就是必须得id与name都相同的才会被排除</li>\n</ul>\n","categories":["Mysql"],"tags":["count等关键字"]},{"title":"Spring  Cloud的基本知识","url":"/2021-03-25-Spring%20%20Cloud%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html","content":"<h2 id=\"Spring-Cloud的基本知识\"><a href=\"#Spring-Cloud的基本知识\" class=\"headerlink\" title=\"Spring  Cloud的基本知识\"></a>Spring  Cloud的基本知识</h2><h3 id=\"1、何为微服务\"><a href=\"#1、何为微服务\" class=\"headerlink\" title=\"1、何为微服务\"></a>1、何为微服务</h3><p>在了解SpringCloud之前，我们先来大致了解下微服务这个概念吧。</p>\n<h4 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h4><p>简单来说，微服务架构是 SOA 架构思想的一种扩展，更加强调服务个体的独立性、拆分粒度更小。</p>\n<p>其实服务化架构已经可以解决大部分企业的需求了，那么我们为什么要研究微服务呢？先说说它们的区别：</p>\n<ul>\n<li>微服务架构强调业务系统需要彻底的组件化和服务化，一个组件就是一个产品，可以独立对外提供服务</li>\n<li>微服务不再强调传统SOA架构里面比较重的ESB企业服务总线</li>\n<li>微服务强调每个微服务都有自己独立的运行空间，包括数据库资源。</li>\n<li>微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行微服务的切分粒度会更小</li>\n</ul>\n<p><strong>微服务的好处有：服务独立、扩展性好、可靠性强，但同时，也面临一些新的问题，比如运维复杂性，分布式复杂性、监控复杂性等等。</strong></p>\n<h3 id=\"2、传统单体架构\"><a href=\"#2、传统单体架构\" class=\"headerlink\" title=\"2、传统单体架构\"></a>2、传统单体架构</h3><p>单体架构在小微企业比较常见，典型代表就是一个应用、一个数据库、一个web容器就可以跑起来。里面集成了所有的功能。这在小型项目里面时比较好维护的，毕竟功能不多，也不复杂，但扩展性和可靠性比较差，因为所有功能集成在一个服务或者一个war包中，修改某个功能时，需要所有服务重新打包。可能前期开发比较快，后期随着功能的增长，交互的周期会越变越长的。</p>\n<h3 id=\"3、服务化架构\"><a href=\"#3、服务化架构\" class=\"headerlink\" title=\"3、服务化架构\"></a>3、服务化架构</h3><p>也可以称之为SOA架构</p>\n<p>SOA代表面向服务的架构，将应用程序根据不同的职责划分为不同的模块，不同的模块直接通过特定的协议和接口进行交互。这样使整个系统切分成很多单个组件服务来完成请求，当流量过大时通过水平扩展相应的组件来支撑，所有的组件通过交互来满足整体的业务需求。</p>\n<h4 id=\"SOA服务化的优点\"><a href=\"#SOA服务化的优点\" class=\"headerlink\" title=\"SOA服务化的优点\"></a>SOA服务化的优点</h4><p>它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p>\n<h4 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h4><p><strong>需求</strong>：比如现我有一个数据库，一个JavaWeb的网站客户端，一个安卓app客户端，一个IOS客户端。现在我要给用户提供一个注册账号的功能。</p>\n<p><strong>不用SOA的设计思想的实现</strong>：JavaWeb里面写一个注册账号的功能，安卓app里面写一个注册账号的功能，IOS同样如此。如过有一天，我的注册方法需要改动，那是不是三个地方都要改，而且要改的一模一样。当然问题不止这一个。</p>\n<p><strong>SOA的设计思想实现</strong>：用Java（或者是其他语言皆可）单独创建一个工程部署在一台服务器上，并且写一个方法（或称函数）执行上述注册操作，然后提供一个借口，其他人可以通过某种途径（可以是http链接，或者是基于socket的RPC调用）访问这个方法来注册。就是说把这个操作封装到一个工程中去，然后暴露访问的方式，形成“服务”。</p>\n<p><strong>服务化架构是一套松耦合的架构，服务的拆分原则是服务内部高内聚，服务之间低耦合。</strong></p>\n<p>一般上我们使用dubbo来进行服务的治理功能，没有使用SpringCloud之前，基本上都是使用dubbo来拆分服务，进行服务间的调用。</p>\n<h3 id=\"4、什么是SpringCloud\"><a href=\"#4、什么是SpringCloud\" class=\"headerlink\" title=\"4、什么是SpringCloud\"></a>4、什么是SpringCloud</h3><p>SpringCloud是基于SpringBoot的一整套实现微服务的<strong>框架</strong>。它提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等组件。最重要的是，基于SpringBoot，会让开发微服务架构非常方便。</p>\n<h3 id=\"SpringCloud-和-Dubbo-的区别\"><a href=\"#SpringCloud-和-Dubbo-的区别\" class=\"headerlink\" title=\"SpringCloud 和 Dubbo 的区别\"></a>SpringCloud 和 Dubbo 的区别</h3><p>首先Dubbo是SOA时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而Spring Cloud诞生于微服务架构时代，考虑的是微服务治理的方面，另外由于依托了Spirng、Spirng Boot的优势之上，两个框架在开始目标就不一致，Dubbo定位服务治理、Spirng Cloud是一个生态。</p>\n<p><strong>如果仅仅关注于服务治理的这个层面，Dubbo其实还优于Spring Cloud很多：</strong></p>\n<ol>\n<li>Dubbo 支持更多的协议，如：rmi、hessian、http、webservice、thrift、memcached、redis 等。</li>\n<li>Dubbo 使用 RPC 协议效率更高，在极端压力测试下，Dubbo 的效率会高于 Spring Cloud 效率一倍多。</li>\n<li>Dubbo 有更强大的后台管理，Dubbo 提供的后台管理 Dubbo Admin 功能强大，提供了路由规则、动态配置、访问控制、权重调节、均衡负载等诸多强大的功能。</li>\n<li>可以限制某个 IP 流量的访问权限，设置不同服务器分发不同的流量权重，并且支持多种算法，利用这些功能我们可以在线上做灰度发布、故障转移等。</li>\n<li>可通过dubbo-monitor和dubbo-admin进行监控和管理相关配置</li>\n</ol>\n<p><strong>所以Dubbo专注于服务治理；Spring Cloud关注于微服务架构生态。</strong></p>\n","categories":["微服务"],"tags":["Cloud"]},{"title":"spring ioc流程 + 怎么解决循环依赖的问题","url":"/2021-03-26-spring%20ioc%E6%B5%81%E7%A8%8B%20+%20%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98.html","content":"<h2 id=\"spring-ioc流程-怎么解决循环依赖的问题\"><a href=\"#spring-ioc流程-怎么解决循环依赖的问题\" class=\"headerlink\" title=\"spring ioc流程 + 怎么解决循环依赖的问题\"></a>spring ioc流程 + 怎么解决循环依赖的问题</h2><p>先调用构造函数进行实例化，然后填充属性，再接着进行其他附加操作和初始化，正是这样的生命周期，才有了Spring的解决循环依赖，这样的解决机制是根据Spring框架内定义的三级缓存来实现的，也就是说：三级缓存解决了Bean之间的循环依赖。</p>\n<p>一级一级向下寻找，找出了前面提到的三级缓存，也就是三个Map集合类：</p>\n<p>singletonObjects：第一级缓存，里面放置的是实例化好的单例对象；</p>\n<p>earlySingletonObjects：第二级缓存，里面存放的是提前曝光的单例对象；</p>\n<p>singletonFactories：第三级缓存，里面存放的是要被实例化的对象的对象工厂。</p>\n<p>所以当一个Bean调用构造函数进行实例化后，即使属性还未填充，就可以通过三级缓存向外暴露依赖的引用值（所以循环依赖问题的解决也是基于Java的引用传递），这也说明了另外一点，基于构造函数的注入，如果有循环依赖，Spring是不能够解决的。还要说明一点，Spring默认的Bean Scope是单例的，而三级缓存中都包含singleton，可见是对于单例Bean之间的循环依赖的解决，Spring是通过三级缓存来实现的。</p>\n<h3 id=\"一、spring-ioc-的大致流程\"><a href=\"#一、spring-ioc-的大致流程\" class=\"headerlink\" title=\"一、spring ioc 的大致流程\"></a>一、spring ioc 的大致流程</h3><p><strong>bean的创建过程</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\bean的创建.png\" alt=\"bean的创建\" loading=\"lazy\"></p>\n<p><strong>简单的来说就是：</strong></p>\n<p><strong>①实例化spring容器并初始化→②扫描指定包中的类创建beanDefinition对象→③执行beanFactoryPostProcessor</strong>（执行在bean创建之前，beanDefinition创建之后，算是一个spring的扩展点）→<strong>④推断构造方法，通过反射创建bean对象→⑤执行beanPostProcessor</strong>（在创建对象之后，算是一个spring的扩展点）→<strong>⑥填充属性</strong>（这里会有循环依赖产生，通过二级缓存解决，如果有多重循环依赖，三级缓存则发挥作用）<strong>→⑦执行aware接口重写方法（如果实现了）、执行生命周期初始化方法、执行配置的init-method→⑦将二级缓存和三级缓存中的工厂对象以及bean对象移除，放入到一级缓存中（单例池）</strong>（这里要说明一下：二级缓存是在创建完实例对象后，如果这个bean支持循环依赖，将根据实例对象生成的工厂放入二级缓存的，<strong>这个工厂的回调函数getEarlyRefenrence()会遍历BeanPostProcessor，其中包含了BeanNameAutoProxyCreator和SmartInstantiationAwareBeanPostProcessor接口，如果是BeanNameAutoProxyCreator则生成代理对象，如果是普通BeanPostProcessor则不作处理</strong></p>\n<p>如果没有循环依赖的场景，不会用到三级缓存，直接将二级缓存中的工厂生产的bean对象放入一级缓存中，并移除二级缓存；如果存在循环依赖的场景，在该bean（接下来用A表示）所依赖的bean（接下来用B表示）执行populate填充A时调用getBean方法，进而调用getsingleton时，会将二级缓存的工厂对象取出生产具体的A对象并放入三级缓存中，如果对A还有循环依赖的，之后就可以直接从三级缓存中获取了，这样做的目的是提高性能，因为二级缓存中的工厂生产bean的过程是一个很漫长的过程，里面会执行很多后置处理器，很大的影响了性能</p>\n<h3 id=\"二、什么是循环依赖\"><a href=\"#二、什么是循环依赖\" class=\"headerlink\" title=\"二、什么是循环依赖\"></a>二、什么是循环依赖</h3><p>循环依赖就是两个及以上的由spring管理的bean相互引用对方（相互作为对方的成员属性）形成的一种关系。如下图所示</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\image2021-1-6_21-0-33.png\" alt=\"image2021-1-6_21-0-33\" loading=\"lazy\"></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\image2021-1-6_21-0-51.png\" alt=\"image2021-1-6_21-0-51\" loading=\"lazy\"></p>\n<p>在BeanFactory中，表示循环依赖的属性为allowCircleReferences，其默认值为true，也就是说spring是默认支持循环依赖的，循环依赖主要是在属性填充的时候触发，当A的bean还没创建好（可以理解成还没放到单例池中形成闭环）去填充B时，发现B里面也有A，如果只有一个缓存，你会发现A拿不到B，B也拿不到A，那么就成了一个死循环，spring在这里就用到了二级缓存来解决这样的问题，（三级缓存解决的是性能问题），接下来通过属性填充的过程来解释一下循环依赖的过程</p>\n<p>![属性填充 (1)](D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\属性填充 (1).png)</p>\n<p>简单的来说就是：<br>例：X中含有Y，Y中含有X。当X对象已经创建好了，此时开始将Y属性填充到X对象中：<br>X已经创建成功，二级缓存中已经存在→①通过getBean方法获取Y对象→②在doGetBean中调用getSingleton方法试着从缓存中获取Y，然而获取不到→④调用createBean创建Y→④创建好了Y对象后，将Y放入二级缓存中（工厂）→⑤填充Y中的属性X→⑥通过getBean方法获取X对象→⑦在doGetBean中调用getSingleton方法试着从缓存中获取X，在二级缓存中的工厂生产出X并返回→⑧完成Y中X属性的填充，将Y放入一级缓存中返回Y的bean→⑨完成X中Y属性的填充，将X放入一级缓存中，并返回X</p>\n<p>三级缓存的作用：三级缓存主要是用来提升性能的，一般地，在两个bean循环依赖的场景下（x依赖Y，Y依赖x），是用不到三级缓存的。</p>\n<p>三级缓存运用的时机：当存在循环依赖且一个bean被两个及两个以上的bean所依赖时（X依赖Y，Y依赖X，Z依赖X），三级缓存就会用到了，X先注入Y，通过实例化Y并注入X时，X就会从二级缓存中的工厂创建并放在三级缓存中，再当Z去注入X时，Z就直接从三级缓存中拿X的bean了，不会再从二级缓存中的工厂去生产了。</p>\n<p>二级缓存和三级缓存的差异：二级缓存中的是一个工厂，这个工厂在生产bean的时候会经历很多BeanPostProcessor，值就大量的降低了性能，而三级缓存中的bean本来就是工厂生产出来的定制化的bean，完全可以省去工厂生产的步骤，进行复用，所以用三级缀存性能更强</p>\n<p>二级缓存的作用：二级缓存的第一个较为常见的作用，就是代理实现AOP，比如说X所依赖的Y是实现了AOP的，那么我们通过X去获取的Y并不是我们所写的Y，而是一个代理对象，这里就需要工厂通过一系列的BeanPostProcessor来生产出代理对象，而二级缓存存放工厂而不是bean的目的就是在此。而二级缓存生产出的代理对象也好 还是其他定制化对象也好，如果有循环依赖的情况，最后都会放到三级缓存中。</p>\n","categories":["框架"],"tags":["Bean"]},{"title":"SpringBoot的基本知识","url":"/2021-03-27-SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html","content":"<h2 id=\"一、SpringBoot的基本知识\"><a href=\"#一、SpringBoot的基本知识\" class=\"headerlink\" title=\"一、SpringBoot的基本知识\"></a>一、SpringBoot的基本知识</h2><h3 id=\"1、什么是-Spring-Boot？\"><a href=\"#1、什么是-Spring-Boot？\" class=\"headerlink\" title=\"1、什么是 Spring Boot？\"></a>1、什么是 Spring Boot？</h3><p>Spring Boot 是 Spring 开源组织下的<strong>子项目</strong>，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>\n<h3 id=\"2、为什么要用-Spring-Boot？\"><a href=\"#2、为什么要用-Spring-Boot？\" class=\"headerlink\" title=\"2、为什么要用 Spring Boot？\"></a>2、为什么要用 Spring Boot？</h3><p>Spring Boot 优点非常多，如：</p>\n<ul>\n<li>独立运行（内嵌tomcat等组件）</li>\n<li>简化配置</li>\n<li>自动配置（EnableAutoConfiguration）</li>\n<li>无代码生成和XML配置</li>\n<li>应用监控</li>\n<li>上手容易</li>\n</ul>\n<h3 id=\"3、什么是-SpringBoot-自动装配？\"><a href=\"#3、什么是-SpringBoot-自动装配？\" class=\"headerlink\" title=\"3、什么是 SpringBoot 自动装配？\"></a>3、什么是 SpringBoot 自动装配？</h3><p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p>\n<blockquote>\n<p>SpringBoot 定义了一套接口规范，这套规范规定：</p>\n<p><strong>SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件</strong>，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>\n<p><strong><code>spring.factories</code>中这么多配置，每次启动都要全部加载么？</strong></p>\n<p>很明显，这是不现实的。会经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p>\n</blockquote>\n<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>\n<p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>\n<h3 id=\"4、SpringBoot-是如何实现自动装配的？\"><a href=\"#4、SpringBoot-是如何实现自动装配的？\" class=\"headerlink\" title=\"4、SpringBoot 是如何实现自动装配的？\"></a>4、SpringBoot 是如何实现自动装配的？</h3><p>我们先看一下 SpringBoot 的核心注解 <code>SpringBootApplication</code> 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\">&lt;<span class=\"number\">1.</span>&gt;<span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\">&lt;<span class=\"number\">2.</span>&gt;<span class=\"meta\">@ComponentScan</span></span><br><span class=\"line\">&lt;<span class=\"number\">3.</span>&gt;<span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">//实际上它也是一个配置类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootConfiguration &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>\n<ul>\n<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>\n<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li>\n<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li>\n</ul>\n<h3 id=\"5、实际实现自动装配的注解\"><a href=\"#5、实际实现自动装配的注解\" class=\"headerlink\" title=\"5、实际实现自动装配的注解\"></a>5、实际实现自动装配的注解</h3><p><strong>@EnableAutoConfiguration:实现自动装配的核心注解</strong></p>\n<p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span> <span class=\"comment\">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class=\"comment\">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    String ENABLED_OVERRIDE_PROPERTY = <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们现在重点分析下<code>AutoConfigurationImportSelector</code> 类到底做了什么？</p>\n<p><strong>AutoConfigurationImportSelector:加载自动装配类</strong></p>\n<p><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>\n<h3 id=\"6、你如何理解-Spring-Boot-中的-Starters？\"><a href=\"#6、你如何理解-Spring-Boot-中的-Starters？\" class=\"headerlink\" title=\"6、你如何理解 Spring Boot 中的 Starters？\"></a>6、你如何理解 Spring Boot 中的 Starters？</h3><p>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。</p>\n","categories":["框架"],"tags":["SpringBoot"]},{"title":"spring系列常用注解","url":"/2021-03-28-spring%E7%B3%BB%E5%88%97%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.html","content":"<h2 id=\"spring系列常用注解\"><a href=\"#spring系列常用注解\" class=\"headerlink\" title=\"spring系列常用注解\"></a>spring系列常用注解</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span>：</span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Required</span></span><br><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\"><span class=\"meta\">@RequestParam</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br></pre></td></tr></table></figure>\n\n<p>1、@Controller</p>\n<p>标识一个类是Spring MVC controller处理器，用来创建处理http请求的对象</p>\n<p>2、@RequestMapping</p>\n<p>作用在类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。<br>作用在方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。</p>\n<p>3、RestController</p>\n<p>Spring4之后加入的注解，原来的@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController代替@Controller就不需要@ResponseBody，默认返回json格式。</p>\n<p>4、@Service</p>\n<p>用于标注业务层组件，以注解的方式把这个类注入到spring配置中</p>\n<p>5、Autowired</p>\n<p>用来装配bean，都可以写在字段或方法上</p>\n<p>默认情况下必须要求依赖的对象必须存在，如果要允许null值，可以设置它的required属性为false，例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required=false)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TestService service;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Required（注释检查）</p>\n<p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p>\n<p>通俗的讲：该注解放在setter方法上，表示当前的setter修饰的属性必须在Spring.xml中进行装配，否则报错BeanInitializationException异常，所以这是个检查注解。</p>\n</blockquote>\n<p>6、@Resource</p>\n<p>等同于@Autowired</p>\n<p>@Autowired按照byType自动注入，而@Resource默认byName自动注入</p>\n<p>@Resource有两个属性是比较重要，分别是name，type ；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果都不指定，这时将通过反射机制使用byName自动注入策略。</p>\n<p>7、@RequestParam</p>\n<p>用于将请求参数区的数据映射到功能方法的参数上，其中course_id就是接口传递的参数，id就是映射course_id的参数名，也可以不写value属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">requ</span><span class=\"params\">(<span class=\"meta\">@RequestParam(value=&quot;course_id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(consumerInfoService.fetch(id));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>8、@Component</p>\n<p>把普通pojo实例化到spring容器中，相当于配置文件中的 <bean id=\"\" class=\"\"/><br>它泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>\n<p>此外，被@controller 、@service、@repository 、@component 注解的类，都会把这些类纳入进spring容器中进行管理</p>\n<p>9、@Scope</p>\n<p>是springIoc容器中的一个作用域</p>\n<p>在Spring Ioc容器中作用域有：singleton（单例）默认的、prototype（多例）、web作用域（request、session、global session）、自定义作用域</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype原型模式：</span><br><span class=\"line\"><span class=\"meta\">@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span>这个是说在每次注入的时候回自动创建一个新的bean实例</span><br><span class=\"line\"></span><br><span class=\"line\">singleton单例模式：</span><br><span class=\"line\"><span class=\"meta\">@Scope(value=ConfigurableBeanFactory.SCOPE_SINGLETON)</span>单例模式，在整个应用中只能创建一个实例</span><br><span class=\"line\"></span><br><span class=\"line\">globalsession模式：</span><br><span class=\"line\"><span class=\"meta\">@Scope(value=WebApplicationContext.SCOPE_GLOBAL_SESSION)</span>全局session中的一般不常用</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scope(value=WebApplicationContext.SCOPE_APPLICATION)</span>在一个web应用中只创建一个实例</span><br><span class=\"line\"></span><br><span class=\"line\">request模式：</span><br><span class=\"line\"><span class=\"meta\">@Scope(value=WebApplicationContext.SCOPE_REQUEST)</span>在一个请求中创建一个实例</span><br><span class=\"line\"></span><br><span class=\"line\">session模式：</span><br><span class=\"line\"><span class=\"meta\">@Scope(value=WebApplicationContext.SCOPE_SESSION)</span>每次创建一个会话中创建一个实例</span><br></pre></td></tr></table></figure>\n\n<p>10、@Bean</p>\n<p>产生一个bean的方法，并且交给Spring容器管理，<em>相当于配置文件中的 <bean id=\"\" class=\"\"/>*</em></p>\n<p>11、@Transactional</p>\n<p>事物管理一般有编程式和声明式两种，编程式是在代码中侵入编写的；而声明式则是通过注解或者是在配置文件中进行配置的，非侵入式的。</p>\n<p>12、@Aspect</p>\n<p>作用是标记一个切面类（spring不会将切面注册为Bean也不会增强，但是需要扫描）</p>\n<p>@Pointcut</p>\n<p>定义切点，切点表达式(execution(权限访问符 返回值类型 方法所属的类名包路径.方法名(形参类型) 异常类型))</p>\n<p>@Before</p>\n<p>前置增强，配合@Pointcut一起使用</p>\n<p>@AfterReturning</p>\n<p>后置增强，配合@Pointcut一起使用</p>\n<p>@Around</p>\n<p>环绕增强，配合@Pointcut一起使用</p>\n<p>@AfterThrowing</p>\n<p>异常抛出增强，配合@Pointcut一起使用</p>\n<p>@After</p>\n<p>最终增强(最后执行)，配合@Pointcut一起使用  </p>\n","categories":["框架"],"tags":["注解"]},{"title":"java中值传递问题","url":"/2021-03-29-TestTransferValue.html","content":"<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestTransferValue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeValue1</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        age = <span class=\"number\">30</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeValue2</span><span class=\"params\">(Person person)</span></span>&#123;</span><br><span class=\"line\">        person.setName(<span class=\"string\">&quot;xxxx&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeValue3</span><span class=\"params\">(String s)</span></span>&#123;<span class=\"comment\">//指向常量池中的abc</span></span><br><span class=\"line\">        s = <span class=\"string\">&quot;xxxx&quot;</span>;<span class=\"comment\">//如果xxxx没在常量池中，会在常量池中创建一个 并指向它，方法结束就没了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">        String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age = <span class=\"number\">20</span>;</span><br><span class=\"line\">        TestTransferValue test1 = <span class=\"keyword\">new</span> TestTransferValue();</span><br><span class=\"line\">        test1.changeValue1(age);</span><br><span class=\"line\">        System.out.println(age);</span><br><span class=\"line\"></span><br><span class=\"line\">        Person person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">        test1.changeValue2(person);</span><br><span class=\"line\">        System.out.println(person.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        String s=<span class=\"string\">&quot;abc&quot;</span>;<span class=\"comment\">//首先在abc如果没在常量池中，会在常量池中创建一个</span></span><br><span class=\"line\">        test1.changeValue3(s);<span class=\"comment\">//</span></span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">20</span></span><br><span class=\"line\">xxxx</span><br><span class=\"line\">abc</span><br></pre></td></tr></table></figure>\n\n","categories":["java"],"tags":["值传递"]},{"title":"volatile和ThreadLocal","url":"/2021-03-30volatile%E3%80%81ThreadLocal.html","content":"<h2 id=\"一、关于volatile关键字\"><a href=\"#一、关于volatile关键字\" class=\"headerlink\" title=\"一、关于volatile关键字\"></a>一、关于volatile关键字</h2><h3 id=\"1、首先了解下java内存模型，简称JMM\"><a href=\"#1、首先了解下java内存模型，简称JMM\" class=\"headerlink\" title=\"1、首先了解下java内存模型，简称JMM\"></a>1、首先了解下java内存模型，简称JMM</h3><p>在JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的Java内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>\n<p>要解决这个问题，就需要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。<br>说白了，volatile关键字的主要作用就是保证变量的可见性然。</p>\n<blockquote>\n<p>JMM本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>\n</blockquote>\n<h3 id=\"2、并发编程的三个重要特性\"><a href=\"#2、并发编程的三个重要特性\" class=\"headerlink\" title=\"2、并发编程的三个重要特性\"></a>2、并发编程的三个重要特性</h3><p>1.原子性：一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<strong>synchronized可以保证代码片段的原子性。</strong></p>\n<p>2.可见性：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile关键字可以保证共享变量的可见性。</p>\n<p>3.有序性：代码在执行的过程中的先后顺序，Java在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。</p>\n<blockquote>\n<p>synchronized关键字和volatile关键字比较：</p>\n<ol>\n<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于<strong>变量</strong>而synchronized关键字可以修饰方法以及代码块。</li>\n<li>synchronized关键字在jdk1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized 关键字的场景还是更多一些。(偏向锁、轻量级锁、重量级锁)</li>\n<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>\n<li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证</strong></li>\n<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。</li>\n</ol>\n</blockquote>\n<h3 id=\"3、volatile-存在的意义\"><a href=\"#3、volatile-存在的意义\" class=\"headerlink\" title=\"3、volatile 存在的意义\"></a>3、volatile 存在的意义</h3><h4 id=\"1-可见性\"><a href=\"#1-可见性\" class=\"headerlink\" title=\"1.可见性\"></a>1.可见性</h4><p>工作内存和主内存同步延迟现象导致的可见性问题，可以使用synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见。</p>\n<h4 id=\"2-有序性\"><a href=\"#2-有序性\" class=\"headerlink\" title=\"2.有序性\"></a>2.有序性</h4><p>对于指令重排导致的可见性问题和有序性问题，可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。</p>\n<blockquote>\n<p>指令重排应用的场景： 单例模式</p>\n<p>DCL（双端检锁）机制不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排。</p>\n<p>原因在于某一个线程执行到第一个检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。指令重排只会保证串行语义的执行一致性，但并不会关心多线程间的语义一致性。</p>\n<ol>\n<li>分配内存空间</li>\n<li>初始化对象</li>\n<li>将对象指向刚分配的内存空间</li>\n</ol>\n<p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。</p>\n</blockquote>\n<h4 id=\"3-volatile-实现原理\"><a href=\"#3-volatile-实现原理\" class=\"headerlink\" title=\"3.volatile 实现原理\"></a>3.volatile 实现原理</h4><blockquote>\n<p>在介绍volatile语义实现原理之前，我们先来看两个与CPU相关的专业术语：</p>\n<p><strong>内存屏障</strong>（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。<br><strong>缓存行</strong>（cache line）：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</p>\n</blockquote>\n<h5 id=\"可见性的实现\"><a href=\"#可见性的实现\" class=\"headerlink\" title=\"可见性的实现\"></a>可见性的实现</h5><p>借助了<strong>CPU的lock</strong>指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：</p>\n<ol>\n<li>写volatile时处理器会将缓存写回到主内存。</li>\n<li>一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</li>\n</ol>\n<blockquote>\n<p>具体cpu和内存间的通信：</p>\n<p>为了提高处理速度，处理器一般不直接和内存通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完成后并不知道处理器何时将缓存数据写回到内存。但如果对加了volatile修饰的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量在缓存行的数据写回到系统内存。这时只是写回到系统内存，但其他处理器的缓存行中的数据还是旧的，要使其他处理器缓存行的数据也是新写回的系统内存的数据，就需要实现缓存一致性协议。即在一个处理器将自己缓存行的数据写回到系统内存后，其他的每个处理器就会通过嗅探在总线上传播的数据来检查自己缓存的数据是否已过期，当处理器发现自己缓存行对应的内存地址的数据被修改后，就会将自己缓存行缓存的数据设置为无效，当处理器要对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到自己的缓存行，重新缓存。</p>\n</blockquote>\n<h5 id=\"有序性的实现\"><a href=\"#有序性的实现\" class=\"headerlink\" title=\"有序性的实现\"></a>有序性的实现</h5><p>volatile有序性的保证就是通过禁止指令重排序来实现的。</p>\n<p>指令重排序包括<strong>编译器</strong>和<strong>处理器</strong>重排序，JMM会分别限制这两种指令重排序。</p>\n<p>实现就是加内存屏障，内存屏障是一种CPU指令。JMM为volatile加内存屏障有以下4种情况：</p>\n<blockquote>\n<p>在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。<br>在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序</p>\n</blockquote>\n<h2 id=\"二、关于ThreadLocal\"><a href=\"#二、关于ThreadLocal\" class=\"headerlink\" title=\"二、关于ThreadLocal\"></a>二、关于ThreadLocal</h2><h3 id=\"1、ThreadLocal简介\"><a href=\"#1、ThreadLocal简介\" class=\"headerlink\" title=\"1、ThreadLocal简介\"></a>1、ThreadLocal简介</h3><p><strong>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>\n<p>答：JDK中提供的ThreadLocal类正是为了解决这样的问题。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p><strong>ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法。</strong></p>\n<p>答：多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。</p>\n<h4 id=\"由来\"><a href=\"#由来\" class=\"headerlink\" title=\"由来\"></a>由来</h4><p><strong>ThreadLocal是JDK包提供的</strong>，它提供线程本地变量，如果创建一ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，他们可以使用get（）和set（）方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<h3 id=\"2、实现\"><a href=\"#2、实现\" class=\"headerlink\" title=\"2、实现\"></a>2、实现</h3><p>从Thread类源代码可以看出Thread 类中有一个threadLocals和一个inheritableThreadLocals 变量，它们都是ThreadLocalMap类型的变量，我们可以把ThreadLocalMap 理解为ThreadLocal类实现的定制化的HashMap。默认情况下这两个变量都是nu11，只有当前线程调用ThreadLocal类的set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的get（）、set（）方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Thread implements Runnable &#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#x2F;&#x2F;与此线程有关的ThreadLocal值，由ThreadLocal类维护</span><br><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class=\"line\">&#x2F;&#x2F;与此线程有关的InheritableThreadLocal InheritableThreadLocal类维护</span><br><span class=\"line\">ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体步骤：</p>\n<p>最终的变量是放在了当前线程的 ThreadLocalMap中，并不是存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。ThrealLocal类中可以通过Thread.currentThread（）获取到当前线程对象后，直接通过getMap（Thread t）可以访问到该线程的ThreadLocalMap对象。<br>ThreadLocal 内部维护的是一个类似Map的ThreadLocalMap数据结构，key为当前对象的Thread 对象，值为0bject对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ThreadLocalMap（ThreadLocal&lt;？&gt; firstkey，Object firstValue）&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如我们在同一个线程中声明了两个ThreadLocal对象的话，会使用Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的key 就是ThreadLocal对象，value就是ThreadLocal对象调用set方法设置的值。</p>\n<h3 id=\"3、ThreadLocal-内存泄露的问题\"><a href=\"#3、ThreadLocal-内存泄露的问题\" class=\"headerlink\" title=\"3、ThreadLocal 内存泄露的问题\"></a>3、ThreadLocal 内存泄露的问题</h3><p>ThreadLocalMap 中使用的key为ThreadLocal]的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap中就会出现key为null的Entry。假如我们不做任何措施的话，value永远无法被GC回收，这个时候就可能会产生内存泄露。</p>\n<p>解决：</p>\n<p><strong>ThreadLocalMap实现中已经考虑了这种情况，在调用set（）、get（）、remove（）方法的时候，会清理掉key为null的记录。</strong></p>\n<p><strong>使用完ThreadLocal方法后最好手动调用remove（）方法</strong></p>\n","categories":["JVM"],"tags":["volatile"]},{"title":"分布式锁","url":"/2021-04-01-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98.html","content":"<h2 id=\"1、分布式锁\"><a href=\"#1、分布式锁\" class=\"headerlink\" title=\"1、分布式锁\"></a>1、分布式锁</h2><p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。</p>\n<h4 id=\"为什么要使用分布式锁\"><a href=\"#为什么要使用分布式锁\" class=\"headerlink\" title=\"为什么要使用分布式锁\"></a><strong>为什么要使用分布式锁</strong></h4><p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\ss.png\" alt=\"ss\" loading=\"lazy\"></p>\n<h4 id=\"分布式锁应该具备哪些条件\"><a href=\"#分布式锁应该具备哪些条件\" class=\"headerlink\" title=\"分布式锁应该具备哪些条件\"></a>分布式锁应该具备哪些条件</h4><ul>\n<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li>\n<li>高可用的获取锁与释放锁</li>\n<li>高性能的获取锁与释放锁</li>\n<li>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）</li>\n<li>具备锁失效机制，防止死锁</li>\n<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>\n</ul>\n<h4 id=\"分布式锁的实现有哪些\"><a href=\"#分布式锁的实现有哪些\" class=\"headerlink\" title=\"分布式锁的实现有哪些\"></a>分布式锁的实现有哪些</h4><ul>\n<li>Memcached：利用Memcached的add命令。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。</li>\n<li>Redis: 和Memcached的方式类似，利用Redis的setnx命令。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。</li>\n<li>Zookeeper：利用Zookeeper的顺序临时节点，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。</li>\n<li>Chubby:  Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。</li>\n</ul>\n<h3 id=\"Nginx-有哪些负载均衡策略？\"><a href=\"#Nginx-有哪些负载均衡策略？\" class=\"headerlink\" title=\"Nginx 有哪些负载均衡策略？\"></a>Nginx 有哪些负载均衡策略？</h3><p>负载均衡，即是代理服务器将接收的请求均衡的分发到各服务器中。</p>\n<p>Nginx 默认提供了 3 种负载均衡策略：</p>\n<p>1、轮询（默认）round_robin</p>\n<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>\n<p>2、IP 哈希 ip_hash</p>\n<p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。</p>\n<p>当然，实际场景下，一般不考虑使用 ip_hash 解决 session 共享。</p>\n<p>3、最少连接 least_conn</p>\n<p>下一个请求将被分派到活动连接数量最少的服务器</p>\n","categories":["分布式"],"tags":["锁"]},{"title":"分页","url":"/2021-04-02-%E5%88%86%E9%A1%B5%E7%9A%84%E6%80%9D%E6%83%B3.html","content":"<h2 id=\"1-分页需要依靠数据库\"><a href=\"#1-分页需要依靠数据库\" class=\"headerlink\" title=\"1.分页需要依靠数据库\"></a>1.分页需要依靠数据库</h2><p>使用mysql数据库 limit。</p>\n<p>首先要知道5个变量（属性）</p>\n<p>1.数据总数        (查数据库，select count(*) ..)</p>\n<p>2.页面大小（每页显示的数据条数）30        (用户自定义)</p>\n<p>3.总页数        （程序自动计算：总页数=数据总数%页面大小==0 ？数据总数/页面大小：数据总数/页面大小+1）</p>\n<p>4.当前页（页码）        （用户自定义）</p>\n<p>5.当前页的对象集合（实体类集合）：每页所显示的所有数据 10个人信息   List<Student>   (查数据库，分页sql)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">记录</span><br><span class=\"line\">1\t\t</span><br><span class=\"line\">..</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">..</span><br><span class=\"line\">20</span><br><span class=\"line\">（这里解释下：mysql的数据起始是从0开始的）</span><br><span class=\"line\">页\t\t每页起始数  每页终止数</span><br><span class=\"line\">0\t\t\t0\t\t9</span><br><span class=\"line\">1\t\t\t10\t\t19</span><br><span class=\"line\">2\t\t\t20\t\t29</span><br><span class=\"line\">n\t\t\tn*10\t(n+1)*10-1</span><br><span class=\"line\">每页都是10页</span><br><span class=\"line\"></span><br><span class=\"line\">对应的sql就是：</span><br><span class=\"line\">select * from table limit n*10,10</span><br><span class=\"line\">也就是 select * from table limit 当前页*页面大小,页面大小</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自己手写一个分页步骤：\"><a href=\"#自己手写一个分页步骤：\" class=\"headerlink\" title=\"自己手写一个分页步骤：\"></a>自己手写一个分页步骤：</h3><p>**1.**我们需要在dao层写一个查所有记录的抽象方法，然后用select * from count(*).. 实现它.</p>\n<p>**2.**写要查的对象方法，需要（传当前页、页面大小）可以直接传page对象；类似下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page&lt;BussFeeTask&gt; findByPage(Pageable pageable,</span><br><span class=\"line\">BussFeeTaskQuery query);</span><br></pre></td></tr></table></figure>\n\n<p>**3.**control l中进行获取 5个属性值 并封装</p>\n<p>（1）当前页：当第一次进行分页查询时</p>\n<p><strong>注意：</strong>我们control 中需要有一个默认值 当前页，也就是判断一个前端没传值，如果为null，我们自己就赋一个初值。</p>\n<p>（2）当前页的数据集合：可以用 下面的 请求转发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">request.setAttribute(<span class=\"string\">&quot;students&quot;</span>,students);</span><br><span class=\"line\">request.getRequestDispatcher(<span class=\"string\">&quot;index.jsp&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure>\n\n<p>（3）总数据：进行调用service</p>\n<p>（4）当前数据集合：进行调用service</p>\n<p>（5）总页数不用赋值：但需要注意的时 我们构造方法中写pageSize的set（）方法中进行算得的，需要保证先得到totalCount ，再得到pageSize，所以封装时要注意顺序。</p>\n<p>control -&gt; service  -&gt;  dao</p>\n<p>**4.**写前端页面：</p>\n<p>在分页的前提下，显示数据的jsp需要哪些数据：</p>\n<p>当前页 currentPage</p>\n<p>页面大小 pageSize</p>\n<p>当前页的数据集合 students</p>\n<p>总数据 totalCount</p>\n<p>总页数 totalPage</p>\n<p>为传递数据方便，封装以上五个字段 写一个工具实体类。</p>\n<p><strong>注</strong>：这里需要注意的是总页数不用要写set方法，总页数=数据总数%页面大小==0 ？数据总数/页面大小：数据总数/页面大小+1；当我们调用 数据总数的set() 和 页面大小的set()以后，会自动计算出总页数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.company;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Page</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前页 currentPage</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentPage;</span><br><span class=\"line\">    <span class=\"comment\">//总页数 totalPage</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalPage;</span><br><span class=\"line\">    <span class=\"comment\">//页面大小 pageSize</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> pageSize;</span><br><span class=\"line\">    <span class=\"comment\">// 总数据 totalCount</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//当前页的数据集合 students</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Student students;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCurrentPage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentPage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCurrentPage</span><span class=\"params\">(<span class=\"keyword\">int</span> currentPage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentPage = currentPage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getTotalPage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalPage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*public void setTotalPage(int totalPage) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        this.totalPage = totalPage;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPageSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pageSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPageSize</span><span class=\"params\">(<span class=\"keyword\">int</span> pageSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里需要保证 要先进行totalCount的赋值，然后进行PageSize赋值，不然会出现空指针的现象，在control里进行数据封装时</span></span><br><span class=\"line\">        <span class=\"comment\">//当调用数据总数和页面大小的时候，自动计算总页数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pageSize = pageSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.totalPage=<span class=\"keyword\">this</span>.totalCount%<span class=\"keyword\">this</span>.pageSize==<span class=\"number\">0</span> ? <span class=\"keyword\">this</span>.totalCount/<span class=\"keyword\">this</span>.pageSize : <span class=\"keyword\">this</span>.totalCount/<span class=\"keyword\">this</span>.pageSize+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getTotalCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTotalCount</span><span class=\"params\">(<span class=\"keyword\">int</span> totalCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.totalCount = totalCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">getStudents</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStudents</span><span class=\"params\">(Student students)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.students = students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Page</span><span class=\"params\">(<span class=\"keyword\">int</span> currentPage, <span class=\"keyword\">int</span> totalPage, <span class=\"keyword\">int</span> pageSize, <span class=\"keyword\">int</span> totalCount, Student students)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentPage = currentPage;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.totalPage = totalPage;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pageSize = pageSize;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.totalCount = totalCount;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.students = students;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Page</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显示页面还有这些参数：首页、上一页、下一页、尾页</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(page.currentPage==page.getTotalPage())&#123;</span><br><span class=\"line\">\t\t%&gt;\t</span><br><span class=\"line\">&lt;a href=&quot;QueryStudentByPage?currentPage=1&quot;&gt;首页&lt;/a&gt;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()-1%&gt;上一页&lt;/a&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;% \t&#125;else if (page.currentPage==1)&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \t %&gt;</span></span><br><span class=\"line\">&lt;a href=&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()+1%&gt;下一页&lt;/a&gt;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;QueryStudentByPage?currentPage=&lt;%=page.getTotalPage()%&gt;尾页&lt;/a&gt;         </span></span><br><span class=\"line\"><span class=\"string\">&lt;% \t&#125;else&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \t%&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;a href=&quot;</span>QueryStudentByPage?currentPage=<span class=\"number\">1</span><span class=\"string\">&quot;&gt;首页&lt;/a&gt;</span></span><br><span class=\"line\">&lt;a href=&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()-1%&gt;上一页&lt;/a&gt;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()+1%&gt;下一页&lt;/a&gt;</span></span><br><span class=\"line\">&lt;a href=&quot;QueryStudentByPage?currentPage=&lt;%=page.getTotalPage()%&gt;尾页&lt;/a&gt;</span><br><span class=\"line\">&lt;% \t\t&#125;</span><br><span class=\"line\">         %&gt;\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>这里的上一页和下一页有一些细节问题：</p>\n<p>在第一页时，上一页按钮应该是不好使的或不可见的</p>\n<p>在最后一页时，下一页按钮应该是不好使的或不可见的</p>\n","categories":["Mysql"],"tags":["分页"]},{"title":"关于数据类型的一些坑","url":"/2021-04-03-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html","content":"<h2 id=\"1、详细剖析一下java浮点型运算为什么会造成精度丢失？\"><a href=\"#1、详细剖析一下java浮点型运算为什么会造成精度丢失？\" class=\"headerlink\" title=\"1、详细剖析一下java浮点型运算为什么会造成精度丢失？\"></a>1、详细剖析一下java浮点型运算为什么会造成精度丢失？</h2><h3 id=\"1-首先我们要搞清楚下面两个问题：\"><a href=\"#1-首先我们要搞清楚下面两个问题：\" class=\"headerlink\" title=\"1.首先我们要搞清楚下面两个问题：\"></a>1.首先我们要搞清楚下面两个问题：</h3><pre><code> (1) 十进制整数如何转化为二进制数\n\n       算法很简单。举个例子，11表示成二进制数：\n\n                 11/2=5 余   1\n\n                   5/2=2   余   1\n\n                   2/2=1   余   0\n\n                   1/2=0   余   1\n\n                      0结束         11二进制表示为(从下往上):1011\n\n      这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。\n\n  (2) 十进制小数如何转化为二进制数\n\n       算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数\n\n                 0.9*2=1.8   取整数部分 1\n\n                 0.8(1.8的小数部分)*2=1.6    取整数部分 1\n\n                 0.6*2=1.2   取整数部分 1\n\n                 0.2*2=0.4   取整数部分 0\n\n                 0.4*2=0.8   取整数部分 0\n\n                 0.8*2=1.6 取整数部分 1\n\n                 0.6*2=1.2   取整数部分 0\n\n                          .........      0.9二进制表示为(从上往下): 1100100100100......\n\n       注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了&quot;减不尽&quot;的精度丢失问题。</code></pre>\n<h3 id=\"2-float型在内存中的存储\"><a href=\"#2-float型在内存中的存储\" class=\"headerlink\" title=\"2.float型在内存中的存储\"></a><strong>2.float型在内存中的存储</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">众所周知、 Java 的float型在内存中占4个字节。float的32个二进制位结构如下</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">float内存存储结构</span><br><span class=\"line\"></span><br><span class=\"line\">             4bytes      31    30    29----23    22----0         </span><br><span class=\"line\"></span><br><span class=\"line\">                        表示       实数符号位    指数符号位        指数位          有效数位</span><br><span class=\"line\"></span><br><span class=\"line\">        其中符号位1表示正，0表示负。有效位数位24位，其中一位是实数符号位。</span><br><span class=\"line\"></span><br><span class=\"line\">         将一个float型转化为内存存储格式的步骤为：</span><br><span class=\"line\"></span><br><span class=\"line\">     （1）先将这个实数的绝对值化为二进制格式，注意实数的整数部分和小数部分的二进制方法在上面已经探讨过了。 </span><br><span class=\"line\">     （2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。 </span><br><span class=\"line\">     （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。 </span><br><span class=\"line\">     （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。 </span><br><span class=\"line\">     （5）如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n&#x3D;0，则第30位放入“0”。 </span><br><span class=\"line\">     （6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n&#x3D;0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。</span><br><span class=\"line\"></span><br><span class=\"line\">          举例说明： 11.9的内存存储格式</span><br><span class=\"line\"></span><br><span class=\"line\">       (1) 将11.9化为二进制后大约是&quot; 1011. 1110011001100110011001100...&quot;。</span><br><span class=\"line\"></span><br><span class=\"line\">       (2) 将小数点左移三位到第一个有效位右侧： &quot;1. 011 11100110011001100110 &quot;。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。</span><br><span class=\"line\"></span><br><span class=\"line\">       (3) 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011 11100110011001100110 ”共23bit。将它放入float存储结构的第22到第0位。</span><br><span class=\"line\"></span><br><span class=\"line\">       (4) 因为11.9是正数，因此在第31位实数符号位放入“0”。</span><br><span class=\"line\"></span><br><span class=\"line\">       (5) 由于我们把小数点左移，因此在第30位指数符号位放入“1”。</span><br><span class=\"line\"></span><br><span class=\"line\">       (6) 因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。</span><br><span class=\"line\"></span><br><span class=\"line\">           最后表示11.9为： 0 1 0000010 011 11100110011001100110</span><br><span class=\"line\"></span><br><span class=\"line\">           再举一个例子：0.2356的内存存储格式</span><br><span class=\"line\">      （1）将0.2356化为二进制后大约是0.00111100010100000100100000。 </span><br><span class=\"line\">      （2）将小数点右移三位得到1.11100010100000100100000。 </span><br><span class=\"line\">      （3）从小数点右边数出二十三位有效数字，即11100010100000100100000放</span><br><span class=\"line\">入第22到第0位。 </span><br><span class=\"line\">      （4）由于0.2356是正的，所以在第31位放入“0”。 </span><br><span class=\"line\">      （5）由于我们把小数点右移了，所以在第30位放入“0”。 </span><br><span class=\"line\">      （6）因为小数点被右移了3位，所以将3化为二进制，在左边补“0”补足七</span><br><span class=\"line\">位，得到0000011，各位取反，得到1111100，放入第29到第23位。 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">           最后表示0.2356为：0 0 1111100 11100010100000100100000</span><br><span class=\"line\"></span><br><span class=\"line\">          将一个内存存储的float二进制格式转化为十进制的步骤： </span><br><span class=\"line\">     （1）将第22位到第0位的二进制数写出来，在最左边补一位“1”，得到二十四位有效数字。将小数点点在最左边那个“1”的右边。 </span><br><span class=\"line\">     （2）取出第29到第23位所表示的值n。当30位是“0”时将n各位求反。当30位是“1”时将n增1。 </span><br><span class=\"line\">     （3）将小数点左移n位（当30位是“0”时）或右移n位（当30位是“1”时），得到一个二进制表示的实数。 </span><br><span class=\"line\">     （4）将这个二进制实数化为十进制，并根据第31位是“0”还是“1”加上正号或负号即可。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-浮点型的减法运算\"><a href=\"#3-浮点型的减法运算\" class=\"headerlink\" title=\"3.浮点型的减法运算\"></a><strong>3.浮点型的减法运算</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">浮点加减运算过程比定点运算过程复杂。完成浮点加减运算的操作过程大体分为四步：</span><br><span class=\"line\"></span><br><span class=\"line\">(1) 0操作数的检查；</span><br><span class=\"line\">        如果判断两个需要加减的浮点数有一个为0，即可得知运算结果而没有必要再进行有序的一些列操作。 </span><br><span class=\"line\"></span><br><span class=\"line\">(2) 比较阶码（指数位）大小并完成对阶；</span><br><span class=\"line\">    两浮点数进行加减，首先要看两数的 指数位 是否相同，即小数点位置是否对齐。若两数 指数位 相同，表示小数点是对齐的，就可以进行尾数的加减运算。反之，若两数阶码不同，表示小数点位置没有对齐，此时必须使两数的阶码相同，这个过程叫做对阶 。</span><br><span class=\"line\"></span><br><span class=\"line\">    如何对 阶(假设两浮点数的指数位为 Ex 和 Ey )：</span><br><span class=\"line\">    通过尾数的移位以改变 Ex 或 Ey ，使之相等。 由 于浮点表示的数多是规格化的，尾数左移会引起最高有位的丢失，造成很大误差；而尾数右移虽引起最低有效位的丢失，但造成的误差较小，因此，对阶操作规定使 尾数右移，尾数右移后使阶码作相应增加，其数值保持不变。很显然，一个增加后的阶码与另一个相等，所增加的阶码一定是小阶。因此在对阶时，总是使小阶向大阶看齐 ，即小阶的尾数向右移位 ( 相当于小数点左移 ) ，每右移一位，其阶码加 1 ，直到两数的阶码相等为止，右移的位数等于阶差 △ E 。 </span><br><span class=\"line\"></span><br><span class=\"line\">(3) 尾数（有效数位）进行加或减运算；</span><br><span class=\"line\"></span><br><span class=\"line\">(4) 结果规格化并进行舍入处理。</span><br></pre></td></tr></table></figure>\n\n<p>java在计算浮点数的时候,由于二进制无法精确表示0.1的值(就好比十进制无法精确表示1/3一样),所以一般会对小数格式化处理.</p>\n<p>但是如果涉及到金钱的项目,一点点误差都不能有,必须使用精确运算的时候,就可以使用BigDecimal方法计算.</p>\n<p><strong>但是在使用中还需要注意一个问题:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;直接使用double类型数据进行运算</span><br><span class=\"line\">System.out.println(0.05+0.01);</span><br><span class=\"line\">&#x2F;&#x2F;使用BigDecimal的double参数的构造器</span><br><span class=\"line\">BigDecimal bd1 &#x3D; new BigDecimal(0.05);</span><br><span class=\"line\">BigDecimal bd2 &#x3D; new BigDecimal(0.01);</span><br><span class=\"line\">System.out.println(bd1.add(bd2));</span><br><span class=\"line\">&#x2F;&#x2F;使用BigDecimal的String参数的构造器</span><br><span class=\"line\">BigDecimal bd3 &#x3D; new BigDecimal(&quot;0.05&quot;);</span><br><span class=\"line\">BigDecimal bd4 &#x3D; new BigDecimal(&quot;0.01&quot;);</span><br><span class=\"line\">System.out.println(bd3.add(bd4));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">0.06000000000000000000006</span><br><span class=\"line\">0.060000000000000000000062937...</span><br><span class=\"line\">0.06</span><br></pre></td></tr></table></figure>\n\n<p>所以在计算的时候,应该先把数字转换成String类型的,才能得到最精确的值.</p>\n<p>附常用的方法:</p>\n<p>add  加</p>\n<p>subtract  减</p>\n<p>multiply  乘</p>\n<p>divide 除</p>\n<p>abs 绝对值</p>\n<p>getScale  根据一个规则取几位小数</p>\n<p>pow  几次方</p>\n<h2 id=\"2、mysql中-int-4-、int-10-的区别\"><a href=\"#2、mysql中-int-4-、int-10-的区别\" class=\"headerlink\" title=\"2、mysql中 int(4) 、int(10)的区别\"></a>2、mysql中 int(4) 、int(10)的区别</h2><p><strong>int(M)</strong></p>\n<p>这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(4)只能存储 4个长度的数字，int(11)就会存储 11 个长度的数字，这是大错特错的。</p>\n<p>int(10)也可以代表 2147483647 (2^32 /2  -1)这个值, int(11)也可以代表。</p>\n<p>要查看出不同效果记得在创建类型的时候加 zerofill这个值，表示用 0 填充，否则看不出效果的。</p>\n<p>我们通常在创建数据库的时候都不会加入这个选项，所以可以说他们之间是没有区别的。</p>\n<p>声明字段是int类型的那一刻起，int就是占四个字节，一个字节 8 位，也就是4*8=32，可以表示的数字个数是 2的 32 次方(2^32 = 4 294 967 296个数字)。</p>\n<p>4 294 967 296个数字也就是0~4 294 967 295，当然如果区分正负号的话所存的数字会比较小。</p>\n<p>所以，<code>int(4)</code> 与<code>int(11)</code>后的括号中的字符表示<strong>显示宽度</strong>，整数列的显示宽度与 MySQL 需要用多少个字符来显示该列数值，与该整数需要的存储空间的大小都没有关系，</p>\n<p><strong><code>int</code>类型的字段能存储的数据上限依旧是2147483647(有符号型)和4294967295(无符号型)。</strong></p>\n<h2 id=\"3、mysql中varchar-和-char-的一些问题\"><a href=\"#3、mysql中varchar-和-char-的一些问题\" class=\"headerlink\" title=\"3、mysql中varchar 和 char 的一些问题\"></a>3、mysql中varchar 和 char 的一些问题</h2><h3 id=\"一-varchar存储规则\"><a href=\"#一-varchar存储规则\" class=\"headerlink\" title=\"一. varchar存储规则\"></a>一. varchar存储规则</h3><p><strong>4.0版本以下</strong>，varchar(20)，指的是20字节*，如果存放UTF8汉字时，只能存6个（每个汉字3字节）<br><strong>5.0版本以上</strong>，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以<strong>存放20个，最大大小是65533字节</strong> （65535-1-1）2^16-1 = 65536-1=65535</p>\n<p>Mysql记录行数据是有限的。大小为64k,即65535个字节，而根据设置的varchar(m),M的宽度来决定变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计。</p>\n<p>在物理存储上，varchar使用1到2个额外的字节表示实际存储的字符串长度（bytes）。如果列的最大长度小于256个字节，用一个字节表示（标识）。如果最大长度大于等于256，使用两个字节。</p>\n<p>NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要 1bit 来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位。<strong>所以如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。</strong></p>\n<h3 id=\"二-varchar和char-的区别\"><a href=\"#二-varchar和char-的区别\" class=\"headerlink\" title=\"二. varchar和char 的区别\"></a>二. varchar和char 的区别</h3><p>char是一种固定长度的类型</p>\n<p>varchar则是一种可变长度的类型</p>\n<p>它们的区别是： </p>\n<p>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用<strong>空格字符</strong>补足（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）</p>\n<h3 id=\"三-MySQL中varchar最大长度是多少？\"><a href=\"#三-MySQL中varchar最大长度是多少？\" class=\"headerlink\" title=\"三.MySQL中varchar最大长度是多少？\"></a>三.MySQL中varchar最大长度是多少？</h3><p>这不是一个固定的数字。</p>\n<h4 id=\"1、限制规则\"><a href=\"#1、限制规则\" class=\"headerlink\" title=\"1、限制规则\"></a>1、限制规则</h4><p><strong>字段的限制在字段定义的时候有以下规则：</strong></p>\n<p><strong>a) 存储限制</strong></p>\n<p>varchar最多能存储65535个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535bytes）。65535并不是一个很精确的上限，可以继续缩小这个上限。65535个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计. </p>\n<p>NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要 1bit 来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位。</p>\n<p><strong>如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。</strong></p>\n<p>因为varchar类型存储变长字段的字符类型，与char类型不同的是，其存储时需要在前缀长度列表加上实际存储的字符，当存储的**字符串长度小于255字节时，其需要1字节的空间，当大于255字节时，需要2字节的空间。</p>\n<p><strong>如果数据表只有一个varchar字段且该字段NOT NULL，那么该varchar字段的最大长度为65533个字节，即65535-2=65533byte</strong></p>\n<p><strong>b) 编码长度限制</strong></p>\n<p> <strong>字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;</strong></p>\n<p> <strong>字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。</strong></p>\n<p> <strong>若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。</strong></p>\n<p><strong>c) 行长度限制</strong></p>\n<p><strong>导致实际应用中varchar长度限制的是一个行定义的长度。 MySQL要求一个行的定义长度不能超过65535。若定义的表长度超过这个值，则提示</strong></p>\n<p><strong>ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。</strong></p>\n<h4 id=\"2、计算例子\"><a href=\"#2、计算例子\" class=\"headerlink\" title=\"2、计算例子\"></a><strong>2、计算例子</strong></h4><p><strong>举两个例说明一下实际长度的计算。</strong></p>\n<p><strong>a)  若一个表只有一个varchar类型，如定义为</strong></p>\n<p><strong>create table t4(c varchar(N)) charset=gbk;</strong></p>\n<ol>\n<li><strong>则此处N的最大值为(65535-1-2)/2= 32766。</strong></li>\n<li><strong>减1的原因是实际行存储从第二个字节开始;</strong></li>\n<li><strong>减2的原因是varchar头部的2个字节表示长度;</strong></li>\n<li><strong>除2的原因是字符编码是gbk。</strong></li>\n</ol>\n<p><strong>b) 若一个表定义为</strong></p>\n<p><strong>create table t4(c int, c2 char(30), c3 varchar(N)) charset=utf8;</strong></p>\n<ol>\n<li><strong>则此处N的最大值为 (65535-1-2-4-30*3)/3=21812</strong></li>\n<li><strong>减1和减2与上例相同;</strong></li>\n<li><strong>减4的原因是int类型的c占4个字节;</strong></li>\n<li><strong>减30*3的原因是char(30)占用90个字节，编码是utf8。</strong> </li>\n</ol>\n<p><strong>如果被varchar超过上述的b规则，被强转成text类型，则每个字段占用定义长度为11字节，当然这已经不是varchar了。</strong></p>\n<h4 id=\"3、varchar物理存储\"><a href=\"#3、varchar物理存储\" class=\"headerlink\" title=\"3、varchar物理存储\"></a>3、varchar物理存储</h4><p><strong>在物理存储上，varchar使用1到2个额外的字节表示实际存储的字符串长度（bytes）\\</strong>。如果列的最大长度小于256个字节，用一个字节表示（标识）。如果最大长度大于等于256，使用两个字节。**</p>\n<p><strong>当选择的字符集为latin1，一个字符占用一个byte</strong></p>\n<p><strong>varchar(255)存储一个字符，一共使用2个bytes物理空间存储数据实际数据长度和数据值。</strong></p>\n<p><strong>varchar(256)存储一个字符，使用2 bytes表示实际数据长度，一共需要3 bytes物理存储空间。</strong></p>\n<p><strong>varchar对于不同的RDBMS引擎，有不通的物理存储方式，虽然有统一的逻辑意义。对于mysql的不同存储引擎，其实现方法与数据的物理存放方式也不同。</strong></p>\n","categories":["Mysql"],"tags":["mysql数据类型坑"]},{"title":"集合set、list是如何保证自身特性的","url":"/2021-04-03-%E9%9B%86%E5%90%88set%E3%80%81list%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%87%AA%E8%BA%AB%E7%89%B9%E6%80%A7%E7%9A%84.html","content":"<h3 id=\"1、Set\"><a href=\"#1、Set\" class=\"headerlink\" title=\"1、Set\"></a>1、Set</h3><p>无序，不重复的；</p>\n<h4 id=\"不重复性：\"><a href=\"#不重复性：\" class=\"headerlink\" title=\"不重复性：\"></a><strong>不重复性：</strong></h4><p>因为当我们向Set集合加入数据时，要加入的数据会和集合里的数据比较</p>\n<p>分步骤判断添加的Key值：<br>1、取到新添加Key值的hashCode值。<br>2、确定数组的index 根据Key的hashCode值和当前table的长度按位取并 h &amp; (length-1);<br>按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同<br>3、这里的hashcode在equals前面，JVM会先判断或运算||的前部分，当这一前部分为true的时候判断终止，返回true（这是为了提高JVM的效率），所以当hashcode不同的时候，equals是不会执行的。</p>\n<p>注意：因为Set是接口，里面的方法偶都是抽象的，要想使用需要继承Set接口,HashSet就是一个实现Set的代表实现类。</p>\n<p>而HashSet底层就是用HashMap来实现的，HashMap在put一个Key时会判断，将要放进去的Key的hash值与 目前HashMap中定位到的那个Key的hash值比较。</p>\n<p>如果hashCode相同才会比较equals，equals相同，则两个对象相同，不能插入，equals不同，可以插入；<br>如果hashCode不同，就直接插入了，两个对象hashCode不相等，他们equals一定是false。</p>\n<blockquote>\n<p>重写equals方法后最好重写hashCode方法，否则两个等价对象可能得到不同的hashCode,这在集合框架中使用可能产生严重后果，这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，<br>当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，<br>导致混淆，因此，就也需要重写hashcode()</p>\n</blockquote>\n<p>注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：<br>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p>\n<h4 id=\"无序性：\"><a href=\"#无序性：\" class=\"headerlink\" title=\"无序性：\"></a><strong>无序性：</strong></h4><p>Set系列集合添加元素无序的根本原因是因为底层采用了<strong>哈希表</strong>存储元素。也就是说在存储数据时数据结构是无法保证顺序的。</p>\n<p>JDK1.8之前：哈希表 = 数组 + 链表 + (哈希算法)</p>\n<p>JDK1.8之后：哈希表 = 数组 + 链表 + 红黑树 + (哈希算法)<br>当链表长度超过阈值(8)时，并且树组长度大于64，将链表转换为红黑树，这样大大减少了查找时间。</p>\n<h3 id=\"2、List\"><a href=\"#2、List\" class=\"headerlink\" title=\"2、List\"></a>2、List</h3><h4 id=\"可重复性：\"><a href=\"#可重复性：\" class=\"headerlink\" title=\"可重复性：\"></a>可重复性：</h4><h4 id=\"有序性：\"><a href=\"#有序性：\" class=\"headerlink\" title=\"有序性：\"></a>有序性：</h4><p>list集合代表一个有序集合，<strong>集合中每个元素都有其对应的顺序索引。所以List集合允许使用重复元素</strong>，可以通过索引来访问指定位置的集合元素。</p>\n<p>List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>\n<p><strong>有序</strong>是根据自己本身的类排序达到的，具体看实现类中是怎做到的。</p>\n<p>List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>\n<h3 id=\"3、Map\"><a href=\"#3、Map\" class=\"headerlink\" title=\"3、Map\"></a>3、Map</h3><p>key-value形式存储的，Map 可能会持有相同的值对象但键对象必须是唯一的。</p>\n<p>list和set是继承collection接口的。<br>Map不是collection的子接口或者实现类。Map是一个接口。</p>\n","categories":["集合"]},{"title":"项目中的乱码和解决","url":"/2021-04-05-%E4%B9%B1%E7%A0%81%E5%92%8C%E8%A7%A3%E5%86%B3.html","content":"<p>今天正式把项目跑通了，但是在外网项目上提交数据时，控制台上打的日志中文乱码，因为项目是同事们基本上都开发完了的，我是后拉取的，找了一下配置，在resources文件下的log4j2.xml文件中有Configuration-&gt;Appenders-&gt;Console标签下加<PatternLayout charset=\"UTF-8\" pattern=\"${LOG.PATTERN}\"/></p>\n<p>然后解决日志打印的中文乱码，但是发现数据库中的中文数据还是乱码 ？？？</p>\n<p>然后在xmm.jdbc.url=jdbc:mysql:数据库名://......后面加  <strong>&amp;characterEncoding=utf8</strong>，重点是数据库编码还是<strong>utf8 -- UTF-8 Unicode</strong>；具体为什么就不清楚了</p>\n<blockquote>\n<p>&amp;characterEncoding=UTF-8  ：在使用这个时应该开启这个功能 &amp;useUnicode=true，使用Unicode字符集</p>\n<p>所以 &amp;useUnicode=true&amp;characterEncoding=UTF-8 一般都是一起使用的</p>\n</blockquote>\n<h2 id=\"1-在这里说一下-amp-characterEncoding-utf8-的作用\"><a href=\"#1-在这里说一下-amp-characterEncoding-utf8-的作用\" class=\"headerlink\" title=\"1.在这里说一下 &amp;characterEncoding=utf8 的作用\"></a>1.在这里说一下 &amp;characterEncoding=utf8 的作用</h2><p>前提是项目数据为UTF-8，数据库是GBK</p>\n<ol>\n<li><p>存数据时：</p>\n<p>数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。</p>\n</li>\n<li><p>取数据时：</p>\n<p>在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。</p>\n</li>\n</ol>\n<p>项目和数据库都为UTF8的话，可以不写！！！</p>\n<h2 id=\"2-连接数据库时allowMultiQueries-true的作用：\"><a href=\"#2-连接数据库时allowMultiQueries-true的作用：\" class=\"headerlink\" title=\"2.连接数据库时allowMultiQueries=true的作用：\"></a>2.连接数据库时allowMultiQueries=true的作用：</h2><ol>\n<li>可以在sql语句后携带分号，实现多语句执行。</li>\n<li>可以执行批处理，同时发出多个SQL语句。</li>\n</ol>\n<h2 id=\"3-既然整体说到这里，说一下整体的乱码解决方案\"><a href=\"#3-既然整体说到这里，说一下整体的乱码解决方案\" class=\"headerlink\" title=\"3.既然整体说到这里，说一下整体的乱码解决方案\"></a>3.既然整体说到这里，说一下整体的乱码解决方案</h2><p>以idea为例，配置全局属性，省的一个一个项目改；点击File | Settings | Editor | File Encodings;把上面的Global Encoding 和 Project Encoding 都设置为UTF-8，下面的Default encoding for propertiles 设置为 UTF-8并勾选后面的方格，最后选择最下面的Create UTF-8 files 为 with NO BOM；点击 Apply 应用  Ok 推出。</p>\n<h2 id=\"4-spring系列框架中解决-前台从后台传递数据时出现中文乱码问题\"><a href=\"#4-spring系列框架中解决-前台从后台传递数据时出现中文乱码问题\" class=\"headerlink\" title=\"4.spring系列框架中解决---前台从后台传递数据时出现中文乱码问题\"></a>4.spring系列框架中解决---前台从后台传递数据时出现中文乱码问题</h2><p><strong>问题描述：</strong></p>\n<p>当传递中文参数到controller类时，无乱是get方式还是post方式都出现乱码</p>\n<p>解决：</p>\n<p>1、保证所有的页面编码都是utf-8，包括jsp页面，浏览器编码设置和idea的编码设置。</p>\n<p>2、spingmvc给我们提供了一个编码过滤器，只需要在配置文件web.xml中加入即可。如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--设置spring自带的过滤器中文乱码解决--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>3、以上两步有时只能解决post方式传递参数乱码问题，get方式还是出现乱码，则就需要该tomcat的配置文件了，打开tomcat的server.xml文件，找到以下行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Connector connectionTimeout&#x3D;&quot;20000&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; redirectPort&#x3D;&quot;8443&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在上面行中插入URIEncoding=&quot;UTF-8&quot;，改成如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Connector URIEncoding&#x3D;&quot;UTF-8&quot;  connectionTimeout&#x3D;&quot;20000&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; redirectPort&#x3D;&quot;8443&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样就解决了springmvc中文参数传递乱码问题了。</p>\n","categories":["Mysql"],"tags":["乱码问题"]},{"title":"敏感数据加解密","url":"/2021-04-04-%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E5%AE%9E%E7%8E%B0.html","content":"<h3 id=\"1-使用mybatis插件-Aces系统完成加解密（aec算法）\"><a href=\"#1-使用mybatis插件-Aces系统完成加解密（aec算法）\" class=\"headerlink\" title=\"1.使用mybatis插件+Aces系统完成加解密（aec算法）\"></a>1.使用mybatis插件+Aces系统完成加解密（aec算法）</h3><p>首先加入pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.jd.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aces-mybatisclient<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>利用mbatis里的TypeHandlers标签,在<strong>mybatis-config.xml</strong>加入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">typeHandlers</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">typeHandler</span> <span class=\"attr\">handler</span>=<span class=\"string\">&quot;com.jd.security.aces.mybatis.handle.AcesIndexHandle&quot;</span> <span class=\"attr\">javaType</span>=<span class=\"string\">&quot;com.jd.security.aces.mybatis.type.AcesJavaType&quot;</span>/&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">typeHandler</span> <span class=\"attr\">handler</span>=<span class=\"string\">&quot;com.jd.security.aces.mybatis.handle.AcesCipherTextHandle&quot;</span> <span class=\"attr\">javaType</span>=<span class=\"string\">&quot;com.jd.security.aces.mybatis.type.AcesJavaType&quot;</span>/&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">typeHandler</span> <span class=\"attr\">handler</span>=<span class=\"string\">&quot;com.jd.security.aces.mybatis.handle.AcesPlainTextHandle&quot;</span> <span class=\"attr\">javaType</span>=<span class=\"string\">&quot;com.jd.security.aces.mybatis.type.AcesJavaType&quot;</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">typeHandlers</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AcesCipherTextHandle：对明文做加密，密文做解密用</li>\n<li>AcesPlainTextHandle：aces.writePlaintext=true时写明文，aces.writePlaintext=false时不写明文</li>\n<li>AcesIndexHandle：对明文生成hash256索引值，用于where等于查询</li>\n</ul>\n<p>根据是否去精确查找信息来判断是否加入密文索引字段。</p>\n<p>使用的加密算法是对称加密算法aes，加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。</p>\n<p>AES加密过程涉及到4种操作，分别是字节替代、行移位、列混淆和轮密钥加。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16个字节的明文、密文和轮密钥都以一个4x4的矩阵表示。</p>\n","categories":["面试"],"tags":["应届面试"]},{"title":"内部类","url":"/2021-04-07-%E5%86%85%E9%83%A8%E7%B1%BB.html","content":"<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><h3 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h3><p>把类定义在另一个类的内部，这个类就叫做内部类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;<span class=\"comment\">//它就是内部类        </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、内部类的访问规则\"><a href=\"#2、内部类的访问规则\" class=\"headerlink\" title=\"2、内部类的访问规则\"></a>2、内部类的访问规则</h3><p>内部类可以直接访问外部类的成员，包括私有的。</p>\n<p>外部类要想访问内部类成员，必须创建对象。</p>\n<h3 id=\"3、内部类的分类\"><a href=\"#3、内部类的分类\" class=\"headerlink\" title=\"3、内部类的分类\"></a>3、内部类的分类</h3><p>成员内部类</p>\n<p>局部内部类</p>\n<p>静态内部类</p>\n<p>匿名内部类</p>\n<h4 id=\"（1）成员内部类\"><a href=\"#（1）成员内部类\" class=\"headerlink\" title=\"（1）成员内部类\"></a>（1）成员内部类</h4><blockquote>\n<p>成员内部类——就是位于外部类成员位置的类<br>特点：可以使用外部类中所有的成员变量和成员方法（包括private的）</p>\n</blockquote>\n<p>格式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(a);</span><br><span class=\"line\">            System.out.println(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer.Inner oi = <span class=\"keyword\">new</span> Outer().<span class=\"function\">new <span class=\"title\">Inner</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        oi.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//成员内部类不是静态的：</span></span><br><span class=\"line\">外部类名.内部类名 对象名 = <span class=\"keyword\">new</span> 外部类名.new 内部类名();</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//成员内部类是静态的：</span></span><br><span class=\"line\">外部类名.内部类名 对象名 = <span class=\"keyword\">new</span> 外部类名.内部类名();    </span><br></pre></td></tr></table></figure>\n\n<p>如果内部类是private修饰的，就不能通过创建对象的方法访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用，这样可以在public中增加一些判断语句，起到数据安全的作用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">              System.out.println(“密码备份文件”);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//使用getXxx()获取成员内部类，可以增加校验语句（文中省略）</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Inner <span class=\"title\">getInner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">              ....</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Inner();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">          Outer outer = <span class=\"keyword\">new</span> Outer();</span><br><span class=\"line\">          Outer.Inner inner = outer.getInner();</span><br><span class=\"line\">          inner.show();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>static 所修饰的内部类，按位置分，属于成员内部类，但也可以称作静态内部类，也常叫做嵌套内部类。</strong></p>\n<p>经典题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age = <span class=\"number\">18</span>;    </span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age = <span class=\"number\">20</span>;    </span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> viod <span class=\"title\">showAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">int</span> age  = <span class=\"number\">25</span>;</span><br><span class=\"line\">              System.out.println(age);<span class=\"comment\">//空1</span></span><br><span class=\"line\">              System.out.println(<span class=\"keyword\">this</span>.age);<span class=\"comment\">//空2</span></span><br><span class=\"line\">              System.out.println(Outer.<span class=\"keyword\">this</span>.age);<span class=\"comment\">//空3</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-局部内部类\"><a href=\"#2-局部内部类\" class=\"headerlink\" title=\"(2) 局部内部类\"></a>(2) 局部内部类</h4><blockquote>\n<p>局部内部类——就是定义在一个方法或者一个作用域里面的类<br>特点：主要是作用域发生了变化，只能在自身所在方法和属性中被使用</p>\n</blockquote>\n<p><strong>格式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在局部位置，可以创建内部类对象，通过对象调用和内部类方法</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age = <span class=\"number\">20</span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age2 = <span class=\"number\">30</span>;</span><br><span class=\"line\">          <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">              <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                  System.out.println(age);</span><br><span class=\"line\">                  <span class=\"comment\">//从内部类中访问方法内变量age2，需要将变量声明为最终类型。</span></span><br><span class=\"line\">                  System.out.println(age2);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">          Inner i = <span class=\"keyword\">new</span> Inner();</span><br><span class=\"line\">          i.show();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么局部内部类访问局部变量必须加final修饰呢？</strong></p>\n<p>因为<strong>局部变量是随着方法的调用而调用</strong>，<strong>使用完毕就消失</strong>，<strong>而堆内存的数据并不会立即消失</strong>。</p>\n<p>所以，堆内存还是用该变量，而该变量已经没有了。<strong>为了让该值还存在，就加final修饰。</strong></p>\n<p>原因是，当我们使用final修饰变量后，堆内存直接存储的<strong>是值</strong>，而<strong>不是变量名</strong>。</p>\n<p>（即上例 age2 的位置存储着常量30 而不是 age2 这个变量名）</p>\n<h4 id=\"3-静态内部类\"><a href=\"#3-静态内部类\" class=\"headerlink\" title=\"(3) 静态内部类\"></a>(3) 静态内部类</h4><blockquote>\n<p>我们所知道static是不能用来修饰类的,但是成员内部类可以看做外部类中的一个成员,所以可以用static修饰,这种用static修饰的内部类我们称作静态内部类,也称作嵌套内部类.<br>特点：静态内部类只能访问静态的外部属性和方法。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outter</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> ages = <span class=\"number\">20</span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Outter</span><span class=\"params\">()</span> </span>&#123;        </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">              System.out.println(age);<span class=\"comment\">//报错</span></span><br><span class=\"line\">              System.out.println(ages);<span class=\"comment\">//正确</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        Outter.Inner inner = <span class=\"keyword\">new</span> Outter.Inner();</span><br><span class=\"line\">        inner.method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-匿名内部类\"><a href=\"#4-匿名内部类\" class=\"headerlink\" title=\"(4) 匿名内部类\"></a>(4) 匿名内部类</h4><blockquote>\n<p>一个没有名字的类，是内部类的简化写法</p>\n</blockquote>\n<p><strong>格式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名或者接口名() &#123;</span><br><span class=\"line\">    重写方法();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本质：其实是继承该类或者实现接口的子类匿名对象</p>\n<p>这也就是下例中，可以直接使用 new Inner() {}.show(); 的原因 == <strong>子类</strong>对象.show();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Inner() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;HelloWorld&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        Outer o = <span class=\"keyword\">new</span> Outer();</span><br><span class=\"line\">        o.method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、应用场景\"><a href=\"#4、应用场景\" class=\"headerlink\" title=\"4、应用场景\"></a>4、应用场景</h3><h4 id=\"1-封装性\"><a href=\"#1-封装性\" class=\"headerlink\" title=\"(1)封装性\"></a>(1)封装性</h4><p>对类的使用访问者的访问权限做出一定的限制，我们需要将一些我们不愿意让别人看到的操作隐藏起来，</p>\n<p>如果我们的内部类不想轻易被任何人访问，可以选择使用private修饰内部类，这样我们就无法通过创建对象的方法来访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public interface Demo &#123;</span><br><span class=\"line\">      void show();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  class Outer &#123;</span><br><span class=\"line\">      private class test implements Demo &#123;</span><br><span class=\"line\">          public void show() &#123;</span><br><span class=\"line\">              System.out.println(&quot;密码备份文件&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      public Demo getInner() &#123;</span><br><span class=\"line\">      \t&#x2F;&#x2F;可以增加一些判断语句</span><br><span class=\"line\">          return new test();</span><br><span class=\"line\">      &#125;   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">          Outer outer &#x3D; new Outer();</span><br><span class=\"line\">          Demo d &#x3D; outer.getInner();</span><br><span class=\"line\">          i.show();&#x2F;&#x2F; 密码备份文件</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-实现多继承\"><a href=\"#2-实现多继承\" class=\"headerlink\" title=\"(2) 实现多继承\"></a>(2) 实现多继承</h4><p>我们之前的学习知道，java是不可以实现多继承的，一次只能继承一个类，我们学习接口的时候，有提到可以用接口来实现多继承的效果，即一个接口有多个实现，但是这里也是有一点弊端的，那就是，一旦实现一个接口就必须实现里面的所有方法，有时候就会出现一些累赘，但是使用内部类可以很好的解决这些问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;BWH_Steven&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">email</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;xxx.@163.com&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Demo1</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.name();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Demo2</span>  </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">email</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.email();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> test1().name();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">email</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> test2().email();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        MyDemo md = <span class=\"keyword\">new</span> MyDemo();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我的姓名:&quot;</span> + md.name());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我的邮箱:&quot;</span> + md.email());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们编写了两个待继承的类Demo1和Demo2，在MyDemo类中书写了两个内部类，test1和test2 两者分别继承了Demo1和Demo2类，这样MyDemo中就间接的实现了多继承。</p>\n<h4 id=\"3-用匿名内部类实现回调功能\"><a href=\"#3-用匿名内部类实现回调功能\" class=\"headerlink\" title=\"(3) 用匿名内部类实现回调功能\"></a>(3) 用匿名内部类实现回调功能</h4><p>我们用通俗讲解就是说在Java中，通常就是编写一个接口，然后你来实现这个接口，然后把这个接口的一个对象作以参数的形式传到另一个程序方法中， 然后通过接口调用你的方法，匿名内部类就可以很好的展现了这一种回调功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">demoMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDemo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">test</span><span class=\"params\">(Demo demo)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test method&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyDemo md = <span class=\"keyword\">new</span> MyDemo();</span><br><span class=\"line\">        <span class=\"comment\">//这里我们使用匿名内部类的方式将接口对象作为参数传递到test方法中去了</span></span><br><span class=\"line\">        md.test(<span class=\"keyword\">new</span> Demo)&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoMethod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;具体实现接口&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["JVM"],"tags":["内部类"]},{"title":"树的基本问题","url":"/2021-04-08-%E6%A0%91%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html","content":"<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"1、二叉树\"><a href=\"#1、二叉树\" class=\"headerlink\" title=\"1、二叉树\"></a>1、二叉树</h3><p>二叉树特点是每个结点最多只能有两棵子树，且有左右之分 。</p>\n<p>二叉树是n个有限元素的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUIlODYlRTUlOTAlODgvMjkwODExNw==\">集合<i class=\"fa fa-external-link-alt\"></i></span>，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。</p>\n<h4 id=\"1-1完全二叉树\"><a href=\"#1-1完全二叉树\" class=\"headerlink\" title=\"1.1完全二叉树\"></a>1.1完全二叉树</h4><p>完全二叉树满足 — 若设二叉树的高度为h，除第h层外，其他各层（1 ~ h-1）的节点数都达到了最大个数，第h层的叶子节点都是从左到右依次排序的。</p>\n<h4 id=\"1-2满二叉树\"><a href=\"#1-2满二叉树\" class=\"headerlink\" title=\"1.2满二叉树\"></a>1.2满二叉树</h4><p>满二叉树满足 —  最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。</p>\n<blockquote>\n<p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p>\n</blockquote>\n<h4 id=\"1-3平衡二叉树\"><a href=\"#1-3平衡二叉树\" class=\"headerlink\" title=\"1.3平衡二叉树\"></a>1.3平衡二叉树</h4><p>平衡二叉树满足 —  平衡二叉树又被称为AVL树（不是AVL算法），它是一颗二叉排序树，并且满足它是一颗空树（root==null）或 它的左右两个子树的高度差的绝对值不大于1，并且左右两个子树都是一颗平衡二叉树。</p>\n<h4 id=\"1-4二叉查找树（BST）\"><a href=\"#1-4二叉查找树（BST）\" class=\"headerlink\" title=\"1.4二叉查找树（BST）\"></a>1.4二叉查找树（BST）</h4><p>二叉查找树，也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：</p>\n<p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>\n<p>（2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>\n<p>（3） 任意节点的左、右子树也分别为二叉查找树；</p>\n<p>（4） 没有键值相等的节点。</p>\n<h3 id=\"2、堆\"><a href=\"#2、堆\" class=\"headerlink\" title=\"2、堆\"></a>2、堆</h3><p>堆是具有以下性质的完全二叉树：</p>\n<p>每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆。</p>\n<p>每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。</p>\n<h3 id=\"3、红黑树\"><a href=\"#3、红黑树\" class=\"headerlink\" title=\"3、红黑树\"></a>3、红黑树</h3><p>首先红黑树的前身是二叉查找树，但是在一些插入情况下会变成线性的数据结构，导致失去本身数据结构的意义。所以出现了自平衡查找二叉树：红黑树</p>\n<p>特点：</p>\n<ol>\n<li>每个节点不是红色的就是黑色的</li>\n<li>根节点总是黑色节点</li>\n<li>每个叶子节点都是黑色的空节点</li>\n<li>如果节点是红色的，则它的两个子节点必须是黑色的，反之不成立</li>\n<li>从任一节点到其每个叶子的<strong>所有路径</strong>都包含相同数目的黑色节点。</li>\n</ol>\n<h3 id=\"4、B-、B-、B\"><a href=\"#4、B-、B-、B\" class=\"headerlink\" title=\"4、B-、B+、B*\"></a>4、B-、B+、B*</h3><p>动态查找树主要有二叉查找树、平衡二叉查找树、红黑树，都是二叉结构，查找的时间复杂度O(log2-N) 与树的深度相关，降低树的深度会提高查找效率，于是有了多路的B-tree、B+ -tree、B* -tree。</p>\n<h4 id=\"1-B树，即B-tree\"><a href=\"#1-B树，即B-tree\" class=\"headerlink\" title=\"1.B树，即B- tree\"></a>1.B树，即B- tree</h4><p>B树是为了磁盘或其它存储设备而设计的一种多叉（路）平衡查找(又称排序)树。</p>\n<p><strong>一棵m阶B树是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树</strong></p>\n<p>1、根结点至少有两个子女；</p>\n<p>2、每个非根节点所包含的关键字个数 j 满足：m/2 - 1 &lt;= j &lt;= m - 1；</p>\n<p>3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：m/2 &lt;= k &lt;= m ；</p>\n<p>4、所有的叶子结点都位于同一层。</p>\n<p><strong>B-tree的特点</strong></p>\n<ul>\n<li>B-tree是一种多路搜索树（并不是二叉的），对于一棵M阶树：</li>\n<li>定义任意非叶子结点最多只有M个孩子；且M&gt;2；</li>\n<li>根结点的孩子数为[2, M]，除非根结点为叶子节点；</li>\n<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>\n<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>\n<li>每个非叶子结点存放至少M/2-1（取上整）和至多M-1个关键字；</li>\n<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>\n<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>\n<li>所有叶子结点位于同一层；</li>\n</ul>\n<p><strong>B-树的特性</strong></p>\n<p>1.关键字集合分布在整颗树中；</p>\n<p>2.任何一个关键字出现且只出现在一个结点中；</p>\n<p>3.搜索有可能在非叶子结点结束；</p>\n<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>\n<p>5.自动层次控制</p>\n<h4 id=\"2-B-树，即B-tree\"><a href=\"#2-B-树，即B-tree\" class=\"headerlink\" title=\"2.B+树，即B+ -tree\"></a>2.B+树，即B+ -tree</h4><p>B+树是应文件系统所需而出的一种B-树的变型树。也是一种多路搜索树。</p>\n<p>B+ 树通常用于<span class=\"exturl\" data-url=\"aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlLzE0\">数据库<i class=\"fa fa-external-link-alt\"></i></span>和操作系统的文件系统中。</p>\n<h4 id=\"3-B-树，即B-tree\"><a href=\"#3-B-树，即B-tree\" class=\"headerlink\" title=\"3.B* 树，即B* -tree\"></a>3.B* 树，即B* -tree</h4><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p>\n<p><strong>小结</strong></p>\n<p><strong>B-树：</strong></p>\n<p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键</p>\n<p>字范围的子结点；</p>\n<p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>\n<p><strong>B+树：</strong></p>\n<p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点</p>\n<p>中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>\n<p>B* 树：</p>\n<p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率</p>\n<p>从1/2提高到2/3</p>\n<h4 id=\"4、3种树的优缺点\"><a href=\"#4、3种树的优缺点\" class=\"headerlink\" title=\"4、3种树的优缺点\"></a>4、3种树的优缺点</h4><p>B-树是一种平衡的多路查找(又称排序)<strong>树，在文件系统中有所应用。主要用作文件的索引。</strong>其中的B就表示平衡(Balance)</p>\n<p>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。 </p>\n<p>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 </p>\n<blockquote>\n<p>比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。 </p>\n<p>B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就会成功并结束查询， 而B+树由于非叶节点只是索引部分，这些节点中只含有其子树中的最大(或最小)关键字，当非终端节点上的关键字等于给点值时，查找并不终止，而是继续向下直到叶子节点。 因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径 。 </p>\n<p>有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。<br>另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。 mysql底层存储是用B+树实现的，因为内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。 </p>\n</blockquote>\n<p>B *  树<br>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B<em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；<br>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>B * 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B\\</em>树分配新结点的概率比B+树要低，空间使用率更高；</p>\n","categories":["数据结构"],"tags":["树"]},{"title":"线程安全的list","url":"/2021-04-09-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84list.html","content":"<h2 id=\"并发下的ArrayList\"><a href=\"#并发下的ArrayList\" class=\"headerlink\" title=\"并发下的ArrayList\"></a>并发下的ArrayList</h2><p>那么它究竟会出现什么问题呢？我们写一段简单的代码看一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ArrayList&lt;Integer&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Runnable runnable = () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                list.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Thread one = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">        Thread two = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">        one.start();</span><br><span class=\"line\">        two.start();</span><br><span class=\"line\">        one.join();</span><br><span class=\"line\">        two.join();</span><br><span class=\"line\">        System.out.println(list.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码中，我们创建了两个线程，同时对ArrayList添加10000个元素，如果我们运行这段代码，我们肯定期望它返回的是20000。可是我在JDK1.8环境中运行这段代码，多次验证，会出现两种结果：</p>\n<p>第一种：抛出数组越界异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.ArrayIndexOutOfBoundsException: <span class=\"number\">163</span></span><br><span class=\"line\">\tat java.util.ArrayList.add(ArrayList.java:<span class=\"number\">459</span>)</span><br><span class=\"line\">\tat com.release.util.container.ArrayListDemo.lambda$main$<span class=\"number\">0</span>(ArrayListDemo.java:<span class=\"number\">15</span>)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第二种：结果&lt;20000</p>\n<p>这是为什么呢？我们来看看ArrayList的部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//存放list集合元素的数组,默认容量10</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData; </span><br><span class=\"line\"><span class=\"comment\">//list大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看add源码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//确定添加元素之后，集合的大小是否足够，若不够则会进行扩容</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//插入元素</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们假如有两个线程在对list插入值，这时线程A获取到的size大小为9，线程B获取的size大小也为9，但是线程A在执行完ensureCapacityInternal(size + 1)后时间片用完了，线程B得以执行，这时线程B发现size+1=10，刚好满足容量大小，不需要进行扩容，这时线程A得到时间片，这时它来执行 elementData[size++] = e时，然而现在size大小为10，这时进行插入就会出现数组越界情况。另外，我们发现size字段没有使用volatile修饰，size++本身就是非原子性的，多个线程之间访问冲突，这时两个线程可能对同一个位置赋值，就可能出现size小于期望值的结果。</p>\n<h4 id=\"1-Collections-SynchronizedList\"><a href=\"#1-Collections-SynchronizedList\" class=\"headerlink\" title=\"1.Collections.SynchronizedList\"></a>1.Collections.SynchronizedList</h4><p>java.util.Collections.synchronizedList(List list) 方法，获取一个线程安全的 List 实例对象。</p>\n<p>正常情况下，Collections.synchronizedList(List list) 返回的是一个 SynchronizedList 的对象，这个对象以组合的方式将对 List 的接口方法操作，委托给传入的 list 对象，并且对所有的接口方法对象加锁，得到并发安全性。<br><strong>Collections.synchronizedList(List list) 方法源码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class=\"line\">        return (list instanceof RandomAccess ?</span><br><span class=\"line\">                new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class=\"line\">                new SynchronizedList&lt;&gt;(list));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当传入的 list 是 ArrayList 时，返回 SynchronizedRandomAccessList 对象；传入 LinkedList 时，返回 SynchronizedList 对象。<br>再来看看 SynchronizedList 源码，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">extends</span> <span class=\"title\">SynchronizedCollection</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;E&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">        SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(list);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.list = list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(list, mutex);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.list = list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> list.get(index);&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> list.set(index, element);&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> list.remove(index);&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...   </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，SynchronizedList 的实现里，get, set, add 等操作都加了 mutex 对象锁，再将操作委托给最初传入的 list。</p>\n<p>这就是以组合的方式，将非线程安全的对象，封装成线程安全对象，而实际的操作都是在原非线程安全对象上进行，只是在操作前给加了同步锁。</p>\n<p>由于有很多业务场景下都有这种需求，所以 Java 类库中封装了这个工具类，给需要的模块使用。</p>\n<h4 id=\"2-CopyOnWriteArrayList\"><a href=\"#2-CopyOnWriteArrayList\" class=\"headerlink\" title=\"2.CopyOnWriteArrayList\"></a>2.CopyOnWriteArrayList</h4><p>Collections.synchronizedList(List<T> list)，但是无论是读取还是写入，它都会进行加锁，当我们并发级别特别高，线程之间在任何操作上都会进行等待，因此在某些场景中它不是最好的选择。在很多的场景中，我们的读取操作可能远远大于写入操作，这时使用这种方式，显然不能让我们满意，那么怎么办呢？别担心，JDK已经为我们考虑好了，为了将读取的性能发挥到极致，提供了CopyOnWriteArrayList类，该类在使用过程中，读读之间不互斥并且更厉害的是读写也不互斥。下面，我们来看看它如何做到的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取重入锁</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">//加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//得到旧数组并获取旧数组的长度</span></span><br><span class=\"line\">       Object[] elements = getArray();</span><br><span class=\"line\">\t   <span class=\"keyword\">int</span> len = elements.length;</span><br><span class=\"line\">        <span class=\"comment\">//复制旧数组的元素到新的数组中并且大小在原基础上加1</span></span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//把值插入到新数组中</span></span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        <span class=\"comment\">//使用新数组替换老数组</span></span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t\t</span><br></pre></td></tr></table></figure>\n\n<p>从源码中，我们可以看出add操作中使用了重入锁，但是此锁只针对<strong>写-写</strong>操作。为什么读写之间不用互斥，关键就在于添加值的操作并不是直接在原有数组中完成，而是使用原有数组复制一个新的数组，然后将值插入到新的数组中，最后使用新数组替换旧数组，这样插入就完成了。大家可以发现，使用这种方式，<strong>在add的过程中旧数组没有得到修改，因此写入操作不影响读取操作</strong>，另外，数组定义private transient volatile Object[] array，其中采用volatile修饰，保证内存可见性，读取线程可以马上知道这个修改。下面我们来看看读取的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Object[] array;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(getArray(), index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">get</span><span class=\"params\">(Object[] a, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (E) a[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Object[] getArray() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>读取操作完全没有使用任何的同步控制或者是加锁，这是因为array数组内部结构不会发生任何改变，只会被另外一个array所替换，因此读取是线程安全的。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在JDK中，获取线程安全的List，我们可以使用Collections.synchronizedList(List<T> list)方式，也可以使用CopyOnWriteArrayList类。在真实环境中，使用它们可以根据我们的业务需要，在插入操作远远超过读取时，建议使用第一种方式，这是因为CopyOnWriteArrayList在插入的过程中会创建新的数组，这样在数据量特别大的情况下，对内存的消耗是很大的。当然，如果是读取操作远远大于插入时，第二种方式肯定更占优势，毕竟读取操作完全不需要加锁。</p>\n","categories":["集合"],"tags":["安全的list"]},{"title":"gc类型、内存泄露和内存溢出","url":"/2021-04-10-gc%E3%80%81oom.html","content":"<h1 id=\"1、怎么看自己项目的gc\"><a href=\"#1、怎么看自己项目的gc\" class=\"headerlink\" title=\"1、怎么看自己项目的gc\"></a>1、怎么看自己项目的gc</h1><h2 id=\"首先来看一下JVM中的GC有哪几种类型？\"><a href=\"#首先来看一下JVM中的GC有哪几种类型？\" class=\"headerlink\" title=\"首先来看一下JVM中的GC有哪几种类型？\"></a>首先来看一下JVM中的GC有哪几种类型？</h2><p>1.-XX:UseSerialGC</p>\n<p>　　虚拟机运行在Client模式的默认值，打开此开关参数后，使用Serial+Serial Old收集器组合进行垃圾收集。</p>\n<p>2.-XX:UseParNewGC</p>\n<p>　　打开此开关参数后，使用ParNew+Serial Old收集器组合进行垃圾收集。</p>\n<p>3.-XX:UseConcMarkSweepGC</p>\n<p>　　打开此开关参数后，使用ParNew+CMS+Serial Old收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent Mode Failure的备用垃圾收集器。</p>\n<p>4.-XX:UseParallelGC</p>\n<p>　　虚拟机运行在Server模式的默认值，打开此开关参数后，使用Parallel Scavenge+Serial Old收集器组合进行垃圾收集。</p>\n<p>5.-XX:UseParallelOldGC</p>\n<p>　　打开此开关参数后，使用Parallel Scavenge+Parallel Old收集器组合进行垃圾收集。</p>\n<h2 id=\"GC日志的查看\"><a href=\"#GC日志的查看\" class=\"headerlink\" title=\"GC日志的查看\"></a>GC日志的查看</h2><p>对应的参数列表</p>\n<p>-XX:+PrintGC 　　                  输出GC日志<br>-XX:+PrintGCDetails              输出GC的详细日志<br>-XX:+PrintGCTimeStamps    输出GC的时间戳（以基准时间的形式）<br>-XX:+PrintGCDateStamps    输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）<br>-XX:+PrintHeapAtGC 　　    在进行GC的前后打印出堆的信息<br>-Xloggc:../logs/gc.log             日志文件的输出路径<br>例如:eclipse.ini中配置下面代码启动后会在同一目录下生成gc.log</p>\n<p>-Xloggc:gc.log<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintGCDetails</p>\n<p>当 JVM 内存严重不足时，就会抛出 java.lang.OutOfMemoryError 错误。</p>\n<h1 id=\"2、内存泄露和内存溢出\"><a href=\"#2、内存泄露和内存溢出\" class=\"headerlink\" title=\"2、内存泄露和内存溢出\"></a>2、内存泄露和内存溢出</h1><h2 id=\"1、内存泄漏\"><a href=\"#1、内存泄漏\" class=\"headerlink\" title=\"1、内存泄漏\"></a>1、内存泄漏</h2><p>memory leak ，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>\n<h2 id=\"2、内存溢出\"><a href=\"#2、内存溢出\" class=\"headerlink\" title=\"2、内存溢出\"></a>2、内存溢出</h2><p>out of memory ，指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>\n<h2 id=\"3、二者的关系\"><a href=\"#3、二者的关系\" class=\"headerlink\" title=\"3、二者的关系\"></a>3、二者的关系</h2><p>内存泄漏的堆积最终会导致内存溢出。</p>\n<p>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</p>\n<p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。</p>\n<h2 id=\"4、内存泄露的具体原因及解决方法\"><a href=\"#4、内存泄露的具体原因及解决方法\" class=\"headerlink\" title=\"4、内存泄露的具体原因及解决方法\"></a>4、内存泄露的具体原因及解决方法</h2><h3 id=\"（1）-内存泄露原因\"><a href=\"#（1）-内存泄露原因\" class=\"headerlink\" title=\"（1） 内存泄露原因\"></a>（1） 内存泄露原因</h3><ol>\n<li>资源未关闭造成的内存泄漏</li>\n<li>集合容器中的内存泄露</li>\n<li>单例造成的内存泄漏</li>\n<li> ThreadLocal 的内存泄露</li>\n</ol>\n<h3 id=\"（2）内存泄露的解决方案\"><a href=\"#（2）内存泄露的解决方案\" class=\"headerlink\" title=\"（2）内存泄露的解决方案\"></a>（2）内存泄露的解决方案</h3><p>因为内存泄漏是在堆内存中，所以对我们来说并不是可见的。通常我们可以借助MAT、LeakCanary等工具来检测应用程序是否存在内存泄漏。<br>1、MAT是一款强大的内存分析工具，功能繁多而复杂。</p>\n<p>2、LeakCanary则是由Square开源的一款轻量级的第三方内存泄漏检测工具，当检测到程序中产生内存泄漏时，它将以最直观的方式告诉我们哪里产生了内存泄漏和导致谁泄漏了而不能被回收。</p>\n<h2 id=\"5、内存溢出的具体原因及解决方法\"><a href=\"#5、内存溢出的具体原因及解决方法\" class=\"headerlink\" title=\"5、内存溢出的具体原因及解决方法\"></a>5、内存溢出的具体原因及解决方法</h2><h3 id=\"（1）内存溢出原因\"><a href=\"#（1）内存溢出原因\" class=\"headerlink\" title=\"（1）内存溢出原因\"></a>（1）内存溢出原因</h3><ol>\n<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li>\n<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收</li>\n<li>代码中存在死循环或循环产生过多重复的对象实体</li>\n<li>启动参数内存值设定的过</li>\n</ol>\n<h3 id=\"（2）内存溢出的解决方案\"><a href=\"#（2）内存溢出的解决方案\" class=\"headerlink\" title=\"（2）内存溢出的解决方案\"></a>（2）内存溢出的解决方案</h3><p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p>\n<p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</p>\n<p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p>\n<ol>\n<li><p>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p>\n</li>\n<li><p>检查List、Map否有使用完后，未清除的问题。List、Map等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p>\n</li>\n<li><p>检查代码中是否有死循环或递归调用。</p>\n</li>\n<li><p>检查是否有大循环重复产生新对象实体。</p>\n</li>\n</ol>\n<p>第四步，使用内存查看工具动态查看内存使用情况.</p>\n","categories":["JVM"],"tags":["内存"]},{"title":"获取 GitHub Personal Access Token 方法","url":"/3.html","content":"<a id=\"more\"></a>\n\n<p>要将博客部署到 GitHub Pages 上， push 操作自然是免不了的，这就要求要有相应的仓库权限。直接用帐号密码无疑是十分不安全的，所以这里通过 GitHub Personal Access Token 来实现。</p>\n<p>点击 GitHub <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Byb2ZpbGU=\">用户设置页面<i class=\"fa fa-external-link-alt\"></i></span> 最下方的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2FwcHM=\">Developer setting<i class=\"fa fa-external-link-alt\"></i></span> ，然后选择 <code>Personal access tokens</code> 来生成一个 token，由于我们只需要能够对普通仓库 push 就行了，所以把 <code>repo</code> 部分勾上即可。<br><img data-src=\"/3/1240.jpeg\" alt=\"GitHub Personal Access Token\" loading=\"lazy\"></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"最简单的 Hexo npm 版本升级","url":"/4.html","content":"<p>[TOC]</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JhaW5lb3JzaGluZS9ucG0tY2hlY2stdXBkYXRlcw==\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"安装npm-check-updates\"><a href=\"#安装npm-check-updates\" class=\"headerlink\" title=\"安装npm-check-updates\"></a>安装npm-check-updates</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"更新-Hexo\"><a href=\"#更新-Hexo\" class=\"headerlink\" title=\"更新 Hexo\"></a>更新 Hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更新所有插件\"><a href=\"#更新所有插件\" class=\"headerlink\" title=\"更新所有插件\"></a>更新所有插件</h2><h3 id=\"检测版本\"><a href=\"#检测版本\" class=\"headerlink\" title=\"检测版本\"></a>检测版本</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新package-json\"><a href=\"#更新package-json\" class=\"headerlink\" title=\"更新package.json\"></a>更新package.json</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu -u</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装package-json新版本\"><a href=\"#安装package-json新版本\" class=\"headerlink\" title=\"安装package.json新版本\"></a>安装package.json新版本</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><p><code>vi update.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ncu</span><br><span class=\"line\">ncu -u</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p><code>bash update.sh</code></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"彻底解决 hexo init 卡顿问题","url":"/5.html","content":"<p>[TOC]</p>\n<p><code>hexo init blog</code>卡住？<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lRTUlQkQlQkIlRTUlQkElOTUlRTglQTclQTMlRTUlODYlQjMraGV4bytpbml0KyVFNSU4RCVBMSVFOSVBMSVCRiVFOSU5NyVBRSVFOSVBMiU5OCZvcT0lRTUlQkQlQkIlRTUlQkElOTUlRTglQTclQTMlRTUlODYlQjMraGV4bytpbml0KyVFNSU4RCVBMSVFOSVBMSVCRiVFOSU5NyVBRSVFOSVBMiU5OCZhcXM9Y2hyb21lLi42OWk1Ny40MDZqMGoxJnNvdXJjZWlkPWNocm9tZSZpZT1VVEYtOA==\">Google<i class=\"fa fa-external-link-alt\"></i></span>谷姐没好办法，分享下自己办法（其实是在翻译源码换gitee源）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">## git submodule init</span><br><span class=\"line\">## git submodule update</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-theme-landscape.git themes&#x2F;landscape</span><br><span class=\"line\">npm i</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n\n\n<a id=\"more\"></a>\n\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWNsaS9ibG9iL21hc3Rlci9saWIvY29uc29sZS9pbml0Lmpz\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update</span><br><span class=\"line\">npm i</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"换gitee\"><a href=\"#换gitee\" class=\"headerlink\" title=\"换gitee\"></a>换gitee</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update</span><br><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm i</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL0dpdC0lRTUlQjclQTUlRTUlODUlQjctJUU1JUFEJTkwJUU2JUE4JUExJUU1JTlEJTk3\">Git 工具 - 子模块<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcw==\">hexojs<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"解决 GitHub Pages 出现独角兽","url":"/6.html","content":"<p><img data-src=\"/6/image-20201021023637217.png\" alt=\"image-20201021023637217\" loading=\"lazy\"></p>\n<a id=\"more\"></a>\n\n<p><strong>We&#39;re having a really bad day.</strong></p>\n<p>The Unicorns have taken over. We&#39;re doing our best to get them under control and get GitHub back up and running.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvbnRhY3Q=\">Contact Support<i class=\"fa fa-external-link-alt\"></i></span> — <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGF0dXMuZ2l0aHViLmNvbS8=\">GitHub Status<i class=\"fa fa-external-link-alt\"></i></span> — <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9naXRodWJzdGF0dXM=\">@githubstatus<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><a href=\"https://weilining.cf/\"><img data-src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mME2UYbodtt+2222u35QheoCCYGBQligIJgkZJNPzgigoaTEj8AdFEMfADfyABkgWiiWcieK4S+QOiHAYUj2hMNKgYlEujpNttu9vttbvdw+chU1K6M535pt3ubHCSyezR+b73eb73+t7vrfXsufOW4bz6+vom9/b23ovnNNw34b5xYGAgODg46Mbt4mesVmsWd1qSpHhdXd2fuP/Afcput5/A88xwymcdBgLqenp6FuRyuWV4zu/v759QyWBjxoz5t76+/gun09mK5xFyakoCAPSaTCazNpvNPoYVbh6O1YKGRF0u13sNDQ27QMzfpiAAKj0lnU6/gBVfAZW2WWpwwVzy0IgP3G73FpjI6REhAGA9qVRqA1b9mVoBVyIC2tDi8Xg24+dUzQiAbS/s7Ox8G2o/3mKCC+Zw0efzPQEfcVjYrARX3dbV1bUtHo8fMgt42f+Mp0yUTVQbdWsAHVsikdiHkHaPxcQXQufXgUBgMRxme9U0AAxfH4vFvjM7eF6UkbJS5qoQwEQGA57Ac5JllFyUVZZ5ckUEgMVxsK2jlSYzI+QXJsiyjzNEAJyJAzb/KQa41jJKL8pODMQiTEAymXw5n8/P0IjD3bh7Rgog59aanxiIRTVvV/oj0tnHca/WMrVwODwB3raTGxzkBg/gnZVapFV62Wy2n5AO70HM/5wbJ0QnXyQSaVPDIuNZzY0V3ntHMwxiwHA0Gj2Np7ecIBDgaDAYXKCQJM1DhrgJ3nhulcPbl8j4NmHe46X/g60fwbz3aewjkqFQaAqebWU1AOqyQwt8Id6qEHMc97zu7u7FGGsn7HAiVuosVw7P35C1nccdgSCxop1dHeZswmfHMnxBo6ZTk+jN8dl/vF7vWofDsa+MLN9oEUBMxOb3+1eoEsBVw6Zmua49r8YmhAKDiEPcMwBsxMiqQ+ixzPFxZyqRpXARG/YOr1ObFJ0gUskXBbamcR1OKmMUvDxHRAu8/LmY3jFLMUpFqz9HxG65smYJdyKyECOxDiEAe/p1gjF2oonivZAsxVgl2daa4EQWCW6J55qFAFFZiJWYLxNQy2qOSUzGRsyXCUDIeliwAHEO4WSlWQBRFoZakXcKmCXmyXAKs0Ve9vl8q42WoIYpJU4hV3hKcNs8m9gl7p/xQ73eF5kB4j5mNrWmTJRNwAzqiV1CxjVTZCIkEq+Z1bZFZSN2CenmVAFVy4Plz8xKAGWjjAKFk6lCBMDR/MJjLLMSQNm43xAiQKTaA+9/wewhDjL+JVI1kkTSSOTcKbMTwPqESAot6dn6Fr1gHwVJju6IRuyiByPuUUBAg5DGkAgBmxlvdgIEK9gDkohdY/BJo4CAG0R8miRSsGABkgVQs4KXu098IgUXSSRsFAoKZiVAVDY2WUiiPTjYRi41KwGisrGsLtlsth8Fiwnz2fBkQvWfRtlE3iF2yW63/yCacXZ1dW02GwGyTFaRd4idJnCKHRaCxYRHoG5LTKT6SyiToP1fJHbmAYPYRR0UnZQtMnA6s0zg+GZBlt0Gdo7EPHgpE3Q6nZ8YyLhc8Xj8MJh/aKTAY+5FPAKHLE7RdwuYJZmNwzyCMkBCYyKROJBMJl9B/PXXCjjmCmDOVzH3fiPpObEWGqoKe4EBl8v1hlqsdLvd23mkxHM9pc9kMpmno9HoeTii7ewbHEZPPx1ztLS1tV3AnGuMjiNjvbQFuHw6zDo5By7dTPAQNBgMLrRarTkSls1mnwT7uwp9virx9QzbW/HuV/j5d/b+6jniKlllP8lkeONJDk+dq9GsQTnC4fB1heO0K47Hwe7WdDr9nAKgXwOBwHI+C45Htj1d6sd429TUNEcmUdc+PRaLHcvn87dXW4ugzdsaGxufL94NFv9zi1J7GVbhlvb2dnaJ3SVrxfc+n2+NTsZ7/H7/Mr3g5XdSIHyJSH1PZ+7fToyl2+ErqilgZ4NaLYB9goVGaHjR93Hv1ZrU4XDsFT20kH3PObzbWk0CgG1jacVIUnAQb9F+VexyLMzkpcLv0IJV7AHQIOCAUYHx7v5qgScmYHtTqSAyZLEJTK22Bie4iq3xsqpm4SAf9Hq9a2DnJ4uLK3SEULcdRvp3i3zHySqpficxEdsQc1NrlYXXvR+O7qASSezXB+h1SuUomgg9LL8BUoV4749EIolKh+EiqWmqVEZlDgHks2pxHw7xTqUQw9J5NcAXOK10AGIoZ6Zli6JY6Z1Q461KoZ4NiKLHarW+KDsxlDUPHZ5zPQZqUVDPJsTqb5n9malbpAh8C2XXDLl62+WZIDFRUlNVOiwencnNU3aQEkL+cDMSoLvZo2fQB7AJssNAuFuvorlDVVkkg2I87+jo2K2QAVphDrfyViK5VqtO34OkaxXCp+7drdDBCAdubm6eidX+2WwqT5komwh4YQLk+H4aE93h8Xg2gvHekQZOGSgLZTLyDTLJ4Lx9/KZWKBSainT4Iy3FqQBfnUZR42PKQFksBr9QKVXCPusD3OiA/RkQ5kP8qV/Jl1WywAp/6+dcmPM2zL1UrUahe4JqfnWWKXIul3uUbfP8njAFLW1OFr3gdFtZ72cNH+PtQT7/brW+NXqJAHh0y9V8/U/A1U7AfwIMAD7mS3pCbuWJAAAAAElFTkSuQmCC\" alt=\"img\" loading=\"lazy\"></a> </p>\n<p>[TOC]</p>\n<h2 id=\"裸yourname-github-io\"><a href=\"#裸yourname-github-io\" class=\"headerlink\" title=\"裸yourname.github.io\"></a>裸yourname.github.io</h2><p>只能等GitHub Pages恢复正常</p>\n<h2 id=\"域名绑定GitHub-Pages\"><a href=\"#域名绑定GitHub-Pages\" class=\"headerlink\" title=\"域名绑定GitHub Pages\"></a>域名绑定GitHub Pages</h2><p>当GitHub Pages出现独角兽，站点文件可以托管到<span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJjZWwuY29tLw==\">vercel<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmV0bGlmeS5jb20v\">netlify<i class=\"fa fa-external-link-alt\"></i></span>，域名可以解析到托管平台。</p>\n<h3 id=\"部署到vercel\"><a href=\"#部署到vercel\" class=\"headerlink\" title=\"部署到vercel\"></a>部署到vercel</h3><p>不支持QQ邮箱、163邮箱，换句话说，请使用谷歌邮箱</p>\n<h4 id=\"使用谷歌邮箱注册登陆gitlab\"><a href=\"#使用谷歌邮箱注册登陆gitlab\" class=\"headerlink\" title=\"使用谷歌邮箱注册登陆gitlab\"></a>使用谷歌邮箱注册登陆gitlab</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRsYWIuY29tL3VzZXJzL3NpZ25faW4=\">https://gitlab.com/users/sign_in<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"使用gitlab注册登陆vercel\"><a href=\"#使用gitlab注册登陆vercel\" class=\"headerlink\" title=\"使用gitlab注册登陆vercel\"></a>使用gitlab注册登陆vercel</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJjZWwuY29tLw==\">https://vercel.com<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"导入github的repo\"><a href=\"#导入github的repo\" class=\"headerlink\" title=\"导入github的repo\"></a>导入github的repo</h4><h4 id=\"vercel的Domains绑定域名\"><a href=\"#vercel的Domains绑定域名\" class=\"headerlink\" title=\"vercel的Domains绑定域名\"></a>vercel的Domains绑定域名</h4><h4 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">A记录解析76.76.21.21 || CNAME记录解析cname.vercel-dns.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到netlify\"><a href=\"#部署到netlify\" class=\"headerlink\" title=\"部署到netlify\"></a>部署到netlify</h3><p>要科学，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGkubmV0bGlmeS5jb23miZPkuI3lvIDlsLHnp5HlrablkKcv\">https://api.netlify.com打不开就科学吧<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"GitHub登陆\"><a href=\"#GitHub登陆\" class=\"headerlink\" title=\"GitHub登陆\"></a>GitHub登陆</h4><h4 id=\"导入GitHub-repo\"><a href=\"#导入GitHub-repo\" class=\"headerlink\" title=\"导入GitHub repo\"></a>导入GitHub repo</h4><h4 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h4><h4 id=\"域名解析-1\"><a href=\"#域名解析-1\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h4><h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvZ2l0aHViL3dvcmtpbmctd2l0aC1naXRodWItcGFnZXMvYWJvdXQtZ2l0aHViLXBhZ2Vz\">关于 GitHub Pages<i class=\"fa fa-external-link-alt\"></i></span>流量每月100GB</p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"最简单的 LaTeX 入门","url":"/7.html","content":"<p>mac下使用Typora添加数学公式<code>command+option+B</code></p>\n<h2 id=\"下标\"><a href=\"#下标\" class=\"headerlink\" title=\"下标\"></a>下标</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">R_&#123;ij&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"长分式\"><a href=\"#长分式\" class=\"headerlink\" title=\"长分式\"></a>长分式</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\frac&#123;X&#125;&#123;Y&#125;</span><br></pre></td></tr></table></figure>\n<p>好用！</p>\n<h2 id=\"练手\"><a href=\"#练手\" class=\"headerlink\" title=\"练手\"></a>练手</h2><p>$$<br>R_i=\\sum_{i}^{n}{\\frac{X_i}{x}}\\ln(\\frac{\\frac{X_i}{X}}{\\frac{Y_i}{Y}})<br>$$</p>\n<p>$$<br>R_{ai}=\\sum_{i}{\\frac{X_{ji}}{X_j}}\\ln(\\frac{\\frac{X_ji}{Xj}}{\\frac{P_ji}{P_j}})<br>$$</p>\n<p>$$<br>R_a=\\sum_{j}{\\frac{X_j}{x}}R_{ai}<br>$$</p>\n<p>$$<br>R_b=\\sum_{j}{\\frac{Xj}{X}}\\ln(\\frac{\\frac{X_j}{X}}{\\frac{P_j}{P}})<br>$$</p>\n<p>$$<br>R=R_a+{R_b}<br>$$</p>\n<p>$$<br>Z_a=\\frac{R_a}{R}<br>$$</p>\n<p>$$<br>Z_b=\\frac{R_b}{R}<br>$$</p>\n<p>$$<br>Z_j=\\frac{X_jR_{ai}}{XR}<br>$$</p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"最简单的使用 jsdelivr 加速网站","url":"/8.html","content":"<p>[TOC]</p>\n<h2 id=\"jsdelivr加速效果\"><a href=\"#jsdelivr加速效果\" class=\"headerlink\" title=\"jsdelivr加速效果\"></a>jsdelivr加速效果</h2><p>使用 jsDelivr 为 Hexo 博客提供高效免费的CDN加速，节省服务器流量且减少宽带占用</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3BpbmcuY2hpbmF6LmNvbS9jZG4uanNkZWxpdnIubmV0\">http://ping.chinaz.com/cdn.jsdelivr.net<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>感受下jsdelivr的加速效果</p>\n<a id=\"more\"></a>\n\n<h2 id=\"使用-jsdelivr-加速-Github-仓库资源背景等图\"><a href=\"#使用-jsdelivr-加速-Github-仓库资源背景等图\" class=\"headerlink\" title=\"使用 jsdelivr 加速 Github 仓库资源背景等图\"></a>使用 jsdelivr 加速 Github 仓库资源背景等图</h2><p>当我们使用 <code>Github</code> 仓库资源时，会因为一些奇怪的原因而掉链子，但我们可以通过 jsdelivr 做 CDN 加速</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==\">jsdelivr<i class=\"fa fa-external-link-alt\"></i></span> 是一个免费的开源 CDN</p>\n<h3 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h3><p><code>https://cdn.jsdelivr.net/gh/</code> Github 用户名/仓库名/资源路径</p>\n<p>默认会访问 <code>master</code> 分支下的资源，可以通过 仓库名拼接 @ + <code>release / commit / branch</code> 来访问特定版本下的资源</p>\n<h3 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlaWxpbmluZy9ibG9nLmlvL21hc3Rlci9pbWFnZXMvYmFja2dyb3VuZC1kYXJrLmpwZw==\">https://raw.githubusercontent.com/weilining/blog.io/master/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn\">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"背景图\"><a href=\"#背景图\" class=\"headerlink\" title=\"背景图\"></a>背景图</h3><p>GitHub仓库：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn\">https://github.com/weilining/blog.io/blob/master/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>对应jsdelivr地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn\">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/background-dark.jpg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>修改地址：<code>blog/source/_data/styles.styl</code></p>\n<h4 id=\"本地\"><a href=\"#本地\" class=\"headerlink\" title=\"本地\"></a>本地</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">body&#123;</span><br><span class=\"line\">  background:url(&#x2F;images&#x2F;background-dark.jpg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"套jsdelivr作为CDN\"><a href=\"#套jsdelivr作为CDN\" class=\"headerlink\" title=\"套jsdelivr作为CDN\"></a>套jsdelivr作为CDN</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">body&#123;</span><br><span class=\"line\">  background:url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;background-dark.jpg&#39;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"头像\"><a href=\"#头像\" class=\"headerlink\" title=\"头像\"></a>头像</h3><p>GitHub地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2ltYWdlcy9sb2dvLnN2Zw==\">https://github.com/weilining/blog.io/blob/master/images/logo.svg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>jsdelivr地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9sb2dvLnN2Zw==\">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>修改地址：<code>_config.next.yml</code></p>\n<h4 id=\"本地-1\"><a href=\"#本地-1\" class=\"headerlink\" title=\"本地\"></a>本地</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  url: &#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"套jsdelivr作为CDN-1\"><a href=\"#套jsdelivr作为CDN-1\" class=\"headerlink\" title=\"套jsdelivr作为CDN\"></a>套jsdelivr作为CDN</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"鼠标点击特效：社会主义价值观\"><a href=\"#鼠标点击特效：社会主义价值观\" class=\"headerlink\" title=\"鼠标点击特效：社会主义价值观\"></a>鼠标点击特效：社会主义价值观</h3><p>GitHub地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2pzL2N1cnNvci9jbGljay13b3JkLmpz\">https://github.com/weilining/blog.io/blob/master/js/cursor/click-word.js<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>jsdelivr地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2pzL2N1cnNvci9jbGljay13b3JkLmpz\">https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/click-word.js<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"本地-2\"><a href=\"#本地-2\" class=\"headerlink\" title=\"本地\"></a>本地</h4><p><code>source/_data/head.njk</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- jquery --&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;click-loveword.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"套jsdelivr作为CDN-2\"><a href=\"#套jsdelivr作为CDN-2\" class=\"headerlink\" title=\"套jsdelivr作为CDN\"></a>套jsdelivr作为CDN</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- jquery --&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.4.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;js&#x2F;cursor&#x2F;click-loveword.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>click-loveword.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;* 社会主体核心价值观效果 *&#x2F;</span><br><span class=\"line\">var a_idx &#x3D; 0;</span><br><span class=\"line\">jQuery(document).ready(function($) &#123;</span><br><span class=\"line\">    $(&quot;body&quot;).click(function(e) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; var a &#x3D; new Array(&quot;❤富强❤&quot;,&quot;❤民主❤&quot;,&quot;❤文明❤&quot;,&quot;❤和谐❤&quot;,&quot;❤自由❤&quot;,&quot;❤平等❤&quot;,&quot;❤公正❤&quot;,&quot;❤法治❤&quot;,&quot;❤爱国❤&quot;,&quot;❤敬业❤&quot;,&quot;❤诚信❤&quot;,&quot;❤友善❤&quot;);</span><br><span class=\"line\">        var a &#x3D; new Array(&quot;富强&quot;,&quot;民主&quot;,&quot;文明&quot;,&quot;和谐&quot;,&quot;自由&quot;,&quot;平等&quot;,&quot;公正&quot;,&quot;法治&quot;,&quot;爱国&quot;,&quot;敬业&quot;,&quot;诚信&quot;,&quot;友善&quot;);</span><br><span class=\"line\">        var $i &#x3D; $(&quot;&lt;span&gt;&lt;&#x2F;span&gt;&quot;).text(a[a_idx]);</span><br><span class=\"line\">        a_idx &#x3D; (a_idx + 1) % a.length;</span><br><span class=\"line\">        var x &#x3D; e.pageX,</span><br><span class=\"line\">        y &#x3D; e.pageY;</span><br><span class=\"line\">        $i.css(&#123;</span><br><span class=\"line\">            &quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999,</span><br><span class=\"line\">            &quot;top&quot;: y - 20,</span><br><span class=\"line\">            &quot;left&quot;: x,</span><br><span class=\"line\">            &quot;position&quot;: &quot;absolute&quot;,</span><br><span class=\"line\">            &quot;font-weight&quot;: &quot;bold&quot;,</span><br><span class=\"line\">            &quot;color&quot;: &quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        $(&quot;body&quot;).append($i);</span><br><span class=\"line\">        $i.animate(&#123;</span><br><span class=\"line\">            &quot;top&quot;: y - 180,</span><br><span class=\"line\">            &quot;opacity&quot;: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        1500,</span><br><span class=\"line\">        function() &#123;</span><br><span class=\"line\">            $i.remove();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;* 爱心特效 *&#x2F;</span><br><span class=\"line\">! function (e, t, a) &#123;</span><br><span class=\"line\">    function n() &#123;</span><br><span class=\"line\">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function r() &#123;</span><br><span class=\"line\">        for (var e &#x3D; 0; e &lt; d.length; e++) d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class=\"line\">        requestAnimationFrame(r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function o() &#123;</span><br><span class=\"line\">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class=\"line\">        e.onclick &#x3D; function (e) &#123;</span><br><span class=\"line\">            t &amp;&amp; t(), i(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function i(e) &#123;</span><br><span class=\"line\">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class=\"line\">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class=\"line\">            el: a,</span><br><span class=\"line\">            x: e.clientX - 5,</span><br><span class=\"line\">            y: e.clientY - 5,</span><br><span class=\"line\">            scale: 1,</span><br><span class=\"line\">            alpha: 1,</span><br><span class=\"line\">            color: s()</span><br><span class=\"line\">        &#125;), t.body.appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function c(e) &#123;</span><br><span class=\"line\">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class=\"line\">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            a.appendChild(t.createTextNode(e))</span><br><span class=\"line\">        &#125; catch (t) &#123;</span><br><span class=\"line\">            a.styleSheet.cssText &#x3D; e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function s() &#123;</span><br><span class=\"line\">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var d &#x3D; [];</span><br><span class=\"line\">    e.requestAnimationFrame &#x3D; function () &#123;</span><br><span class=\"line\">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123;</span><br><span class=\"line\">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;(), n()</span><br><span class=\"line\">&#125;(window, document);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><p>jsdelivr github 延迟，建议使用<code>https://cdn.jsdelivr.net/gh/</code> Github 用户名/仓库名/资源路径</p>\n<p>有延迟：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvQG1hc3Rlci9qcy9jdXJzb3Iv\">https://cdn.jsdelivr.net/gh/weilining/blog.io@master/js/cursor/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>无延迟：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2pzL2N1cnNvci8=\">https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>无延迟：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvQDEuMC9qcy9jdXJzb3Iv\">https://cdn.jsdelivr.net/gh/weilining/blog.io@1.0/js/cursor/<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"Hxeo 写一篇博客的具体细节","url":"/9.html","content":"<h1 id=\"以我用的Next主题为例\"><a href=\"#以我用的Next主题为例\" class=\"headerlink\" title=\"以我用的Next主题为例\"></a>以我用的Next主题为例</h1><p>一篇博客头写的内容</p>\n<ul>\n<li>toc: true  目录是否生成</li>\n<li>comments: true  评论是否开启</li>\n<li>sticky: 100  数值越大，置顶，相同取第一个写的</li>\n<li>tags: - Next 标签名字</li>\n<li>categories: - Hexo  分类名字</li>\n<li>description: - 描述，一篇博客，不点开，只能看到题目+这个描述  </li>\n<li>date: 2020-10-23 23:04:05  时间</li>\n<li>updated: 2020-10-23 23:04:05    更新时间</li>\n</ul>\n","categories":["Hexo"],"tags":["Next"]},{"title":"2020 Hexo NexT 最简单的深度美化","url":"/1.html","content":"<p>[TOC]</p>\n<h2 id=\"1分钟教程\"><a href=\"#1分钟教程\" class=\"headerlink\" title=\"1分钟教程\"></a>1分钟教程</h2><p>看完1分钟教程，后面初始化用来理解和查缺补漏</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\"></span><br><span class=\"line\">npm i</span><br><span class=\"line\">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>先配置好以下环境</p>\n<ul>\n<li><p>Git</p>\n</li>\n<li><p>Node.js</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"Hexo-amp-amp-NexT安装\"><a href=\"#Hexo-amp-amp-NexT安装\" class=\"headerlink\" title=\"Hexo&amp;&amp;NexT安装\"></a>Hexo&amp;&amp;NexT安装</h3><h4 id=\"正常\"><a href=\"#正常\" class=\"headerlink\" title=\"正常\"></a>正常</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install hexo-theme-next@latest ### https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next</span><br></pre></td></tr></table></figure>\n<h4 id=\"代理快速安装\"><a href=\"#代理快速安装\" class=\"headerlink\" title=\"代理快速安装\"></a>代理快速安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm install hexo-cli@latest -g</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-starter.git blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">git clone --depth 1 https:&#x2F;&#x2F;gitee.com&#x2F;weilining&#x2F;hexo-theme-landscape.git themes&#x2F;landscape</span><br><span class=\"line\">npm i</span><br><span class=\"line\">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p><code>_config.yml</code>的<code>theme: landscape</code>改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地预览\"><a href=\"#本地预览\" class=\"headerlink\" title=\"本地预览\"></a>本地预览</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo cl &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==\">http://localhost:4000<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"生成静态网页文件\"><a href=\"#生成静态网页文件\" class=\"headerlink\" title=\"生成静态网页文件\"></a>生成静态网页文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo cl &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>先准备好以下</p>\n<ul>\n<li><p>GitHub账号</p>\n</li>\n<li><p>创建<code>_config.next.yml</code>(在<code>_config.yml</code>旁边)</p>\n</li>\n</ul>\n<h3 id=\"网页个人信息\"><a href=\"#网页个人信息\" class=\"headerlink\" title=\"网页个人信息\"></a>网页个人信息</h3><p><code>_config.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: Ln&#39;s Blog</span><br><span class=\"line\">subtitle: &#39;有朋自远方来，不亦乐乎&#39;</span><br><span class=\"line\">description: &#39;算法、技术&#39;</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: Lining Wei</span><br><span class=\"line\">language: zh-CN</span><br><span class=\"line\">timezone: &#39;Asia&#x2F;ShangHai</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速配置\"><a href=\"#快速配置\" class=\"headerlink\" title=\"快速配置\"></a>快速配置</h3><p>使用快速配置可以直接跳过进阶，直达高级</p>\n<p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">scheme: Gemini</span><br><span class=\"line\">darkmode: true</span><br><span class=\"line\">creative_commons:</span><br><span class=\"line\">  license: by-nc-sa</span><br><span class=\"line\">  sidebar: false</span><br><span class=\"line\">  post: true #文章底部是否显示</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-bell</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  baidusitemap: &#x2F;baidusitemap.xml || fa fa-cloud</span><br><span class=\"line\">menu_settings:</span><br><span class=\"line\">  icons: true</span><br><span class=\"line\">  badges: true</span><br><span class=\"line\">sidebar:</span><br><span class=\"line\">  position: left</span><br><span class=\"line\">  display: post</span><br><span class=\"line\">  padding: 18</span><br><span class=\"line\">  offset: 12</span><br><span class=\"line\">avatar:</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">  rounded: true   #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆</span><br><span class=\"line\">  rotated: true #设置鼠标移到图片上后头像是否转动</span><br><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blog.io || fab fa-github</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  icons_only: true</span><br><span class=\"line\">  transition: true</span><br><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  number: true</span><br><span class=\"line\">  wrap: true # 如果为true，则如果标题宽度比侧栏宽度长，则所有单词将放在下一行。</span><br><span class=\"line\">footer:</span><br><span class=\"line\">  since: 2015</span><br><span class=\"line\">  icon:</span><br><span class=\"line\">    name: fa fa-heart</span><br><span class=\"line\">    animated: true</span><br><span class=\"line\">    color: &quot;#808080&quot;</span><br><span class=\"line\">  copyright: Ln</span><br><span class=\"line\">  powered: false</span><br><span class=\"line\">post_meta:</span><br><span class=\"line\">  updated_at:</span><br><span class=\"line\">    enable: true # 文章“更新于”显示</span><br><span class=\"line\">post_edit:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blogbackup.io&#x2F;edit&#x2F;main&#x2F;source&#x2F;</span><br><span class=\"line\">mobile_layout_economy: true # 手机文章紧挨着</span><br><span class=\"line\">codeblock:</span><br><span class=\"line\">  theme:</span><br><span class=\"line\">    light: default</span><br><span class=\"line\">    dark: tomorrow-night</span><br><span class=\"line\">  copy_button:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    style: mac</span><br><span class=\"line\">back2top:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  sidebar: false</span><br><span class=\"line\">  scrollpercent: true</span><br><span class=\"line\">github_banner:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  permalink: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blog.io</span><br><span class=\"line\">  title: Fork NexT on GitHub</span><br><span class=\"line\">math:</span><br><span class=\"line\">  mathjax:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">pjax: true</span><br><span class=\"line\">mediumzoom: true</span><br><span class=\"line\">livere_uid: MTAyMC80NDkyOC8yMTQ1MA&#x3D;&#x3D;</span><br><span class=\"line\">google_analytics:</span><br><span class=\"line\">  tracking_id: UA-108155018-3</span><br><span class=\"line\">note:</span><br><span class=\"line\">  style: simple</span><br><span class=\"line\">  icons: true</span><br><span class=\"line\">  light_bg_offset: -3</span><br><span class=\"line\">tabs:</span><br><span class=\"line\">  transition:</span><br><span class=\"line\">    tabs: true</span><br><span class=\"line\">    labels: true</span><br><span class=\"line\">mermaid:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">motion:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  async: true</span><br><span class=\"line\">vendors:</span><br><span class=\"line\">  internal: jsdelivr</span><br><span class=\"line\">quicklink:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  home: true</span><br><span class=\"line\">  archive: true</span><br><span class=\"line\">  delay: true</span><br><span class=\"line\">  timeout: 3000</span><br><span class=\"line\">  priority: true</span><br><span class=\"line\">  ignores:</span><br><span class=\"line\">nprogress:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  spinner: true</span><br><span class=\"line\">tag_icon: true</span><br><span class=\"line\">favicon:</span><br><span class=\"line\">  small: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;favicon-16x16-next.png</span><br><span class=\"line\">  medium: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;favicon-32x32-next.png</span><br><span class=\"line\">  apple_touch_icon: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">  safari_pinned_tab: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">reward_settings:</span><br><span class=\"line\">  enable: true </span><br><span class=\"line\">  animation: true</span><br><span class=\"line\">  comment: Buy me a coffee #这里填你的提示语</span><br><span class=\"line\">reward:</span><br><span class=\"line\">  wechatpay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">  alipay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">canvas_ribbon:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  size: 300 # The width of the ribbon</span><br><span class=\"line\">  alpha: 0.6 # The transparency of the ribbon</span><br><span class=\"line\">  zIndex: -1 # The display level of the ribbon</span><br><span class=\"line\">links_settings:</span><br><span class=\"line\">  icon: fa fa-globe</span><br><span class=\"line\">  title: 友情链接</span><br><span class=\"line\">  # Available values: block | inline</span><br><span class=\"line\">  layout: inline</span><br><span class=\"line\">links:</span><br><span class=\"line\">  Ln: https:&#x2F;&#x2F;weilining.github.io</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true</span><br><span class=\"line\">  total_visitors_icon: fa fa-user</span><br><span class=\"line\">  total_views: true</span><br><span class=\"line\">  total_views_icon: fa fa-eye</span><br><span class=\"line\">  post_views: true</span><br><span class=\"line\">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"换Gemini主题\"><a href=\"#换Gemini主题\" class=\"headerlink\" title=\"换Gemini主题\"></a>换Gemini主题</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"暗黑模式\"><a href=\"#暗黑模式\" class=\"headerlink\" title=\"暗黑模式\"></a>暗黑模式</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">darkmode: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打赏\"><a href=\"#打赏\" class=\"headerlink\" title=\"打赏\"></a>打赏</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reward_settings:</span><br><span class=\"line\">  enable: true </span><br><span class=\"line\">  animation: true</span><br><span class=\"line\">  comment: Buy me a coffee #这里填你的提示语</span><br><span class=\"line\">reward:</span><br><span class=\"line\">  wechatpay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class=\"line\">  alipay: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io@master&#x2F;images&#x2F;apple-touch-icon-next.png</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打开jsdelivr加速\"><a href=\"#打开jsdelivr加速\" class=\"headerlink\" title=\"打开jsdelivr加速\"></a>打开jsdelivr加速</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vendors:</span><br><span class=\"line\">  internal: jsdelivr</span><br><span class=\"line\">  plugins: jsdelivr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打开动画异步加载\"><a href=\"#打开动画异步加载\" class=\"headerlink\" title=\"打开动画异步加载\"></a>打开动画异步加载</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">motion:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  async: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码mac风格-amp-amp-粘贴按钮\"><a href=\"#代码mac风格-amp-amp-粘贴按钮\" class=\"headerlink\" title=\"代码mac风格&amp;&amp;粘贴按钮\"></a>代码mac风格&amp;&amp;粘贴按钮</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">codeblock:</span><br><span class=\"line\">  copy_button:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    style: mac</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阅读百分比显示\"><a href=\"#阅读百分比显示\" class=\"headerlink\" title=\"阅读百分比显示\"></a>阅读百分比显示</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">back2top:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  scrollpercent: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进度条\"><a href=\"#进度条\" class=\"headerlink\" title=\"进度条\"></a>进度条</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nprogress:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  spinner: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">creative_commons:</span><br><span class=\"line\">  license: by-nc-sa</span><br><span class=\"line\">  sidebar: false</span><br><span class=\"line\">  post: true #文章底部是否显示</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"菜单栏\"><a href=\"#菜单栏\" class=\"headerlink\" title=\"菜单栏\"></a>菜单栏</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-bell</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  baidusitemap: &#x2F;baidusitemap.xml || fa fa-cloud</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"菜单栏设置\"><a href=\"#菜单栏设置\" class=\"headerlink\" title=\"菜单栏设置\"></a>菜单栏设置</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu_settings:</span><br><span class=\"line\">  icons: true</span><br><span class=\"line\">  badges: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"侧边栏设置\"><a href=\"#侧边栏设置\" class=\"headerlink\" title=\"侧边栏设置\"></a>侧边栏设置</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sidebar:</span><br><span class=\"line\">  position: left</span><br><span class=\"line\">  display: post</span><br><span class=\"line\">  padding: 18</span><br><span class=\"line\">  offset: 12</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"头像设置\"><a href=\"#头像设置\" class=\"headerlink\" title=\"头像设置\"></a>头像设置</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  # url: &#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br><span class=\"line\">  rounded: true   #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆</span><br><span class=\"line\">  rotated: true #设置鼠标移到图片上后头像是否转动</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;blog.io || fab fa-github</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  icons_only: true</span><br><span class=\"line\">  transition: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  number: true</span><br><span class=\"line\">  wrap: true # 如果为true，则如果标题宽度比侧栏宽度长，则所有单词将放在下一行。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"底部设置\"><a href=\"#底部设置\" class=\"headerlink\" title=\"底部设置\"></a>底部设置</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">footer:</span><br><span class=\"line\">  since: 2015</span><br><span class=\"line\">  icon:</span><br><span class=\"line\">    name: fa fa-heart</span><br><span class=\"line\">    animated: true</span><br><span class=\"line\">    color: &quot;#808080&quot;</span><br><span class=\"line\">  copyright: Ln</span><br><span class=\"line\">  powered: false</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h3><h4 id=\"GitHub创建仓库并打开GitHub-Pages功能\"><a href=\"#GitHub创建仓库并打开GitHub-Pages功能\" class=\"headerlink\" title=\"GitHub创建仓库并打开GitHub Pages功能\"></a>GitHub创建仓库并打开GitHub Pages功能</h4><p>仓库名：Github 用户名.github.io</p>\n<p>例如：weilining.github.io</p>\n<p>验证仓库是否创建成功：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy93ZWlsaW5pbmcuZ2l0aHViLmlv\">https://github.com/weilining/weilining.github.io<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>PS:记得打开GitHub Pages</p>\n<p><code>setting-&gt;GitHub Pages</code></p>\n<h4 id=\"URL设置\"><a href=\"#URL设置\" class=\"headerlink\" title=\"URL设置\"></a>URL设置</h4><p><code>_config.yml</code>的<code>url: http://example.com</code>改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: https:&#x2F;&#x2F;weilining.github.io</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: git</span><br><span class=\"line\">    repo:</span><br><span class=\"line\">      github:</span><br><span class=\"line\">        url: https:&#x2F;&#x2F;github.com&#x2F;weilining&#x2F;weilining.github.io.git # https:&#x2F;&#x2F;github.com&#x2F;Github 用户名&#x2F;仓库名&#x2F;资源路径</span><br><span class=\"line\">        branch: master</span><br><span class=\"line\">        token: f7e4ee8c4b57d3fab8c0680e192c11111fa844f6 # GitHub Personal Access Token </span><br><span class=\"line\">    name: weilining # Github 用户名</span><br><span class=\"line\">    email: email@gmail.com # Github 登陆邮箱</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuY2YvMy5odG1s\">获取 GitHub Personal Access Token 方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"GitHub-Pages预览\"><a href=\"#GitHub-Pages预览\" class=\"headerlink\" title=\"GitHub Pages预览\"></a>GitHub Pages预览</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuZ2l0aHViLmlvLw==\">https://weilining.github.io<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"高级\"><a href=\"#高级\" class=\"headerlink\" title=\"高级\"></a>高级</h2><p>先准备好以下</p>\n<ul>\n<li>创建<code>blog/source/_data/styles.styl</code></li>\n</ul>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1nZW5lcmF0b3Itc2VhcmNoZGI=\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: all</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.next.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  trigger: auto</span><br><span class=\"line\">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.next.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  RSS: &#x2F;atom.xml || fa fa-rss</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"宠物\"><a href=\"#宠物\" class=\"headerlink\" title=\"宠物\"></a>宠物</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJkL2Jsb2IvbWFzdGVyL1JFQURNRS56aC1DTi5tZA==\">官方<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3hpYXpleXUvbGl2ZTJkLXdpZGdldC1tb2RlbHM=\">模型<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"模块安装\"><a href=\"#模块安装\" class=\"headerlink\" title=\"模块安装\"></a>模块安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-helper-live2d</span><br><span class=\"line\">npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">live2d:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  scriptFrom: local</span><br><span class=\"line\">  pluginRootPath: live2dw&#x2F;</span><br><span class=\"line\">  pluginJsPath: lib&#x2F;</span><br><span class=\"line\">  pluginModelPath: assets&#x2F;</span><br><span class=\"line\">  tagMode: false</span><br><span class=\"line\">  log: false</span><br><span class=\"line\">  model:</span><br><span class=\"line\">    use: live2d-widget-model-wanko</span><br><span class=\"line\">  display:</span><br><span class=\"line\">    position: right</span><br><span class=\"line\">    width: 150</span><br><span class=\"line\">    height: 300</span><br><span class=\"line\">  mobile:</span><br><span class=\"line\">    show: true</span><br><span class=\"line\">  react:</span><br><span class=\"line\">    opacity: 0.7</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"背景透明\"><a href=\"#背景透明\" class=\"headerlink\" title=\"背景透明\"></a>背景透明</h3><p><code>blog/source/_data/styles.styl</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 背景透明</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">  opacity: 0.9;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加背景\"><a href=\"#加背景\" class=\"headerlink\" title=\"加背景\"></a>加背景</h3><p><code>blog/source/_data/styles.styl</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;背景</span><br><span class=\"line\">body&#123;</span><br><span class=\"line\">  background:url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;background-dark.jpg&#39;);</span><br><span class=\"line\">  height:100%;</span><br><span class=\"line\">  width:100%;</span><br><span class=\"line\">  background-repeat:repeat-x;</span><br><span class=\"line\">  background-attachment:fixed;</span><br><span class=\"line\">  background-size:cover;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h3><p><code>_config.yml</code> 的<code>post_asset_folder: true</code>改成下面的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">### https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;asset-folders</span><br><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"顶级\"><a href=\"#顶级\" class=\"headerlink\" title=\"顶级\"></a>顶级</h2><h3 id=\"百度SEO\"><a href=\"#百度SEO\" class=\"headerlink\" title=\"百度SEO\"></a>百度SEO</h3><h4 id=\"安装站点地图模块\"><a href=\"#安装站点地图模块\" class=\"headerlink\" title=\"安装站点地图模块\"></a>安装站点地图模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-4\"><a href=\"#配置-4\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code>后面加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">baidusitemap:</span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo s</code></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwL2JhaWR1c2l0ZW1hcC54bWw=\">http://localhost:4000/baidusitemap.xml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"安装主动推送模块\"><a href=\"#安装主动推送模块\" class=\"headerlink\" title=\"安装主动推送模块\"></a>安装主动推送模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-submit-urls-to-search-engine</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-5\"><a href=\"#配置-5\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL3NpdGUvaW5kZXgjIyMv\">百度站点管理<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>普通收录-&gt;资源提交-&gt;API提交-&gt;推送接口里有token</p>\n<p><code>_config.yml</code>后面加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo_submit_urls_to_search_engine:</span><br><span class=\"line\">  submit_condition: count ###链接被提交的条件，可选值：count | period 现仅支持count</span><br><span class=\"line\">  count: 10 ### 提交最新的10个链接</span><br><span class=\"line\">  period: 900 ### 提交修改时间在 900 秒内的链接</span><br><span class=\"line\">  google: 0 ### 是否向Google提交，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  bing: 1 ### 是否向bing提交，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  baidu: 1 ### 是否向baidu提交，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  txt_path: submit_urls.txt #### 文本文档名， 需要推送的链接会保存在此文本文档里</span><br><span class=\"line\">  baidu_host: https:&#x2F;&#x2F;cjh0613.github.io #### 在百度站长平台中注册的域名</span><br><span class=\"line\">  baidu_token: 请按照文档说明获取 #### 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span><br><span class=\"line\">  bing_host: https:&#x2F;&#x2F;cjh0613.github.io #### 在bing站长平台中注册的域名</span><br><span class=\"line\">  bing_token: 请按照文档说明获取 #### 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span><br><span class=\"line\">  google_host: https:&#x2F;&#x2F;cjh0613.github.io #### 在google站长平台中注册的域名</span><br><span class=\"line\">  google_key_file: Project.json ###存放google key的json文件，放于网站根目录（与hexo _config.yml文件位置相同），请不要把json文件内容直接发布在公众仓库里!</span><br><span class=\"line\">  replace: 0  ### 是否替换链接中的部分字符串，可选值：1 | 0（0：否；1：是）</span><br><span class=\"line\">  find_what: http:&#x2F;&#x2F;cjh0613.github.io&#x2F;blog</span><br><span class=\"line\">  replace_with: https:&#x2F;&#x2F;cjh0613.com</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.yml</code>的<code>deploy:</code>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  - type: &#39;&#39;</span><br><span class=\"line\">  - type: baidu_url_submitter ### 主动提交百度爬虫</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.yml</code>的<code>url: http://example.com</code>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: https:&#x2F;&#x2F;weilining.cf</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo d</code>最后出现<code>&#123;&quot;remain&quot;:2996,&quot;success&quot;:2&#125;</code>即可</p>\n<h4 id=\"缩短url\"><a href=\"#缩短url\" class=\"headerlink\" title=\"缩短url\"></a>缩短url</h4><p><code>_config.yml</code>的<code>permalink: :year/:month/:day/:title/</code>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">permalink: :title.html</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NexT防止外链搜索及SEO设置\"><a href=\"#NexT防止外链搜索及SEO设置\" class=\"headerlink\" title=\"NexT防止外链搜索及SEO设置\"></a>NexT防止外链搜索及SEO设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd blog</span><br><span class=\"line\">vi _config.next.yml</span><br></pre></td></tr></table></figure>\n\n<p><code>_config.next.yml</code>写入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">disable_baidu_transformation: true ### 禁用移动设备上的百度转换，建议 true</span><br><span class=\"line\">index_with_subtitle: true ### 带副标题的索引,开启后会在标签标题后面自动加上网站名称，建议 true</span><br><span class=\"line\">### nofollow防止外链搜索</span><br><span class=\"line\">exturl: true ### 使用Base64加密和解密自动添加外部URL。</span><br><span class=\"line\">baidu_site_verification: code-wFDrn4lvkD</span><br><span class=\"line\">baidu_push: true ###建议 true ###启用百度推送，这样博客会自动把网址推到百度，这对SEO很有帮助。</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo s</code></p>\n<h4 id=\"quicklink加载性能优化\"><a href=\"#quicklink加载性能优化\" class=\"headerlink\" title=\"quicklink加载性能优化\"></a>quicklink加载性能优化</h4><p><code>_config.next.yml</code>加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">quicklink:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  home: true</span><br><span class=\"line\">  archive: true</span><br><span class=\"line\">  delay: true</span><br><span class=\"line\">  timeout: 3000</span><br><span class=\"line\">  priority: true</span><br><span class=\"line\">  ignores:</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"robots-txt\"><a href=\"#robots-txt\" class=\"headerlink\" title=\"robots.txt\"></a>robots.txt</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd blog</span><br><span class=\"line\">vi source&#x2F;robots.txt</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">User-agent: *</span><br><span class=\"line\">Allow: &#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">Sitemap: https:&#x2F;&#x2F;weilining.cf&#x2F;sitemap.xml</span><br><span class=\"line\">Sitemap: https:&#x2F;&#x2F;weilining.cf&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3Rvb2xzL3JvYm90cy10ZXN0aW5nLXRvb2w/dXRtX3NvdXJjZT1zdXBwb3J0Lmdvb2dsZS5jb20vd2VibWFzdGVycy8mdXRtX21lZGl1bT1yZWZlcnJhbCZ1dG1fY2FtcGFpZ249NjA2MjU5OA==\">打开“robots.txt 测试工具”<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"谷歌SEO\"><a href=\"#谷歌SEO\" class=\"headerlink\" title=\"谷歌SEO\"></a>谷歌SEO</h3><h4 id=\"安装站点地图模块-1\"><a href=\"#安装站点地图模块-1\" class=\"headerlink\" title=\"安装站点地图模块\"></a>安装站点地图模块</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-6\"><a href=\"#配置-6\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p><code>_config.yml</code>后面加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p><code>hexo cl &amp;&amp; hexo s</code></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwL3NpdGVtYXAueG1s\">http://localhost:4000/sitemap.xml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><code>_config.next.yml</code>加上以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">google_site_verification: KZjcRcBkV43JHcyiH4z1Yk2xu-mqlS1fQNk5Dzv7_q0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到服务器\"><a href=\"#部署到服务器\" class=\"headerlink\" title=\"部署到服务器\"></a>部署到服务器</h3><p><code>blog/public</code>下所有文件复制到nginx的web服务器根目录</p>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXNoLmNsb3VkZmxhcmUuY29tLw==\">cloudflare<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>建议：要开启CDN，先删除其他A/AAAA，只留一条。关闭CDN之后再加多条A/AAAA。</p>\n<h3 id=\"MarkDown书写\"><a href=\"#MarkDown书写\" class=\"headerlink\" title=\"MarkDown书写\"></a>MarkDown书写</h3><p>二级标题后紧跟的子标题级别必须是三级标题。<br>一个页面一个H1标签，以二级标题为起点，二级标题不要太多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">## 标题</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加一言\"><a href=\"#添加一言\" class=\"headerlink\" title=\"添加一言\"></a>添加一言</h3><p><code>blog/source/_data/sidebar.njk</code></p>\n<p>将下面这段代码放入页面内需要展示一句话的位置即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;# 一言 #&#125;</span><br><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;api.uixsj.cn&#x2F;hitokoto&#x2F;w.php?code&#x3D;js&quot;&gt;&lt;&#x2F;script&gt;&lt;div id&#x3D;&quot;xsjhitokoto&quot;&gt;&lt;script&gt;xsjhitokoto()&lt;&#x2F;script&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>中英文版 使用方法同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;api.uixsj.cn&#x2F;hitokoto&#x2F;en.php?code&#x3D;js&quot;&gt;&lt;&#x2F;script&gt;&lt;div id&#x3D;&quot;enhitokoto&quot;&gt;&lt;script&gt;enhitokoto()&lt;&#x2F;script&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"网页Get测试\"><a href=\"#网页Get测试\" class=\"headerlink\" title=\"网页Get测试\"></a>网页Get测试</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuMTdjZS5jb20v\">https://www.17ce.com/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"页面加载性能测试\"><a href=\"#页面加载性能测试\" class=\"headerlink\" title=\"页面加载性能测试\"></a>页面加载性能测试</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==\">Google PageSpeed Insights<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=\">NexT<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWlsaW5pbmcuY2Yv\">Ln&#39;s Blog<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"各平台收录查询\"><a href=\"#各平台收录查询\" class=\"headerlink\" title=\"各平台收录查询\"></a>各平台收录查询</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9c2l0ZTp3ZWlsaW5pbmcuY2Y=\">百度收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5iaW5nLmNvbS9zZWFyY2g/cT1zaXRlOndlaWxpbmluZy5jZg==\">必应收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT1zaXRlOndlaWxpbmluZy5jZg==\">谷歌收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc28uY29tL3M/cT1zaXRlOndlaWxpbmluZy5jZg==\">360收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly95YW5kZXguY29tL3NlYXJjaC8/dGV4dD1zaXRlOndlaWxpbmluZy5jZg==\">yandex收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc29nb3UuY29tL3dlYj9xdWVyeT1zaXRlOndlaWxpbmluZy5jZg==\">搜狗收录weilining.cf查询<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"各平台-Robots-txt-测试工具\"><a href=\"#各平台-Robots-txt-测试工具\" class=\"headerlink\" title=\"各平台 Robots.txt 测试工具\"></a>各平台 Robots.txt 测试工具</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL3JvYm90cw==\">百度<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmluZy5jb20vd2VibWFzdGVycy9yb2JvdHN0eHR0ZXN0ZXI=\">必应<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3Rvb2xzL3JvYm90cy10ZXN0aW5nLXRvb2w=\">谷歌<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJtYXN0ZXIueWFuZGV4LnJ1L3NpdGUvaHR0cHM6d2VpbGluaW5nLmNmOjQ0My90b29scy9yb2JvdHN0eHQv\">Yandex<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"各平台管理\"><a href=\"#各平台管理\" class=\"headerlink\" title=\"各平台管理\"></a>各平台管理</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmluZy5jb20vd2VibWFzdGVycy9ob21lP3NpdGVVcmw9aHR0cHM6Ly93ZWlsaW5pbmcuY2Yv\">必应<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL2Rhc2hib2FyZC9pbmRleD9zaXRlPWh0dHBzOi8vd2VpbGluaW5nLmNmLw==\">百度<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJtYXN0ZXIueWFuZGV4LnJ1L3NpdGUvaHR0cHM6d2VpbGluaW5nLmNm\">Yandex<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJz\">谷歌<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><table>\n<thead>\n<tr>\n<th>插件名</th>\n<th>版本号</th>\n<th>官方文档</th>\n<th>功能</th>\n<th>NexT集成</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hexo-related-popular-posts</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-related-popular-posts?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RlYTMvaGV4by1yZWxhdGVkLXBvcHVsYXItcG9zdHM=\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></td>\n<td>相关文章</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-generator-baidu-sitemap</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-baidu-sitemap?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>百度站点地图</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-generator-sitemap</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-sitemap?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>谷歌站点地图</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-deployer-git</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-deployer-git?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>部署</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-generator-searchdb</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-searchdb?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>本地搜索</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-generator-feed</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-generator-feed?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>RSS</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-submit-urls-to-search-engine</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-submit-urls-to-search-engine?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>百度主动推送</td>\n<td>否</td>\n</tr>\n<tr>\n<td>hexo-word-counter</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-word-counter?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>文字数</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-theme-next</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-theme-next?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td></td>\n<td>NexT主题</td>\n<td>是</td>\n</tr>\n<tr>\n<td>hexo-helper-live2d</td>\n<td><img data-src=\"https://img.shields.io/npm/v/hexo-helper-live2d?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJkL2Jsb2IvbWFzdGVyL1JFQURNRS56aC1DTi5tZA==\">GitHub<i class=\"fa fa-external-link-alt\"></i></span></td>\n<td>宠物</td>\n<td>否</td>\n</tr>\n<tr>\n<td>live2d-widget-model-wanko</td>\n<td><img data-src=\"https://img.shields.io/npm/v/live2d-widget-model-wanko?color=red&logo=npm&style=flat-square\" alt=\"npm\" loading=\"lazy\"></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3hpYXpleXUvbGl2ZTJkLXdpZGdldC1tb2RlbHM=\">模型<i class=\"fa fa-external-link-alt\"></i></span></td>\n<td>宠物模型</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vd2VpbGluaW5nL2hleG8tc3RhcnRlci9ibG9iL21hc3Rlci9fY29uZmlnLnltbA==\">https://gitee.com/weilining/hexo-starter/blob/master/_config.yml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2NzL2Jsb2IvbWFzdGVyL19jb25maWcubmV4dC55bWw=\">theme-next-docs/_config.next.yml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2NzL2Jsb2IvbWFzdGVyL19jb25maWcueW1s\">theme-next-docs/_config.yml<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvdGhlbWUtbmV4dC1kb2Nz\">theme-next-docs<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2Nz\">NexT docs<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhv\">Hexo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYW9ndWFpL3AvMTEyMzkxODIuaHRtbA==\">2019Hexo博客Next主题深度美化 打造一个炫酷博客(2)-奥怪的小栈<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmJpbGwubW9lL2hleG8tdGhlbWUtbmV4dC1jb25maWctb3B0aW1pemF0aW9uLw==\">https://blog.bill.moe/hexo-theme-next-config-optimization/<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["Hexo"],"tags":["Next"]},{"title":"第一天线下笔试","url":"/2020-10-19-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8B%E9%9D%A2%E8%AF%95.html","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><p>今天第一次参加了线下的Java开发面试，和想象的有点不一样；参加面试的公司是海能达公司，去的是江北的分公司参加的面试，整个过程只有3轮面试，但我的第一次只献给了一面，还没见到二面，有点惨哦。</p>\n<p>第一眼见到面试官，感觉很和蔼，他让我坐下并低头看着简历，他：先来个自我介绍，我：巴拉巴拉，期间他笑了一下，也许他感觉我太紧张，笑话我? 然后他就看着我的简历，他：你做过两个项目，我: 嗯 ！他：那就先说说你的项目，你的第一个项目是网上书店系统ssm，</p>\n<h3 id=\"项目1\"><a href=\"#项目1\" class=\"headerlink\" title=\"项目1\"></a>项目1</h3><h4 id=\"1-他：问的问题：\"><a href=\"#1-他：问的问题：\" class=\"headerlink\" title=\"1.他：问的问题：\"></a>1.他：问的问题：</h4><h5 id=\"①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；\"><a href=\"#①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；\" class=\"headerlink\" title=\"①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；\"></a>①<strong>那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；</strong></h5><h5 id=\"②你前端发送的一个请求是怎么找到相应的Controller的\"><a href=\"#②你前端发送的一个请求是怎么找到相应的Controller的\" class=\"headerlink\" title=\"②你前端发送的一个请求是怎么找到相应的Controller的\"></a>②<strong>你前端发送的一个请求是怎么找到相应的Controller的</strong></h5><h5 id=\"③你的Spring-mvc是怎么工作的，工作原理\"><a href=\"#③你的Spring-mvc是怎么工作的，工作原理\" class=\"headerlink\" title=\"③你的Spring mvc是怎么工作的，工作原理\"></a>③<strong>你的Spring mvc是怎么工作的，工作原理</strong></h5><h5 id=\"④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况\"><a href=\"#④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况\" class=\"headerlink\" title=\"④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况\"></a>④<strong>你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况</strong></h5><h5 id=\"⑤mybatis的一个知识-我忘\"><a href=\"#⑤mybatis的一个知识-我忘\" class=\"headerlink\" title=\"⑤mybatis的一个知识 我忘...\"></a>⑤mybatis的一个知识 我忘...</h5><h5 id=\"⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里\"><a href=\"#⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里\" class=\"headerlink\" title=\"⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里\"></a>⑥<strong>你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里</strong></h5><h5 id=\"⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录-并追问怎么实现（表的字段等）；\"><a href=\"#⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录-并追问怎么实现（表的字段等）；\" class=\"headerlink\" title=\"⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录 并追问怎么实现（表的字段等）；\"></a>⑦<strong>你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录 并追问怎么实现（表的字段等）；</strong></h5><p>他：行，项目先问到着，问问你基础；我：嗯嗯，问了==和equal、hashcode和equals、public protected default private、线程的实现几种方式和区别、你理解的多态、有几种线程池并解释、说出几种NIO的实现类；</p>\n<p>然后他又看简历，说：说说maven是做什么的，并说几条maven常见命令；你用过redis吗，在哪了用的，说说redis是干什么（具体用与什么场景）；他：那我再问问你下一个项目，你的自行车报名系统是干什么的、管理员都干了些什么；</p>\n<p>最后帮我总结了一下，说我刚开始的框架知识给他的印象很差，但后来的基础知识答得很好，可以用自己得理解来答，希望你能好好看自己得框架部分，注意细节。---end---</p>\n<h3 id=\"解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜\"><a href=\"#解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜\" class=\"headerlink\" title=\"解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜...\"></a>解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜...</h3><h5 id=\"①\"><a href=\"#①\" class=\"headerlink\" title=\"①\"></a><strong>①</strong></h5><p><strong>首先我用工具建立了一个web工程、导入ssm框架得jar包、配置对应得xml文件、写demo测试，没问题了就可以开发了。</strong></p>\n<p>细节：</p>\n<p>（对应得xml文件主要有applicationContext.xml、spring-mvc.xml、mybatis-config.xml、web.xml文件；</p>\n<p>applicationContext.xml文件主要是：</p>\n<p>a、配置注解扫描范围</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.haina.ssmbicycle.service&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>b、引用数据库配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>c、配置数据源（</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;pooledDateSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;jdbcUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClass&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;user&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>d、配置MyBatis的SqlSessionFactory，他是单个数据库映射关系经过编译后的内存镜像</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactory&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;configLocation&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><span class=\"comment\">&lt;!-- 配置mybatis全局配置文件 --&gt;</span> </span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;pooledDateSource&quot;</span>/&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span><span class=\"comment\">&lt;!-- 兼容xml方式 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>e、配置Dao所在包 Mybatis会动态创建实现类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span></span></span><br><span class=\"line\">    &lt;property name=&quot;basePackage&quot; value=&quot;com.haina.ssmbicycle.dao&quot;/&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>mybatis-config.xml文件主要是：</p>\n<p>a、开启驼峰命名转换、打印sql语句                </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 开启驼峰命名转换 user_id ==&gt; userId --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapUnderscoreToCamelCase&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    \t<span class=\"comment\">&lt;!-- 驼峰规则：一般数据库表类似tb_user,里面字段都为uesr_id、uese_name等，而对应的实体类都为userId、userName --&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 打印sql语句 STDOUT_LOGGING为标准日志输出 --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>springmvc.xml文件主要是：</p>\n<p>a、配置注解扫描范围</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.haina.ssmbicycle.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>b、配置拦截器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;prefix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;suffix&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>c、配置多媒体文件解析器，用于文件上传）</p>\n<p>web.xml文件：(在web/WEB-INF/web.xml)</p>\n<p>（默认欢迎页面的配置、字符编码过滤器的配置、前端控制器、以及指定spring核心配置文件和SpringMVC的配置文件，DispatcherServlet是前端控制器;</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 默认主页 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">welcome-file-list</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>index.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">welcome-file-list</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 指定spring配置文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置spring监听器 :可以在web容器启动的时候自动初始化spring容器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 调用Spring的编码过滤器 ：</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSpring中的字符集过滤器可以很方便的为我们解决项目中出现的中文乱码问题，而且使用方法也很简单，只需要在web.xml文件中配置一下该过滤器，设置两个重要的参数（encoding和forceEncoding）即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>myencoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 编码过滤器映射路径 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>myencoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在这里再解释一下@Controller：标名它是一个控制器，被Spring容器所管理，这个注解是在@Component后面出的，为了表示代码的分层，于是就有了@Controller、@Service、@Mapper这三个注解，他们的作用是一样的。</p>\n<p>@RequestMapping：表示接受的请求，还是GetMapping、PostMapping等注解表示请求方法的不同。</p>\n<p>@Autowired：表示自动注入，前提就是被注入的对象被Spring容器所管理。</p>\n<p>ModelAndView：这个前面说过，它装的就是数据和逻辑视图名。）</p>\n<h5 id=\"②\"><a href=\"#②\" class=\"headerlink\" title=\"②\"></a><strong>②</strong></h5><p><strong>前端jsp页面进行action请求到对应的servlet(springmvc)去处理，如果想要springmvc去处理，而不是普通的servlet，需要去web.xml文件去配置dispatcherServlet</strong></p>\n<pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n/：一切请求，注意不是/ *\n/ user：拦截以/ user开始的请求\n/user/abc.do：只拦截该请求\n.action：只拦截.action最后的请求</code></pre>\n<p>）然后通过映射是去匹配@RequestMapping注解，找到相应的controller；如果面试官还问怎么扫描到你的@RequestMapping注解，是在springmvc-config.xml文件中配置扫描controller包；</p>\n<p><strong>Jsp被访问时，执行的过程（使用Servlet）:</strong></p>\n<ul>\n<li>客户端-&gt;发起请求-&gt;服务器接收请求-&gt;Jsp本身-&gt;翻译-&gt;编译-&gt;执行</li>\n</ul>\n<p><strong>服务器是如何查找处理请求用的Servlet的呢？</strong></p>\n<ul>\n<li> 客户端-&gt;发出请求-&gt;服务器接收请求-&gt;web.xml-&gt;寻找与请求匹配的<url-pattern>-&gt;当前<servlet-mapping>中的同级<servlet-name>的值-&gt;利用该值寻找;与该<servlet-mapping>配对的<servlet>的<servlet-name>的值-&gt;获取<servlet-class>中的完整类路径</li>\n</ul>\n<h5 id=\"③\"><a href=\"#③\" class=\"headerlink\" title=\"③\"></a>③</h5><p>a.客户端（浏览器）发送请求，直接请求到DispatcherServlet（前端控制器）。</p>\n<p>b.DispatcherServlet根据请求信息调用HandlerMapping(HandlerMapping,充当着url和Controller之间映射关系配置的角色;HandlerMapping是接口，Spring MVC提供了一系列HandlerMapping的实现，根据一定的规则选择controller。如果当前的HandlerMappign实现中没有能够满足你所需要的规则是，可以通过实现HandlerMapping接口进行扩展。它主要有三部分组成：HandlerMapping映射注册、根据url获取对应的处理器、拦截器注册。),解析请求对应的Handler。</p>\n<p>c.解析到对应的Handler(也就是我们常说的Controller控制器)后，开始由HandlerAdapter适配器处理。</p>\n<p>d.HandlerAdapter适配器会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。</p>\n<p>e.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View</p>\n<p>f.ViewResolver（视图解析器）会根据逻辑上的View查找实际的View</p>\n<p>g.DispatcherServlt把返回的Model数据对象传给View（进行视图渲染）</p>\n<p>h.把View返回给请求者（浏览器）</p>\n<h5 id=\"④\"><a href=\"#④\" class=\"headerlink\" title=\"④\"></a>④</h5><p>首先用户想要买书，必须先要把书加入到购物车，在购物车里点击提交订单时会验证你数据库中图书的库存，如果购买图书大于库存数量，会提示购买图书的名字库存不足，并告诉库存有多少图书。</p>\n<h5 id=\"⑤\"><a href=\"#⑤\" class=\"headerlink\" title=\"⑤\"></a>⑤</h5><h5 id=\"⑥\"><a href=\"#⑥\" class=\"headerlink\" title=\"⑥\"></a>⑥</h5><p><strong>Mybatis中接口和对应的mapper文件不一定要放在同一个包下，放在一起的目的是为了Mybatis进行自动扫描，并且要注意此时java接口的名称和mapper文件的名称要相同（mybatis会根据Mapper.xml中配置的信息创建一个实现了Maper.java接口的代理类(使用JDK动态代理)），否则会报异常，由于此时Mybatis会自动解析对应的接口和相应的配置文件，所以就不需要配置mapper文件的位置了。如果接口和mapper文件不在同一个包下，就不能进行自动扫描解析了，需要对接口和文件分别进行配置；使用Spring来配置</strong></p>\n<pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;!-- 配置mybatis全局配置文件 --&gt; \n           &lt;property name=&quot;dataSource&quot; ref=&quot;pooledDateSource&quot;/&gt;\n    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;!-- 兼容xml方式 --&gt;\n&lt;/bean&gt;</code></pre>\n<p>如果在工程中使用了maven构建工具，那么就会出现一个问题：我们知道在典型的maven工程中，目录结构有：src/main/java和src/main/resources，前者是用来存放java源代码的，后者则是存放一些资源文件，比如配置文件等，在默认的情况下maven打包的时候，对于src/main/java目录只打包源代码，而不会打包其他文件。所以此时如果把对应的mapper文件放到src/main/java目录下时，不会打包到最终的jar文件夹中，也不会输出到target文件夹中，由于在进行单元测试的时候执行的是/target目录下/test-classes下的代码，所以在测试的时候也不会成功。</p>\n<h5 id=\"⑦\"><a href=\"#⑦\" class=\"headerlink\" title=\"⑦\"></a>⑦</h5><p>一个人同时买多本书在数据库中订单表只产生一条记录，而记录表中产生多条记录；这个订单信息主要有订单id、总价、商品详情（书名 价格 数量）、收货信息（收货人、电话、收获地址）、订单状态（已付款、未付款、已完成）、支付方式（微信、支付宝、货到付款）、下单时间、操作；对应的数据库中有两个表，一个是<strong>记录表</strong>，主要是记录每一本书的价格、数量、订单id、图书id；另一个是<strong>订单表</strong>，主要记录记录订单id、总价、订单状态（已付款、未付款、已完成）、支付方式（微信、支付宝、货到付款）、收货人、电话、收货地址、下单时间、user_id。那么前端具体怎么实现的呢，是通过&lt;c:forEach var=&quot;order&quot; items=&quot;${orderList}&quot;&gt;jstl标签把后端循环遍历来的数据放到orderList，通过model.addAttribute(&quot;orderList&quot;, orderList)传到前端，然后每次取到的数据存放到val变量中，然后在前端jsp页面上写好死的显示页面，如果有单条记录有多个信息的，比如说是一个人的订单中的多本书的信息，可以用jstl表达式往出拿信息。</p>\n<h3 id=\"基础：\"><a href=\"#基础：\" class=\"headerlink\" title=\"基础：\"></a>基础：</h3><h4 id=\"1-与-equals-重要\"><a href=\"#1-与-equals-重要\" class=\"headerlink\" title=\"1.== 与 equals(重要)\"></a>1.<strong>== 与 equals(重要)</strong></h4><p>==:<br>   它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型⽐较的是值，引⽤数据类型⽐较的是内存地址)。</p>\n<p>equals() :<br>   它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“==”⽐较这两个对象。情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>\n<h4 id=\"2-hashcode和equals\"><a href=\"#2-hashcode和equals\" class=\"headerlink\" title=\"2.hashcode和equals\"></a>2.<strong>hashcode和equals</strong></h4><p>  hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode()在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。</p>\n<p>hashCode（）与 equals（）的相关规定 </p>\n<pre><code>    1. 如果两个对象相等，则 hashcode ⼀定也是相同的\n    2. 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true\n    3. 两个对象有相同的 hashcode 值，它们也不⼀定是相等的\n    4. 因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖\n    5. hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）</code></pre>\n<h4 id=\"3-public-protected-default-private的访问权限修饰区别\"><a href=\"#3-public-protected-default-private的访问权限修饰区别\" class=\"headerlink\" title=\"3.public protected default private的访问权限修饰区别\"></a>3.<strong>public protected default private的访问权限修饰区别</strong></h4><p>  public在本类中、同一包中、子类中不在同一包中、其他包下都能访问<br>  protected在本类中、同一包中、子类中不在同一包中都能访问<br>  default在本类中、同一包中都能访问<br>  private在本类中能访问</p>\n<h4 id=\"4-多线程的实现方式和区别\"><a href=\"#4-多线程的实现方式和区别\" class=\"headerlink\" title=\"4.多线程的实现方式和区别\"></a>4.<strong>多线程的实现方式和区别</strong></h4><p>①继承Thread类<br>    public class MyThread extends Thread {<br>    @Override<br>    public void run(){<br>        super.run();<br>        System.out.println(&quot;执行子线程...&quot;);<br>    }</p>\n<p>测试用例</p>\n<pre><code>public class Test &#123;\npublic static void main(String[] args) &#123;\n    MyThread myThread = new MyThread();\n    myThread.start();\n    System.out.println(&quot;主线程...&quot;);\n    &#125;\n&#125;</code></pre>\n<p>②实现Rannable接口</p>\n<pre><code>public class MyRunnable implements Runnable &#123;\n@Override\npublic void run() &#123;\n    System.out.println(&quot;执行子线程...&quot;);\n     &#125;\n&#125;</code></pre>\n<p>测试用例</p>\n<pre><code> public class Test &#123;\n public static void main(String[] args) &#123;\n\n     Runnable runnable = new MyRunnable();\n     Thread thread = new Thread(runnable);\n     thread.start();\n     System.out.println(&quot;主线程运行结束!&quot;);\n &#125;</code></pre>\n<p>③使用Callable和Future创建线程</p>\n<p>上面的两种方式都有这两个问题：</p>\n<ul>\n<li>无法获取子线程的返回值</li>\n<li>run方法不可以抛出异常</li>\n</ul>\n<p>为了解决这两个问题，我们就需要用到Callable这个接口了。说到接口，上面的Runnable接口实现类实例是作为Thread类的构造函数的参数传入的，之后通过Thread的start执行run方法中的内容。但是Callable并不是Runnable的子接口，是个全新的接口，它的实例不能直接传入给Thread构造，所以需要另一个接口来转换一下。</p>\n<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个实现类FutureTask，该实现类的继承关系如图所示：</p>\n<pre><code>import java.util.concurrent.Callable;\npublic class MyCallable implements Callable &#123;\nint i = 0;\n@Override\npublic Object call() throws Exception &#123;\n    System.out.println(Thread.currentThread().getName()+&quot;  i的值：&quot;+ i);\n    return i++; //call方法可以有返回值\n    &#125;\n&#125;    </code></pre>\n<p>测试用例</p>\n<pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\npublic class Test &#123;\npublic static void main(String[] args) &#123;\n    Callable callable = new MyCallable();\n    for (int i = 0; i &lt; 10; i++) &#123;\n        FutureTask task = new FutureTask(callable);\n        new Thread(task,&quot;子线程&quot;+ i).start();\n        try &#123;\n            //获取子线程的返回值\n            System.out.println(&quot;子线程返回值：&quot;+task.get() + &quot;\\n&quot;);\n        &#125;  catch (Exception e) &#123;\n            e.printStackTrace();\n                &#125;\n        &#125;\n     &#125;\n&#125;</code></pre>\n<p>④使用线程池</p>\n<p><strong>前三种实现多线程的比较：</strong></p>\n<p>第一种和后面两种的对比：</p>\n<ul>\n<li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li>\n<li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li>\n</ul>\n<p>第二种和第三种方式对比：</p>\n<ul>\n<li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li>\n<li>第三种方法有两个优点：有返回值、可以抛出异常</li>\n</ul>\n<p><strong>实现多线程的总结</strong></p>\n<p><strong>实际开发中可能有更复杂的代码实现，需要继承其他的类，所以平时更推荐通过实现接口来实现多线程，也就是通过第二或第三种方式来实现，这样能保持代码灵活和解耦。<br>而选择第二还是第三种方式，则要根据run()方法是不是需要返回值或者捕获异常来决定，如果不需要，可以选择用第二种方式实现，代码更简洁。</strong></p>\n<h4 id=\"5-有几种线程池并解释\"><a href=\"#5-有几种线程池并解释\" class=\"headerlink\" title=\"5.有几种线程池并解释\"></a><strong>5.有几种线程池并解释</strong></h4><ol>\n<li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li>\n<li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n<li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li>\n<li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li>\n</ol>\n<h4 id=\"6-说出几种NIO的实现类\"><a href=\"#6-说出几种NIO的实现类\" class=\"headerlink\" title=\"6.说出几种NIO的实现类\"></a><strong>6.说出几种NIO的实现类</strong></h4><p>NIO 包含下面几个核心的组件：</p>\n<ul>\n<li>Channel(通道)</li>\n<li>Buffer(缓冲区)</li>\n<li>Selector(选择器)</li>\n</ul>\n<p>想到这扩展一下：BIO,NIO,AIO 有什么区别? </p>\n<ul>\n<li><strong>BIO（Blocking I/0）：同步阻塞I/0模式</strong>，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐较不错的，可以让每⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。</li>\n<li><strong>NIO（Non-blocking/New I/0）：NIO是一种同步非阻塞的I/0模型</strong>，在Java 1.4中引入了NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。</li>\n<li><strong>AIO（Asynchronous I/0）：AIO也就是NIO 2，</strong>在Java 7中引入了NIO的改进版NIO 2，它是异步非阻塞的I0模型。异步10是基于事件和回调机制实现的,</li>\n</ul>\n<h4 id=\"7-你理解的多态\"><a href=\"#7-你理解的多态\" class=\"headerlink\" title=\"7.你理解的多态\"></a><strong>7.你理解的多态</strong></h4><p>所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，<strong>即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。</strong></p>\n<p>在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖[又叫重写]接⼝中同一方法）。</p>\n<h4 id=\"8-说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗\"><a href=\"#8-说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗\" class=\"headerlink\" title=\"8.说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗\"></a><strong>8.说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗</strong></h4><p><strong>概述</strong></p>\n<ul>\n<li>Maven是一个构建工具，服务与构建使用Maven配置好项目后，输入简单的命令如：mvn clean install，Maven会帮我们处理那些繁琐的任务</li>\n</ul>\n<ul>\n<li><p>Maven是跨平台的</p>\n</li>\n<li><p>Maven最大化的消除了构建的重复</p>\n</li>\n<li><p>Maven可以帮助我们标准化构建过程所有的项目都是简单一致的，简化了学习成本总之Maven作为一个构建工具不仅帮我们自动化构建，还能抽象构建过程提供构建任务实现他跨平台，对外提供一致的操作接口，这一切足以使他成为优秀的，流行的构建工具</p>\n</li>\n<li><p>但是Maven不仅是构建工具，他还是一个依赖管理工具和项目信息管理工具，他还提供了中央仓库，能帮我们自动下载构件</p>\n</li>\n<li><p>使用Maven还能享受一个额外的好处，即Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置Convention Over Configuration）</p>\n</li>\n</ul>\n<p><strong><em>它是一个Apache的开源项目，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理，还提供了中央仓库，能自动下载构件，为了不重复造轮子。</em></strong></p>\n<p>例如：两个项目A B，项目A需要依赖一些jar包，项目B也需要依赖这些jar包，那么此时如果都把jar包引入到项目中，就是在重复造轮子，我们应该把这些所有的jar包放到一个地方，需要用的时候过去取即可。</p>\n<p><strong>常用的maven命令：</strong></p>\n<ul>\n<li><p>maven clean：对项目进行清理，清理的过程中会删除删除target目录下编译的内容。</p>\n</li>\n<li><p>maven compile：编译项目源代码。</p>\n</li>\n<li><p>maven test：对项目的运行测试。</p>\n</li>\n<li><p>maven deploy： 发布项目</p>\n</li>\n<li><p>maven packet：可以打包后的文件存放到项目的 target 目录下，打包好的文件通常都是编译后生成的class文件。</p>\n</li>\n<li><p>maven install：在本地仓库生成仓库的安装包可以供其他项目引用，同时打包后的文件存放到项目的 target 目录下。对项目打包有三种打包方式，pom打包，jar包和war包。打包方式在pom.xml文件中进行指定。</p>\n</li>\n</ul>\n<p><em>pom工程一般是聚合工程，代表父工程，负责管理jar包的版本、maven插件的版本等，主要做统一的依赖管理。</em></p>\n<p><em>jar包就是普通的打包方式，可以是pom工程的子工程。</em></p>\n<p><em>war包的都是web工程，是可以直接放到tomcat下运行的工程。</em></p>\n<p>我的项目中主要是用maven来对项目中jar包依赖进行统一的管理。</p>\n<h4 id=\"9-你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）\"><a href=\"#9-你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）\" class=\"headerlink\" title=\"9.你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）\"></a><strong>9.你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）</strong></h4><p><strong>简介</strong></p>\n<p><strong>Redis:</strong> REmote DIctionary Server(远程字典服务器)是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。</p>\n<p><strong>redis使用场景</strong></p>\n<ol>\n<li><p>热点数据的缓存<br>由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。</p>\n</li>\n<li><p>限时业务的运用<br>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>\n</li>\n<li><p>计数器相关问题<br>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>\n</li>\n<li><p>排行榜相关问题<br>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。例如：在奶茶活动中，我们需要展示各个部门的点赞排行榜，所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p>\n</li>\n<li><p>分布式锁<br>这个主要利用redis的setnx命令进行，setnx：&quot;set if not exists&quot;就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。</p>\n</li>\n<li><p>延时操作<br>这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p>\n</li>\n<li><p>队列<br>由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。　</p>\n</li>\n</ol>\n<h3 id=\"项目2\"><a href=\"#项目2\" class=\"headerlink\" title=\"项目2\"></a>项目2</h3><p><strong>1.你的自行车报名系统是干什么的，管理员都干了些什么</strong></p>\n<p>随着自行车赛事活动的增加，把赛事变得更加理性和规范，使赛事朝着IP化、品质化方向发展。参赛者可以线上报名为赛事提供诸多便利。</p>\n<p>完成管理员的登录、完成管理员创建比赛、查看比赛列表、管理员查看赛事报名状态、<br>对赛事管理（修改、删除）</p>\n","categories":["面试"],"tags":["应届面试"]},{"title":"贪心算法","url":"/2020-11-08-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html","content":"<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><p>在以下的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p>\n<h3 id=\"1-分配饼干\"><a href=\"#1-分配饼干\" class=\"headerlink\" title=\"1.分配饼干\"></a>1.分配饼干</h3><ol start=\"455\">\n<li>Assign Cookies (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYXNzaWduLWNvb2tpZXMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXNzaWduLWNvb2tpZXMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：每个孩子都有一个满足度 g，每个饼干都有一个大小 s，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解析：</p>\n<ol>\n<li><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</p>\n</li>\n<li><p>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</p>\n</li>\n</ol>\n<p>每个孩子的满足度和饼干的大小不是顺序排序的，所以首先我们要把这两个数组进行顺序排序，选择升序排序，因为我们要输出可以满足孩子的数量，所以要先满足满足度最小的孩子后，在满足比他大的，具体怎么比较呢：</p>\n<p>因为我们不知道有多少个g、s，不知道循环次数，所以用while来判断s、g是否超出边界；每次第一个孩子满足度（最小的）和饼干大小（最小的）比较；第一种情况：g&lt;=s,记录满足孩子数量，进行第二个组g、s，相当于g、s +1；第二种情况：g&gt;s,不记录满足孩子数量，进行第二个组g、s+1比较，相当于g、s+1;总结来说s是一直要+1的，也就是说满不满足s都要+1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findContentChildren</span><span class=\"params\">(<span class=\"keyword\">int</span>[] g, <span class=\"keyword\">int</span>[] s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(g==<span class=\"keyword\">null</span> || s==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Array.sort(g);</span><br><span class=\"line\">        Array.sort(s);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> gi=<span class=\"number\">0</span>;<span class=\"keyword\">int</span> si=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(gi&lt;g.length &amp;&amp; si&lt;s.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(g[gi]&lt;=s[si])&#123;</span><br><span class=\"line\">                gi++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            si++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-不重叠的区间个数\"><a href=\"#2-不重叠的区间个数\" class=\"headerlink\" title=\"2.不重叠的区间个数\"></a>2.不重叠的区间个数</h3><ol start=\"435\">\n<li>Non-overlapping Intervals (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p>\n<ul>\n<li>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</li>\n<li>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</li>\n<li>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 2</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [ [1,2], [2,3] ]</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解析：进行二维数组中第二位数升序排序，输入: [ [1,2], [2,3], [3,4], [1,3] ]，排完序后是[ [1,2], [2,3], [1,3], [3,4] ]，把第一个结束校验的位置放到end = intervals[0][1],因为第一组区间一定存在，然后往后面判断不重复的区间，所以存在不重复区间cnt=1，默认第一个区间存在；如果end &gt; intervals[i][0]成立,说明第二组区间和第一组区间重合，跳出（continue），不计cnt，然后i+1，继续判断end &gt; intervals[i][0],如果不成立，cnt+1、更新end的值end=ntervals[i][1] 因为这个区间和上一个区间不重复，并且本区间中后面的数较大，所以end等于本区间最大值，i+1,一直到循环结束，用还数组长度-cnt=重复的区间数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] intervals)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        <span class=\"comment\">//二维数组，第二个元素排序，另一个元素跟随</span></span><br><span class=\"line\">        <span class=\"comment\">//Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o[]));</span></span><br><span class=\"line\">        <span class=\"comment\">//二维数组，第一个元素排序 ，另一个元素跟随                          </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end=intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][<span class=\"number\">0</span>] &lt; end )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;           </span><br><span class=\"line\">                end=intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.length-cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-投飞镖刺破气球\"><a href=\"#3-投飞镖刺破气球\" class=\"headerlink\" title=\"3. 投飞镖刺破气球\"></a>3. 投飞镖刺破气球</h3><ol start=\"452\">\n<li>Minimum Number of Arrows to Burst Balloons (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1udW1iZXItb2YtYXJyb3dzLXRvLWJ1cnN0LWJhbGxvb25zL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1udW1iZXItb2YtYXJyb3dzLXRvLWJ1cnN0LWJhbGxvb25zL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>\n<p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：points = [[<span class=\"number\">10</span>,<span class=\"number\">16</span>],[<span class=\"number\">2</span>,<span class=\"number\">8</span>],[<span class=\"number\">1</span>,<span class=\"number\">6</span>],[<span class=\"number\">7</span>,<span class=\"number\">12</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">2</span></span><br><span class=\"line\">解释：对于该样例，x = <span class=\"number\">6</span> 可以射爆 [<span class=\"number\">2</span>,<span class=\"number\">8</span>],[<span class=\"number\">1</span>,<span class=\"number\">6</span>] 两个气球，以及 x = <span class=\"number\">11</span> 射爆另外两个气球</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">5</span>,<span class=\"number\">6</span>],[<span class=\"number\">7</span>,<span class=\"number\">8</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">4</span>,<span class=\"number\">5</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：points = [[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>]]</span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findMinArrowShots</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] points)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(points.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Array.sort(points,Comparator.comparingInt(o-&gt;o[<span class=\"number\">1</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end=points[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;points.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(points[i][<span class=\"number\">0</span>] &lt;= end)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                end=points[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-根据身高和序号重组队列\"><a href=\"#4-根据身高和序号重组队列\" class=\"headerlink\" title=\"4.根据身高和序号重组队列\"></a>4.根据身高和序号重组队列</h3><ol start=\"406\">\n<li>Queue Reconstruction by Height(Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcXVldWUtcmVjb25zdHJ1Y3Rpb24tYnktaGVpZ2h0L2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcXVldWUtcmVjb25zdHJ1Y3Rpb24tYnktaGVpZ2h0L2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p>\n<p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</p>\n<p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[[<span class=\"number\">7</span>,<span class=\"number\">0</span>], [<span class=\"number\">4</span>,<span class=\"number\">4</span>], [<span class=\"number\">7</span>,<span class=\"number\">1</span>], [<span class=\"number\">5</span>,<span class=\"number\">0</span>], [<span class=\"number\">6</span>,<span class=\"number\">1</span>], [<span class=\"number\">5</span>,<span class=\"number\">2</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[<span class=\"number\">5</span>,<span class=\"number\">0</span>], [<span class=\"number\">7</span>,<span class=\"number\">0</span>], [<span class=\"number\">5</span>,<span class=\"number\">2</span>], [<span class=\"number\">6</span>,<span class=\"number\">1</span>], [<span class=\"number\">4</span>,<span class=\"number\">4</span>], [<span class=\"number\">7</span>,<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n\n<p> 解释：身高从高到低排序的好处是，对于前面已经排好的队</p>\n<p>1.如果下一个人(h,k)比前面所有人都矮，那么，他插入队列的k处，使其达到k的要求，对其他人没影响，达到要求！</p>\n<p> 2.如果下一个人跟之前排好队的人中最矮的身高一样，这时候，就体现为什么之前排序时候，先考虑身高，再按照k的升序了，这时候，新来的人虽然与之前最矮之人身高一样，但是由于他的k比之前最矮的人的k都大，所以，他插入的地方一定在已经排好队的，和他身高一样的，最矮之人的后面，对这些最矮人们没有影响，当然，对其他比他高的人就更没有影响了。</p>\n<p>其只要了解一点：我们一个一个地排队，对于前面已经排好的队，如果我们在k的位置插入一个新人，那么对k之前的人没有任何影响，对于k之后比新人高的人也没有任何影响，因此，我们每插入一个人的时候，要么保证前面所有人都比新人高，要么至少保证插入的位置后面的所有人都比新人高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] reconstructQueue(<span class=\"keyword\">int</span>[][] people) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (people == <span class=\"keyword\">null</span> || people.length == <span class=\"number\">0</span> || people[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 当第一维相等时比较第二维的</span></span><br><span class=\"line\">    Arrays.sort(people, (a, b) -&gt; (a[<span class=\"number\">0</span>] == b[<span class=\"number\">0</span>] ? a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] : b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *for(元素类型t 元素变量x : 遍历对象obj)&#123; </span></span><br><span class=\"line\"><span class=\"comment\">    *\t\t\t引用了x的java语句; </span></span><br><span class=\"line\"><span class=\"comment\">\t*\t\t\t&#125; </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] p : people) &#123;</span><br><span class=\"line\">        queue.add(p[<span class=\"number\">1</span>], p);<span class=\"comment\">//因为之前的已经排过序了，所以直接插入自己的位置就可以了</span></span><br><span class=\"line\">        <span class=\"comment\">//相对于[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]经过h降序、k升序</span></span><br><span class=\"line\">        <span class=\"comment\">//-&gt; [[7,0], [7,1], [6,1],[5,0],[5,2]，[4,4],]</span></span><br><span class=\"line\">        <span class=\"comment\">//经过foreach后 p[1]= 0 1 1 0 2 4</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0], [7,1], [6,1], [5,0], [5,2], [4,4]</span></span><br><span class=\"line\">        <span class=\"comment\">// 再一个一个插入。</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0]</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [7,0], [6,1], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [5,0], [7,0], [6,1], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [5,0], [7,0], [5,2], [6,1], [7,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// [5,0], [7,0], [5,2], [6,1], [4,4], [7,1]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回一个数组，该数组按正确顺序（从第一个元素到最后一个元素）包含此列表中的所有元素。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[queue.size()][]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-买卖股票最大的收益\"><a href=\"#5-买卖股票最大的收益\" class=\"headerlink\" title=\"5. 买卖股票最大的收益\"></a>5. 买卖股票最大的收益</h3><ol start=\"121\">\n<li>Best Time to Buy and Sell Stock (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p>\n<p>解释：只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出，最大利润 = <span class=\"number\">6</span>-<span class=\"number\">1</span> = <span class=\"number\">5</span> 。</span><br><span class=\"line\">     注意利润不能是 <span class=\"number\">7</span>-<span class=\"number\">1</span> = <span class=\"number\">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class=\"number\">0</span>。    </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> minf=prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">       <span class=\"keyword\">int</span> max=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(minf&gt;prices[i])&#123;</span><br><span class=\"line\">               minf=prices[i];</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               max = Math.max(max,prices[i]-minf);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-买卖股票的最大收益-II\"><a href=\"#6-买卖股票的最大收益-II\" class=\"headerlink\" title=\"6. 买卖股票的最大收益 II\"></a>6. 买卖股票的最大收益 II</h3><ol start=\"122\">\n<li>Best Time to Buy and Sell Stock II (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay1paS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay1paS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<p>解释：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此**当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0**，那么就把 prices[i] - prices[i-1] 添加到收益中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">7</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">3</span> 天（股票价格 = <span class=\"number\">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class=\"number\">5</span>-<span class=\"number\">1</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\">     随后，在第 <span class=\"number\">4</span> 天（股票价格 = <span class=\"number\">3</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class=\"number\">6</span>-<span class=\"number\">3</span> = <span class=\"number\">3</span> 。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">1</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天 （股票价格 = <span class=\"number\">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class=\"number\">5</span>-<span class=\"number\">1</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\">     注意你不能在第 <span class=\"number\">1</span> 天和第 <span class=\"number\">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class=\"line\">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if a&lt;=b&lt;=c&lt;=d</span></span><br><span class=\"line\">    <span class=\"comment\">//max=d-a</span></span><br><span class=\"line\">    <span class=\"comment\">//d-a=(d-c)+(c-b)+(b-a)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[i]&gt;prices[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                sum+=prices[i]-prices[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-种植花朵\"><a href=\"#7-种植花朵\" class=\"headerlink\" title=\"7. 种植花朵\"></a>7. 种植花朵</h3><ol start=\"605\">\n<li>Can Place Flowers (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。也就是flowerbed 数组中 1 表示已经种下了花朵，0代表每种下。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: flowerbed = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>], n = <span class=\"number\">1</span></span><br><span class=\"line\">输出: True</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入: flowerbed = [<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>], n = <span class=\"number\">2</span></span><br><span class=\"line\">输出: False</span><br><span class=\"line\">注意：</span><br><span class=\"line\">    数组内已种好的花不会违反种植规则。</span><br><span class=\"line\">\t输入的数组长度范围为 [<span class=\"number\">1</span>, <span class=\"number\">20000</span>]。</span><br><span class=\"line\">\tn 是非负整数，且不会超过输入数组的大小。    </span><br></pre></td></tr></table></figure>\n\n<p>解释：在[1,0,0,0,1],插入1，并且需怕满足一个1的前后都是0，所以我们可以换一个思路想，我们找0，如果0的前后都是0，那么这个o就可以置为1了（这里要特殊判断一下，数组的0、data.length-1索引，因为要判断到最前面和最后面后出现数组越界），并且记录插入的值，因为最后要返回的是是否种下了n朵花，用插入的cnt和n比较，如果cnt&gt;=n，代表能够种下n多花。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canPlaceFlowers</span><span class=\"params\">(<span class=\"keyword\">int</span>[] flowerbed, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;flowerbed.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flowerbed[i]==<span class=\"number\">0</span> &amp;&amp; (i==<span class=\"number\">0</span> || flowerbed[i-<span class=\"number\">1</span>]==<span class=\"number\">0</span>) &amp;&amp; (i==flowerbed.length-<span class=\"number\">1</span> || flowerbed[i+<span class=\"number\">1</span>]==<span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">                flowerbed[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count&gt;=n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-判断是否为子序列\"><a href=\"#8-判断是否为子序列\" class=\"headerlink\" title=\"8. 判断是否为子序列\"></a>8. 判断是否为子序列</h3><ol start=\"392\">\n<li>Is Subsequence (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>\n<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">输入：s = <span class=\"string\">&quot;abc&quot;</span>, t = <span class=\"string\">&quot;ahbgdc&quot;</span></span><br><span class=\"line\">返回 <span class=\"keyword\">true</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = <span class=\"string\">&quot;axc&quot;</span>, t = <span class=\"string\">&quot;ahbgdc&quot;</span></span><br><span class=\"line\">返回 <span class=\"keyword\">false</span>.</span><br></pre></td></tr></table></figure>\n\n<p>解释：这道题如果你会java的一些常见API就会很简单了，首先把子序列用toCharArray()转成一个字符数组，然后用int indexOf(String str, int index)返回从 index位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1；把index初始值赋为-1，如果在遍历中index==-1则返回false,否则返回true.</p>\n<p>//toCharArray() 方法将字符串转换为字符数组。<br>public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p>\n<p>foreach语句是java5的新特征之一，在遍历数组、集合方面，foreach为开发人员提供了极大的方便。<br>foreach 语法格式如下：<br>for(元素类型t 元素变量x : 遍历对象obj){<br>     引用了x的java语句; } </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isSubsequence(String s, String t) &#123;</span><br><span class=\"line\">    int index &#x3D; -1;</span><br><span class=\"line\">    for(char c : s.toCharArray())&#123;</span><br><span class=\"line\">        index &#x3D; t.indexOf(c,index+1);</span><br><span class=\"line\">        if(index &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-修改一个数成为非递减数组\"><a href=\"#9-修改一个数成为非递减数组\" class=\"headerlink\" title=\"9. 修改一个数成为非递减数组\"></a>9. 修改一个数成为非递减数组</h3><ol start=\"665\">\n<li>Non-decreasing Array (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbm9uLWRlY3JlYXNpbmctYXJyYXkvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLWRlY3JlYXNpbmctYXJyYXkvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p>\n<p>解释：这道题主要就是判断两种情况，判断5 7 4 6这样的数   判断4 2 1这样的数，第一种是把4变成7，第二种是把4变成2</p>\n<p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">true</span></span><br><span class=\"line\">解释: 你可以通过把第一个<span class=\"number\">4</span>变成<span class=\"number\">1</span>来使得它成为一个非递减数列。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入: nums = [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">false</span></span><br><span class=\"line\">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。  </span><br><span class=\"line\">   </span><br><span class=\"line\">    </span><br><span class=\"line\">输入: nums = [<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">false</span></span><br><span class=\"line\">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入: nums = [<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">输出: <span class=\"keyword\">true</span></span><br><span class=\"line\">解释: 你可以通过把第一个<span class=\"number\">4</span>变成<span class=\"number\">7</span>来使得它成为一个非递减数列。        </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkPossibility</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length&amp;&amp;cnt&lt;<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//使用cnt&lt;2 当出现第二个比前面大的数，直接停止循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;=nums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">               <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i-<span class=\"number\">2</span>&gt;=<span class=\"number\">0</span> &amp;&amp; nums[i]&lt;nums[i-<span class=\"number\">2</span>])&#123;<span class=\"comment\">//判断5 7 4 8这样的数</span></span><br><span class=\"line\">            <span class=\"comment\">//7&gt;5 ,4&lt;7  只能让4的位置换成7才能不是递减</span></span><br><span class=\"line\">                nums[i]=nums[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">                nums[i-<span class=\"number\">1</span>]=nums[i];<span class=\"comment\">//判断4 2 3这样的数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-子数组最大的和\"><a href=\"#10-子数组最大的和\" class=\"headerlink\" title=\"10. 子数组最大的和\"></a>10. 子数组最大的和</h3><ol start=\"53\">\n<li>Maximum Subarray (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>解释：要找到一个连续数组的最大和，首先要找到一个大于0的数，然后判断，取一个temp中间值，如果temp大于0 temp=temp+nums[i];只有返回的temp大于0，才会使连续的数组，如果中间出现temp小于0，就代表放弃前面的数组了，重新开始从本nums[i]加起。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [-<span class=\"number\">2</span>,<span class=\"number\">1</span>,-<span class=\"number\">3</span>,<span class=\"number\">4</span>,-<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,-<span class=\"number\">5</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">6</span></span><br><span class=\"line\">解释: 连续子数组 [<span class=\"number\">4</span>,-<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>] 的和最大，为 <span class=\"number\">6</span>。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            temp = temp&gt;<span class=\"number\">0</span> ? nums[i]+temp:nums[i];</span><br><span class=\"line\">            max = Math.max(temp,max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-分隔字符串使同种字符出现在一起\"><a href=\"#11-分隔字符串使同种字符出现在一起\" class=\"headerlink\" title=\"11. 分隔字符串使同种字符出现在一起\"></a>11. 分隔字符串使同种字符出现在一起</h3><ol start=\"763\">\n<li>Partition Labels (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<p>解释：一想到分割字符串就想到了回溯，但本题其实不用那么复杂。</p>\n<p>可以分为如下两步：</p>\n<p>统计每一个字符最后出现的位置<br>从头遍历字符，如果找到之前字符最大出现位置下标和当前下标相等，则找到了分割点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：S = <span class=\"string\">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class=\"line\">输出：[<span class=\"number\">9</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">划分结果为 <span class=\"string\">&quot;ababcbaca&quot;</span>, <span class=\"string\">&quot;defegde&quot;</span>, <span class=\"string\">&quot;hijhklij&quot;</span>。</span><br><span class=\"line\">每个字母最多出现在一个片段中。</span><br><span class=\"line\">像 <span class=\"string\">&quot;ababcbacadefegde&quot;</span>, <span class=\"string\">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">partitionLabels</span><span class=\"params\">(String S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//统计每个字母出现的最大下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] lastIndexsOfChar = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class=\"line\">        lastIndexsOfChar[char2Index(S.charAt(i))] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个集合装返回的数据</span></span><br><span class=\"line\">    List&lt;Integer&gt; partitions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> firstIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (firstIndex &lt; S.length()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastIndex = firstIndex;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = firstIndex; i &lt; S.length() &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = lastIndexsOfChar[char2Index(S.charAt(i))];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &gt; lastIndex) &#123;</span><br><span class=\"line\">                lastIndex = index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//装每个分割点的字符数</span></span><br><span class=\"line\">        partitions.add(lastIndex - firstIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//重新遍历下一个字符开始的字符串</span></span><br><span class=\"line\">        firstIndex = lastIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> partitions;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">char2Index</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["算法"],"tags":["贪心算法"]},{"title":"ConcurrentHashMap","url":"/2020-11-17-ConcurrentHashMap.html","content":"<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><h2 id=\"JDK1-7\"><a href=\"#JDK1-7\" class=\"headerlink\" title=\"JDK1.7\"></a>JDK1.7</h2><h3 id=\"1-存储结构\"><a href=\"#1-存储结构\" class=\"headerlink\" title=\"1. 存储结构\"></a>1. 存储结构</h3><p><img data-src=\"https://i.loli.net/2020/11/17/3LAd5JPm4V8N6RU.png\" loading=\"lazy\"></p>\n<p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现.</p>\n<h3 id=\"2-初始化\"><a href=\"#2-初始化\" class=\"headerlink\" title=\"2. 初始化\"></a>2. 初始化</h3><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class=\"line\"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public ConcurrentHashMap() &#123;</span><br><span class=\"line\">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 默认初始化容量</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 默认负载因子</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 默认并发级别</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure>\n\n<p>接着看下这个有参构造函数的内部实现逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 参数校验</span><br><span class=\"line\">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException();</span><br><span class=\"line\">    &#x2F;&#x2F; 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br><span class=\"line\">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class=\"line\">        concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class=\"line\">    &#x2F;&#x2F; Find power-of-two sizes best matching arguments</span><br><span class=\"line\">    &#x2F;&#x2F; 2的多少次方</span><br><span class=\"line\">    int sshift &#x3D; 0;</span><br><span class=\"line\">    int ssize &#x3D; 1;</span><br><span class=\"line\">    &#x2F;&#x2F; 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br><span class=\"line\">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class=\"line\">        ++sshift;</span><br><span class=\"line\">        ssize &lt;&lt;&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 记录段偏移量</span><br><span class=\"line\">    this.segmentShift &#x3D; 32 - sshift;</span><br><span class=\"line\">    &#x2F;&#x2F; 记录段掩码</span><br><span class=\"line\">    this.segmentMask &#x3D; ssize - 1;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置容量</span><br><span class=\"line\">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class=\"line\">    &#x2F;&#x2F; c &#x3D; 容量 &#x2F; ssize ，默认 16 &#x2F; 16 &#x3D; 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br><span class=\"line\">    int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class=\"line\">    if (c * ssize &lt; initialCapacity)</span><br><span class=\"line\">        ++c;</span><br><span class=\"line\">    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class=\"line\">    &#x2F;&#x2F;Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br><span class=\"line\">    while (cap &lt; c)</span><br><span class=\"line\">        cap &lt;&lt;&#x3D; 1;</span><br><span class=\"line\">    &#x2F;&#x2F; create segments and segments[0]</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Segment 数组，设置 segments[0]</span><br><span class=\"line\">    Segment&lt;K,V&gt; s0 &#x3D; new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class=\"line\">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class=\"line\">    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class=\"line\">    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]</span><br><span class=\"line\">    this.segments &#x3D; ss;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p>\n<ol>\n<li>必要参数校验。</li>\n<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造<strong>默认值是 16.</strong></li>\n<li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li>\n<li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li>\n<li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li>\n<li><strong>初始化 segments[0]**，</strong>默认大小为 2<strong>，</strong>负载因子 0.75<strong>，</strong>扩容阀值是 2*0.75=1.5**，插入第二个值时才会进行扩容。</li>\n</ol>\n<h3 id=\"3-put\"><a href=\"#3-put\" class=\"headerlink\" title=\"3. put\"></a>3. put</h3><p>接着上面的初始化参数继续查看 put 方法源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Maps the specified key to the specified value in this table.</span><br><span class=\"line\"> * Neither the key nor the value can be null.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;&#x2F;tt&gt; method</span><br><span class=\"line\"> * with a key that is equal to the original key.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param key key with which the specified value is to be associated</span><br><span class=\"line\"> * @param value value to be associated with the specified key</span><br><span class=\"line\"> * @return the previous value associated with &lt;tt&gt;key&lt;&#x2F;tt&gt;, or</span><br><span class=\"line\"> *         &lt;tt&gt;null&lt;&#x2F;tt&gt; if there was no mapping for &lt;tt&gt;key&lt;&#x2F;tt&gt;</span><br><span class=\"line\"> * @throws NullPointerException if the specified key or value is null</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    Segment&lt;K,V&gt; s;</span><br><span class=\"line\">    if (value &#x3D;&#x3D; null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    int hash &#x3D; hash(key);</span><br><span class=\"line\">    &#x2F;&#x2F; hash 值无符号右移 28位（初始化时获得），然后与 segmentMask&#x3D;15 做与运算</span><br><span class=\"line\">    &#x2F;&#x2F; 其实也就是把高4位与segmentMask（1111）做与运算</span><br><span class=\"line\">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class=\"line\">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class=\"line\">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class=\"line\">        &#x2F;&#x2F; 如果查找到的 Segment 为空，初始化</span><br><span class=\"line\">        s &#x3D; ensureSegment(j);</span><br><span class=\"line\">    return s.put(key, hash, value, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Returns the segment for the given index, creating it and</span><br><span class=\"line\"> * recording in segment table (via CAS) if not already present.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param k the index</span><br><span class=\"line\"> * @return the segment</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class=\"line\">    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;</span><br><span class=\"line\">    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset</span><br><span class=\"line\">    Segment&lt;K,V&gt; seg;</span><br><span class=\"line\">    &#x2F;&#x2F; 判断 u 位置的 Segment 是否为null</span><br><span class=\"line\">    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        Segment&lt;K,V&gt; proto &#x3D; ss[0]; &#x2F;&#x2F; use segment 0 as prototype</span><br><span class=\"line\">        &#x2F;&#x2F; 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br><span class=\"line\">        int cap &#x3D; proto.table.length;</span><br><span class=\"line\">        &#x2F;&#x2F; 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br><span class=\"line\">        float lf &#x3D; proto.loadFactor;</span><br><span class=\"line\">        &#x2F;&#x2F; 计算扩容阀值</span><br><span class=\"line\">        int threshold &#x3D; (int)(cap * lf);</span><br><span class=\"line\">        &#x2F;&#x2F; 创建一个 cap 容量的 HashEntry 数组</span><br><span class=\"line\">        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class=\"line\">        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; recheck</span><br><span class=\"line\">            &#x2F;&#x2F; 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br><span class=\"line\">            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class=\"line\">            &#x2F;&#x2F; 自旋检查 u 位置的 Segment 是否为null</span><br><span class=\"line\">            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class=\"line\">                   &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 使用CAS 赋值，只会成功一次</span><br><span class=\"line\">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return seg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p>\n<ol>\n<li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p>\n</li>\n<li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p>\n<p><strong>初始化 Segment 流程：</strong></p>\n<ol>\n<li>检查计算得到的位置的 Segment 是否为null.</li>\n<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li>\n<li>再次检查计算得到的指定位置的 Segment 是否为null.</li>\n<li>使用创建的 HashEntry 数组初始化这个 Segment.</li>\n<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li>\n</ol>\n</li>\n<li><p>Segment.put 插入 key,value 值。</p>\n</li>\n</ol>\n<p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br><span class=\"line\">    V oldValue;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class=\"line\">        &#x2F;&#x2F; 计算要put的数据位置</span><br><span class=\"line\">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class=\"line\">        &#x2F;&#x2F; CAS 获取 index 坐标的值</span><br><span class=\"line\">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class=\"line\">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class=\"line\">            if (e !&#x3D; null) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br><span class=\"line\">                K k;</span><br><span class=\"line\">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class=\"line\">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class=\"line\">                    oldValue &#x3D; e.value;</span><br><span class=\"line\">                    if (!onlyIfAbsent) &#123;</span><br><span class=\"line\">                        e.value &#x3D; value;</span><br><span class=\"line\">                        ++modCount;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                e &#x3D; e.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br><span class=\"line\">                if (node !&#x3D; null)</span><br><span class=\"line\">                    node.setNext(first);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class=\"line\">                int c &#x3D; count + 1;</span><br><span class=\"line\">                &#x2F;&#x2F; 容量大于扩容阀值，小于最大容量，进行扩容</span><br><span class=\"line\">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">                    rehash(node);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    &#x2F;&#x2F; index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br><span class=\"line\">                    setEntryAt(tab, index, node);</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                count &#x3D; c;</span><br><span class=\"line\">                oldValue &#x3D; null;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>\n<ol>\n<li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p>\n</li>\n<li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p>\n</li>\n<li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>\n<p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p>\n<ol>\n<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>\n<li>直接头插法插入。</li>\n</ol>\n<p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p>\n<ol>\n<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>\n<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol>\n<li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li>\n<li>直接链表头插法插入。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p>\n</li>\n</ol>\n<p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node &#x3D; null;</span><br><span class=\"line\">    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node</span><br><span class=\"line\">    &#x2F;&#x2F; 自旋获取锁</span><br><span class=\"line\">    while (!tryLock()) &#123;</span><br><span class=\"line\">        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below</span><br><span class=\"line\">        if (retries &lt; 0) &#123;</span><br><span class=\"line\">            if (e &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node</span><br><span class=\"line\">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class=\"line\">                retries &#x3D; 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (key.equals(e.key))</span><br><span class=\"line\">                retries &#x3D; 0;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                e &#x3D; e.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 自旋达到指定次数后，阻塞等到只到获取到锁</span><br><span class=\"line\">            lock();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;</span><br><span class=\"line\">            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed</span><br><span class=\"line\">            retries &#x3D; -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-扩容-rehash\"><a href=\"#4-扩容-rehash\" class=\"headerlink\" title=\"4. 扩容 rehash\"></a>4. 扩容 rehash</h3><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class=\"line\">    &#x2F;&#x2F; 老容量</span><br><span class=\"line\">    int oldCapacity &#x3D; oldTable.length;</span><br><span class=\"line\">    &#x2F;&#x2F; 新容量，扩大两倍</span><br><span class=\"line\">    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;</span><br><span class=\"line\">    &#x2F;&#x2F; 新的扩容阀值 </span><br><span class=\"line\">    threshold &#x3D; (int)(newCapacity * loadFactor);</span><br><span class=\"line\">    &#x2F;&#x2F; 创建新的数组</span><br><span class=\"line\">    HashEntry&lt;K,V&gt;[] newTable &#x3D; (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class=\"line\">    &#x2F;&#x2F; 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br><span class=\"line\">    int sizeMask &#x3D; newCapacity - 1;</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 遍历老数组</span><br><span class=\"line\">        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class=\"line\">        if (e !&#x3D; null) &#123;</span><br><span class=\"line\">            HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class=\"line\">            &#x2F;&#x2F; 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span><br><span class=\"line\">            int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class=\"line\">            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F;  Single node on list</span><br><span class=\"line\">                &#x2F;&#x2F; 如果当前位置还不是链表，只是一个元素，直接赋值</span><br><span class=\"line\">                newTable[idx] &#x3D; e;</span><br><span class=\"line\">            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot</span><br><span class=\"line\">                &#x2F;&#x2F; 如果是链表了</span><br><span class=\"line\">                HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class=\"line\">                int lastIdx &#x3D; idx;</span><br><span class=\"line\">                &#x2F;&#x2F; 新的位置只可能是不便或者是老的位置+老的容量。</span><br><span class=\"line\">                &#x2F;&#x2F; 遍历结束后，lastRun 后面的元素位置都是相同的</span><br><span class=\"line\">                for (HashEntry&lt;K,V&gt; last &#x3D; next; last !&#x3D; null; last &#x3D; last.next) &#123;</span><br><span class=\"line\">                    int k &#x3D; last.hash &amp; sizeMask;</span><br><span class=\"line\">                    if (k !&#x3D; lastIdx) &#123;</span><br><span class=\"line\">                        lastIdx &#x3D; k;</span><br><span class=\"line\">                        lastRun &#x3D; last;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#x2F;&#x2F; ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br><span class=\"line\">                newTable[lastIdx] &#x3D; lastRun;</span><br><span class=\"line\">                &#x2F;&#x2F; Clone remaining nodes</span><br><span class=\"line\">                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class=\"line\">                    &#x2F;&#x2F; 遍历剩余元素，头插法到指定 k 位置。</span><br><span class=\"line\">                    V v &#x3D; p.value;</span><br><span class=\"line\">                    int h &#x3D; p.hash;</span><br><span class=\"line\">                    int k &#x3D; h &amp; sizeMask;</span><br><span class=\"line\">                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class=\"line\">                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 头插法插入新的节点</span><br><span class=\"line\">    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node</span><br><span class=\"line\">    node.setNext(newTable[nodeIndex]);</span><br><span class=\"line\">    newTable[nodeIndex] &#x3D; node;</span><br><span class=\"line\">    table &#x3D; newTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p>\n<h3 id=\"5-get\"><a href=\"#5-get\" class=\"headerlink\" title=\"5. get\"></a>5. get</h3><p>到这里就很简单了，get 方法只需要两步即可。</p>\n<ol>\n<li>计算得到 key 的存放位置。</li>\n<li>遍历指定位置查找相同 key 的 value 值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class=\"line\">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class=\"line\">    int h &#x3D; hash(key);</span><br><span class=\"line\">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class=\"line\">    &#x2F;&#x2F; 计算得到 key 的存放位置</span><br><span class=\"line\">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class=\"line\">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class=\"line\">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class=\"line\">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class=\"line\">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 如果是链表，遍历查找到相同 key 的 value。</span><br><span class=\"line\">            K k;</span><br><span class=\"line\">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class=\"line\">                return e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JDK1-8\"><a href=\"#JDK1-8\" class=\"headerlink\" title=\"JDK1.8\"></a>JDK1.8</h2><h3 id=\"1-存储结构-1\"><a href=\"#1-存储结构-1\" class=\"headerlink\" title=\"1. 存储结构\"></a>1. 存储结构</h3><p><img data-src=\"https://i.loli.net/2020/11/17/54tSzRX2UGPLWOk.png\" loading=\"lazy\"></p>\n<p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>\n<h3 id=\"2-初始化-initTable\"><a href=\"#2-初始化-initTable\" class=\"headerlink\" title=\"2. 初始化 initTable\"></a>2. 初始化 initTable</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class=\"line\">    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        ／／　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br><span class=\"line\">        if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class=\"line\">            &#x2F;&#x2F; 让出 CPU 使用权</span><br><span class=\"line\">            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class=\"line\">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table &#x3D; tab &#x3D; nt;</span><br><span class=\"line\">                    sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                sizeCtl &#x3D; sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>\n<ol>\n<li>-1 说明正在初始化</li>\n<li>-N 说明有N-1个线程正在进行扩容</li>\n<li>表示 table 初始化大小，如果 table 没有初始化</li>\n<li>表示 table 容量，如果 table　已经初始化。</li>\n</ol>\n<h3 id=\"3-put-1\"><a href=\"#3-put-1\" class=\"headerlink\" title=\"3. put\"></a>3. put</h3><p>直接过一遍 put 源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    return putVal(key, value, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class=\"line\">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; key 和 value 不能为空</span><br><span class=\"line\">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class=\"line\">    int hash &#x3D; spread(key.hashCode());</span><br><span class=\"line\">    int binCount &#x3D; 0;</span><br><span class=\"line\">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; f &#x3D; 目标位置元素</span><br><span class=\"line\">        Node&lt;K,V&gt; f; int n, i, fh;&#x2F;&#x2F; fh 后面存放目标位置的元素 hash 值</span><br><span class=\"line\">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class=\"line\">            &#x2F;&#x2F; 数组桶为空，初始化数组桶（自旋+CAS)</span><br><span class=\"line\">            tab &#x3D; initTable();</span><br><span class=\"line\">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br><span class=\"line\">            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class=\"line\">                break;  &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class=\"line\">            tab &#x3D; helpTransfer(tab, f);</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            V oldVal &#x3D; null;</span><br><span class=\"line\">            &#x2F;&#x2F; 使用 synchronized 加锁加入节点</span><br><span class=\"line\">            synchronized (f) &#123;</span><br><span class=\"line\">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class=\"line\">                    &#x2F;&#x2F; 说明是链表</span><br><span class=\"line\">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">                        binCount &#x3D; 1;</span><br><span class=\"line\">                        &#x2F;&#x2F; 循环加入新的或者覆盖节点</span><br><span class=\"line\">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class=\"line\">                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal &#x3D; e.val;</span><br><span class=\"line\">                                if (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val &#x3D; value;</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class=\"line\">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, null);</span><br><span class=\"line\">                                break;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else if (f instanceof TreeBin) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; 红黑树</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount &#x3D; 2;</span><br><span class=\"line\">                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) !&#x3D; null) &#123;</span><br><span class=\"line\">                            oldVal &#x3D; p.val;</span><br><span class=\"line\">                            if (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val &#x3D; value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (binCount !&#x3D; 0) &#123;</span><br><span class=\"line\">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                if (oldVal !&#x3D; null)</span><br><span class=\"line\">                    return oldVal;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(1L, binCount);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>根据 key 计算出 hashcode 。</li>\n<li>判断是否需要进行初始化。</li>\n<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>\n<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>\n<li>如果都不满足，则利用 synchronized 锁写入数据。</li>\n<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>\n</ol>\n<h3 id=\"4-get\"><a href=\"#4-get\" class=\"headerlink\" title=\"4. get\"></a>4. get</h3><p>get 流程比较简单，直接过一遍源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class=\"line\">    &#x2F;&#x2F; key 所在的 hash 位置</span><br><span class=\"line\">    int h &#x3D; spread(key.hashCode());</span><br><span class=\"line\">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class=\"line\">        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 如果指定位置元素存在，头结点hash值相同</span><br><span class=\"line\">        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class=\"line\">            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                &#x2F;&#x2F; key hash 值相等，key值相同，直接返回元素 value</span><br><span class=\"line\">                return e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (eh &lt; 0)</span><br><span class=\"line\">            &#x2F;&#x2F; 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span><br><span class=\"line\">            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class=\"line\">        while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 是链表，遍历查找</span><br><span class=\"line\">            if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class=\"line\">                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                return e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下 get 过程：</p>\n<ol>\n<li>根据 hash 值计算位置。</li>\n<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>\n<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>\n<li>如果是链表，遍历查找之。</li>\n</ol>\n<p>总结：</p>\n<p>总的来说 ConcruuentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><p>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>\n<p>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>\n<p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p>\n<h4 id=\"1-ConcurrentHashMap-和-Hashtable-的区别\"><a href=\"#1-ConcurrentHashMap-和-Hashtable-的区别\" class=\"headerlink\" title=\"1.ConcurrentHashMap 和 Hashtable 的区别\"></a>1.ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。底层数据结构： JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现，JDK1.8 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采⽤ 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的；实现线程安全的⽅式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和CAS 来操作。（JDK1.6以后对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。</p>\n<h4 id=\"2-synchronized关键字\"><a href=\"#2-synchronized关键字\" class=\"headerlink\" title=\"2.synchronized关键字\"></a>2.synchronized关键字</h4><p>解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p>\n<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。<strong>庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯</strong>对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。J<strong>DK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</strong></p>\n<h4 id=\"3-synchronized-关键字和-volatile-关键字区别\"><a href=\"#3-synchronized-关键字和-volatile-关键字区别\" class=\"headerlink\" title=\"3.synchronized 关键字和 volatile 关键字区别\"></a>3.synchronized 关键字和 volatile 关键字区别</h4><p>synchronized 关键字和 volatile 关键字是两个互补的存在，⽽不是对⽴的存在！</p>\n<p>volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定⽐ synchronized 关键字要好。但是volatile 关键字只能⽤于变量⽽ synchronized 关键字可以修饰⽅法以及代码块。<strong>volatile 关键字能保证数据的可⻅性，但</strong>不能保证数据的原⼦性。<strong>synchronized 关键字两者都能保证。</strong></p>\n<p>volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性</p>\n<p>⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>\n<h4 id=\"4-ConcurrentHashmap不支持key或者value为null\"><a href=\"#4-ConcurrentHashmap不支持key或者value为null\" class=\"headerlink\" title=\"4.ConcurrentHashmap不支持key或者value为null\"></a>4.ConcurrentHashmap不支持key或者value为null</h4><p>ConcurrentHashmap HashMap和Hashtable都是key-value存储结构，但他们有一个不同点是 ConcurrentHashmap、Hashtable不支持key或者value为null，而HashMap是支持的。为什么会有这个区别？在设计上的目的是什么？</p>\n<p>ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。</p>\n<p>key不能为空，因为采用了fail-safe机制，这种机制会使得读取的数据不一定是最新的，使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，HashTable同理。故在入参时，若为 null 就报空指针异常，而且在取hashcode时，压根就没考虑空的情况。</p>\n<pre><code>/** Implementation for put and putIfAbsent */\nfinal V putVal(K key, V value, boolean onlyIfAbsent) &#123;\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    ......\n&#125;</code></pre>\n","categories":["JUC"],"tags":["安全的Map"]},{"title":"某米一面视频面","url":"/2020-11-19-%E6%9F%90%E7%B1%B3%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91%E9%9D%A2.html","content":"<p>某米面试</p>\n<p>视频面：</p>\n<p>面试官网很卡，用的牛客视频面，上来就是两个算法题</p>\n<p>然后介绍自己的项目，说说项目的难点及解决方案</p>\n<p>讲一下Spring架构</p>\n<p>面试官在面试过程中一再说明基础很重要，并且要有解决难点的能力，求支</p>\n<p>多线程并发用到了哪种方式，线程之间的通信、同步一般怎么做</p>\n<p>线程和进程通讯的区别</p>\n<p>ArrayList、LinkedLIst区别</p>\n<p>设计模式：观察者</p>\n<p>堆、栈的区别</p>\n<h3 id=\"1-讲一下Spring架构\"><a href=\"#1-讲一下Spring架构\" class=\"headerlink\" title=\"1.讲一下Spring架构\"></a>1.讲一下Spring架构</h3><p>轻量<br>框架的大小和运行开销都是轻量级的<br>Spring是非侵入式框架：应用中的对象不依赖于Spring框架中的类。</p>\n<p>控制反转<br>通过IOC容器实现控制反转促进松耦合<br>将依赖关系的管理从Java对象中解放出来,交给IOC容器完成,实现对象之间的关系解耦<br>将原来对象-对象的个关系,转化为对象-IOC容器-对象的关系<br>依赖对象会被动的由容器实现装载，不需要对象自己完成创建</p>\n<p>面向切面<br>通过AOP,以动态和非侵入式的方式来增强服务功能<br>应用的业务逻辑与系统级服务相分离,提高内聚性<br>应用对象只需实现业务逻辑即可,无需负责其他系统级关注点,例如日志和事务支持</p>\n<p>容器<br>Spring的Bean容器,包含并管理应用对象的配置和生命周期<br>如:可配置bean如何被创建(单例,原型及类之间的依赖关系)</p>\n<p>框架<br>Spring可以将简单的组件配置、组合成为复杂的应用。<br>例如:Spring中,对象可以在一个XML文件里被声明式的组合<br>例如:Spring框架下实现多个子框架的组合:<br>    这些子框架之间可以彼此独立，也可以使用其它的框架方案加以代替，<br>Spring提供了很多基础功能(如:事务管理、持久化框架集成等),而开发者只需要关注应用逻辑的开发</p>\n<p>1、Spring Core：主要组件是BeanFactory，创建JavaBean的工厂，使用控制反转（IOC） 模式，将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>\n<p>2、Spring AOP：集成了面向切面的编程功能（AOP把一个业务流程分成几部分，例如权限检查、业务处理、日志记录，每个部分单独处理，然后把它们组装成完整的业务流程。每个部分被称为切面），可以将声明性事物管理集成到应用程序中。</p>\n<p>3、Spring context：一个核心配置文件，为Spring框架提供上下文信息。</p>\n<p>4、Spring dao：Spring操作数据库的模块。</p>\n<p>5、Spring ORM：Spring集成了各种orm（object relationship mapping 对象关系映射）框架的模块，集成mybatis</p>\n<p>6、Spring web：集成各种优秀的web层框架的模块（Struts、Springmvc）</p>\n<p>7、Spring web mvc：Spring web层框架</p>\n<h3 id=\"2-进程之间的通信\"><a href=\"#2-进程之间的通信\" class=\"headerlink\" title=\"2.进程之间的通信\"></a>2.进程之间的通信</h3><p>进程间通信又称<code>IPC(Inter-Process Communication)</code>,指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:</p>\n<ul>\n<li>低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)</li>\n<li>高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等)。</li>\n</ul>\n<p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p>\n<ol>\n<li>管道/匿名管道(Pipes) ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。</li>\n<li>有名管道(Names Pipes) : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘⽂件的⽅式存在，可以实现本机任意两个进程通信。</li>\n<li>信号(Signal) ：信号是⼀种⽐较复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；</li>\n<li>消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字 节流以及缓冲区⼤⼩受限等缺。</li>\n<li>信号量(Semaphores) ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</li>\n<li>共享内存(Shared memory) ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。</li>\n<li>套接字(Sockets) : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持TCP/IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h3 id=\"3-线程之间的通信\"><a href=\"#3-线程之间的通信\" class=\"headerlink\" title=\"3.线程之间的通信\"></a>3.线程之间的通信</h3><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>\n<p><strong>① 锁机制</strong></p>\n<p>互斥锁、条件变量、读写锁和自旋锁。</p>\n<ul>\n<li><code>互斥锁</code>确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。</li>\n<li><code>读写锁</code>当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。</li>\n<li><code>条件变量</code>可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\n<li><code>自旋锁</code>上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。</li>\n</ul>\n<p><strong>② 信号量机制(Semaphore)</strong></p>\n<p>包括无名线程信号量和命名线程信号量。线程的信号和进程的信号量类似，使用线程的信号量可以高效地完成基于线程的资源计数。信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。</p>\n<p><strong>③ 信号机制(Signal)</strong></p>\n<p>类似进程间的信号处理。</p>\n<p><strong>④ violate全局变量-共享内存</strong></p>\n<p>关于violate可以参考博文：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQvYXJ0aWNsZS9kZXRhaWxzLzg1MzE4MDc1\">多线程并发之volatile的底层实现原理<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><strong>⑤ wait/notify</strong></p>\n<p>阻塞/唤醒，关于这个参考博文：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQvYXJ0aWNsZS9kZXRhaWxzLzUyNzAwNDEz\">Thread入门与线程方法详解及多线程安全<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<h3 id=\"4-多线程\"><a href=\"#4-多线程\" class=\"headerlink\" title=\"4.多线程\"></a>4.多线程</h3><p><strong>01知识点汇总</strong></p>\n<p><img data-src=\"https://pic2.zhimg.com/80/v2-65315ef1db4e1baa4720e095f6cca761_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>多线程协作时，因为对资源的锁定与等待会产生死锁，需要了解产生死锁的四个基本条件，要明白竞争条件与临界区的概念，知道通过破坏造成死锁的4个条件来防止死锁。</p>\n<p>除了了解进程间的通信方式，还要知道线程的通信方式，通信主要指线程之间的协作机制，例如Wait、Notify</p>\n<p>另外需要知道Java为多线程提供的一些机制，例如Threadlocal用来保存线程独享的数据，Fork/Foin机制用于大任务的分割与汇总，Volatile对多线程数据可见性的保证以及线程的中断机制。</p>\n<p>其他还有: Threadlocal的实现机制。Fork/Join的工作窃取算法等内容。</p>\n<p><strong>02</strong>知识点详解</p>\n<p><strong>1、详解-线程的状态转换</strong></p>\n<p>先介绍线程状态转换。</p>\n<p>线程是Jvm执行任务的最小单元，理解线程的状态转换是理解后续多线程问题的基础。</p>\n<p>第一个详解知识点介绍线程状态转换。</p>\n<p>在Jvm运行中，线程一共有New、Runnable、Blocked、Waiting、Timed_waiting、Terminated六种状态，这些状态对应Thread.State枚举类中的状态。</p>\n<p>当创建一个线程的时候，线程处在New状态，运行Thread的Start方法后，线程进入Runnable可运行状态。</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-78af03b97e138fb44d14ce4ce273d21a_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>这个时候，所有可运行状态的线程并不能马上运行，而是需要先进入就绪状态等待线程调度，如图中间的Ready状态。在获取到Cpu后才能进入运行状态，如图中的Running。运行状态可以随着不同条件转换成除New以外的其他状态。</p>\n<p>先看左边，在运行态中的线程进入Synchronized同步块或者同步方法时，如果获取锁失败，则会进入到Blocked状态。当获取到锁后，会从Blocked状态恢复到就绪状态。</p>\n<p>再看右边，运行中的线程还会进入等待状态，这两个等待一个是有超时时间的等待，例如调用Object.wait、Thread.join等。另外一个时无超时的等待，例如调用Thread.join或者Locksupport.park。</p>\n<p>这两种等待都可以通过Notify或Unpark结束等待状态恢复到就绪状态。</p>\n<p>最后是线程运行完成结束时，如图下方，线程状态变成Terminated</p>\n<p><strong>2、详解-CAS与ABA问题</strong></p>\n<p>解决线程同步与互斥的主要方式是Cas、Synchronized、和Lock。</p>\n<p>Cas是属于乐观锁的一种实现，是一种轻量级锁，Juc中很多工具类的实现就是基于Cas。</p>\n<p>Cas操作是线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。</p>\n<p>比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。</p>\n<p>Cas容易出现Aba问题，如果线程T1读取值A之后，发生过两次写入，先由线程T2写回了b，又由T3写回了A，此时T1在写回比较时，值还是A，就无法判断是否发生过修改。</p>\n<p>Aba问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳。Juc工具包中提供了这样的类。</p>\n<p><strong>3、详解-Synchronized</strong></p>\n<p>Synchronized是最常用的线程同步手段之一，它是如何保证同一时刻只有一个线程可以进入临界区呢？</p>\n<p>我们知道Synchronized是对对象进行加锁，在Jvm中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向Monitor对象的起始地址。当Monitor被某个线程持有后，就会处于锁定状态，Owner部分会指向持有Monitor对象的线程。另外Monitor中还有两个队列，用来存放进入及等待获取锁的线程。</p>\n<p>Synchronized应用在方法上时，在字节码中是通过方法的AccCC_Synchronized标志来实现的，Synchronized应用在同步块上时，在字节码中是通过Monitorenter和Monitorexit实现的。</p>\n<p>针对Synchronized获取锁的方式，Jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一线程再次获取锁，如果失败，就升级为Cas轻量级锁，如果再失败会短暂自旋，防止线程被系统挂起。最后如果以上都失败就是升级为重量级锁。</p>\n<p><strong>4、详解-Aqs与Lock</strong></p>\n<p>在介绍Lock前，先介绍Aqs，也就是队列同步器，这是实现Lock的基础。</p>\n<p>Aqs有一个State标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。</p>\n<p>当获得锁的线程需要等待某个条件时，会进入Condition的等待队列，等待队列可以有多个。</p>\n<p>当Condition条件满足时，线程会从等待队列重新进入到同步队列进行获取锁的竞争。</p>\n<p>Reentrantlock就是基于Aqs实现的，Reentrantlock内部有公平锁和非公平锁两种实现，差别就在于新来的线程会不会比已经在同步队列中的等待线程更早获得锁。</p>\n<p>和Reentrantlock实现方式类似，Semaphore也是基于aqs，差别在于Reentrantlock是独占锁，Semaphore是共享锁。</p>\n<p><strong>5、详解-线程池</strong></p>\n<p>线程池通过复用线程，避免线程频繁创建和销毁。</p>\n<p>Java的Executors工具类中，提供了5种类型线程池的创建方法，它们的特点和适用场景如下：</p>\n<p><strong>第1种是：固定大小线程池</strong>，特点是线程数固定，使用无界队列，适用于任务数量不均匀的场景、对内存压力不敏感，但系统负载比较敏感的场景；</p>\n<p><strong>第2种是：Cached线程池</strong>，特点是不限制线程数，适用于要求低延迟的短期任务场景；</p>\n<p><strong>第3种是：单线程线程池</strong>，也就是一个线程的固定线程池，适用于需要异步执行但需要保证任务顺序的场景；</p>\n<p><strong>第4种是：Scheduled线程池</strong>，适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式；</p>\n<p><strong>第5种是：工作窃取线程池</strong>，使用的ForkJoinPool，是固定并行度的多任务队列，适合任务执行时长不均匀的场景。</p>\n<p><strong>6、详解-线程池参数介绍</strong></p>\n<p>前面提到的线程池，除了工作窃取线程池外，都是通过ThreadPoolExecutor的不同初始化参数来创建的。</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-19cb3e86c1812d7c1d98ac7b35e72956_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>第1个参数：</strong>设置核心线程数。默认情况下核心线程会一直存活。</p>\n<p><strong>第2个参数：</strong>设置最大线程数。决定线程池最多可以创建的多少线程。</p>\n<p><strong>第3个参数和第4个参数：</strong>用来设置线程空闲时间，和空闲时间的单位，当线程闲置超过空闲时间就会被销毁。可以通过AllowCoreThreadTimeOut方法来允许核心线程被回收。</p>\n<p><strong>第5个参数：</strong>设置缓冲队列，图中左下方的三个队列是设置线程池时常使用的缓冲队列。其中Array Blocking Queue是一个有界队列，就是指队列有最大容量限制。Linked Blocking Queue是无界队列，就是队列不限制容量。最后一个是Synchronous Queue，是一个同步队列，内部没有缓冲区。</p>\n<p><strong>第6个参数：</strong>设置线程池工厂方法，线程工厂用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的Group、线程名、优先级等。一般使用默认工厂类即可。</p>\n<p><strong>第7个参数：</strong>设置线程池满时的拒绝策略。如右下角所示有四种策略，abort策略在线程池满后，提交新任务时会抛出Rejected Execution Exception，这个也是默认的拒绝策略。</p>\n<p>Discard策略会在提交失败时对任务直接进行丢弃。CallerRuns策略会在提交失败时，由提交任务的线程直接执行提交的任务。Discard Oldest策略会丢弃最早提交的任务。</p>\n<p><strong>■前面的5种线程池都是使用怎样的参数来创建的呢？</strong></p>\n<p>固定大小线程池创建时核心和最大线程数都设置成指定的线程数，这样线程池中就只会使用固定大小的线程数。队列使用无界队列Linked Blocking Queue。</p>\n<p>Single线程池就是线程数设置为1的固定线程池。Cached线程池的核心线程数设置为0，最大线程数是Integer.Max_Value，主要是通过把缓冲队列设置成SynchronousQueue，这样只要没有空闲线程就会新建。scheduled线程池与前几种不同的是使用了Delayed Work Queue，这是一种按延迟时间获取任务的优先级队列。</p>\n<p><strong>7、详解-线程池执行流程</strong></p>\n<p>我们向线程提交任务时可以使用Execute和Submit，区别就是Submit可以返回一个Future对象，通过Future对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。Submit最终也是通过Execute执行的。</p>\n<p><strong>线程池提交任务时的执行顺序如下：</strong></p>\n<p>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</p>\n<ul>\n<li>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</li>\n<li>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</li>\n<li>如果已经达到了最大线程数，则执行指定的拒绝策略。这里需要注意队列的判断与最大线程数判断的顺序，不要搞反。</li>\n</ul>\n<p><strong>8、详解-JUC工具类</strong></p>\n<p>前面基础知识部分已经提到过，Juc是Java提供的用于多线程处理的工具类库，其中的常用工具类的作用如下：</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-0eff7d812a12f5b88cfbd71652aa2222_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>第一行的类都是基本数据类型的原子类：包括Atomicboolean、Atomiclong、Atomicinteger类。</p>\n<p>AtomicLong通过Unsafe类实现，基于Cas。Unsafe类是底层工具类，Juc中很多类的底层都使用到了Unsafe包中的功能。Unsafe类提供了类似C的指针操作，提供Cas等功能。Unsafe类中的所有方法都是Native修饰的；</p>\n<p>另外Longadder等四个类是Jdk1.8中提供的更高效的操作类。LongAdder基于Cell实现，使用分段锁思想，是一种空间换时间的策略，更适合高并发场景；</p>\n<p>LongAccumulator提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。</p>\n<p>第二行中的类提供了对对象的原子读写功能，后两个类Atomic Stamped Reference和Atomic Markable Reference是用来解决我们前面提到的Abs问题，分别基于时间戳和标记位来解决。</p>\n<p><strong>9、详解-JUC2</strong></p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-be70189f84bf14ce5957080bf4903912_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>这一页表格中，第一行的类主要是锁相关的类，例如我们前面介绍过的Reentrant重入锁。<br>与Reentrant Lock的独占锁不同，Semaphore是共享锁，允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如100个车辆要使用20个停车位，那么最多允许20个车占用停车位。</p>\n<p>Stamped Lock是1.8改进的读写锁，是使用一种Clh的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。</p>\n<p>第二行中主要是异步执行相关的类，这里可以重点了解jdk1.8中提供的CompletableFuture，可以支持流式调用，可以方便的进行多Future的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便的设置完成时间。</p>\n<p>另外一个是1.7中提供的ForkJoinPool，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。ForkJoinPool的特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。</p>\n<p><strong>10、详情-JUC3</strong></p>\n<p><img data-src=\"https://pic4.zhimg.com/80/v2-251dd271af2975a82836d6c64cb26e87_720w.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>表格中第一行是常用的阻塞队列，刚才讲解线程池时已经简单介绍过了，这里在补充一点，Linked Blocking Deque是双端队列，也就是可以分别从队头和队尾操作入队、出队。<br>而Array Blocking Queue单端队列，只能从队尾入队，队头出队。</p>\n<p>第二行是控制多线程协作时使用的类。其中Count Down Latch实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。</p>\n<p>Cyclic Barrier可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。</p>\n<p>Semaphore前面已经介绍过，用来控制对共享资源的访问并发度。</p>\n<p>最后一行是比较常用的两个集合类，可以了解一下Copy On Write ArrayList，Cow通过在写入数据时进行Copy修改，然后在更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。</p>\n<p><strong>03面试考察点</strong></p>\n<p><strong>第1点：</strong>是要理解线程的同步与互斥的原理，包括临界资源、临界区的概念，知道重量级锁、轻量级锁、自旋锁、偏向锁、重入锁、读写锁的概念。</p>\n<p><strong>第2点：</strong>要掌握线程安全相关机制，例如 Cas、Synchronized、Lock三种同步方式的实现原理、要明白Threadlocal是每个线程独享的局部变量，了解Threadlocal使用弱引用的ThreadLocalMap保存不同的Threadlocal变量。</p>\n<p><strong>第3点：</strong>要了解Juc中的工具类的使用场景与主要的几种工具类的实现原理，例如Reentrantlock，Concurrenthashmap、Longadder等实现方式</p>\n<p><strong>第4点：</strong>要熟悉线程池的原理、使用场景、常用配置，例如大量短期任务的场景适合使用Cached线程池；系统资源比较紧张时，可以选择固定线程池。</p>\n<p>另外注意慎用无界队列，可能会有Oom的风险。</p>\n<p><strong>第5点：</strong>要深刻理解线程的同步与异步、阻塞与非阻塞，同步和异步的区别是任务是否是同一个线程执行，阻塞与非阻塞的区别是异步执行任务时，线程是不是会阻塞等待结果，还是会继续执行后续逻辑。</p>\n<p><strong>04面试加分项</strong></p>\n<p>掌握了上面这些内容，如果能做到这几点加分项，一定会给面试官留下更好的印象。</p>\n<p><strong>第1点：</strong>是可以结合实际项目经验或者实际案例介绍原理，例如介绍线程池设置时，可以提到自己的项目中有一个需要高吞吐量的场景，使用了Cached的线程池。</p>\n<p><strong>第2点：</strong>如果有过解决多线程问题的经验或者排查思路的话会获得面试加分</p>\n<p><strong>第3点：</strong>能够熟悉常用的线程分析工具与方法，例如会用Jstack分析线程的运行状态，查找锁对象持有状况等</p>\n<p><strong>第4点：</strong>了解Java8对Juc工具类做了哪些增强，例如提供了Longadder来替换Atomiclong，更适合并发度比较高的场景。</p>\n<p><strong>最后，</strong>可以了解一下Reactive异步编程思想，了解Back Pressure背压的概念与应用场景。</p>\n<p>相信研究完以上内容，你会对并发与多线程有一定了解，从容准备面试，祝你拿到心仪Offer。</p>\n<h3 id=\"5-堆栈区别\"><a href=\"#5-堆栈区别\" class=\"headerlink\" title=\"5.堆栈区别\"></a>5.堆栈区别</h3><p> Java把内存划分成两种：一种是堆内存，一种是栈内存。</p>\n<p>堆：主要用于存储实例化的对象，数组。由JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以共享数据的。</p>\n<p>栈：主要用于存储局部变量和对象的引用变量，每个线程都会有一个独立的栈空间，所以线程之间是不共享数据的。</p>\n<p>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p>\n<p>堆内存用来存放由new创建的对象和数组。  在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p>\n<p>二、栈与堆的共同点和优缺点</p>\n<p>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p>\n<p>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p>\n<p>Java中的数据类型有两种。</p>\n<p>一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。</p>\n<p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。</p>\n<p>假设我们同时定义<br> int a = 3; int b = 3；<br> 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。<br> 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p>\n<p>另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显式地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p>\n<p>三、Java堆和栈的区别</p>\n<p>java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别</p>\n<p>1、各司其职<br> 最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>\n<p>2、独有还是共享<br> 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>\n<p>3、异常错误<br> 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br> 而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p>\n<p>4、空间大小<br> 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。</p>\n<p>你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。</p>\n<p>这就是Java中堆和栈的区别。理解好这个问题的话，可以对你解决开发中的问题，分析堆内存和栈内存使用，甚至性能调优都有帮助。</p>\n<p>四、JVM中的堆和栈<br> JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. 从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p>\n<p>每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程 共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。<br> Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java <img data-src=\"https://img.javatt.com/18/184543bd25712d1e8ed8fc46149fb7b5.png\" alt=\"这里写图片描述\" loading=\"lazy\"></p>\n<p>会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</p>\n","categories":["面试"],"tags":["应届面试"]},{"title":"redis缓存中数据和数据库中数据不一致的解决办法","url":"/2020-11-24-redis%E7%BC%93%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html","content":"<h2 id=\"为什么会发生数据库和缓存数据的不一致问题。\"><a href=\"#为什么会发生数据库和缓存数据的不一致问题。\" class=\"headerlink\" title=\"为什么会发生数据库和缓存数据的不一致问题。\"></a>为什么会发生数据库和缓存数据的不一致问题。</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</p>\n<h3 id=\"1-一性是什么，一致性包含了以下两种：\"><a href=\"#1-一性是什么，一致性包含了以下两种：\" class=\"headerlink\" title=\"1. 一性是什么，一致性包含了以下两种：\"></a>1. 一性是什么，一致性包含了以下两种：</h3><ol>\n<li>缓存中有数据，那么数据库的数据必须要和缓存的数据要一致。</li>\n<li>缓存中没有数据，在数据库值必须要是最新的数据。</li>\n</ol>\n<p>不符合以上两种情况的数据就是发生了数据不一致问题，对于读写缓存来说，就会发生这样的问题，此时我们要需要相应的策略去做做同步还是异步：</p>\n<ol>\n<li>同步写回策略：就是写入缓存时，必须要写入数据库，保证数据一致性。</li>\n<li>异步写回策略：想写入缓存，等到缓存失效或者淘汰的时候，再写入数据库，此时如果还没有写入数据库，缓存就挂了，这样数据就会丢失，数据库就没有最新的值了。</li>\n</ol>\n<p>对于读写缓存来说，要想数据一致性就要采用同步写回策略，如果数据不是必要的数据，可以采用数据的异步写回策略，比如电商商品的非重要参数。<br>如果我们采用同步写回策略，就要保证写入缓存和数据的数据能到保证原子性，也就是说，缓存和数据的数据要同时增删改，一起更新或者都不更新。</p>\n<h3 id=\"2-删除数据怎么保Redis和数据库的一致性问题\"><a href=\"#2-删除数据怎么保Redis和数据库的一致性问题\" class=\"headerlink\" title=\"2. 删除数据怎么保Redis和数据库的一致性问题\"></a>2. 删除数据怎么保Redis和数据库的一致性问题</h3><p>数据删除时，先选择删除数据库还是先选择缓存。 </p>\n<h4 id=\"一、选择先删除数据库。\"><a href=\"#一、选择先删除数据库。\" class=\"headerlink\" title=\"一、选择先删除数据库。\"></a>一、选择先删除数据库。</h4><ol>\n<li>当我们删除数据的时候，先选择删除数据库，后选择删除缓存时，会在一定事件内发生数据不一致问题，比如线程A和B还有其他，A在删除数据数据的时候，B和其他线程来读取数据，这个时候，B和其他线程会读取到旧值，当A线程删除完成删除缓存后就可以消除读取旧值问题。这个会造成一小段时间内会读取到旧值。</li>\n<li>当我们删除数据的时候，先选择删除数据库，在删除缓存时，删除缓存失败了，会造成旧数据一直会读取。比如线程A和B还有其他，A在删除数据库成功了，A和其他线程删除缓存失败。就会造成B和其他线程一直在读取旧值。<strong>解决方法选择删除数据库的时候，通过消息中间件MQ或者Kafka发送一条删除指令，在数据库删除完成之后启动一个线程去删除缓存，如果删除失败一直做删除操作，一直到删除成功。</strong></li>\n</ol>\n<h4 id=\"二、选择先删除缓存。\"><a href=\"#二、选择先删除缓存。\" class=\"headerlink\" title=\"二、选择先删除缓存。\"></a>二、选择先删除缓存。</h4><ol>\n<li>当我们删除数据的时候，先选择删除缓存，后选择删除数据库，会导致缓存出问题，比如线程A和B还有其他线程，A线程删除了缓存，还没有来及删除数据库（比如网络延迟），此时B和其他线程来读取消息，会发生缓存中没有数据，就会去数据库查询数据，数据库中的值还是以前的值，这样会造成缓存被重新更新为旧值，解决方法：<strong>可以使用缓存双删，可以把线程A休眠一段时间，这个时间是B线程读取数据被把数据写到缓存中的时间，这个时间还需要开发者在测试中找到比较准确的时间，来设置这个A线程的休眠时间。</strong></li>\n<li>当我们删除数据的时候，先选择删除缓存，后选择删除数据库时删除失败了，这样会造成缓存数据一直在数据库没有被删除，导致一直读取的时旧值，<strong>这样可以通过消息中间件去操作，直到数据库更新成功，在去删除缓存，这样的实现用到了缓存双删和消息中间件。</strong></li>\n</ol>\n<h4 id=\"三，自我认为还是选择先删除数据库在去删缓存。\"><a href=\"#三，自我认为还是选择先删除数据库在去删缓存。\" class=\"headerlink\" title=\"三，自我认为还是选择先删除数据库在去删缓存。\"></a>三，自我认为还是选择先删除数据库在去删缓存。</h4><ol>\n<li> 首先如果删除缓存，缓存缺失，会给数据库带来一定的压力。</li>\n<li> 如果业务中读数据和写缓存的时间控制的不好设置，那么双删的等待时间就不好设置。</li>\n</ol>\n<h4 id=\"四，如果业务中必须要准确的数据，保证数据一致性。\"><a href=\"#四，如果业务中必须要准确的数据，保证数据一致性。\" class=\"headerlink\" title=\"四，如果业务中必须要准确的数据，保证数据一致性。\"></a>四，如果业务中必须要准确的数据，保证数据一致性。</h4><ol>\n<li>当删除数据库的值时，其他客户端短暂把并发请求暂存，等数据库删除和缓存更新之后再去发起请求，从而保证数据的一致性。这样下来并发就减小了。</li>\n</ol>\n<h3 id=\"3-添加数据怎么保证Redis和数据库的一致性问题\"><a href=\"#3-添加数据怎么保证Redis和数据库的一致性问题\" class=\"headerlink\" title=\"3. 添加数据怎么保证Redis和数据库的一致性问题\"></a>3. 添加数据怎么保证Redis和数据库的一致性问题</h3><h4 id=\"一、选择先添加数据库。\"><a href=\"#一、选择先添加数据库。\" class=\"headerlink\" title=\"一、选择先添加数据库。\"></a>一、选择先添加数据库。</h4><ol>\n<li>当把数据先添加数据库时，添加缓存的操作出了问题，下一次查询数据导致缓存中没有数据，对数据库的压力较大。</li>\n</ol>\n<h4 id=\"二、选择先添加缓存。\"><a href=\"#二、选择先添加缓存。\" class=\"headerlink\" title=\"二、选择先添加缓存。\"></a>二、选择先添加缓存。</h4><ol>\n<li>当把数据先添加缓存时，添加数据库的操作出了问题，我们可以采用Mq或Kafka消息中间件发送添加指令，直到数据添加到数据库，则结束操作。</li>\n</ol>\n<h3 id=\"4-修改数据怎么保Redis和数据库的一致性问题\"><a href=\"#4-修改数据怎么保Redis和数据库的一致性问题\" class=\"headerlink\" title=\"4. 修改数据怎么保Redis和数据库的一致性问题\"></a>4. 修改数据怎么保Redis和数据库的一致性问题</h3><h4 id=\"一-选择先更新数据库，对于读写缓存的读写并发操作\"><a href=\"#一-选择先更新数据库，对于读写缓存的读写并发操作\" class=\"headerlink\" title=\"一.选择先更新数据库，对于读写缓存的读写并发操作\"></a>一.选择先更新数据库，对于读写缓存的读写并发操作</h4><ol>\n<li>当先更新数据到新数据库时，数据库更新完毕后，在更新缓存，当缓存更新失败，会导致访问命中的缓存一直都是旧值，直到这个缓存失效或者淘汰，才能得到新的数据。</li>\n<li>比如A和B其他线程，A线程更新数据库，数据库更新数据完毕后，更新缓存，当缓存更新失败，B和其他线程就会一直读取旧值，直到此数据失效或者淘汰之后，才能读取到新的值。</li>\n</ol>\n<h4 id=\"二-选择先更新缓存，对于读写缓存的读写并发操作\"><a href=\"#二-选择先更新缓存，对于读写缓存的读写并发操作\" class=\"headerlink\" title=\"二.选择先更新缓存，对于读写缓存的读写并发操作\"></a>二.选择先更新缓存，对于读写缓存的读写并发操作</h4><ol>\n<li>当先更新数据到缓存，数据更新完毕之后，在更新数据库，此时数据库跟新失败，会导致访问命中的缓存是最新值，当数据失效或者淘汰之后再去读取数据，还是读取的数据库的旧值，这样数据就会不一致。比如A和B其他线程，A线程先去更新缓存的值时，更新数据库的值失败之后，B和其他线程读取的时最新的数据，等到数据失效，B和其他线程读取的值就是旧值。</li>\n</ol>\n<p>解决以上两种修改操作，我们可以利用消息中间件可以做到，当失败了一直等到数据一致，保证数据库能更新，和缓存数据能够写进去，和删除的效果是一致的。</p>\n<h4 id=\"三-选择先更新数据库，对于读写缓存的写写并发操作\"><a href=\"#三-选择先更新数据库，对于读写缓存的写写并发操作\" class=\"headerlink\" title=\"三.选择先更新数据库，对于读写缓存的写写并发操作\"></a>三.选择先更新数据库，对于读写缓存的写写并发操作</h4><ol>\n<li>当先更新数据到数据库时，有两个线程A和B线程时，当A线程去修改数据库，B线程也去修改数据库，B线程去修改缓存，A线程在去修改缓存，会造成数据不一致问题。</li>\n</ol>\n<h4 id=\"四-选择先更新缓存，对于读写缓存的写写并发操作\"><a href=\"#四-选择先更新缓存，对于读写缓存的写写并发操作\" class=\"headerlink\" title=\"四.选择先更新缓存，对于读写缓存的写写并发操作\"></a>四.选择先更新缓存，对于读写缓存的写写并发操作</h4><ol>\n<li>当先更新数据到缓存时，有两个线程A和B线程时，当A线程去修改缓存，B线程也去修改缓存，B线程去修改数据库，A线程在去修改数据库，会造成数据不一致问题。</li>\n</ol>\n<p>解决以上两种方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。</p>\n<p>综上使用读写缓存读写并发的时候，可以使用消息中间件来维护数据不一致问题，在读写模式下对业务造成的影响不是很大。当使用读写缓存写写并发的时候，可以使用加分布式锁来维护数据不一致问题。</p>\n<p>另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。</p>\n<h3 id=\"5-具体解决办法\"><a href=\"#5-具体解决办法\" class=\"headerlink\" title=\"5.具体解决办法\"></a>5.具体解决办法</h3><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。</p>\n<p><strong>缓存和数据库一致性解决方案</strong></p>\n<h4 id=\"第一种方案：采用延时双删策略（双淘汰策略）\"><a href=\"#第一种方案：采用延时双删策略（双淘汰策略）\" class=\"headerlink\" title=\"第一种方案：采用延时双删策略（双淘汰策略）\"></a><strong>第一种方案：采用延时双删策略（双淘汰策略）</strong></h4><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>\n<p><strong>1.具体的步骤就是：</strong></p>\n<ol>\n<li>先删除缓存</li>\n<li>再写数据库</li>\n<li>休眠（一定的时间）毫秒：</li>\n<li>再次删除缓存</li>\n</ol>\n<p><strong>2.确定休眠时间</strong></p>\n<p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保<strong>读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。</p>\n<p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p>\n<h5 id=\"3-设置缓存过期时间\"><a href=\"#3-设置缓存过期时间\" class=\"headerlink\" title=\"3.设置缓存过期时间\"></a>3.设置缓存过期时间</h5><p>从理论上来说，给<strong>缓存设置过期时间，是保证最终一致性的解决方案</strong>。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p>\n<h5 id=\"4-该方案的弊端\"><a href=\"#4-该方案的弊端\" class=\"headerlink\" title=\"4.该方案的弊端\"></a>4.该方案的弊端</h5><p>结合<strong>双删策略+缓存超时</strong>设置，这样最差的情况就是在<strong>超时时间内数据存在不一致，而且又增加了写请求的耗时</strong>。</p>\n<h4 id=\"第二种方案：异步更新缓存-基于订阅binlog的同步机制\"><a href=\"#第二种方案：异步更新缓存-基于订阅binlog的同步机制\" class=\"headerlink\" title=\"第二种方案：异步更新缓存(基于订阅binlog的同步机制)\"></a><strong>第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></h4><p><strong>技术整体思路：</strong></p>\n<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>\n<p>1）读Redis：热数据基本都在Redis</p>\n<p>2）写MySQL:增删改都是操作MySQL</p>\n<p>3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis</p>\n<p>3.1）数据操作主要分为两大块：</p>\n<ul>\n<li>一个是全量(将全部数据一次写入到redis)</li>\n</ul>\n<ul>\n<li>一个是增量（实时更新）</li>\n</ul>\n<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>\n<p>3.2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p>\n<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>\n<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>\n<p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p>\n<p>最后： 我的理解是多个线程的读或写操作都放进了队列，这样可以保证写库并且删了缓存之后再执行下一个线程的读操作，通过这种方式保证了操作的原子性，另外只要异步消息处理的足够快，那么是不会有问题的</p>\n<h3 id=\"6-推荐解决方案\"><a href=\"#6-推荐解决方案\" class=\"headerlink\" title=\"6.推荐解决方案\"></a>6.推荐解决方案</h3><h4 id=\"一-解决不一致两种方法\"><a href=\"#一-解决不一致两种方法\" class=\"headerlink\" title=\"一.解决不一致两种方法:\"></a>一.解决不一致两种方法:</h4><ol>\n<li><p>CAP理论(Cache Aside Pattern):<strong>缓存</strong>+<strong>数据库</strong>读写的模式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</span><br><span class=\"line\">2.更新的时候，先更新数据库，然后再删除缓存。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>读<strong>请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"二-CAP为什么是删除缓存，而不是更新缓存\"><a href=\"#二-CAP为什么是删除缓存，而不是更新缓存\" class=\"headerlink\" title=\"二.CAP为什么是删除缓存，而不是更新缓存\"></a>二.CAP为什么是删除缓存，而不是更新缓存</h4><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p>\n<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p>\n<p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？</p>\n<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>\n<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p>\n<h4 id=\"三-CAP可能会出现上述的数据库-缓存不一致的情况\"><a href=\"#三-CAP可能会出现上述的数据库-缓存不一致的情况\" class=\"headerlink\" title=\"三.CAP可能会出现上述的数据库+缓存不一致的情况\"></a>三.CAP可能会出现上述的数据库+缓存不一致的情况</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了</p>\n<h5 id=\"解决方案如下：\"><a href=\"#解决方案如下：\" class=\"headerlink\" title=\"解决方案如下：\"></a>解决方案如下：</h5><p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。</p>\n<p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>\n<p>这里有一个<strong>优化点</strong>，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>\n<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>\n<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>\n<h5 id=\"高并发的场景下，该解决方案要注意的问题：\"><a href=\"#高并发的场景下，该解决方案要注意的问题：\" class=\"headerlink\" title=\"高并发的场景下，该解决方案要注意的问题：\"></a>高并发的场景下，该解决方案要注意的问题：</h5><ul>\n<li><p>读请求长时阻塞<br>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p>\n<p>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p>\n<p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每隔库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。</p>\n<p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p>\n<p>如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p>\n<p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p>\n</li>\n<li><p>读请求并发量过高<br>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p>\n<p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p>\n</li>\n<li><p>多服务实例部署的请求路由<br>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，<strong>都通过 Nginx 服务器路由到相同的服务实例上</strong>。<br>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p>\n</li>\n<li><p>热点商品的路由问题，导致请求的倾斜<br>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>\n</li>\n</ul>\n","categories":["redis"],"tags":["数据不一致"]},{"title":"Java中的锁概念等","url":"/2021-03-19-java%E4%B8%AD%E7%9A%84%E9%94%81.html","content":"<h2 id=\"一、java中关于锁的问题\"><a href=\"#一、java中关于锁的问题\" class=\"headerlink\" title=\"一、java中关于锁的问题\"></a>一、java中关于锁的问题</h2><h3 id=\"1、锁涉及的几个重要概念\"><a href=\"#1、锁涉及的几个重要概念\" class=\"headerlink\" title=\"1、锁涉及的几个重要概念\"></a>1、锁涉及的几个重要概念</h3><h4 id=\"1-1死锁\"><a href=\"#1-1死锁\" class=\"headerlink\" title=\"1.1死锁\"></a>1.1死锁</h4><p>线程之间相互等着对方释放资源，而自己的资源又不释放给别人，这种情况就是死锁。所以，只要其中一线程释放了资源，死锁就会被解除。</p>\n<h4 id=\"1-2可重入锁\"><a href=\"#1-2可重入锁\" class=\"headerlink\" title=\"1.2可重入锁\"></a>1.2可重入锁</h4><p>重入锁指的是，一个线程在拥有了当前资源的锁之后，可以再次拿到该锁而不被阻塞。</p>\n<h4 id=\"1-3自旋锁\"><a href=\"#1-3自旋锁\" class=\"headerlink\" title=\"1.3自旋锁\"></a>1.3自旋锁</h4><p>自旋锁指的是，线程在没有获得锁时，不是被直接挂起，而是执行一个空循环while（自旋）。默认是循环10次。</p>\n<blockquote>\n<p>自旋锁的目的 ：为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。</p>\n<p>如果锁被另一个线程长时间占用，即使自旋了之后当前线程还是会被挂起，空循环就会变成浪费系统资源的操作，反而降低了整体性能。所以，自旋锁是不适应锁占用时间长的并发情况的。</p>\n</blockquote>\n<h4 id=\"1-4自适应自旋锁\"><a href=\"#1-4自适应自旋锁\" class=\"headerlink\" title=\"1.4自适应自旋锁\"></a>1.4自适应自旋锁</h4><p>自旋锁为了解决浪费系统资源，有了自适应自旋锁，这是是对自旋锁的一种优化。当一个线程自旋后成功获得了锁，那么下次自旋的次数就会增加。因为虚拟机认为，既然上次自旋期间成功拿到了锁，那么后面的自旋会有很大几率拿到锁。相反，如果对于某个锁，很少有自旋能够成功获得的，那么后面就会减少自旋次数，甚至省略掉自旋过程，以免浪费处理器资源。 <strong>这种锁是默认开启的。</strong></p>\n<h4 id=\"1-5偏向锁\"><a href=\"#1-5偏向锁\" class=\"headerlink\" title=\"1.5偏向锁\"></a>1.5偏向锁</h4><p>偏向锁指的是，当第一个线程请求时，会判断锁的对象头里的ThreadId字段的值，如果为空，则让该线程持有偏向锁，并将ThreadId的值置为当前线程ID。当前线程再次进入时，如果线程ID与ThreadId的值相等，则该线程就不会再重复获取锁了。因为锁的请求与释放是要消耗系统资源的。</p>\n<blockquote>\n<p>如果有其他线程也来请求该锁，则偏向锁就会撤销，然后升级为轻量级锁。如果锁的竞争十分激烈，则轻量级锁又会升级为重量级锁。这里涉及到一系列锁升级。</p>\n</blockquote>\n<h4 id=\"1-6锁粗化\"><a href=\"#1-6锁粗化\" class=\"headerlink\" title=\"1.6锁粗化\"></a>1.6锁粗化</h4><p>锁粗化指的是，在编译期间将相邻的同步代码块合并成一个大同步块。这样做可以减少反复申请和释放同一个锁对象导致的系统开销。<strong>锁粗化也是默认开启的。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">粗化前伪代码：</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(monitor)&#123;</span><br><span class=\"line\">    method1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(monitor)&#123;</span><br><span class=\"line\">    method2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">粗化后伪代码：</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(monitor)&#123;</span><br><span class=\"line\">    method1();</span><br><span class=\"line\">    method2();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>锁粗化也提醒了我们平时写代码时，尽量不要在循环内使用锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 粗化前</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这会导致频繁同步代码，无谓的消耗系统资源</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(monitor)&#123;</span><br><span class=\"line\">        doSomething...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 粗化后</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(monitor)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++)&#123;    </span><br><span class=\"line\">        doSomething...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-7类锁和对象锁（非常重要-自己可以跑一下代码示例，下面各种情况都已测试）\"><a href=\"#1-7类锁和对象锁（非常重要-自己可以跑一下代码示例，下面各种情况都已测试）\" class=\"headerlink\" title=\"1.7类锁和对象锁（非常重要 自己可以跑一下代码示例，下面各种情况都已测试）\"></a>1.7类锁和对象锁（非常重要 自己可以跑一下代码示例，下面各种情况都已测试）</h4><p><strong>（需要细细品：涉及加锁的范围，特别容易被忽视 而导致自己加了锁，但和自己逾期的结果不符）</strong></p>\n<p>如果你分不清类锁和对象锁，那你在代码中对于锁的使用和分析就很容易出问题。</p>\n<p><strong>对象锁占用的资源是对象级别，类锁占有的资源是类级别。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class A &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对象锁：普通实例方法默认同步监视器就是this，</span></span><br><span class=\"line\">    <span class=\"comment\">// 即调用该方法的对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"title\">methodB</span><span class=\"params\">()</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"comment\">// 对象锁：this表示是对象锁</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 类锁：修饰静态方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">methodC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">methodD</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类锁：A.class说明是类锁</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(A.class)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 普通方法：任何情况下调用时，都不会发生竞争</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">common</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>methodA,和methodB都是对当前对象加锁，即如果有两个线程同时访问同一个对象的methoA或methodB会发生竞争。如果两个线程访问的是不同对象的methodA和methodB则不会发生竞争。</p>\n</li>\n<li><p>methodC和methodD是对类加锁，即如果两个线程同时访问同一个对象的methodC和methodD会发生竞争，且两个线程同时访问不同对象的methodC和methodD是也会发生竞争。</p>\n</li>\n<li><p>如果一个线程访问methodA或methodB，另一个线程访问methodC或methodD，则这两个线程不会发生竞争。因为一个是类锁另一个是对象锁。类锁和对象锁是两个不一样的锁，控制着不同的区域，它们互不干扰。</p>\n</li>\n</ol>\n<p>下面测试用例证明上述定义说明都是正确的，代码为证！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestSynchronized</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">minus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">5</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; - &quot;</span> + count);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">minus_</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (TestSynchronized.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = <span class=\"number\">5</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; - &quot;</span> + count);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">minus2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">5</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; - &quot;</span> + count);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestSynchronized t1 = <span class=\"keyword\">new</span> TestSynchronized();</span><br><span class=\"line\">        TestSynchronized t2 = <span class=\"keyword\">new</span> TestSynchronized();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus2();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;1&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t2.minus2();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;2&quot;</span>).start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus2();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;1&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus2();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;2&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            TestSynchronized.minus();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;1&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            TestSynchronized.minus();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;2&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus2();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;1&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            TestSynchronized.minus();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;2&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus_();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;a&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus_();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;b&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t1.minus_();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;a&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            t2.minus_();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;b&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>5种类锁示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#125;Class A &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 普通字符串属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String val;</span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object staticObj;</span><br><span class=\"line\"><span class=\"comment\">// ==&gt;类锁情况1：synchronized修饰静态方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">methodB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ==&gt;类锁情况2：同步块里的对象是类</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(A.class)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">methodC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ==&gt;类锁情况3：同步块里的对象是字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"string\">&quot;A&quot;</span>)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">methodD</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ==&gt;类锁情况4：同步块里的对象是静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(staticObj)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">methodE</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ==&gt;类锁情况5：同步块里的对象是字符串属性</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(val)&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>补充：<br>两个线程分别访问一个类的静态synchronized和一个静态不加锁方法时，不阻塞。<br>两个线程分别访问一个类的静态synchronized和一个非静态synchronized方法时，不阻塞。</p>\n<h3 id=\"2、synchronized实现原理\"><a href=\"#2、synchronized实现原理\" class=\"headerlink\" title=\"2、synchronized实现原理\"></a>2、synchronized实现原理</h3><p>临界区：被同步保护的代码区域。也就是下面字节码中monitorenter和monitorexit指令之间的区域。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">synchronizedTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; synchronizedTest&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述同步代码块对应的字节码：</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\20190629225407674.png\" alt=\"20190629225407674\" loading=\"lazy\"></p>\n<p>在字节码中，位置3处有个monitorenter就是申请锁的指令，位置19处有个monitorexit就是释放锁的指令。</p>\n<p>监视锁monitor ：是每个对象都有的一个隐藏字段。申请锁成功之后，monitor就会成为当前线程的唯一持有者。线程第一次执行monitorenter指令后，monitor的值由0变为1。当该线程再次遇到monitorenter指令后，就会将monitor继续累加1。这也是synchronized实现重入锁的原理。</p>\n<p>我们知道，JVM会有指令重排序的操作。Java会在位置3和位置4之间插入一个获取屏障，在位置18和19之间插入一个释放屏障，这两个屏障保证临界区内的任何操作都不会被指令重排序到临界区之外。加上锁的排他性，临界区内的操作便具有了原子性。</p>\n<p>在monitorexit指令后还会插入一个StoreLoad屏障，该屏障保证了monitorenter和monitorexit指令是成对不混乱的，从而保证了synchronized既可并列又可嵌套。</p>\n<p><strong>总结：</strong></p>\n<p>同步操作的实现，需要给对象关联一个互斥体，这个互斥体就可以叫做锁。</p>\n<p>锁的作用是，保证同一竞争资源在同一时刻只会有一个线程占有。</p>\n<p>Java中锁的实现方式有两种：synchronized关键字和并发包中的锁类。</p>\n<p>锁的优化策略有：锁消除、锁偏向、自适应自旋锁、锁粗化。</p>\n<p>尽量不要在循环内使用锁，以减少资源消耗。</p>\n<h4 id=\"2-1synchronized锁的优化\"><a href=\"#2-1synchronized锁的优化\" class=\"headerlink\" title=\"2.1synchronized锁的优化\"></a>2.1synchronized锁的优化</h4><p>Java中<code>Synchronized</code>是我们常用的<code>同步互斥手段</code>，在早期版本中，它是一个<code>悲观锁</code>设计下的<code>独占锁</code>，并且<code>可重入</code>。<code>Synchronized在获取到同步锁后，其他线程将会阻塞，对于阻塞或者唤醒一个线程都需要操作系统来完成，这就需要从用户态切换到内核态，这样的操作就需要消耗很多处理器时间，具有很强的性能损耗</code>，因此Synchronized在<strong>1.6</strong>中做了很多的优化，减少频繁的切换到内核态。</p>\n<p>在1.6之中为了提高Synchronized的性能，增加了<code>自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等来高效地共享数据，解决竞争问题</code>。<br><code>自旋锁</code>:在多线程操作中共享数据的锁定可能是和短暂的，避免线程在很短的时间内做用户态的切换，那么在允许多线程并行的基础上，让后面请求锁的线程“等待一下”，等待过程不放弃处理器的执行时间，为了让线程等待只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br><code>自适应自旋</code>是对自旋锁的优化，自旋锁的缺点就是如果锁占用的时间很长，那么就会浪费处理器资源，并且还对处理器有要求。加入自适应自旋就是自旋的时间不再固定，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态决定，如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋很可能再次成功，应此可能允许等待时间更长；如果某一个锁上，很少自旋成功，那么将跳过自旋过程，避免资源浪费。虚拟机使用这一的策略和技术完成对Synchronized的一种优化</p>\n<p><code>锁消除</code>是指在虚拟机及时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除如：消除锁的判断主要来于逃逸分析的数据支持，如果判断在一段代码中，堆上的数据都不会逃逸出去从而被其他线程访问到，那么就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁就自热无效</p>\n<h3 id=\"3、Java锁的种类\"><a href=\"#3、Java锁的种类\" class=\"headerlink\" title=\"3、Java锁的种类\"></a>3、Java锁的种类</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">公平锁&#x2F;非公平锁</span><br><span class=\"line\">可重入锁</span><br><span class=\"line\">独享锁&#x2F;共享锁</span><br><span class=\"line\">互斥锁&#x2F;读写锁</span><br><span class=\"line\">乐观锁&#x2F;悲观锁</span><br><span class=\"line\">分段锁</span><br><span class=\"line\">偏向锁&#x2F;轻量级锁&#x2F;重量级锁</span><br><span class=\"line\">自旋锁</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\20190505195114634.jpeg\" alt=\"20190505195114634\" loading=\"lazy\"></p>\n<p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p>\n<h4 id=\"3-1、公平锁-非公平锁\"><a href=\"#3-1、公平锁-非公平锁\" class=\"headerlink\" title=\"3.1、公平锁/非公平锁\"></a>3.1、公平锁/非公平锁</h4><p>公平锁和非公平锁主要是关于等待的线程的排队的问题，这个排队要利AQS（AbstractQueuedSynchronizer）。</p>\n<p>公平锁 ：是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁 ： 是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁（true|false），默认是非公平锁 false。非公平锁的优点在于吞吐量比公平锁大。<br>对于synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>\n<h5 id=\"什么是AQS？\"><a href=\"#什么是AQS？\" class=\"headerlink\" title=\"什么是AQS？\"></a>什么是AQS？</h5><p>AQS定义两种资源共享⽅式</p>\n<p><strong>Exclusive（独占）</strong>：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：</p>\n<ul>\n<li><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p>\n</li>\n<li><p>⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的</p>\n</li>\n</ul>\n<p><strong>Share（共享）</strong>：多个线程可同时执⾏，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后⾯讲到。</p>\n<p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：</p>\n<p><img data-src=\"/../../../../../SoftwareInstallation/Typora/file/%E8%AE%B0%E4%BA%8B%E6%9C%AC/pictures/9d182d944e0889c304ef529ba50a4fcd205214.png\" alt=\"img\" loading=\"lazy\"></p>\n<blockquote>\n<p>我们以重入锁（ReentrantLock）为例解释AQS。AQS由三个部分组成，</p>\n<p>State：当前线程锁的个数。<br>exclusiveOwerThread：当前占有锁的线程 。<br>CLH队列等待运行的线程。<br>线程1 CAS算法A=V(state)=0，修改state的值为1<br>线程1又想获取锁，此时A=V(state)=1，state再加1,无论A想获得多少次，只是state+1<br>线程2 进行CAS比较，发现A不等于V，并且发现state不等于0，直接到CLH列队中等待。<br>线程3和线程4也一样到CLH队列中等待。如果先来的线程先排队，获取锁的优先权，则为公平锁。如果，无视等待队列，直接尝试获取锁。</p>\n<p>队列如果已经满了，该怎么办呢？</p>\n<p>无法进入队列的线程，进入ArrayBlockingQueue,等队列有空位再进入队列。</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\20190505204255694.jpeg\" alt=\"20190505204255694\" loading=\"lazy\"></p>\n</blockquote>\n<h4 id=\"3-2、可重入锁\"><a href=\"#3-2、可重入锁\" class=\"headerlink\" title=\"3.2、可重入锁\"></a>3.2、可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。对于Java ReentrantLock而言, 其名字是Reentrant Lock即是重新进入锁。对于synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">setA</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    setB();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">setB</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p>\n<h4 id=\"3-3、独享锁-共享锁\"><a href=\"#3-3、独享锁-共享锁\" class=\"headerlink\" title=\"3.3、独享锁/共享锁\"></a>3.3、独享锁/共享锁</h4><p>独享锁：是指该锁一次只能被一个线程所持有；</p>\n<p>共享锁：是指该锁可被多个线程所持有。</p>\n<p>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁,读锁的共享锁可保证并发读是非常高效的，读写、写读 、写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>\n<p>对于synchronized而言，当然是独享锁。</p>\n<h4 id=\"3-4、互斥锁-读写锁\"><a href=\"#3-4、互斥锁-读写锁\" class=\"headerlink\" title=\"3.4、互斥锁/读写锁\"></a>3.4、互斥锁/读写锁</h4><p>上面说到的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁 就是独享锁/共享锁具体的实现。</p>\n<p>互斥锁：在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p>\n<p>互斥锁在Java中的具体实现就是ReentrantLock；</p>\n<p>读写锁在Java中的具体实现就是ReadWriteLock。</p>\n<h4 id=\"3-5、乐观锁-悲观锁\"><a href=\"#3-5、乐观锁-悲观锁\" class=\"headerlink\" title=\"3.5、乐观锁/悲观锁\"></a>3.5、乐观锁/悲观锁</h4><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p>\n<p>悲观锁 ：认为自己在使用数据的时候，一定有别的线程来修改数据，在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>锁实现：关键字synchronized、接口Lock的实现类。</p>\n<p>使用的场景：写操作较多，先加锁可以保证写操作是数据正确。</p>\n<p>乐观锁：认为自己在使用数据的时候不会有其他的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。<br>锁实现：java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。</p>\n<p>使用场景：读操作较多，不加锁的特点能够使其读操作的性能大幅提升</p>\n<h4 id=\"3-6、分段锁\"><a href=\"#3-6、分段锁\" class=\"headerlink\" title=\"3.6、分段锁\"></a>3.6、分段锁</h4><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个HashMap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取HashMap全局信息的时候，就需要获取所有的分段锁才能统计。</p>\n<p>分段锁的设计目的是 细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>\n<h4 id=\"3-7、偏向锁-轻量级锁-重量级锁\"><a href=\"#3-7、偏向锁-轻量级锁-重量级锁\" class=\"headerlink\" title=\"3.7、偏向锁/轻量级锁/重量级锁\"></a>3.7、偏向锁/轻量级锁/重量级锁</h4><p>这三种锁是指锁的状态，并且是针对synchronized。在Java 5通过引入锁升级的机制来实现高效synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>\n<p><strong>偏向锁</strong> ：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>\n<p><strong>轻量级锁</strong> ：是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>\n<p><strong>重量级锁</strong> ：是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\20210308160236835.png\" alt=\"20210308160236835\" loading=\"lazy\"></p>\n<h4 id=\"3-8、自旋锁\"><a href=\"#3-8、自旋锁\" class=\"headerlink\" title=\"3.8、自旋锁\"></a>3.8、自旋锁</h4><p>是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断判断是否能够被成功获取，自旋知道获取到锁才会退出循环。自旋是通过CAS算法进行的。何为CAS算法呢？</p>\n<h5 id=\"3-8-1-CAS\"><a href=\"#3-8-1-CAS\" class=\"headerlink\" title=\"3.8.1 CAS\"></a>3.8.1 CAS</h5><p>CAS(compare and swap)：比较和交换，顾名思义就是先进行比较然后在进行交换。这里比较和交换是线程中的数据和内存中的数据之间的操作。</p>\n<blockquote>\n<p>JAVA对CAS的支持：</p>\n<p>在JDK1.5中新增java.util.concurrent包就是建立在CAS之上的。相对于对于synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以java.util.concurrent在性能上有了很大的提升。</p>\n<p>以java.util.concurrent包中的AtomicInteger为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解 getAndIncrement方法，该方法的作用相当于 ++i 操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value; </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = get();  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = current + <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSet(current, next))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>线程1和线程2都读取内存中的数据V赋值给A<br>线程1把V的值由0改为了1，并想把修改后的值写回到内存<br>线程1将A的值和V的值进行比较<br>两者相等，说明没有线程对V的值进行修改，直接把修改后的值（B=1）写入内存，此时，V=1。<br>线程2进行将A的值和V的值进行比较<br>两者不相等，说明有线程对V的值进行修改，此时线程2不能够把修改后的值写入内存，因为它获得的A的值不是最新的，由A得到的B的值也可能是错误的。线程2会读取A的值，重新计算出B的值，再尝试重新写入，如果还是不相等在继续尝试，不断的自旋。</p>\n<p>如下图所示：</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\20190505201114825.jpeg\" alt=\"20190505201114825\" loading=\"lazy\"></p>\n<h5 id=\"3-8-2-ABA问题\"><a href=\"#3-8-2-ABA问题\" class=\"headerlink\" title=\"3.8.2 ABA问题\"></a>3.8.2 ABA问题</h5><p>我们发现CAS算法存在一个非常明显的缺陷，那就是ABA问题。何为ABA问题呢？</p>\n<p>如下图所示:线程1线程2 线程3 都获取A=V=0  </p>\n<p>线程1修改V的值为1 写入内存<br>线程2 把v的值改为2，但是没来的及写入，线程3 就开始运行<br>线程3 将V的值改为0 写入内存<br>线程2 比较A和V的值发现A=V，他自认为没有其他的线程对V进行修改，因而忽略了A-&gt;B-&gt;A的过程，形成了ABA问题。</p>\n<p><strong>ABA的问题解决方法很简单：AtomicStampedReference在变量前面添加版本号，每次变量更新的时候都把版本号加一。</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\20190505202907828.jpeg\" alt=\"20190505202907828\" loading=\"lazy\"></p>\n<p>我们知道自旋是会消耗CPU资源的（不断循环），为什么不用阻塞的方式使等待的线程停止工作呢？原因有两个</p>\n<p>（1）同步代码块逻辑简单情况下，自旋消耗的资源时很少的（在同步代码块逻辑简单的情况下，用自旋是比较合适的）</p>\n<p>（2）最为关键的原因是阻塞与唤醒线程需要操作系统切换CPU状态，需要消耗一定的时间（CPU上下文切换）</p>\n<h5 id=\"那么为什么阻塞和唤醒线程会消耗大量时间呢？\"><a href=\"#那么为什么阻塞和唤醒线程会消耗大量时间呢？\" class=\"headerlink\" title=\"那么为什么阻塞和唤醒线程会消耗大量时间呢？\"></a>那么为什么阻塞和唤醒线程会消耗大量时间呢？</h5><p>因为线程的阻塞唤醒涉及大量的步骤，我们以线程阻塞为例进行说明</p>\n<p>步骤1：线程1获取CPU时间片执行</p>\n<p>步骤2：线程1被阻塞，上下文切换</p>\n<p>步骤3：线程2抢占CPU时间片执行</p>\n<p>步骤2涉及两个子步骤：</p>\n<p>步骤2.1 从用户态切换到内核态</p>\n<p>为什么要进行这种切换呢？</p>\n<p>用户是没有权限对内存进行操作，我们要切换到内核态才有权对内存进行操作。</p>\n<p>步骤2.2 把线程1的状态保存到PCB(内存)</p>\n<p>我们到底要保存线程的哪些信息呢？</p>\n<p>一个线程在运行时的内存模型主要有5个部分组成：</p>\n<p>（1）程序计数器：记录下一条指令的地址</p>\n<p>（2）虚拟机栈：保存函数的信息，例如，局部的变量，函数返回地址，操作数等</p>\n<p>（3）本地方法栈：和虚拟机栈类似，不过其保存的函数的信息是native函数</p>\n<p>（4）方法区：保存类的信息，静态变量等</p>\n<p>（5）堆：实例化的对象（堆是用户申请的（C语言中malloc函数），而栈是系统自动分配的）。很明显：程序计数器、虚拟机栈、方法区、堆等信息都会被保存到内存中。</p>\n<p>可见上下文切换是非常耗时的。</p>\n","categories":["java中的锁"],"tags":["锁"]},{"title":"Mysql中锁的相关问题","url":"/2021-03-24-Mysql%E4%B8%AD%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html","content":"<h2 id=\"Mysql中锁的相关问题\"><a href=\"#Mysql中锁的相关问题\" class=\"headerlink\" title=\"Mysql中锁的相关问题\"></a>Mysql中锁的相关问题</h2><h3 id=\"1-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁\"><a href=\"#1-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁\" class=\"headerlink\" title=\"1.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁\"></a>1.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁</h3><h4 id=\"（1）开销、加锁速度、死锁、粒度、并发性能\"><a href=\"#（1）开销、加锁速度、死锁、粒度、并发性能\" class=\"headerlink\" title=\"（1）开销、加锁速度、死锁、粒度、并发性能\"></a>（1）开销、加锁速度、死锁、粒度、并发性能</h4><ul>\n<li>表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</li>\n<li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li>\n<li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>引擎</th>\n<th>行锁</th>\n<th>表锁</th>\n<th>页锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MyISAM</td>\n<td></td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>InnoDB</td>\n<td>支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"（2）如何加表锁\"><a href=\"#（2）如何加表锁\" class=\"headerlink\" title=\"（2）如何加表锁\"></a>（2）如何加表锁</h4><p><strong>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p>\n<blockquote>\n<p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p>\n</blockquote>\n<p>给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(total) <span class=\"keyword\">from</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(subtotal) <span class=\"keyword\">from</span> order_detail;</span><br><span class=\"line\">这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Lock</span> <span class=\"keyword\">tables</span> orders <span class=\"keyword\">read</span> <span class=\"keyword\">local</span>, order_detail <span class=\"keyword\">read</span> <span class=\"keyword\">local</span>;</span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(total) <span class=\"keyword\">from</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(subtotal) <span class=\"keyword\">from</span> order_detail;</span><br><span class=\"line\"><span class=\"keyword\">Unlock</span> <span class=\"keyword\">tables</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要特别说明以下两点内容。</p>\n<ul>\n<li>上面的例子在Lock tables时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面的章节中还会进一步介绍。</li>\n<li>在用Lock tables给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行Lock tables后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</li>\n</ul>\n<p><strong>其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。</strong></p>\n<h4 id=\"（3）InnoDB锁问题\"><a href=\"#（3）InnoDB锁问题\" class=\"headerlink\" title=\"（3）InnoDB锁问题\"></a>（3）InnoDB锁问题</h4><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>\n<p>InnoDB的行锁模式及加锁方法</p>\n<p>InnoDB实现了以下两种类型的行锁。</p>\n<ul>\n<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>\n</li>\n<li><p>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>\n</li>\n<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>\n</li>\n<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>\n</li>\n</ul>\n<p>上述锁模式的兼容情况具体如下表所示。</p>\n<p> InnoDB行锁模式兼容性列表</p>\n<table>\n<thead>\n<tr>\n<th>请求锁模式  是否兼容当前锁模式</th>\n<th>X</th>\n<th>IX</th>\n<th>S</th>\n<th>IS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>X</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>冲突</td>\n</tr>\n<tr>\n<td>IX</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>冲突</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>S</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>IS</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n</tbody></table>\n<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>\n<p><strong>意向锁是InnoDB自动加的，不需用户干预</strong>。</p>\n<p><strong>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句,InnoDB不会加任何锁；</strong></p>\n<p>事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>\n<ul>\n<li>共享锁（S）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>排他锁（X)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name WHERE ... FOR UPDATE。</span><br></pre></td></tr></table></figure>\n\n<p>用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁。</p>\n<h5 id=\"InnoDB行锁实现方式\"><a href=\"#InnoDB行锁实现方式\" class=\"headerlink\" title=\"InnoDB行锁实现方式\"></a><strong>InnoDB行锁实现方式</strong></h5><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</p>\n<p>InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>\n<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。</p>\n<p><strong>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</strong></p>\n<p>a.在如下所示的例子中，开始tab_no_index表没有索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table tab_no_index(id int,name varchar(10)) engine=innodb;</span><br><span class=\"line\">Query OK, 0 rows affected (0.15 sec)</span><br><span class=\"line\">mysql&gt; insert into tab_no_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;);</span><br><span class=\"line\">Query OK, 4 rows affected (0.00 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class=\"line\"></span><br><span class=\"line\">ok的</span><br><span class=\"line\"></span><br><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class=\"line\"></span><br><span class=\"line\">session_2 等待 走的是表锁</span><br></pre></td></tr></table></figure>\n\n<p>在如上表所示的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下表所示。</p>\n<p>b.创建tab_with_index表，id字段有普通索引：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table tab_with_index(id int,name varchar(10)) engine=innodb;</span><br><span class=\"line\">Query OK, 0 rows affected (0.15 sec)</span><br><span class=\"line\">mysql&gt; alter table tab_with_index add index id(id);</span><br><span class=\"line\">Query OK, 4 rows affected (0.24 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<p>  InnoDB存储引擎的表在使用索引时使用行锁例子</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class=\"line\"></span><br><span class=\"line\">ok的</span><br><span class=\"line\"></span><br><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class=\"line\"></span><br><span class=\"line\">ok的</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。</strong></p>\n<p>在如下表所示的例子中，表tab_with_index的id字段有索引，name字段没有索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tab_with_index <span class=\"keyword\">drop</span> <span class=\"keyword\">index</span> <span class=\"keyword\">name</span>;</span><br><span class=\"line\">Query OK, 4 rows affected (0.22 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class=\"line\">mysql&gt; insert into tab_with_index  values(1,&#x27;4&#x27;);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| id   | name |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| 1    | 1    |</span><br><span class=\"line\">| 1    | 4    |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;1&#x27; for update;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;4&#x27; for update;</span><br><span class=\"line\">等待</span><br><span class=\"line\"></span><br><span class=\"line\">虽然session_2访问的是和session_1不同的记录，但是因为使用了相同的索引，所以需要等待锁：</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</strong></p>\n<p>在如下表所示的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; alter table tab_with_index add index name(name);</span><br><span class=\"line\">Query OK, 5 rows affected (0.23 sec)</span><br><span class=\"line\">Records: 5  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<p> InnoDB存储引擎的表使用不同索引的阻塞例子</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1 for update;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| id   | name |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| 1    | 1    |</span><br><span class=\"line\">| 1    | 4    |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">2 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">Session_2  使用<span class=\"keyword\">name</span>的索引访问记录，因为记录没有被索引，所以可以获得锁：</span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> tab_with_index <span class=\"keyword\">where</span> <span class=\"keyword\">name</span> = <span class=\"string\">&#x27;2&#x27;</span> <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| id   | name |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| 2    | 2    |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">Session_2 由于访问的记录已经被session_1锁定，所以等待获得锁。</span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> tab_with_index <span class=\"keyword\">where</span> <span class=\"keyword\">name</span> = <span class=\"string\">&#x27;4&#x27;</span> <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）</strong>即便在条件中使用了索引字段<strong>，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的</strong>，如果MySQL认为<strong>全表扫描</strong>效率更高，比如对一些很小的表，它就<strong>不会使用索引</strong>，这种情况下InnoDB将<strong>使用表锁，而不是行锁</strong>。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>\n<p>在下面的例子中，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。</p>\n<p>例子中tab_with_index表的name字段有索引，但是name字段是varchar类型的，如果where条件中不是和varchar类型进行比较，则会对name进行类型转换，而执行的全表扫描。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; alter table tab_no_index add index name(name);</span><br><span class=\"line\">Query OK, 4 rows affected (8.06 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class=\"line\">mysql&gt; explain select * from tab_with_index where name = 1 \\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">         id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: tab_with_index</span><br><span class=\"line\">         type: ALL   全表扫码</span><br><span class=\"line\">possible_keys: name</span><br><span class=\"line\">         key: NULL</span><br><span class=\"line\">      key_len: NULL</span><br><span class=\"line\">         ref: NULL</span><br><span class=\"line\">        rows: 4</span><br><span class=\"line\">        Extra: Using where</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\">mysql&gt; explain select * from tab_with_index where name = &#x27;1&#x27; \\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">          id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">       table: tab_with_index</span><br><span class=\"line\">        type: ref         用索引了</span><br><span class=\"line\">possible_keys: name</span><br><span class=\"line\">        key: name</span><br><span class=\"line\">      key_len: 23</span><br><span class=\"line\">        ref: const</span><br><span class=\"line\">       rows: 1</span><br><span class=\"line\">     Extra: Using where</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）间隙锁（Next-Key锁）\"><a href=\"#（4）间隙锁（Next-Key锁）\" class=\"headerlink\" title=\"（4）间隙锁（Next-Key锁）\"></a>（4）间隙锁（Next-Key锁）</h4><p>解决了mysql幻读的问题。</p>\n<p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</strong></p>\n<p>**a.**举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span>  emp <span class=\"keyword\">where</span> empid &gt; <span class=\"number\">100</span> <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br></pre></td></tr></table></figure>\n\n<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>\n<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其它事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p>\n<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>\n<p><strong>b.还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</strong></p>\n<p>在如下表所示的例子中，假如emp表中只有101条记录，其empid的值分别是1,2,......,100,101。</p>\n<p>InnoDB存储引擎的间隙锁阻塞例子</p>\n<table>\n<thead>\n<tr>\n<th>session_1</th>\n<th>session_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>当前session对不存在的记录加for update的锁：                                                                       mysql&gt; select * from emp where empid = 102 for update;</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>这时，如果其他session插入empid为102的记录（注意：这条记录并不存在），也会出现锁等待：                   mysql&gt;insert into emp(empid,...) values(102,...);阻塞等待</td>\n</tr>\n<tr>\n<td>Session_1 执行rollback：                                 mysql&gt; rollback;                                     Query OK, 0 rows affected (13.04 sec)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>由于其他session_1回退后释放了Next-Key锁，当前session可以获得锁并成功插入记录：                               mysql&gt;insert into emp(empid,...) values(102,...);                Query OK, 1 row affected (13.35 sec)</td>\n</tr>\n</tbody></table>\n<h4 id=\"（5）什么时候使用表锁\"><a href=\"#（5）什么时候使用表锁\" class=\"headerlink\" title=\"（5）什么时候使用表锁\"></a>（5）什么时候使用表锁</h4><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p>\n<ul>\n<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>\n<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>\n</ul>\n<p>当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。</p>\n<p>在InnoDB下，使用表锁要注意以下两点。</p>\n<p>（1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。有关死锁，下一小节还会继续讨论。</p>\n<p>（2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。正确的方式见如下语句：</p>\n<p>例如，如果需要写表t1并从表t读，可以按如下做：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">SET AUTOCOMMIT=0;</span><br><span class=\"line\">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class=\"line\">[do something with tables t1 and t2 here];</span><br><span class=\"line\">COMMIT;</span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","categories":["Mysql"],"tags":["锁"]},{"title":"某团春招一面","url":"/2021-04-06-%E7%BE%8E%E5%9B%A2%E6%98%A5%E6%8B%9B%E6%AD%BB%E4%BA%A11%E9%9D%A2.html","content":"<p>美团一面</p>\n<p>redis 为什么是单线程的<br>mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁<br>mysql下都有哪些数据结构，场景都用在哪里了<br>事物的回滚，a,b,c中a b成功了，c没成功，具体底层是怎么回滚的<br>事物的隔离级别<br>rpc框架通信的协议策略等，具体到可以解决哪个环节出现的问题<br>消息队列 具体是怎么削峰的（配置策略等），kafka把消息存在哪里，消息会溢出吗<br>hashtable 中写读、读写可以同时进行吗<br>层序遍历二叉树<br>定时任务的底层是怎么做到的<br>多线程中怎么抛出异常<br>java中都有什么锁，怎么实现加锁<br>软件工程学过吗，讲讲思想<br>机器开多少个多线程正常，比如说是和八核处理器，开多少个线程</p>\n<h3 id=\"1-redis-为什么是单线程的\"><a href=\"#1-redis-为什么是单线程的\" class=\"headerlink\" title=\"1.redis 为什么是单线程的\"></a>1.redis 为什么是单线程的</h3><p>首先要了解Redis的<strong>高并发和快速</strong>原因：</p>\n<p>1.redis是基于内存的，内存的读写速度非常快；</p>\n<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>\n<p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>\n<blockquote>\n<p>上下文切换线程:</p>\n<p>多线程编程中一般线程的个数都大于CPU核心的个数，而一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。<br>概括来说就是：当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。<br>Linux 相比与其他操作系统（包括其他类Unix系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n</blockquote>\n<p><strong>多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。</strong>因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。</p>\n<h3 id=\"2-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁\"><a href=\"#2-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁\" class=\"headerlink\" title=\"2.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁\"></a>2.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁</h3><h4 id=\"（1）开销、加锁速度、死锁、粒度、并发性能\"><a href=\"#（1）开销、加锁速度、死锁、粒度、并发性能\" class=\"headerlink\" title=\"（1）开销、加锁速度、死锁、粒度、并发性能\"></a>（1）开销、加锁速度、死锁、粒度、并发性能</h4><ul>\n<li>表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</li>\n<li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li>\n<li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>引擎</th>\n<th>行锁</th>\n<th>表锁</th>\n<th>页锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MyISAM</td>\n<td></td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>InnoDB</td>\n<td>支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"（2）如何加表锁\"><a href=\"#（2）如何加表锁\" class=\"headerlink\" title=\"（2）如何加表锁\"></a>（2）如何加表锁</h4><p><strong>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p>\n<blockquote>\n<p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p>\n</blockquote>\n<p>给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(total) <span class=\"keyword\">from</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(subtotal) <span class=\"keyword\">from</span> order_detail;</span><br><span class=\"line\">这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Lock</span> <span class=\"keyword\">tables</span> orders <span class=\"keyword\">read</span> <span class=\"keyword\">local</span>, order_detail <span class=\"keyword\">read</span> <span class=\"keyword\">local</span>;</span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(total) <span class=\"keyword\">from</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">sum</span>(subtotal) <span class=\"keyword\">from</span> order_detail;</span><br><span class=\"line\"><span class=\"keyword\">Unlock</span> <span class=\"keyword\">tables</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要特别说明以下两点内容。</p>\n<ul>\n<li>上面的例子在Lock tables时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面的章节中还会进一步介绍。</li>\n<li>在用Lock tables给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行Lock tables后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</li>\n</ul>\n<p><strong>其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。</strong></p>\n<h4 id=\"（3）InnoDB锁问题\"><a href=\"#（3）InnoDB锁问题\" class=\"headerlink\" title=\"（3）InnoDB锁问题\"></a>（3）InnoDB锁问题</h4><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p>\n<p>InnoDB的行锁模式及加锁方法</p>\n<p>InnoDB实现了以下两种类型的行锁。</p>\n<ul>\n<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>\n</li>\n<li><p>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>\n</li>\n<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>\n</li>\n<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>\n</li>\n</ul>\n<p>上述锁模式的兼容情况具体如下表所示。</p>\n<p> InnoDB行锁模式兼容性列表</p>\n<table>\n<thead>\n<tr>\n<th>请求锁模式  是否兼容当前锁模式</th>\n<th>X</th>\n<th>IX</th>\n<th>S</th>\n<th>IS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>X</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>冲突</td>\n</tr>\n<tr>\n<td>IX</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>冲突</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>S</td>\n<td>冲突</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>IS</td>\n<td>冲突</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n</tbody></table>\n<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>\n<p><strong>意向锁是InnoDB自动加的，不需用户干预</strong>。</p>\n<p><strong>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句,InnoDB不会加任何锁；</strong></p>\n<p>事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>\n<ul>\n<li>共享锁（S）：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>排他锁（X)：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name WHERE ... FOR UPDATE。</span><br></pre></td></tr></table></figure>\n\n<p>用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁。</p>\n<h5 id=\"InnoDB行锁实现方式\"><a href=\"#InnoDB行锁实现方式\" class=\"headerlink\" title=\"InnoDB行锁实现方式\"></a><strong>InnoDB行锁实现方式</strong></h5><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</p>\n<p>InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>\n<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。</p>\n<p><strong>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</strong></p>\n<p>a.在如下所示的例子中，开始tab_no_index表没有索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table tab_no_index(id int,name varchar(10)) engine=innodb;</span><br><span class=\"line\">Query OK, 0 rows affected (0.15 sec)</span><br><span class=\"line\">mysql&gt; insert into tab_no_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;);</span><br><span class=\"line\">Query OK, 4 rows affected (0.00 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class=\"line\"></span><br><span class=\"line\">ok的</span><br><span class=\"line\"></span><br><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class=\"line\"></span><br><span class=\"line\">session_2 等待 走的是表锁</span><br></pre></td></tr></table></figure>\n\n<p>在如上表所示的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下表所示。</p>\n<p>b.创建tab_with_index表，id字段有普通索引：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table tab_with_index(id int,name varchar(10)) engine=innodb;</span><br><span class=\"line\">Query OK, 0 rows affected (0.15 sec)</span><br><span class=\"line\">mysql&gt; alter table tab_with_index add index id(id);</span><br><span class=\"line\">Query OK, 4 rows affected (0.24 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<p>  InnoDB存储引擎的表在使用索引时使用行锁例子</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class=\"line\"></span><br><span class=\"line\">ok的</span><br><span class=\"line\"></span><br><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class=\"line\"></span><br><span class=\"line\">ok的</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。</strong></p>\n<p>在如下表所示的例子中，表tab_with_index的id字段有索引，name字段没有索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tab_with_index <span class=\"keyword\">drop</span> <span class=\"keyword\">index</span> <span class=\"keyword\">name</span>;</span><br><span class=\"line\">Query OK, 4 rows affected (0.22 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class=\"line\">mysql&gt; insert into tab_with_index  values(1,&#x27;4&#x27;);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| id   | name |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| 1    | 1    |</span><br><span class=\"line\">| 1    | 4    |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;1&#x27; for update;</span><br><span class=\"line\">session_2</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;4&#x27; for update;</span><br><span class=\"line\">等待</span><br><span class=\"line\"></span><br><span class=\"line\">虽然session_2访问的是和session_1不同的记录，但是因为使用了相同的索引，所以需要等待锁：</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</strong></p>\n<p>在如下表所示的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; alter table tab_with_index add index name(name);</span><br><span class=\"line\">Query OK, 5 rows affected (0.23 sec)</span><br><span class=\"line\">Records: 5  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<p> InnoDB存储引擎的表使用不同索引的阻塞例子</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">session_1</span><br><span class=\"line\">mysql&gt; select * from tab_with_index where id = 1 for update;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| id   | name |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| 1    | 1    |</span><br><span class=\"line\">| 1    | 4    |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">2 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">Session_2  使用<span class=\"keyword\">name</span>的索引访问记录，因为记录没有被索引，所以可以获得锁：</span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> tab_with_index <span class=\"keyword\">where</span> <span class=\"keyword\">name</span> = <span class=\"string\">&#x27;2&#x27;</span> <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| id   | name |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| 2    | 2    |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">Session_2 由于访问的记录已经被session_1锁定，所以等待获得锁。</span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> tab_with_index <span class=\"keyword\">where</span> <span class=\"keyword\">name</span> = <span class=\"string\">&#x27;4&#x27;</span> <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）</strong>即便在条件中使用了索引字段<strong>，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的</strong>，如果MySQL认为<strong>全表扫描</strong>效率更高，比如对一些很小的表，它就<strong>不会使用索引</strong>，这种情况下InnoDB将<strong>使用表锁，而不是行锁</strong>。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>\n<p>在下面的例子中，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。</p>\n<p>例子中tab_with_index表的name字段有索引，但是name字段是varchar类型的，如果where条件中不是和varchar类型进行比较，则会对name进行类型转换，而执行的全表扫描。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; alter table tab_no_index add index name(name);</span><br><span class=\"line\">Query OK, 4 rows affected (8.06 sec)</span><br><span class=\"line\">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class=\"line\">mysql&gt; explain select * from tab_with_index where name = 1 \\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">         id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: tab_with_index</span><br><span class=\"line\">         type: ALL   全表扫码</span><br><span class=\"line\">possible_keys: name</span><br><span class=\"line\">         key: NULL</span><br><span class=\"line\">      key_len: NULL</span><br><span class=\"line\">         ref: NULL</span><br><span class=\"line\">        rows: 4</span><br><span class=\"line\">        Extra: Using where</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\">mysql&gt; explain select * from tab_with_index where name = &#x27;1&#x27; \\G</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">          id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">       table: tab_with_index</span><br><span class=\"line\">        type: ref         用索引了</span><br><span class=\"line\">possible_keys: name</span><br><span class=\"line\">        key: name</span><br><span class=\"line\">      key_len: 23</span><br><span class=\"line\">        ref: const</span><br><span class=\"line\">       rows: 1</span><br><span class=\"line\">     Extra: Using where</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）间隙锁（Next-Key锁）\"><a href=\"#（4）间隙锁（Next-Key锁）\" class=\"headerlink\" title=\"（4）间隙锁（Next-Key锁）\"></a>（4）间隙锁（Next-Key锁）</h4><p>解决了mysql幻读的问题。</p>\n<p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</strong></p>\n<p>**a.**举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span>  emp <span class=\"keyword\">where</span> empid &gt; <span class=\"number\">100</span> <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;</span><br></pre></td></tr></table></figure>\n\n<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>\n<p><strong>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求</strong>，对于上面的例子，要是不使用间隙锁，如果其它事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p>\n<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>\n<p><strong>b.还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</strong></p>\n<p>在如下表所示的例子中，假如emp表中只有101条记录，其empid的值分别是1,2,......,100,101。</p>\n<p>InnoDB存储引擎的间隙锁阻塞例子</p>\n<table>\n<thead>\n<tr>\n<th>session_1</th>\n<th>session_2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>当前session对不存在的记录加for update的锁：                                                                       mysql&gt; select * from emp where empid = 102 for update;</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>这时，如果其他session插入empid为102的记录（注意：这条记录并不存在），也会出现锁等待：                   mysql&gt;insert into emp(empid,...) values(102,...);阻塞等待</td>\n</tr>\n<tr>\n<td>Session_1 执行rollback：                                 mysql&gt; rollback;                                     Query OK, 0 rows affected (13.04 sec)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>由于其他session_1回退后释放了Next-Key锁，当前session可以获得锁并成功插入记录：                               mysql&gt;insert into emp(empid,...) values(102,...);                Query OK, 1 row affected (13.35 sec)</td>\n</tr>\n</tbody></table>\n<h4 id=\"（5）什么时候使用表锁\"><a href=\"#（5）什么时候使用表锁\" class=\"headerlink\" title=\"（5）什么时候使用表锁\"></a>（5）什么时候使用表锁</h4><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p>\n<ul>\n<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>\n<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>\n</ul>\n<p>当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。</p>\n<p>在InnoDB下，使用表锁要注意以下两点。</p>\n<p>（1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。有关死锁，下一小节还会继续讨论。</p>\n<p>（2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。正确的方式见如下语句：</p>\n<p>例如，如果需要写表t1并从表t读，可以按如下做：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">SET AUTOCOMMIT=0;</span><br><span class=\"line\">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class=\"line\">[do something with tables t1 and t2 here];</span><br><span class=\"line\">COMMIT;</span><br><span class=\"line\">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-mysql下都有哪些数据结构，场景都用在哪里了\"><a href=\"#3-mysql下都有哪些数据结构，场景都用在哪里了\" class=\"headerlink\" title=\"3.mysql下都有哪些数据结构，场景都用在哪里了\"></a>3.mysql下都有哪些数据结构，场景都用在哪里了</h3><p>首先要知道Hash索引和B+树索引的底层实现原理:</p>\n<p>hash索引底层就是hash表，进行查找时,调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</p>\n<p>B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据。</p>\n<p>那么可以看出他们有以下的不同:</p>\n<ul>\n<li>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</li>\n</ul>\n<p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p>\n<ul>\n<li>hash索引不支持使用索引进行排序,原理同上.</li>\n<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.<strong>AAAA</strong>和<strong>AAAAB</strong>的索引没有相关性.</li>\n<li>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</li>\n<li>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</li>\n</ul>\n<p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p>\n<h4 id=\"聚簇索引与非聚簇索引的区别\"><a href=\"#聚簇索引与非聚簇索引的区别\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引的区别\"></a>聚簇索引与非聚簇索引的区别</h4><p> 在《数据库原理》里面，对聚簇索引的解释是: <strong>聚簇索引的顺序就是数据的物理存储顺序</strong>，聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p>\n<p>而对非聚簇索引的解释是:<strong>索引顺序与数据物理排列顺序无关。</strong></p>\n<p>正式因为如此，所以一个表最多只能有一个聚簇索引。聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是 索引节点，并保留一个链接指向对应 数据块。</p>\n<p>在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. <strong>在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.</strong></p>\n<p>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p>\n<h3 id=\"4-事物的回滚，a-b-c中a-b成功了，c没成功，具体底层是怎么回滚的\"><a href=\"#4-事物的回滚，a-b-c中a-b成功了，c没成功，具体底层是怎么回滚的\" class=\"headerlink\" title=\"4.事物的回滚，a,b,c中a b成功了，c没成功，具体底层是怎么回滚的\"></a>4.事物的回滚，a,b,c中a b成功了，c没成功，具体底层是怎么回滚的</h3><h3 id=\"5-机器开多少个多线程正常，比如说是和八核处理器，开多少个线程\"><a href=\"#5-机器开多少个多线程正常，比如说是和八核处理器，开多少个线程\" class=\"headerlink\" title=\"5.机器开多少个多线程正常，比如说是和八核处理器，开多少个线程\"></a>5.机器开多少个多线程正常，比如说是和八核处理器，开多少个线程</h3><p>根据一些大厂经验：具体还得需要根据实际机器进行测试调控</p>\n<p>CPU密集型：核心线程数 = CPU核数 + 1<br>IO密集型：核心线程数 = CPU核数 * 2+1<br>注：IO密集型（某大厂实践经验）<br>核心线程数 = CPU核数 / （1-阻塞系数）<br>例如阻塞系数 0.8，CPU核数为4，则核心线程数为20</p>\n<blockquote>\n<p><strong>CPU密集型（CPU-bound）</strong><br>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p>\n<p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p>\n<p><strong>IO密集型（I/O bound）</strong><br>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。</p>\n<p>I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p>\n</blockquote>\n","categories":["面试"],"tags":["应届面试"]},{"title":"动态规划","url":"/2020-11-07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html","content":"<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>\n<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p>\n<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>\n<h2 id=\"一、斐波那契数列\"><a href=\"#一、斐波那契数列\" class=\"headerlink\" title=\"一、斐波那契数列\"></a>一、斐波那契数列</h2><h3 id=\"1-爬楼梯\"><a href=\"#1-爬楼梯\" class=\"headerlink\" title=\"1. 爬楼梯\"></a>1. 爬楼梯</h3><ol start=\"70\">\n<li>Climbing Stairs (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>\n<p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p>\n<p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>\n<p>即dp[i] = dp[i-1] + dp[i-2]</p>\n<p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： <span class=\"number\">2</span></span><br><span class=\"line\">输出： <span class=\"number\">2</span></span><br><span class=\"line\">解释： 有两种方法可以爬到楼顶。</span><br><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"number\">1</span> 阶 + <span class=\"number\">1</span> 阶</span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"number\">2</span> 阶</span><br><span class=\"line\">    </span><br><span class=\"line\">输入： <span class=\"number\">3</span></span><br><span class=\"line\">输出： <span class=\"number\">3</span></span><br><span class=\"line\">解释： 有三种方法可以爬到楼顶。</span><br><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"number\">1</span> 阶 + <span class=\"number\">1</span> 阶 + <span class=\"number\">1</span> 阶</span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"number\">1</span> 阶 + <span class=\"number\">2</span> 阶</span><br><span class=\"line\"><span class=\"number\">3.</span>  <span class=\"number\">2</span> 阶 + <span class=\"number\">1</span> 阶    </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre2=<span class=\"number\">1</span>; <span class=\"keyword\">int</span> pre1=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur=pre2+pre1;</span><br><span class=\"line\">            pre2=pre1;</span><br><span class=\"line\">            pre1=cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-强盗抢劫\"><a href=\"#2-强盗抢劫\" class=\"headerlink\" title=\"2. 强盗抢劫\"></a>2. 强盗抢劫</h3><ol start=\"198\">\n<li>House Robber (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>\n<p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</p>\n<p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p>\n<p>dp[i]=max(dp[i-2]+dp[i],dp[i-1])</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">解释：偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">1</span>) ，然后偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">3</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">1</span> + <span class=\"number\">3</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">输入：[<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"number\">12</span></span><br><span class=\"line\">解释：偷窃 <span class=\"number\">1</span> 号房屋 (金额 = <span class=\"number\">2</span>), 偷窃 <span class=\"number\">3</span> 号房屋 (金额 = <span class=\"number\">9</span>)，接着偷窃 <span class=\"number\">5</span> 号房屋 (金额 = <span class=\"number\">1</span>)。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">2</span> + <span class=\"number\">9</span> + <span class=\"number\">1</span> = <span class=\"number\">12</span> 。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre1=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre2=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cur = Math.max(pre1+nums[i],pre2);</span><br><span class=\"line\">            pre1=pre2;</span><br><span class=\"line\">            pre2=cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-强盗在环形街区抢劫\"><a href=\"#3-强盗在环形街区抢劫\" class=\"headerlink\" title=\"3. 强盗在环形街区抢劫\"></a>3. 强盗在环形街区抢劫</h3><ol start=\"213\">\n<li>House Robber II (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，第一家和最后一家是连在一起的，求最大抢劫量。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：<span class=\"number\">3</span></span><br><span class=\"line\">解释：你不能先偷窃 <span class=\"number\">1</span> 号房屋（金额 = <span class=\"number\">2</span>），然后偷窃 <span class=\"number\">3</span> 号房屋（金额 = <span class=\"number\">2</span>）, 因为他们是相邻的。</span><br><span class=\"line\">    输入：nums = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">输入：nums = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]    </span><br><span class=\"line\">输出：<span class=\"number\">4</span></span><br><span class=\"line\">解释：你可以先偷窃 <span class=\"number\">1</span> 号房屋（金额 = <span class=\"number\">1</span>），然后偷窃 <span class=\"number\">3</span> 号房屋（金额 = <span class=\"number\">3</span>）。</span><br><span class=\"line\">     偷窃到的最高金额 = <span class=\"number\">1</span> + <span class=\"number\">3</span> = <span class=\"number\">4</span> 。</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">输入：nums = [<span class=\"number\">0</span>]</span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(rob(nums, <span class=\"number\">0</span>, n - <span class=\"number\">2</span>), rob(nums, <span class=\"number\">1</span>, n - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pre2 = <span class=\"number\">0</span>, pre1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur = Math.max(pre1, pre2 + nums[i]);</span><br><span class=\"line\">        pre2 = pre1;</span><br><span class=\"line\">        pre1 = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-信件错排\"><a href=\"#4-信件错排\" class=\"headerlink\" title=\"4. 信件错排\"></a>4. 信件错排</h3><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p>\n<p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>\n<ul>\n<li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li>\n<li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li>\n</ul>\n<p>综上所述，错误装信数量方式数量为：</p>\n<h2 id=\"二、矩阵路径\"><a href=\"#二、矩阵路径\" class=\"headerlink\" title=\"二、矩阵路径\"></a>二、矩阵路径</h2><h3 id=\"1-矩阵的最小路径和\"><a href=\"#1-矩阵的最小路径和\" class=\"headerlink\" title=\"1. 矩阵的最小路径和\"></a>1. 矩阵的最小路径和</h3><ol start=\"64\">\n<li>Minimum Path Sum (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小，且每次只能<strong>向右和向下</strong>移动，也就是求从矩阵的左上角到右下角的最小路径和。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出: <span class=\"number\">7</span></span><br><span class=\"line\">解释: 因为路径 <span class=\"number\">1</span>→<span class=\"number\">3</span>→<span class=\"number\">1</span>→<span class=\"number\">1</span>→<span class=\"number\">1</span> 的总和最小。</span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<p>由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>\n<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。<strong>由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</strong></p>\n<p>创建二维数组dp，与原始网格的大小相同，dp[i][j]表示从左上角出发到 (i,j)位置的最小路径和。显然，dp[0][0]=grid[0][0]。对于dp中的其余元素，通过以下状态转移方程计算元素值。</p>\n<p>当 i&gt;0 且j=0 时，dp[i][0]=dp[i-1][0]+grid[i][0]</p>\n<p>当i=0 且 j&gt;0 时，dp[0][j]=dp[0][j-1]+grid[0][j]</p>\n<p>当 i&gt;0 且 j&gt;0 时，dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]</p>\n<p>最后得到 dp[m-1][n-1] 的值即为从网格左上角到网格右下角的最小路径和。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minPathSum</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(grid==<span class=\"keyword\">null</span> &amp;&amp; grid.length==<span class=\"number\">0</span> &amp;&amp; grid[<span class=\"number\">0</span>].length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=grid.length; <span class=\"keyword\">int</span> m=grid[<span class=\"number\">0</span>].length;<span class=\"comment\">//注意二维数组取内的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][m];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>]=dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>]+grid[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j]=dp[<span class=\"number\">0</span>][j-<span class=\"number\">1</span>]+grid[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">                dp[i][j]=Math.min(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>])+grid[i][j];</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>][m-<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-矩阵的总路径数\"><a href=\"#2-矩阵的总路径数\" class=\"headerlink\" title=\"2. 矩阵的总路径数\"></a>2. 矩阵的总路径数</h3><ol start=\"62\">\n<li>Unique Paths (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p>\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p>解释：我们令 dp[i][j] 是到达 i, j 最多路径动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]，注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>\n<p>时间复杂度：O(m*n)O(m∗n)</p>\n<p>空间复杂度：O(m * n)O(m∗n)</p>\n<p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> dp[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">             dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">             dp[<span class=\"number\">0</span>][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">                 dp[i][j]=dp[i][j-<span class=\"number\">1</span>]+dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> dp[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    <span class=\"comment\">//优化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[]= <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);<span class=\"comment\">//填充数组中的数都为1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">               dp[j]+=dp[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                        <span class=\"comment\">//相当于我们每次只需要 dp[i-1][j],dp[i][j-1],哪[4][3]举例</span></span><br><span class=\"line\">                             <span class=\"comment\">//i=1 j=1 dp[1]=1+1=2</span></span><br><span class=\"line\">                             <span class=\"comment\">//     j=2 dp[2]=1+2=3</span></span><br><span class=\"line\">                             <span class=\"comment\">//i=2 j=1 dp[1]=2+1=3</span></span><br><span class=\"line\">                             <span class=\"comment\">//    j=2 dp[2]=3+3=6</span></span><br><span class=\"line\">                             <span class=\"comment\">//i=3 j=1 dp[1]=3+1=4</span></span><br><span class=\"line\">                             <span class=\"comment\">//    j=2 dp[2]=6+4=10</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三、数组区间\"><a href=\"#三、数组区间\" class=\"headerlink\" title=\"三、数组区间\"></a>三、数组区间</h2><h3 id=\"1-数组区间和\"><a href=\"#1-数组区间和\" class=\"headerlink\" title=\"1. 数组区间和\"></a>1. 数组区间和</h3><ol start=\"303\">\n<li>Range Sum Query - Immutable (Easy)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LWltbXV0YWJsZS9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LWltbXV0YWJsZS9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums = [-<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">2</span>, -<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">sumRange(<span class=\"number\">0</span>, <span class=\"number\">2</span>) -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">sumRange(<span class=\"number\">2</span>, <span class=\"number\">5</span>) -&gt; -<span class=\"number\">1</span></span><br><span class=\"line\">sumRange(<span class=\"number\">0</span>, <span class=\"number\">5</span>) -&gt; -<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：本题提供了有参的构造方法和调用方法，首先我们传进一个数组，然后输入数组的下标索引（初始，结束）包括本身，如果是（0，2）那就是前三个数相加，（1，2）第二个数和第三个数相加，综上我们可以算出每个数之和，也就是前几个数之和，再详细的就是[-2, 0, 3, -5, 2, -1]中0下标总数和sum[1]=-2，sum[2]=-2+0+3=1;sum[0]=0是因为我们算（1，2）是sum[3]-sum[1]=1-（-2）=3，（sum[3]=sum[1]+sum[2]+sum[3]）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumArray</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sum[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NumArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        sum = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length+<span class=\"number\">1</span>];<span class=\"comment\">//创建一个属数组装我们传进的数组，大小+1，因为做减法，第一个-0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length+<span class=\"number\">1</span>;i++)&#123;<span class=\"comment\">//=第一个的值</span></span><br><span class=\"line\">            sum[i]=sum[i-<span class=\"number\">1</span>]+nums[i-<span class=\"number\">1</span>];<span class=\"comment\">//循环遍历出从nums数组中的前i的数之和，从1开始</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[j+<span class=\"number\">1</span>]-sum[i];<span class=\"comment\">//下标大的+1 （0，2）-&gt;(3-1)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-数组中等差递增子区间的个数\"><a href=\"#2-数组中等差递增子区间的个数\" class=\"headerlink\" title=\"2. 数组中等差递增子区间的个数\"></a>2. 数组中等差递增子区间的个数</h3><ol start=\"413\">\n<li>Arithmetic Slices (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>\n<p>如果满足条件：</p>\n<p>元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q ；函数要返回数组 A 中所有为等差数组的子数组个数。则称子数组(P, Q)为等差数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：A = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span>: <span class=\"number\">6</span>, <span class=\"keyword\">for</span> <span class=\"number\">3</span> arithmetic slices in A:</span><br><span class=\"line\"></span><br><span class=\"line\">输出：[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">\t [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\"> \t [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">\t [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">\t [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">\t [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<p>解释:</p>\n<p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>\n<p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;规律...</span><br><span class=\"line\">dp[2] &#x3D; 1</span><br><span class=\"line\">    [0, 1, 2]</span><br><span class=\"line\">dp[3] &#x3D; dp[2] + 1 &#x3D; 2</span><br><span class=\"line\">    [0, 1, 2, 3], &#x2F;&#x2F; [0, 1, 2] 之后加一个 3</span><br><span class=\"line\">    [1, 2, 3]     &#x2F;&#x2F; 新的递增子区间</span><br><span class=\"line\">dp[4] &#x3D; dp[3] + 1 &#x3D; 3</span><br><span class=\"line\">    [0, 1, 2, 3, 4], &#x2F;&#x2F; [0, 1, 2, 3] 之后加一个 4</span><br><span class=\"line\">    [1, 2, 3, 4],    &#x2F;&#x2F; [1, 2, 3] 之后加一个 4</span><br><span class=\"line\">    [2, 3, 4]        &#x2F;&#x2F; 新的递增子区间</span><br></pre></td></tr></table></figure>\n\n<p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p>\n<p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfArithmeticSlices</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A==<span class=\"keyword\">null</span> &amp;&amp; A.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;A.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[i]-A[i-<span class=\"number\">1</span>]==A[i-<span class=\"number\">1</span>]-A[i-<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">                dp[i]=dp[i-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cnt:dp)&#123;</span><br><span class=\"line\">            sum+=cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、分割整数\"><a href=\"#四、分割整数\" class=\"headerlink\" title=\"四、分割整数\"></a>四、分割整数</h2><h3 id=\"1-分割整数的最大乘积\"><a href=\"#1-分割整数的最大乘积\" class=\"headerlink\" title=\"1. 分割整数的最大乘积\"></a>1. 分割整数的最大乘积</h3><ol start=\"343\">\n<li>Integer Break (Medim)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>\n<p>解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"number\">2</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br><span class=\"line\">解释: <span class=\"number\">2</span> = <span class=\"number\">1</span> + <span class=\"number\">1</span>, <span class=\"number\">1</span> × <span class=\"number\">1</span> = <span class=\"number\">1</span>。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: <span class=\"number\">10</span></span><br><span class=\"line\">输出: <span class=\"number\">36</span></span><br><span class=\"line\">解释: <span class=\"number\">10</span> = <span class=\"number\">3</span> + <span class=\"number\">3</span> + <span class=\"number\">4</span>, <span class=\"number\">3</span> × <span class=\"number\">3</span> × <span class=\"number\">4</span> = <span class=\"number\">36</span>。</span><br></pre></td></tr></table></figure>\n\n<p>解释1：</p>\n<p>对于正整数 n，当 n ≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。</p>\n<p>创建数组 dp，其中dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。</p>\n<p>当 i ≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j&lt;i），则有以下两种方案：</p>\n<p>将 i 拆分成 j 和 i-j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 (i-j)×j；</p>\n<p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 dp[i-j]×j。</p>\n<p>因此，当 j 固定时，有 dp[i]=max(j × (i-j),j × dp[i-j])。由于 j 的取值范围是 1 到 i-1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如下：</p>\n<p>dp[<em>i</em>]=1≤<em>j</em>&lt;<em>i</em>max{max(<em>j</em>×(<em>i</em>−<em>j</em>),<em>j</em>×dp[<em>i</em>−<em>j</em>])}</p>\n<p>最终得到 dp[n] 的值即为将正整数 n 拆分成至少两个正整数的和之后，这些正整数的最大乘积。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">integerBreak</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;i;j++)&#123;   </span><br><span class=\"line\">                cnt=Math.max(cnt,Math.max((j*(i-j)),j*dp[i-j]));</span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">            dp[i]=cnt;       </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//另一种方法</span></span><br><span class=\"line\">        <span class=\"comment\">//因为4可拆分2x2 5拆分2x3 6拆分3x3 7拆分成2x2x3 8拆分3x3x2最大，所以可以把转换成</span></span><br><span class=\"line\">        <span class=\"comment\">//2和3的，尽可能的满足3，然后剩下的满足2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n-<span class=\"number\">1</span>; <span class=\"comment\">//1-&gt;0 2-&gt;1 3-&gt;2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q1=n/<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q2=n%<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q2==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)Math.pow(<span class=\"number\">3</span>,q1); </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(q2==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)(Math.pow(<span class=\"number\">3</span>,q1-<span class=\"number\">1</span>)*<span class=\"number\">4</span>);<span class=\"comment\">//7%3=1 7/3=2 3x2x2 10%3=1 10/3=3 3x3x2x2</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)(Math.pow(<span class=\"number\">3</span>,q1)*<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-按平方数来分割整数\"><a href=\"#2-按平方数来分割整数\" class=\"headerlink\" title=\"2. 按平方数来分割整数\"></a>2. 按平方数来分割整数</h3><ol start=\"279\">\n<li>Perfect Squares(Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGVyZmVjdC1zcXVhcmVzL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVyZmVjdC1zcXVhcmVzL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给你一个整数n，求他的若干个完全平方数的最少数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = <span class=\"number\">12</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: <span class=\"number\">12</span> = <span class=\"number\">4</span> + <span class=\"number\">4</span> + <span class=\"number\">4.</span></span><br><span class=\"line\"></span><br><span class=\"line\">输入: n = <span class=\"number\">13</span></span><br><span class=\"line\">输出: <span class=\"number\">2</span></span><br><span class=\"line\">解释: <span class=\"number\">13</span> = <span class=\"number\">4</span> + <span class=\"number\">9.</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<p>思路：动态规划<br>首先初始化长度为 n+1 的数组 dp，每个位置都为 0<br>如果 n 为 0，则结果为 0<br>对数组进行遍历，下标为 i，每次都将当前数字先更新为最大的结果，即 dp[i]=i，比如 i=4，最坏结果为4=1+1+1+1 即为 4 个数字<br>动态转移方程为：dp[i] = MIN(dp[i], dp[i - j * j] + 1)，i 表示当前数字，j<em>j 表示平方数<br>时间复杂度：O(n</em>sqrt(n))，sqrt 为平方根</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numSquares</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];<span class=\"comment\">// 默认初始化值都为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            dp[i]=i;<span class=\"comment\">//最坏的情况就是每次+1，不变化本值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;i-j*j&gt;=<span class=\"number\">0</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//n=5</span></span><br><span class=\"line\">                <span class=\"comment\">//i=4时，4-2*2=0 dp[4]=d[0]+1=1 </span></span><br><span class=\"line\">                <span class=\"comment\">//i=5时,5-2*2=1 dp[1]=1+0=2   &lt; 5-1*1=3 dp[3]=3</span></span><br><span class=\"line\">                <span class=\"comment\">//所以取dp[n] 最少两个我完全平方数可以构成n(n=5)</span></span><br><span class=\"line\">                dp[i]=Math.min(dp[i],dp[i-j*j]+<span class=\"number\">1</span>);<span class=\"comment\">// 动态转移方程</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-分割整数构成字母字符串\"><a href=\"#3-分割整数构成字母字符串\" class=\"headerlink\" title=\"3. 分割整数构成字母字符串\"></a>3. 分割整数构成字母字符串</h3><ol start=\"91\">\n<li>Decode Ways (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVjb2RlLXdheXMvZGVzY3JpcHRpb24v\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGVjb2RlLXdheXMvZGVzY3JpcHRpb24v\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：Given encoded message &quot;12&quot;, it could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>\n<p>解释：</p>\n<p>这是一题典型的动态问题，但是需要考的情况较多：<br>dp数组表示长度为i的字符可以表示的解码次数；初始化 dp[0] = 1;<br>情况讨论：<br>1.当一个数为0时，结果肯定是0；<br>2.当长度为1时，肯定是1（此处排除了0）<br>3.当字符大于等于2时的情形：</p>\n<ul>\n<li>1.当前字符为0且上一个字符为0或者当前字符为0上一个字符大于2（即012，130，301）这种情况下不能解码，返回0</li>\n<li>2.当前字符为0，那么当前字符只能与前一个字符组成组合 dp[i] = dp[i-2]</li>\n<li>3.当前字符不是0，但前一个字符是，这种情况下，该字符只能独立解码，dp[i] = dp[i-1];</li>\n<li>4.常规情况，当前字符与上一个字符的和&gt;26(直接拼成string与26比较也可)，如果大于26，那么这2字符只能一组，dp[i] = dp[i-2],否则，dp[i] = dp[i-2]+dp[i-1]</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = s.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;0&#x27;</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(i-<span class=\"number\">1</span>) == <span class=\"string\">&#x27;1&#x27;</span> || s.charAt(i-<span class=\"number\">1</span>) == <span class=\"string\">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;<span class=\"string\">&#x27;7&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断第一位为1或2的第二位小于7的，以为第一位和二位不能超过27</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s.charAt(i) == <span class=\"string\">&#x27;0&#x27;</span>) dp[i + <span class=\"number\">1</span>] = dp[i - <span class=\"number\">1</span>];<span class=\"comment\">//如果第二位为0，只能和第一位组合</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i + <span class=\"number\">1</span>] = dp[i] + dp[i - <span class=\"number\">1</span>];<span class=\"comment\">//否则</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s.charAt(i) == <span class=\"string\">&#x27;0&#x27;</span>)&#123;<span class=\"comment\">//第一位不是2或1 且第二位&gt;7</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                dp[i + <span class=\"number\">1</span>] = dp[i];<span class=\"comment\">//否则就是正常情况</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、最长递增子序列\"><a href=\"#五、最长递增子序列\" class=\"headerlink\" title=\"五、最长递增子序列\"></a>五、最长递增子序列</h2><p>已知一个序列 {S1, S2,...,Sn}，取出若干数组成新的序列 {Si1, Si2,..., Sim}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p>\n<p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p>\n<p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,...,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,..., Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。</p>\n<p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>\n<p><a href=\"https://camo.githubusercontent.com/c6b76b65c1880a507bf1cb0250456121db57a1ab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65653939346461342d306663372d343433642d616335362d6330386361663030613230342e6a7067\"><img data-src=\"https://camo.githubusercontent.com/c6b76b65c1880a507bf1cb0250456121db57a1ab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65653939346461342d306663372d343433642d616335362d6330386361663030613230342e6a7067\" alt=\"img\" loading=\"lazy\"></a></p>\n<p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p>\n<h3 id=\"1-最长递增子序列\"><a href=\"#1-最长递增子序列\" class=\"headerlink\" title=\"1. 最长递增子序列\"></a>1. 最长递增子序列</h3><ol start=\"300\">\n<li>Longest Increasing Subsequence (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>\n<p>解释：</p>\n<p>定义 dp[i]dp[i] 为考虑前 ii 个元素，以第 ii 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p>\n<p>我们从小到大计算 dp[] 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：<br>dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</p>\n<p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个nums[i]。由于dp[j] 代表 nums[0…j] 中以nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p>\n<p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>,<span class=\"number\">18</span>]</span><br><span class=\"line\">输出: <span class=\"number\">4</span> </span><br><span class=\"line\">解释: 最长的上升子序列是 [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">101</span>]，它的长度是 <span class=\"number\">4</span>。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> max=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class=\"line\">                    max=Math.max(max,dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i]=max;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ref=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">             ref=Math.max(ref,dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-一组整数对能够构成的最长链\"><a href=\"#2-一组整数对能够构成的最长链\" class=\"headerlink\" title=\"2. 一组整数对能够构成的最长链\"></a>2. 一组整数对能够构成的最长链</h3><ol start=\"646\">\n<li>Maximum Length of Pair Chain (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1sZW5ndGgtb2YtcGFpci1jaGFpbi9kZXNjcmlwdGlvbi8=\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1sZW5ndGgtb2YtcGFpci1jaGFpbi9kZXNjcmlwdGlvbi8=\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [[<span class=\"number\">1</span>,<span class=\"number\">2</span>], [<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">3</span>,<span class=\"number\">4</span>]]</span><br><span class=\"line\">Output: <span class=\"number\">2</span></span><br><span class=\"line\">Explanation: The longest chain is [<span class=\"number\">1</span>,<span class=\"number\">2</span>] -&gt; [<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n\n<p>解释 ：</p>\n<p>在一个长度为 k，以 pairs[i] 结尾的数对链中，如果 pairs[i][1] &lt; pairs[j][0]，则将该数对加入链中，数对链长度变为 k+1。</p>\n<p>根据数对的第一个数排序所有的数对，dp[i] 存储以 pairs[i] 结尾的最长链的长度。当 i &lt; j 且 pairs[i][1] &lt; pairs[j][0] 时，扩展数对链，更新 dp[j] = max(dp[j], dp[i] + 1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLongestChain</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] pairs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pairs==<span class=\"keyword\">null</span> &amp;&amp;pairs.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(pairs,Comparator.comparingInt(o-&gt;o[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[]=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[pairs.length];</span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;pairs.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pairs[j][<span class=\"number\">1</span>]&lt;pairs[i][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                   dp[i]=Math.max(dp[i],dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// int cnt=0;</span></span><br><span class=\"line\">        <span class=\"comment\">// for(int i=0;i&lt;pairs.length;i++)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     cnt = Math.max(cnt,dp[i]);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// return cnt;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.stream(dp).max().orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-最长摆动子序列\"><a href=\"#3-最长摆动子序列\" class=\"headerlink\" title=\"3. 最长摆动子序列\"></a>3. 最长摆动子序列</h3><ol start=\"376\">\n<li>Wiggle Subsequence (Medium)</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>\n<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>\n<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。使用 O(N) 时间复杂度求解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,7,4,9,2,5]</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 整个序列均为摆动序列。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class=\"line\">输出: 7</span><br><span class=\"line\">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 第一个差存在正数或负数也是摆动序列</span><br></pre></td></tr></table></figure>\n\n<p>解释：相当于只有第二个数大小第一个数、紧接着下一个数小于前一个数才算时有3个摆动序列,例如[1,7,8,9,2,1] 7&gt;1 up=2, 8&gt;7 9&gt;8 -&gt;dp=1+1=2 , 然后2&lt;9  down=up+1=2+1=3, 最后1&lt;2 down=2+1=3 ;反之一样的道理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">wiggleMaxLength</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//O(n)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> up=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> down=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//相当于只有先时第二个数大小第一个数、紧接着下一个数小于前一个数才算时有3个摆动序列</span></span><br><span class=\"line\"><span class=\"comment\">//例如[1,7,8,9,2,1] 7&gt;1 up=2,8&gt;7 9&gt;8 -&gt;dp=2 然后2&lt;9 down=up+1=2+1=3,最后1&lt;2 down=2+1=3  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;nums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                up=down+<span class=\"number\">1</span>;  </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]&lt;nums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                down=up+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(up,down);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、最长公共子序列\"><a href=\"#六、最长公共子序列\" class=\"headerlink\" title=\"六、最长公共子序列\"></a>六、最长公共子序列</h2><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>\n<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p>\n<ul>\n<li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li>\n<li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li>\n</ul>\n<p>综上，最长公共子序列的状态转移方程为：</p>\n<p><img data-src=\"https://i.loli.net/2020/11/14/NHAh5oIfcDZ2aLK.png\" loading=\"lazy\"></p>\n<p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p>\n<p>与最长递增子序列相比，最长公共子序列有以下不同点：</p>\n<ul>\n<li>针对的是两个序列，求它们的最长公共子序列。</li>\n<li>在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j。</li>\n<li>在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</li>\n</ul>\n<h3 id=\"1-最长公共子序列\"><a href=\"#1-最长公共子序列\" class=\"headerlink\" title=\"1. 最长公共子序列\"></a>1. 最长公共子序列</h3><ol start=\"143\">\n<li>Longest Common Subsequence</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">Leetcode<i class=\"fa fa-external-link-alt\"></i></span> / <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">力扣<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>题目描述：给定两个字符串 S1 和 S2，返回这两个字符串的最长公共子序列的长度。</p>\n<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text1 = <span class=\"string\">&quot;abcde&quot;</span>, text2 = <span class=\"string\">&quot;ace&quot;</span> </span><br><span class=\"line\">输出：<span class=\"number\">3</span>  </span><br><span class=\"line\">解释：最长公共子序列是 <span class=\"string\">&quot;ace&quot;</span>，它的长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">输入：text1 = <span class=\"string\">&quot;abc&quot;</span>, text2 = <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">输出：<span class=\"number\">3</span></span><br><span class=\"line\">解释：最长公共子序列是 <span class=\"string\">&quot;abc&quot;</span>，它的长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">输入：text1 = <span class=\"string\">&quot;abc&quot;</span>, text2 = <span class=\"string\">&quot;def&quot;</span></span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m=text1.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n=text2.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dp[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;m+<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;n+<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1.charAt(i-<span class=\"number\">1</span>)==text2.charAt(j-<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                    dp[i][j]=dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i][j]=Math.max(dp[i-<span class=\"number\">1</span>][j],dp[i][j-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、0-1-背包\"><a href=\"#七、0-1-背包\" class=\"headerlink\" title=\"七、0-1 背包\"></a>七、0-1 背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>\n<p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>\n<ul>\n<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li>\n<li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li>\n</ul>\n<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>\n<p>dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);</p>\n","categories":["算法"],"tags":["动态规划"]},{"title":"JVM垃圾回收+多线程","url":"/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html","content":"<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"一、JVM\"><a href=\"#一、JVM\" class=\"headerlink\" title=\"一、JVM\"></a>一、JVM</h2><h3 id=\"1如何判断哪些对象已经死亡了，可以回收了？\"><a href=\"#1如何判断哪些对象已经死亡了，可以回收了？\" class=\"headerlink\" title=\"1如何判断哪些对象已经死亡了，可以回收了？\"></a>1如何判断哪些对象已经死亡了，可以回收了？</h3><p><strong>1.使用引用计数法</strong></p>\n<p>给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。</p>\n<p>总结：但是原始引用计数无法解决循环引用的问题</p>\n<p><strong>2.可达性分析算法</strong></p>\n<p>这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。</p>\n<p>在Java 语言中，可作为GC Roots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>\n<li>方法区中类静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n</ul>\n<h3 id=\"2-垃圾回收算法都有哪些？\"><a href=\"#2-垃圾回收算法都有哪些？\" class=\"headerlink\" title=\"2.垃圾回收算法都有哪些？\"></a>2.垃圾回收算法都有哪些？</h3><p><strong>1.标记-清除算法</strong></p>\n<p>该算法分为“标记”和“清除”两个阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的象。它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到的。</p>\n<p>这种垃圾收集算法会带来两个明显的问题：</p>\n<ul>\n<li>效率问题</li>\n<li>空间问题（标记清除后会产生大量不连续的碎片）</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/11/06/8LZ5c9TNjwvnHRF.png\" alt=\"图片\" loading=\"lazy\"></p>\n<p><strong>2.复制算法</strong></p>\n<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。</p>\n<p>优点：解决了效率低的问题</p>\n<p>缺点：造成空间的浪费，使用一块内存，真正只使用了他的一半</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/i3vfuLBRtVydUc4.png\" loading=\"lazy\"></p>\n<p><strong>3.标记-整理（压缩）算法</strong></p>\n<p>根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，<strong>⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。</strong></p>\n<p>优点：不会造成空间问题产生大量碎片</p>\n<p>缺点：但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/GuPFaKpw6iLcV7z.png\" loading=\"lazy\"></p>\n<p><strong>4.分代收集算法</strong></p>\n<p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收呢，来看一下对象的分配有啥规律。</p>\n<p><strong>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</strong></p>\n<p>细节问题（敲黑板，咳咳）：</p>\n<p>大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/jBbFgwu3Q5yfZsR.png\" loading=\"lazy\"></p>\n<p><strong>分代收集工作原理</strong></p>\n<p><strong>1、对象在新生代的分配与回收</strong></p>\n<ol>\n<li>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</li>\n<li>当 Eden 区将满时，触发 Minor GC</li>\n<li>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间</li>\n<li>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</li>\n<li>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</li>\n</ol>\n<p><strong>2、对象何时晋升老年代</strong></p>\n<ul>\n<li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li>\n<li>年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li>\n<li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li>\n<li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li>\n</ul>\n<p><strong>3、空间分配担保</strong></p>\n<p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p>\n<p><strong>4、Stop The World</strong></p>\n<p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p>\n<p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p>\n<p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p>\n<p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p>\n<p>由于 Full GC（或Minor GC） 会影响性能，<strong>所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，</strong>这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p>\n<ul>\n<li>循环的末尾</li>\n<li>方法返回前</li>\n<li>调用方法的 call 之后</li>\n<li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li>\n</ul>\n<h3 id=\"3-垃圾收集器都有哪些？\"><a href=\"#3-垃圾收集器都有哪些？\" class=\"headerlink\" title=\"3.垃圾收集器都有哪些？\"></a>3.垃圾收集器都有哪些？</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/epE8AaUqD1CYnj2.png\" loading=\"lazy\"></p>\n<ul>\n<li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li>\n<li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li>\n<li>同时在新老生代工作的垃圾回收器：G1</li>\n</ul>\n<p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p>\n<h4 id=\"Ⅰ-新生代垃圾回收器\"><a href=\"#Ⅰ-新生代垃圾回收器\" class=\"headerlink\" title=\"Ⅰ.新生代垃圾回收器\"></a>Ⅰ.新生代垃圾回收器</h4><p><strong>1.Serial 收集器</strong></p>\n<p>Serial收集器是工作在新生代的，<strong>单线程的垃圾收集器</strong>，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说<strong>在 GC 期间，此时的应用不可用。</strong></p>\n<p>但是Serial收集器有没有优于其他垃圾收集器的地⽅呢？</p>\n<p>当然有，它简单⽽⾼效（与其他收集器的单线程相⽐）。Serial收集器由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。Serial收集器对于运⾏在Client模式下的虚拟机来说是个不错的选择。</p>\n<p><strong>2.ParNew 收集器</strong> </p>\n<p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完全一样，在底层上，这两种收集器也共用了相当多的代码。</p>\n<p><strong>ParNew 主要工作在 Server 模式</strong>，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为<strong>除了 Serial  收集器，只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p>\n<p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p>\n<p><strong>3.Parallel Scavenge 收集器</strong> </p>\n<p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p>\n<p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 <strong>Parallel Scavenge 目标是达到一个可控制的吞吐量（</strong>吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 <strong>CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</strong></p>\n<p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p>\n<p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p>\n<h4 id=\"Ⅱ-老年代垃圾回收器\"><a href=\"#Ⅱ-老年代垃圾回收器\" class=\"headerlink\" title=\"Ⅱ.老年代垃圾回收器\"></a>Ⅱ.老年代垃圾回收器</h4><p><strong>1.Serial Old 收集器</strong> </p>\n<p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/CsQVw6y7xSzthai.png\" loading=\"lazy\"></p>\n<p><strong>2.Parallel Old 收集器</strong> </p>\n<p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p>\n<p><img data-src=\"https://i.loli.net/2020/11/06/Q8jx3FaohNR5G4D.png\" loading=\"lazy\"></p>\n<p><strong>3.CMS 收集器</strong> </p>\n<p>CMS（Concurrent Mark Sweep）收集器是⼀种以<strong>获取最短回收停顿时间为⽬标的收集器</strong>。它⽽⾮常符合在注重⽤户体验的应⽤上使⽤。<br>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第⼀款真正意义上的并发收集器，它第⼀次实现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。</p>\n<p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤：</p>\n<ol>\n<li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>\n<li>并发标记：同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以GC线程⽆法保证可达性分析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。</li>\n<li>重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对象的标记记录，这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短</li>\n<li>并发清除：开启⽤户线程，同时GC线程开始对为标记的区域做清扫。</li>\n</ol>\n<p><img data-src=\"https://i.loli.net/2020/11/06/jHqgf4yWZR3unL7.png\" loading=\"lazy\"></p>\n<p>从它的名字就可以看出它是⼀款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下⾯三个明显的缺点：</p>\n<ul>\n<li>对CPU资源敏感；</li>\n<li>⽆法处理浮动垃圾；</li>\n<li>它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。</li>\n</ul>\n<p><strong>4.G1（Garbage First） 收集器</strong></p>\n<p>G1 (Garbage-First)是⼀款⾯向服务器的垃圾收集器,被称为驾驭一切的垃圾回收器；主要针对配备多颗处理器及⼤容量内存的机器以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征.</p>\n<p>G1 收集器的工作步骤如下</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ol>\n<p><img data-src=\"https://i.loli.net/2020/11/06/XLRkuels7qVa3SN.png\" loading=\"lazy\"></p>\n<p>G1收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的Region也就是它的名字Garbage-First的由来)。这种使⽤Region划分内存空间以及有优先级的区域回收⽅式保证了GF收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。</p>\n<h2 id=\"二、多线程\"><a href=\"#二、多线程\" class=\"headerlink\" title=\"二、多线程\"></a>二、多线程</h2><h3 id=\"1-什么是进程和线程？\"><a href=\"#1-什么是进程和线程？\" class=\"headerlink\" title=\"1.什么是进程和线程？\"></a>1.什么是进程和线程？</h3><p>进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</p>\n<p>线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。</p>\n<p>举个例子：进程和线程区别，用java内存区域来说；线程与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。</p>\n<h3 id=\"2-多线程是什么？\"><a href=\"#2-多线程是什么？\" class=\"headerlink\" title=\"2.多线程是什么？\"></a>2.多线程是什么？</h3><p>提到多线程这里要说两个概念，就是<strong>串行和并行</strong>，搞清楚这个我们才能更好的理解多线程。</p>\n<p>所谓串行其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子，我们下载多个文件，在串行中它是按照一定的顺序去进行下载的，也就是说必须等下载完A之后，才能开始下载B，它们在时间上是不可能发生重叠的。</p>\n<p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的在同一时刻发生的，并行在时间上是重叠的。</p>\n<p>了解了这两个概念之后我们再来说说什么是多线程，举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能，按照单线程来说，你想要清理垃圾还要病毒查杀，那么你必须先做完其中的一件事才能做下一件事，是有一个执行的顺序的，如果是多线程的话，我们其实在清理垃圾的时候还可以查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行的先后顺序。</p>\n<p><strong>所以：多线程就是一个进程运行中产生了多个线程</strong></p>\n<h3 id=\"3-什么是线程安全？线程安全级别有什么？\"><a href=\"#3-什么是线程安全？线程安全级别有什么？\" class=\"headerlink\" title=\"3.什么是线程安全？线程安全级别有什么？\"></a>3.什么是线程安全？线程安全级别有什么？</h3><p>既然是线程安全问题，那么毫无疑问所有的隐患都是出现在多个线程访问的情况下产生的，也就是我们要确保在多条线程访问的时候，<u>我们的程序还能按照我们预期的行为去执行</u>，<strong>也就是说：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。</strong></p>\n<p>线程安全级别：</p>\n<ol>\n<li><p>不可变：不变的对象绝对是线程安全的，不需要线程同步，如String、Long、BigInteger</p>\n</li>\n<li><p>绝对的线程安全：对象自身做了 足够的内部同步，也不需要外部同步，如 Random 、ConcurrentHashMap、Concurrent集合、atomic</p>\n</li>\n<li><p>相对的线程安全：对象的部分方法可以无条件安全使用，但是有些方法需要外部同步，需要Collections.synchronized；有条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器</p>\n</li>\n<li><p>线程兼容：对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如ArrayList HashMap</p>\n</li>\n<li><p>线程对立：即使外部进行了同步调用，也不能保证线程安全，这种情况非常少，如System.setOut()、System.runFinalizersOnExit()</p>\n</li>\n</ol>\n<h3 id=\"4-怎么保证线程安全？\"><a href=\"#4-怎么保证线程安全？\" class=\"headerlink\" title=\"4.怎么保证线程安全？\"></a>4.怎么保证线程安全？</h3><p><strong>当多个线程要共享一个实例对象的值得时候，那么在考虑安全的多线程并发编程时就要保证下面3个要素：</strong></p>\n<ul>\n<li>原子性（Synchronized, Lock）</li>\n<li>有序性(Volatile，Synchronized, Lock)</li>\n<li>可见性(Volatile，Synchronized,Lock)</li>\n</ul>\n<p>但是由于synchronized和Lock保证每个时刻只有一个线程执行同步代码，所以是线程安全的，也可以实现这一功能，<strong>但是由于线程是同步执行的，所以会影响效率。</strong></p>\n<p><strong>下面是对3个要素的详细解释：</strong></p>\n<ul>\n<li><strong>原子性</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，<strong>基本数据类型的变量的读取和赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</li>\n<li><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>\n<li><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</li>\n</ul>\n<p><strong>volatile的作用：保证数据的可见性和防止指令重排。</strong></p>\n<ul>\n<li>volatile仅能用在变量级别，而synchronized可用在变量和方法中。</li>\n<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取共享变量时，它会去内存中读取新值。</li>\n<li>普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li>\n<li>更新主存的步骤：当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效，然后当前线程将变量的值跟新到主存，更新成功后将其他线程的缓存行更新为新的主存地址</li>\n<li>其他线程读取变量时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</li>\n<li> 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li>\n</ul>\n<p><strong>1、使用安全类，比如 Java. util. concurrent</strong></p>\n<p><strong>2、使用synchronized关键字，自动锁</strong> </p>\n<p><strong>定义</strong>：synchronized关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</strong>当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用。</p>\n<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 <strong>Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销；主要解决以下三种场景:</strong></p>\n<ul>\n<li>只有一个线程进入临界区，偏向锁</li>\n<li>多线程未竞争，轻量级锁</li>\n<li>多线程竞争，重量级锁</li>\n</ul>\n<p>偏向锁→轻量级锁→重量级锁过程，<strong>锁可以升级但不能降级</strong>，这种策略是为了提高获得锁和释放锁的效率</p>\n<p><strong>底层原理：</strong></p>\n<p>① synchronized 同步语句块的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;synchronized 代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执⾏monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因)的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>\n<p>② synchronized 修饰⽅法的的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedDemo2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;synchronized ⽅法&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，JVM 通过该 ACC_SYNCHRONIZED 访问<br>标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。</p>\n<p><strong>3、使用Lock类，手动锁</strong></p>\n<p>先来说说它跟synchronized有什么区别吧，Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，什么意思？</p>\n<p>就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。我们先来看下一般是如何使用的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock(); <span class=\"comment\">// ReentrantLock是Lock的子类</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(Thread thread)</span></span>&#123;</span><br><span class=\"line\">      lock.lock(); <span class=\"comment\">// 获取锁对象</span></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;线程名：&quot;</span>+thread.getName() + <span class=\"string\">&quot;获得了锁&quot;</span>);</span><br><span class=\"line\">          <span class=\"comment\">// Thread.sleep(2000);</span></span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;线程名：&quot;</span>+thread.getName() + <span class=\"string\">&quot;释放了锁&quot;</span>);</span><br><span class=\"line\">          lock.unlock(); <span class=\"comment\">// 释放锁对象</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-多线程的实现方式和区别\"><a href=\"#5-多线程的实现方式和区别\" class=\"headerlink\" title=\"5.多线程的实现方式和区别\"></a>5.多线程的实现方式和区别</h3><p>①继承Thread类</p>\n<p>②实现Rannable接口</p>\n<p>③使用Callable和Future创建线程</p>\n<ul>\n<li><p>上面的两种方式都有这两个问题;二第三个方法就是解决这两个问题的</p>\n<ul>\n<li>无法获取子线程的返回值</li>\n<li>run方法不可以抛出异常</li>\n</ul>\n</li>\n</ul>\n<p><strong>前三种实现多线程的比较：</strong></p>\n<p>第一种和后面两种的对比：</p>\n<ul>\n<li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li>\n<li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li>\n</ul>\n<p>第二种和第三种方式对比：</p>\n<ul>\n<li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li>\n<li>第三种方法有两个优点：有返回值、可以抛出异常</li>\n</ul>\n<h3 id=\"6-怎么启动多线程？\"><a href=\"#6-怎么启动多线程？\" class=\"headerlink\" title=\"6.怎么启动多线程？\"></a>6.怎么启动多线程？</h3><p>调用start()方法；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">threadTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tString name2 = Thread.currentThread().getName();</span><br><span class=\"line\">\t\tSystem.out.println(name2+<span class=\"string\">&quot;:你好啊 我是一个线程!&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;.start();;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tthreadTest();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">没错就是这么简单,只需要<span class=\"keyword\">new</span> Thread()然后重写run方法就可以实现创建一个线程,使用start方法即可启动该线程.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-有几种线程池-是怎么实现的？\"><a href=\"#7-有几种线程池-是怎么实现的？\" class=\"headerlink\" title=\"7.有几种线程池,是怎么实现的？\"></a>7.有几种线程池,是怎么实现的？</h3><ol>\n<li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li>\n<li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n<li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li>\n<li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li>\n</ol>\n<p><strong>底层具体实现：</strong></p>\n<p>通过Executor 框架的⼯具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：</p>\n<ul>\n<li><strong>newSingleThreadExecutor</strong></li>\n<li><strong>newFixedThreadPool</strong></li>\n<li><strong>newCachedThreadPool</strong></li>\n</ul>\n<p>下⾯这些对创建 ⾮常重要，在后⾯使⽤线程池的过程中你⼀定会⽤到！所以，务必拿着⼩本本记清楚。</p>\n<p><strong>ThreadPoolExecutor构造函数重要参数分析</strong> </p>\n<ul>\n<li>corePoolSize : 核⼼线程数线程数定义了<strong>最⼩可以同时运⾏的线程数量</strong>。</li>\n<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数<br>量变为最⼤线程数。</li>\n<li>workQueue: 当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到<br>的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>ThreadPoolExecutor其他常⻅参数:</p>\n<ol>\n<li><p>keepAliveTime:当线程池中的线程数量⼤于 corePoolSize 的时候，如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁；</p>\n</li>\n<li><p>unit : keepAliveTime 参数的时间单位。</p>\n</li>\n<li><p>threadFactory :executor 创建新线程的时候会⽤到。</p>\n</li>\n<li><p>handler :饱和策略。关于饱和策略下⾯单独介绍⼀下。<br>ThreadPoolExecutor 饱和策略<br>ThreadPoolExecutor 饱和策略定义:<br>如果当前同时运⾏的线程数量达到最⼤线程数量并且队列也已经被放满了任时， ThreadPoolTaskExecutor 定义⼀些策略:ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。ThreadPoolExecutor.CallerRunsPolicy：调⽤执⾏⾃⼰的线程运⾏任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应⽤程序可以承受此延迟并且你不能任务丢弃任何⼀个任务请求的话，你可以选择这个策略。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, //线程池的核心线程数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize, //最大线程数。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          Long keepAliveTime,// 设置线程超时时间。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BLockingQueue&lt;Runnable&gt;workQueue,   //阻塞队列</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory, //线程工厂,线程池利用该工厂创建线程 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             RejectedExecutionHandLer handler)</span></span>&#123;<span class=\"comment\">//  线程任务拒绝策略。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-说说-sleep-⽅法和-wait-⽅法区别和共同点\"><a href=\"#8-说说-sleep-⽅法和-wait-⽅法区别和共同点\" class=\"headerlink\" title=\"8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?\"></a>8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h3><p>两者最主要的区别在于：sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</p>\n<ul>\n<li>两者都可以暂停线程的执⾏。</li>\n<li>Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</li>\n<li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者notifyAll() ⽅法。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。</li>\n<li>sleep() ⽅法执⾏完成后，线程会⾃动苏醒。</li>\n</ul>\n<h3 id=\"9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？\"><a href=\"#9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？\" class=\"headerlink\" title=\"9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？\"></a>9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</h3><p>这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都回答不上来！</p>\n<p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。</p>\n<p>总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。</p>\n","categories":["JVM"],"tags":["垃圾回收"]},{"title":"HashMap","url":"/2020-11-17-HashMap.html","content":"<p>HashMap</p>\n<h3 id=\"HashMap-概述\"><a href=\"#HashMap-概述\" class=\"headerlink\" title=\"HashMap 概述\"></a>HashMap 概述</h3><p>HashMap 是 Map 接口的实现，HashMap 允许空的 key-value 键值对，HashMap 被认为是 Hashtable 的增强版，HashMap 是一个非线程安全的容器，如果想构造线程安全的 Map 考虑使用 ConcurrentHashMap。HashMap 是无序的，因为 HashMap 无法保证内部存储的键值对的有序性。</p>\n<p>HashMap 的底层数据结构是数组 + 链表的集合体，数组在 HashMap 中又被称为<code>桶(bucket)</code>。遍历 HashMap 需要的时间损耗为 HashMap 实例桶的数量 + (key - value 映射) 的数量。因此，如果遍历元素很重要的话，不要把初始容量设置的太高或者负载因子设置的太低。</p>\n<p>HashMap 实例有两个很重要的因素，初始容量和负载因子，初始容量指的就是 hash 表桶的数量，负载因子是一种衡量哈希表填充程度的标准，当哈希表中存在足够数量的 entry，以至于超过了负载因子和当前容量，这个哈希表会进行 rehash 操作，内部的数据结构重新 rebuilt。</p>\n<p>注意 HashMap 不是线程安全的，如果多个线程同时影响了 HashMap ，并且至少一个线程修改了 HashMap 的结构，那么必须对HashMap 进行同步操作。可以使用 <code>Collections.synchronizedMap(new HashMap)</code> 来创建一个线程安全的 Map。</p>\n<p>HashMap 会导致除了迭代器本身的 remove 外，外部 remove 方法都可能会导致 fail-fast 机制，因此尽量要用迭代器自己的 remove 方法。如果在迭代器创建的过程中修改了 map 的结构，就会抛出 <code>ConcurrentModificationException</code> 异常。</p>\n<h3 id=\"1-HashMap-中的构造函数：\"><a href=\"#1-HashMap-中的构造函数：\" class=\"headerlink\" title=\"1.HashMap 中的构造函数：\"></a>1.HashMap 中的构造函数：</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal initial </span></span><br><span class=\"line\"><span class=\"string\">capacity: &quot;</span> + initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal load factor: &quot;</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    <span class=\"comment\">//最终也会调用到上面的构造函数，不过这个默认的负载因子就是 HashMap 的默认负载因子也就是 0.75f</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    <span class=\"comment\">//默认初始值为16</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class=\"comment\">//带有 Map 的构造函数，会直接把外部元素批量放入 HashMap 中。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">  putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;<span class=\"comment\">// 默认加载因子0.75；</span></span><br><span class=\"line\"><span class=\"comment\">//HashMap默认初始容量16，加载因子0.75，也就是说最多能放16*0.75=12个元素，当put第13个时，HashMap\t</span></span><br><span class=\"line\"><span class=\"comment\">//将发生rehash，rehash的一系列处理比较影响性能，所以当我们需要向HashMap存放较多元素时，最好指定合</span></span><br><span class=\"line\"><span class=\"comment\">//适的初始容量和加载因子，否则HashMap默认只能存12个元素，将会发生多次rehash操作。                                               </span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16;默认初始容量为16，</span></span><br><span class=\"line\"><span class=\"comment\">//这里是不是有个疑问？int 占用四个字节，按说最大容量应该是左移 31 位，为什么 HashMap 最大容量是左移 30 位呢？因为在数值计算中</span></span><br><span class=\"line\"><span class=\"comment\">//最高位也就是最左位的位 是代表着符号为，0 -&gt; 正数，1 -&gt; 负数，容量不可能是负数，所以 HashMap 最高位只能移位到 2 ^ 30 次幂。                                                                                                </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\"><a href=\"#2-HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\" class=\"headerlink\" title=\"2.HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩\"></a>2.HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩</h3><ol>\n<li>HashMap<strong>在确定数组下标Index的时候</strong>，采用的是( length-1) &amp; hash 的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，因为只要输入的Hash值本身分布均匀，Hash算法的结果就是均匀的。所以HashMap规定了其容量必须是2的n次方.</li>\n<li>由于HashMap规定了其<strong>容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小</strong>。使用位运算同时还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30，<strong>int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</strong></li>\n</ol>\n<p><strong>下⾯这个⽅法（tableSizeFor）保证了 HashMap 总是使⽤2的幂作为哈希表的⼤⼩，也就是说但你创建一个大小不是2的幂的大小，最后会给你返回一个离最近2的幂的大小的值</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY </span><br><span class=\"line\">: n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">\t<span class=\"comment\">/*  &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0</span></span><br><span class=\"line\"><span class=\"comment\">\t比如7的二进制是0111，7&gt;&gt;&gt;2表示右移2位，变成001，即为1</span></span><br><span class=\"line\"><span class=\"comment\">\tcap=8;n=7;n=0111  n|n&gt;&gt;&gt;1 = 0111 | 0011 = 0111 n|n&gt;&gt;&gt;2 0111 | 0001 = 0111</span></span><br><span class=\"line\"><span class=\"comment\">\tn|n&gt;&gt;&gt;4 0111 | 0000 = 0111 最后一步 return=n+1=8</span></span><br><span class=\"line\"><span class=\"comment\">\t综上可得，当hashMap指定初始值的时候，会调用tableSizeFor方法，总是返回2的n次方的值；</span></span><br><span class=\"line\"><span class=\"comment\">\t并且总是等于该算法接近该初始值并比它大的那个值;</span></span><br><span class=\"line\"><span class=\"comment\">\t就是让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。当指定初始值入参</span></span><br><span class=\"line\"><span class=\"comment\">\t为0时，返回实际容量为1。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;<span class=\"comment\">//最大容量为2的30次方\t </span></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-HashMap-的数据结构\"><a href=\"#3-HashMap-的数据结构\" class=\"headerlink\" title=\"3.HashMap 的数据结构\"></a>3.HashMap 的数据结构</h3><p>JDK1.7 中，HashMap 采用<code>数组（位桶） + 链表</code>的实现，即使用<code>链表</code>来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多（哈希冲突），即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。</p>\n<p>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。</p>\n<p><strong>解决哈希冲突的方法：</strong></p>\n<ol>\n<li><p>开放定址法：使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。</p>\n</li>\n<li><p>再哈希法：同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。这种方法不易产生聚集，但增加了计算时间。</p>\n</li>\n<li><p>链地址法：将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>\n</li>\n<li><p>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>\n<p><strong>红黑树：</strong></p>\n</li>\n</ol>\n<p>红黑树是AVL树的变种，红黑树通过一些着色法则确保没有一条路径会比其它路径长出两倍，因而达到接近平衡的目的。所谓红黑树，不仅是一个二叉搜索树，而且必须满足一下规则：<br>   1、每个节点不是红色就是黑色。<br>   2、根节点为黑色。<br>   3、如果节点为红色，其子节点必须为黑色。<br>   4、任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同。<br>上面的这些约束保证了这个树大致上是平衡的，这也决定了红黑树的插入、删除、查询等操作是比较快速的。 根据规则4，新增节点必须为红色；根据规则3，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形</p>\n<p><strong>链表：</strong></p>\n<p>HashMap中的链表是单链表</p>\n<p>jdk1.7: <strong>数组的每个元素都是一个单链表的头节点</strong></p>\n<p>jdk1.8: 树化操作的过程有点复杂，将原本的单链表转化为双向链表，再遍历这个双向链表转化为红黑树。</p>\n<h3 id=\"4-HashMap-的-put-过程\"><a href=\"#4-HashMap-的-put-过程\" class=\"headerlink\" title=\"4.HashMap 的 put 过程\"></a>4.HashMap 的 put 过程</h3><p>大致过程如下，首先会使用 hash 方法计算对象的哈希码，根据哈希码来确定在数组（桶）中存放的位置，如果桶中没有 Node 节点则直接进行 put，如果对应桶已经有 Node 节点，会对链表长度进行分析，判断长度是否大于 8，如果链表长度小于 8 ，在 JDK1.7 前会使用头插法，在 JDK1.8 之后更改为尾插法。如果链表长度大于 8 会进行树化操作（并且数组长度大于64），把链表转换为红黑树，在红黑树上进行存储。</p>\n<p>以 JDK 1.8 为基准进行分析，后面也是。先贴出整段代码，后面会逐行进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">  <span class=\"comment\">// 如果table 为null 或者没有为 table 分配内存，就resize一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    n = (tab = resize()).length;</span><br><span class=\"line\">  <span class=\"comment\">// 指定hash值节点为空则直接插入，这个(n - 1) &amp; hash才是表中真正的哈希</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">    <span class=\"comment\">// 计算表中的这个真正的哈希值与要插入的key.hash相比</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\">    <span class=\"comment\">// 若不同的话，并且当前节点已经在 TreeNode 上了</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">      <span class=\"comment\">// 采用红黑树存储方式</span></span><br><span class=\"line\">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">    <span class=\"comment\">// key.hash 不同并且也不再 TreeNode 上，在链表上找到 p.next==null</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在表尾插入</span></span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 新增节点后如果节点个数到达阈值，则进入 treeifyBin() 进行再次判断</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了同 hash、key 的节点，那么直接退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 p 指向下一节点</span></span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// map中含有旧值，返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">      afterNodeAccess(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// map调整次数 + 1</span></span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"comment\">// 键值对的数量达到阈值，需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    resize();</span><br><span class=\"line\">  afterNodeInsertion(evict);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先看一下 <code>putVal</code> 方法，这个方法是 final 的，如果你自已定义 HashMap 继承的话，是不允许你自己重写 put 方法的，然后这个方法涉及五个参数</p>\n<ul>\n<li>hash -&gt; put 放在桶中的位置，在 put 之前，会进行 hash 函数的计算。</li>\n<li>key -&gt; 参数的 key 值</li>\n<li>value -&gt; 参数的 value 值</li>\n<li>onlyIfAbsent -&gt; 是否改变已经存在的值，也就是是否进行 value 值的替换标志</li>\n<li>evict -&gt; 是否是刚创建 HashMap 的标志</li>\n</ul>\n<p>在调用到 putVal 方法时，<strong>首先会进行 hash 函数计算应该插入的位置</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>哈希函数的源码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//JDK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的</span></span><br><span class=\"line\">    <span class=\"comment\">//hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置</span></span><br><span class=\"line\"> \t<span class=\"comment\">//（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash</span></span><br><span class=\"line\">\t<span class=\"comment\">//值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span><br><span class=\"line\">\t<span class=\"comment\">//所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现</span></span><br><span class=\"line\">\t<span class=\"comment\">//⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。</span></span><br></pre></td></tr></table></figure>\n\n<p>首先先来理解一下 hash 函数的计算规则</p>\n<p>Hash 函数</p>\n<p>hash 函数会根据你传递的 key 值进行计算，首先计算 key 的 <code>hashCode</code> 值，然后再对 hashcode 进行无符号右移操作，最后再和 hashCode 进行<code>异或 ^</code> 操作。</p>\n<blockquote>\n<p><code>&gt;&gt;&gt;</code>: 无符号右移操作，它指的是 <strong>无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong> ，也就是不管是正数还是负数，右移都会在空缺位补 0 。</p>\n</blockquote>\n<p>在得到 hash 值后，就会进行 put 过程。</p>\n<p>首先会判断 HashMap 中的 Node 数组是否为 null，如果第一次创建 HashMap 并进行第一次插入元素，首先会进行数组的 resize，也就是<code>重新分配</code>，这里还涉及到一个 <code>resize()</code> 扩容机制源码分析，我们后面会介绍。</p>\n<p><strong>扩容完毕后，会计算出 HashMap 的存放位置，通过使用 ( n - 1 ) &amp; hash 进行计算得出。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t <span class=\"comment\">// 1. HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash \t     </span></span><br><span class=\"line\">\t <span class=\"comment\">//的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</span></span><br><span class=\"line\">\t <span class=\"comment\">// 2. 由于HashMap规定了其容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小。使用位运算同时\t </span></span><br><span class=\"line\">     <span class=\"comment\">//还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于\t           </span></span><br><span class=\"line\">     <span class=\"comment\">//HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运\t</span></span><br><span class=\"line\">     <span class=\"comment\">//算符表示就是 1 &lt;&lt; 30，int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</span></span><br></pre></td></tr></table></figure>\n\n<p>然后会把这个位置作为数组的下标作为存放元素的位置。如果不为空，那么计算表中的这个真正的哈希值与要插入的 key.hash 相比。如果哈希值相同，key-value 不一样，再判断是否是树的实例，如果是的话，那么就把它插入到树上。如果不是，就执行尾插法在 entry 链尾进行插入。</p>\n<h3 id=\"5-扩容机制\"><a href=\"#5-扩容机制\" class=\"headerlink\" title=\"5.扩容机制\"></a>5.扩容机制</h3><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。好在 HashMap 是一种自动扩容的数据结构，在这种基于变长的数据结构中，扩容机制是非常重要的。</p>\n<p>在 HashMap 中，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。HashMap 中的扩容机制是由 <code>resize()</code> 方法来实现的，下面我们就来一次认识下。</p>\n<p>HashMap 中有两个非常重要的变量，一个是 <code>loadFactor</code> ，一个是 <code>threshold</code> ，loadFactor 表示的就是负载因子，threshold 表示的是下一次要扩容的阈值，当 threshold = loadFactor * 数组长度时，数组长度扩大位原来的两倍，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  <span class=\"comment\">// 存储old table 的大小</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  <span class=\"comment\">// 存储扩容阈值</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果old table数据已达最大，那么threshold也被设置成最大</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">      threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 左移扩大二倍,</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">      <span class=\"comment\">// 扩容成原来二倍</span></span><br><span class=\"line\">      newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果oldThr                                                                                                                                               !&gt; 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">    newCap = oldThr;</span><br><span class=\"line\">  <span class=\"comment\">// 如果old table &lt;= 0 并且 存储的阈值 &lt;= 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">    newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果扩充阈值为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容阈值为 初始容量*负载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">              (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 重新给负载因子赋值</span></span><br><span class=\"line\">  threshold = newThr;</span><br><span class=\"line\">  <span class=\"comment\">// 获取扩容后的数组</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">  table = newTab;</span><br><span class=\"line\">  <span class=\"comment\">// 如果第一次进行table 初始化不会走下面的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 扩容之后需要重新把节点放在新扩容的数组中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt; e;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">          <span class=\"comment\">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class=\"line\">          ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">          Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; next;</span><br><span class=\"line\">          <span class=\"comment\">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">              loTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">              hiTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 将分组后的链表映射到新桶中</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j] = loHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>扩容机制源码比较长，我们耐心点进行拆分</p>\n<p>我们以 if...else if...else 逻辑进行拆分，上面代码主要做了这几个事情</p>\n<ul>\n<li>判断 HashMap 中的数组的长度，也就是 <code>(Node&lt;K,V&gt;[])oldTab.length()</code> ，再判断数组的长度是否比最大的的长度也就是 2^30 次幂要大，大的话直接取最大长度，否则利用位运算 <code>&lt;&lt;</code>扩容为原来的两倍</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135604592-1504962060.png\" alt=\"img\" loading=\"lazy\"></p>\n<ul>\n<li>如果数组长度不大于0 ，再判断扩容阈值 <code>threshold</code> 是否大于 0 ，也就是看有无外部指定的扩容阈值，若有则使用，这里需要说明一下 threshold 何时是 <code>oldThr &gt; 0</code>，因为 oldThr = threshold ，这里其实比较的就是 threshold，因为 HashMap 中的每个构造方法都会调用 <code>HashMap(initCapacity,loadFactor)</code> 这个构造方法，所以如果没有外部指定 initialCapacity，初始容量使用的就是 16，然后根据 <code>this.threshold = tableSizeFor(initialCapacity);</code> .</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135614686-238811487.png\" alt=\"img\" loading=\"lazy\"></p>\n<ul>\n<li>否则，直接使用默认的初始容量和扩容阈值，走 else 的逻辑是在 table 刚刚初始化的时候。</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135622150-1149800383.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>然后会判断 newThr 是否为 0 ，笔者在刚开始研究时发现 <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code> 一直以为这是常量做乘法，怎么会为 0 ，其实不是这部分的问题，在于上面逻辑判断中的扩容操作，可能会导致<code>位溢出</code>。</p>\n<p>导致位溢出的示例：oldCap = 2^28 次幂，threshold &gt; 2 的三次方整数次幂。在进入到 <code>float ft = (float)newCap * loadFactor;</code> 这个方法是 2^28 * 2^(3+n) 会直接 &gt; 2^31 次幂，导致全部归零。</p>\n<p><strong>在扩容后需要把节点放在新扩容的数组中，这里也涉及到三个步骤</strong></p>\n<ul>\n<li>循环桶中的每个 Node 节点，判断 Node[i] 是否为空，为空直接返回，不为空则遍历桶数组，并将键值对映射到新的桶数组中。</li>\n<li>如果不为空，再判断是否是树形结构，如果是树形结构则按照树形结构进行拆分，拆分方法在 <code>split</code> 方法中。</li>\n<li>如果不是树形结构，则遍历链表，并将链表节点按原顺序进行分组。</li>\n</ul>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135633904-751470058.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"6-讲一讲-get-方法全过程\"><a href=\"#6-讲一讲-get-方法全过程\" class=\"headerlink\" title=\"6.讲一讲 get 方法全过程\"></a>6.讲一讲 get 方法全过程</h3><p>我们上面讲了 HashMap 中的 put 方法全过程，下面我们来看一下 <code>get</code> 方法的过程</p>\n<p>首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找到真实的元素位置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 总是会check 一下第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">        ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是第一个元素，并且下一个元素不是空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否属于 TreeNode，如果是 TreeNode 实例，直接从 TreeNode.getTreeNode 取</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果还不是 TreeNode 实例，就直接循环数组元素，直到找到指定元素位置</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来简单介绍下吧，首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<p><code>getNode</code> 方法有一个比较重要的过程就是 <strong>(n - 1) &amp; hash</strong>，这段代码是确定需要查找的桶的位置的，那么，为什么要 (n - 1) &amp; hash 呢？</p>\n<p>n 就是 HashMap 中桶的数量，这句话的意思也就是说 (n - 1) &amp; hash 就是 (桶的容量 - 1) &amp; hash</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为什么 HashMap 的检索位置是 (table.size - 1) &amp; hash</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 49</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 50</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 51</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么每次算完之后的 (n - 1) &amp; hash ，依次为</p>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135651991-667806972.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>也就是 <strong>tab[(n - 1) &amp; hash]</strong> 算出的具体位置。</p>\n<h3 id=\"7-HashMap-的遍历方式\"><a href=\"#7-HashMap-的遍历方式\" class=\"headerlink\" title=\"7.HashMap 的遍历方式\"></a>7.HashMap 的遍历方式</h3><p>HashMap 的遍历，也是一个使用频次特别高的操作</p>\n<p>HashMap 遍历的基类是 <code>HashIterator</code>，它是一个 Hash 迭代器，它是一个 HashMap 内部的抽象类，它的构造比较简单，只有三种方法，<strong>hasNext 、 remove 和 nextNode</strong> 方法，其中 nextNode 方法是由三种迭代器实现的</p>\n<p>这三种迭代器就就是</p>\n<ul>\n<li><code>KeyIterator</code> ，对 key 进行遍历</li>\n<li><code>ValueIterator</code>，对 value 进行遍历</li>\n<li><code>EntryIterator</code>， 对 Entry 链进行遍历</li>\n</ul>\n<p>虽然说看着迭代器比较多，但其实他们的遍历顺序都是一样的，构造也非常简单，都是使用 <code>HashIterator</code> 中的 <code>nextNode</code> 方法进行遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().key; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().value; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntryIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Map.<span class=\"function\">Entry&lt;K,V&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HashIterator 中的遍历方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashIterator</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; next;        <span class=\"comment\">// 下一个 entry 节点</span></span><br><span class=\"line\">  Node&lt;K,V&gt; current;     <span class=\"comment\">// 当前 entry 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> expectedModCount;  <span class=\"comment\">// fail-fast 的判断标识</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> index;             <span class=\"comment\">// 当前槽</span></span><br><span class=\"line\"></span><br><span class=\"line\">  HashIterator() &#123;</span><br><span class=\"line\">    expectedModCount = modCount;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t = table;</span><br><span class=\"line\">    current = next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// advance to first entry</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">nextNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t;</span><br><span class=\"line\">    Node&lt;K,V&gt; e = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((next = (current = e).next) == <span class=\"keyword\">null</span> &amp;&amp; (t = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>next 和 current 分别表示下一个 Node 节点和当前的 Node 节点，HashIterator 在初始化时会遍历所有的节点。下面我们用图来表示一下他们的遍历顺序</p>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135703898-308748730.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>你会发现 <code>nextNode()</code> 方法的遍历方式和 HashIterator 的遍历方式一样，只不过判断条件不一样，构造 HashIterator 的时候判断条件是有没有链表，桶是否为 null，而遍历 nextNode 的判断条件变为下一个 node 节点是不是 null ，并且桶是不是为 null。</p>\n<h3 id=\"8-HashMap-中的移除方法\"><a href=\"#8-HashMap-中的移除方法\" class=\"headerlink\" title=\"8.HashMap 中的移除方法\"></a>8.HashMap 中的移除方法</h3><p>HashMap 中的移除方法也比较简单了，源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">    <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      node = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">              ((k = e.key) == key ||</span><br><span class=\"line\">               (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">            node = e;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          p = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                         (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">        tab[index] = node.next;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        p.next = node.next;</span><br><span class=\"line\">      ++modCount;</span><br><span class=\"line\">      --size;</span><br><span class=\"line\">      afterNodeRemoval(node);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remove 方法有很多，最终都会调用到 removeNode 方法，只不过传递的参数值不同，我们拿 remove(object) 来演示一下。</p>\n<p>首先会通过 hash 来找到对应的 bucket，然后通过遍历链表，找到键值相等的节点，然后把对应的节点进行删除。</p>\n<h3 id=\"9-HashMap-为啥线程不安全\"><a href=\"#9-HashMap-为啥线程不安全\" class=\"headerlink\" title=\"9.HashMap 为啥线程不安全\"></a>9.HashMap 为啥线程不安全</h3><p>HashMap 不是一个线程安全的容器，不安全性体现在多线程并发对 HashMap 进行 put 操作上。如果有两个线程 A 和 B ，首先 A 希望插入一个键值对到 HashMap 中，在决定好桶的位置进行 put 时，此时 A 的时间片正好用完了，轮到 B 运行，B 运行后执行和 A 一样的操作，只不过 B 成功把键值对插入进去了。如果 A 和 B 插入的位置（桶）是一样的，那么线程 A 继续执行后就会覆盖 B 的记录，造成了数据不一致问题。</p>\n<p>还有一点在于 HashMap 在扩容时，因 resize 方法会形成环，造成死循环，导致 CPU 飙高。</p>\n<h3 id=\"10-HashMap-是如何处理哈希碰撞的\"><a href=\"#10-HashMap-是如何处理哈希碰撞的\" class=\"headerlink\" title=\"10.HashMap 是如何处理哈希碰撞的\"></a>10.HashMap 是如何处理哈希碰撞的</h3><p>HashMap 底层是使用位桶 + 链表实现的，位桶决定元素的插入位置，位桶是由 hash 方法决定的，当多个元素的 hash 计算得到相同的哈希值后，HashMap 会把多个 Node 元素都放在对应的位桶中，形成链表，这种处理哈希碰撞的方式被称为链地址法。</p>\n<p>其他处理 hash 碰撞的方式还有 <strong>开放地址法、rehash 方法、建立一个公共溢出区</strong>这几种方法。</p>\n<h3 id=\"11-HashMap-线程安全的实现有哪些\"><a href=\"#11-HashMap-线程安全的实现有哪些\" class=\"headerlink\" title=\"11.HashMap 线程安全的实现有哪些\"></a>11.HashMap 线程安全的实现有哪些</h3><p>因为 HashMap 不是一个线程安全的容器，所以并发场景下推荐使用 <code>ConcurrentHashMap</code> ，或者使用线程安全的 HashMap，使用 <code>Collections</code> 包下的线程安全的容器，比如说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Collections.synchronizedMap(<span class=\"keyword\">new</span> HashMap());</span><br></pre></td></tr></table></figure>\n\n<p>还可以使用 HashTable ，它也是线程安全的容器，基于 key-value 存储，经常用 HashMap 和 HashTable 做比较就是因为 HashTable 的数据结构和 HashMap 相同。</p>\n<p>上面效率最高的就是 ConcurrentHashMap。</p>\n<h3 id=\"11-HashMap和Hashtable的区别\"><a href=\"#11-HashMap和Hashtable的区别\" class=\"headerlink\" title=\"11.HashMap和Hashtable的区别:\"></a>11.HashMap和Hashtable的区别:</h3><ol>\n<li><p>线程是否安全： HashMap 是⾮线程安全的，Hashtable 是线程安全的；<strong>Hashtable 内部的⽅法基本都经过 synchronized 修饰</strong>。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap吧！）；</p>\n</li>\n<li><p>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，Hashtable 基本被淘汰，不要在代码中使⽤它；</p>\n</li>\n<li><p>对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有⼀个 null，直接抛出 NullPointerException。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①<strong>创建时如果不指定容量初始值，Hashtable 默认的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后每次扩充（resize（）），容量变为原来的2倍</strong>。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 <strong>tableSizeFor</strong>()⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是2的幂次⽅。</li>\n<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</li>\n</ol>\n<h5 id=\"HashMap中的key可以是任何对象或数据类型吗\"><a href=\"#HashMap中的key可以是任何对象或数据类型吗\" class=\"headerlink\" title=\"HashMap中的key可以是任何对象或数据类型吗\"></a><strong>HashMap中的key可以是任何对象或数据类型吗</strong></h5><ul>\n<li><strong>可以为null，但不能是可变对象</strong>，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li>\n<li><strong>如果可变对象在 HashMap 中被用作键</strong>，<strong>那就要小心在改变对象状态的时候，不要改变它的哈希值了</strong>。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li>\n</ul>\n","categories":["集合"],"tags":["HashMap"]},{"title":"Java 8新特性","url":"/2021-02-18-JAVA%208%E6%96%B0%E7%89%B9%E6%80%A7.html","content":"<h2 id=\"一、Lambda表达式\"><a href=\"#一、Lambda表达式\" class=\"headerlink\" title=\"一、Lambda表达式\"></a>一、Lambda表达式</h2><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>\n<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>lambda 表达式的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(parameters) -&gt; expression </span><br><span class=\"line\">或 </span><br><span class=\"line\">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下是lambda表达式的重要特征:</p>\n<ul>\n<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>\n<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>\n<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>\n<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *Lambda表达式的使用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 1.举例 (o1,o2) -&gt; Integer.compare(o1,o2);</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.格式</span></span><br><span class=\"line\"><span class=\"comment\"> *      -&gt; :lambda操作符 或 箭头操作符</span></span><br><span class=\"line\"><span class=\"comment\"> *      -&gt;左边 :lambda形参列表 （其实就是接口中的抽象方法的形参列表）</span></span><br><span class=\"line\"><span class=\"comment\"> *      -&gt;右边 :lambda体（其实就是重写的抽象方法的方法体）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 3.Lambda表达式的使用： (分为6种情况介绍)</span></span><br><span class=\"line\"><span class=\"comment\"> *          总结：</span></span><br><span class=\"line\"><span class=\"comment\"> *          -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda参数列表只有一个参数，其一对()也可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> *          -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句(可能是return语句)，可以省略这一对&#123;&#125;和return关键字</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 4.lambda表达式的本质： 作为函数式接口的实例（针对于接口的实现类）</span></span><br><span class=\"line\"><span class=\"comment\"> *                     对于接口有要求：只有一个抽象方法，所以重新时就不用告诉重新的方法名字了</span></span><br><span class=\"line\"><span class=\"comment\"> * 5.如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> *                                                      -java8新特性</span></span><br><span class=\"line\"><span class=\"comment\"> *                想要使用lambda表达式必须使用函数式接口，我们可以在接口上使用<span class=\"doctag\">@Functionallterface</span>注解，可以检查他是否是一个函数式接口，并且注解会保存在javadoc上</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t\t\t  所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体场景：</span></span><br><span class=\"line\"><span class=\"comment\"> *          语法格式一：无参，无返回值</span></span><br><span class=\"line\"><span class=\"comment\"> *          语法格式二：需要一个参数，但是无返回值</span></span><br><span class=\"line\"><span class=\"comment\"> *          语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class=\"line\"><span class=\"comment\"> *          语法格式四：lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> *          语法格式五：lambda 需要两个货以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class=\"line\"><span class=\"comment\"> *          语法格式六：当lambda体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>\n<p>在 Java8Tester.java 文件输入以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">7</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tempInt = i;<span class=\"comment\">//final修饰</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;\\t 收集到地：&quot;</span>+tempInt+<span class=\"string\">&quot;龙珠&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    cyclicBarrier.await();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.company;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Java8Lambda</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Java8Lambda java8Lambda =  <span class=\"keyword\">new</span> Java8Lambda();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//类型声明</span></span><br><span class=\"line\">        MathOperation addition = (<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b) -&gt; a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//不用类型声明</span></span><br><span class=\"line\">        MathOperation subtraction = (a,b) -&gt; a - b;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//大括号中返回语句</span></span><br><span class=\"line\">        MathOperation multiplication = (a, b) -&gt;  &#123;<span class=\"keyword\">return</span> a * b;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//没有大括号及返回语句</span></span><br><span class=\"line\">        MathOperation division = (a,b) -&gt; a / b;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(java8Lambda.operation(<span class=\"number\">2</span>,<span class=\"number\">5</span>,addition));</span><br><span class=\"line\">        System.out.println(java8Lambda.operation(<span class=\"number\">10</span>,<span class=\"number\">5</span>,subtraction));</span><br><span class=\"line\">        System.out.println(java8Lambda.operation(<span class=\"number\">2</span>,<span class=\"number\">5</span>,multiplication));</span><br><span class=\"line\">        System.out.println(java8Lambda.operation(<span class=\"number\">10</span>,<span class=\"number\">5</span>,division));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//不用括号</span></span><br><span class=\"line\">        GreetingService greetingService = message -&gt; System.out.println(message);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用括号</span></span><br><span class=\"line\">        GreetingService greetingService1 = (message) -&gt; System.out.println(message);</span><br><span class=\"line\"></span><br><span class=\"line\">        greetingService.sayMessage(<span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        greetingService1.sayMessage(<span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MathOperation</span></span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operation</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GreetingService</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sayMessage</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">operation</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,MathOperation mathOperation)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mathOperation.operation(a, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.company;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.Comparator;</span><br><span class=\"line\">import java.util.function.Consumer;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Java8Lambda2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;语法格式一：无参，无返回值</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test1()&#123;</span><br><span class=\"line\">        Runnable r1 &#x3D; new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                System.out.println(&quot;我是赵日天&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        r1.run();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;***********************&quot;);</span><br><span class=\"line\">        Runnable r2 &#x3D; () -&gt; System.out.println(&quot;我是李破敌&quot;);</span><br><span class=\"line\">        r2.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;语法格式二：需要一个参数，但是无返回值</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test2()&#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con &#x3D; new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void accept(String s) &#123;</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        con.accept(&quot;谎言和誓言有什么区别呢？&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;***********************&quot;);</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 &#x3D; (String s) -&gt; System.out.println(s);</span><br><span class=\"line\">        con1.accept(&quot;没有区别，都是骗人的&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test3()&#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 &#x3D; (String s) -&gt; System.out.println(s);</span><br><span class=\"line\">        con1.accept(&quot;没有区别，都是骗人的&quot;);</span><br><span class=\"line\">        System.out.println(&quot;*********************&quot;);</span><br><span class=\"line\">        Consumer&lt;String&gt; con2 &#x3D; (s) -&gt; System.out.println(s);</span><br><span class=\"line\">        con1.accept(&quot;没有区别，都是骗人的&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test4()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;类型推断</span><br><span class=\"line\"></span><br><span class=\"line\">        int[] arr &#x3D; &#123;1,2,3&#125;;&#x2F;&#x2F;类型推断</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;语法格式四：lambda 若只需要一个参数时，参数的小括号可以省略</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test5()&#123;</span><br><span class=\"line\">        Consumer&lt;String&gt; con1 &#x3D; ( s) -&gt; System.out.println(s);</span><br><span class=\"line\">        con1.accept(&quot;没有区别，都是骗人的&quot;);</span><br><span class=\"line\">        System.out.println(&quot;*********************&quot;);</span><br><span class=\"line\">        Consumer&lt;String&gt; con2 &#x3D; s -&gt; System.out.println(s);</span><br><span class=\"line\">        con1.accept(&quot;没有区别，都是骗人的&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;语法格式五：lambda 需要两个货以上的参数，多条执行语句，并且可以有返回值</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test6()&#123;</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com &#x3D; new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">                System.out.println(o1);</span><br><span class=\"line\">                System.out.println(o2);</span><br><span class=\"line\">                return o1.compareTo(o2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(com.compare(13,33));</span><br><span class=\"line\">        System.out.println(&quot;*************&quot;);</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 &#x3D; (o1,o2) -&gt;&#123;</span><br><span class=\"line\">            System.out.println(o1);</span><br><span class=\"line\">            System.out.println(o2);</span><br><span class=\"line\">            return o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(com1.compare(93,33));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;语法格式六：当lambda体只有一条语句时，return 与大括号若有，都可以省略</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test7()&#123;</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com1 &#x3D; (o1,o2) -&gt;&#123;</span><br><span class=\"line\">            return o1.compareTo(o2);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(com1.compare(93,33));</span><br><span class=\"line\">        System.out.println(&quot;***************&quot;);</span><br><span class=\"line\">        Comparator&lt;Integer&gt; com2 &#x3D; (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class=\"line\">        System.out.println(com2.compare(22,33));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void test()&#123;</span><br><span class=\"line\">        Comparator&lt;Integer&gt; comparator &#x3D; new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">                return Integer.compare(o1,o2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        int temp &#x3D; comparator.compare(23,33);</span><br><span class=\"line\">        System.out.println(temp);</span><br><span class=\"line\">        System.out.println(&quot;****************************&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; comparator1 &#x3D; (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class=\"line\">        int temp1 &#x3D; comparator.compare(23,33);</span><br><span class=\"line\">        System.out.println(temp1);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;****************************&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Comparator&lt;Integer&gt; comparator3&#x3D; Integer :: compare;</span><br><span class=\"line\">        int temp2 &#x3D; comparator.compare(93,33);</span><br><span class=\"line\">        System.out.println(temp2);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、函数式编程\"><a href=\"#二、函数式编程\" class=\"headerlink\" title=\"二、函数式编程\"></a>二、函数式编程</h2><p>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象（OOP）编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程）</p>\n<p>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</p>\n<p>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</p>\n<p>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</p>\n<h3 id=\"lambda表达式的本质\"><a href=\"#lambda表达式的本质\" class=\"headerlink\" title=\"lambda表达式的本质\"></a><strong>lambda表达式的本质</strong></h3><p>： 作为函数式接口的实例（针对于接口的实现类）；对于接口有要求：只有一个抽象方法，所以重新时就不用告诉重新的方法名字了</p>\n<h3 id=\"函数式接口的本质\"><a href=\"#函数式接口的本质\" class=\"headerlink\" title=\"函数式接口的本质\"></a><strong>函数式接口的本质</strong></h3><p>：如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口</p>\n<blockquote>\n<p>想要使用lambda表达式必须使用函数式接口，我们可以在接口上使用@Functionallterface注解，可以检查他是否是一个函数式接口，并且注解会保存在javadoc上</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.company;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * java内置的4大核心函数式接口</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 消费型接口 Consumer&lt;T&gt; void accept(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> * 供给型接口 Supplier&lt;T&gt; T get()</span></span><br><span class=\"line\"><span class=\"comment\"> * 函数型接口 Function&lt;T,R&gt; R apply(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> * 断定型接口 Predicate&lt;T&gt; boolean test(T t)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Java8Lambda3</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        happyTime(<span class=\"number\">500</span>, <span class=\"keyword\">new</span> Consumer&lt;Double&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Double aDouble)</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;买了瓶水花了&quot;</span>+aDouble);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        happyTime(<span class=\"number\">900</span>,m -&gt;System.out.println(<span class=\"string\">&quot;买了瓶水花了&quot;</span>+m));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">happyTime</span><span class=\"params\">(<span class=\"keyword\">double</span> money, Consumer&lt;Double&gt; consumer)</span></span>&#123;</span><br><span class=\"line\">        consumer.accept(money);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;哈哈&quot;</span>,<span class=\"string\">&quot;哈喝&quot;</span>,<span class=\"string\">&quot;呵呵&quot;</span>);</span><br><span class=\"line\">        List&lt;String&gt; filterStrings = filterString(list, <span class=\"keyword\">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> s.contains(<span class=\"string\">&quot;哈&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(filterStrings);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;(*&amp;*******************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; filterStrings1 = filterString(list, s -&gt; s.contains(<span class=\"string\">&quot;哈&quot;</span>));</span><br><span class=\"line\">        System.out.println(filterStrings1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据给的的规则，过滤集合中的字符串，此规则由Predicate的方法决定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">filterString</span><span class=\"params\">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; filterList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s:list)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre.test(s))&#123;</span><br><span class=\"line\">                filterList.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filterList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、方法引用（Metlod-References）\"><a href=\"#三、方法引用（Metlod-References）\" class=\"headerlink\" title=\"三、方法引用（Metlod References）\"></a>三、方法引用（Metlod References）</h2><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>\n<p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a><strong>要求</strong></h3><p>：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！情况一、二满足</p>\n<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a><strong>格式</strong></h3><p>：使用操作符“ :: ”将类（或对象）与方法名分隔开来。<br>如下三种主要使用情况：</p>\n<blockquote>\n<p>情况一    对象 :: 实例方法名</p>\n<p>情况二    类 :: 静态方法名</p>\n<p>情况三    类 :: 实例方法名  </p>\n<p>情况三有可能出现传过来参数是两个a,b，但返回的是a.compareTo(b),这种也成立</p>\n</blockquote>\n<h2 id=\"四、Optional类\"><a href=\"#四、Optional类\" class=\"headerlink\" title=\"四、Optional类\"></a>四、Optional类</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。<br>以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类 已经成为Java 8类库的一部分。</p>\n<p>Optional<T>类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</p>\n<p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent（）方法会返回true，调用get（） 方法 会返回该对象。</p>\n<p><strong>常用的几种方法：</strong></p>\n<p>Optional.of(T t)：创建一个Optional实例，t必须非空;</p>\n<p>Optional.empty()：创建一个空的Optional实例</p>\n<p>Optional.ofNullable(T t)：t可以为null</p>\n<p>和ofNullable常一起用的有orElse(T t1)方法，如果Optional.ofNullable(T t)中的t不为空返回原来的对象，t为空返回orElse(T t1)中的他t1对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yhc.java8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Boy</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Girl girl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Boy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Boy</span><span class=\"params\">(Girl girl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Boy&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;girl=&quot;</span> + girl +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Girl <span class=\"title\">getGirl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setGirl</span><span class=\"params\">(Girl girl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.girl = girl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.yhc.java8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Girl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Girl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Girl</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Girl&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yhc.java8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Optional;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Java8Optional2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Optional.of(T t)：创建一个Optional实例，t必须非空;</span></span><br><span class=\"line\"><span class=\"comment\">Optional.empty()：创建一个空的Optional实例</span></span><br><span class=\"line\"><span class=\"comment\">Optional.ofNullable(T t)：t可以为null</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Girl girl = <span class=\"keyword\">new</span> Girl();</span><br><span class=\"line\">        <span class=\"comment\">//girl=null; 出现空指针异常</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Girl girl = <span class=\"keyword\">new</span> Girl();</span><br><span class=\"line\">        <span class=\"comment\">//girl=null; //ofNullable(T t)：t可以为null</span></span><br><span class=\"line\">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class=\"line\">        System.out.println(optionalGirl);</span><br><span class=\"line\">        <span class=\"comment\">//orElse(T t1)如果当前的Optional内部封装的t是非空的，则返回内部的t</span></span><br><span class=\"line\">        <span class=\"comment\">//如果内部的t是空的，则返回orElse()方法中得到参数t1</span></span><br><span class=\"line\">        Girl girl1 = optionalGirl.orElse(<span class=\"keyword\">new</span> Girl(<span class=\"string\">&quot;赵丽颖&quot;</span>));</span><br><span class=\"line\">        System.out.println(girl1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getGrilName</span><span class=\"params\">(Boy boy)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  boy.getGirl().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//优化以后的getGirlName()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getGrilName1</span><span class=\"params\">(Boy boy)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(boy != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            Girl girl = boy.getGirl();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(girl != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> girl.getName();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用Optional以后的getGirlName()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getGrilName2</span><span class=\"params\">(Boy boy)</span></span>&#123;</span><br><span class=\"line\">        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class=\"line\">        <span class=\"comment\">//此时的boy1 一定非空</span></span><br><span class=\"line\">        Boy boy1 = boyOptional.orElse(<span class=\"keyword\">new</span> Boy(<span class=\"keyword\">new</span> Girl(<span class=\"string\">&quot;迪丽热巴&quot;</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        Girl girl = boy1.getGirl();</span><br><span class=\"line\"></span><br><span class=\"line\">        Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class=\"line\">        <span class=\"comment\">//此时girl1一定非空</span></span><br><span class=\"line\">        Girl girl1 = girlOptional.orElse(<span class=\"keyword\">new</span> Girl(<span class=\"string\">&quot;古力娜扎&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> girl1.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Boy boy = <span class=\"keyword\">new</span> Boy();</span><br><span class=\"line\">        boy=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String girlName = getGrilName(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Boy boy = <span class=\"keyword\">new</span> Boy();</span><br><span class=\"line\">        boy=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        String girlName = getGrilName1(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Boy boy=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        boy = <span class=\"keyword\">new</span> Boy();</span><br><span class=\"line\">        boy = <span class=\"keyword\">new</span> Boy(<span class=\"keyword\">new</span> Girl(<span class=\"string\">&quot;苍老师&quot;</span>));</span><br><span class=\"line\">        String girlName = getGrilName2(boy);</span><br><span class=\"line\">        System.out.println(girlName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、Stream-API\"><a href=\"#五、Stream-API\" class=\"headerlink\" title=\"五、Stream API\"></a>五、Stream API</h2><p>Java8中有两大最为重要的改变。第一个是Lambda表达式；另外一个则是Stream APl。</p>\n<p>Stream API（java.util.stream）把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为StreamAPI可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>\n<p>Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API对集合数据进行操作，就类似于使用SQL执行的数据库查询。也可以使用StreamAPI来并行执行操作。简言之，StreamAPI提供了一种高效且易于使用的处理数据的方式。</p>\n<h3 id=\"为什么要使用Stream-API\"><a href=\"#为什么要使用Stream-API\" class=\"headerlink\" title=\"为什么要使用Stream API\"></a>为什么要使用Stream API</h3><p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</p>\n<p>Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。</p>\n<h3 id=\"Stream到底是什么呢？\"><a href=\"#Stream到底是什么呢？\" class=\"headerlink\" title=\"Stream到底是什么呢？\"></a>Stream到底是什么呢？</h3><p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>\n<p>“集合讲的是数据，Stream讲的是计算！”</p>\n<p>注意：</p>\n<ol>\n<li>Stream自己不会存储元素。</li>\n<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>\n<li>Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>\n</ol>\n<h3 id=\"Stream的操作：三个步骤\"><a href=\"#Stream的操作：三个步骤\" class=\"headerlink\" title=\"Stream的操作：三个步骤\"></a>Stream的操作：三个步骤</h3><p>1、创建Stream一个数据源（如：集合、数组），获取一个流</p>\n<p>2、中间操作一个中间操作<strong>链</strong>，对数据源的数据进行处理</p>\n<p>3、终止操作（终端操作）<strong>一旦执行终止操作，就执行中间操作链，并产生结果</strong>。之后，不会再被使用</p>\n<p><strong>实例：</strong></p>\n<h4 id=\"1-创建Stream数据源\"><a href=\"#1-创建Stream数据源\" class=\"headerlink\" title=\"1.创建Stream数据源\"></a>1.创建Stream数据源</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yhc.java8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.IntStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. Stream关注的是对数据的运算，与CPU打交道</span></span><br><span class=\"line\"><span class=\"comment\"> *      集合关注的是数据的存储，与内存打交道</span></span><br><span class=\"line\"><span class=\"comment\"> * 2.</span></span><br><span class=\"line\"><span class=\"comment\"> * ①Stream 自己不会存储元素</span></span><br><span class=\"line\"><span class=\"comment\"> * ②Stream 不会改变原对象。相反，他们会返回一个持有结果的新Stream。</span></span><br><span class=\"line\"><span class=\"comment\"> * ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 3. Stream执行流程</span></span><br><span class=\"line\"><span class=\"comment\"> * ①Stream的实例化</span></span><br><span class=\"line\"><span class=\"comment\"> * ②一系列的中间操作（过滤、映射....）</span></span><br><span class=\"line\"><span class=\"comment\"> * ③终止操作</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 4. 说明：</span></span><br><span class=\"line\"><span class=\"comment\"> *  一个中间操作链，对数据的数据进行处理</span></span><br><span class=\"line\"><span class=\"comment\"> *  一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被执行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Java8Stream</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式一：通过集合</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//default Stream&lt;E&gt; stream():返回一个顺序流</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//default Stream&lt;E&gt; parallelStream():返回一个并行流</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; parllelStream= employees.parallelStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式二：通过数组</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array):返回一个流</span></span><br><span class=\"line\">        IntStream stream = Arrays.stream(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        Employee e1 = <span class=\"keyword\">new</span> Employee(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Tom&quot;</span>);</span><br><span class=\"line\">        Employee e2 = <span class=\"keyword\">new</span> Employee(<span class=\"number\">1001</span>,<span class=\"string\">&quot;Jerry&quot;</span>);</span><br><span class=\"line\">        Employee[] arr1 = <span class=\"keyword\">new</span> Employee[]&#123;e1,e2&#125;;</span><br><span class=\"line\">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式三：通过Stream的of()</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//创建 Stream方式四：创建无限流</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//迭代 public static&lt;T&gt; Stream&lt;T&gt; iterate（final T seed，final UnaryOperator&lt;T&gt; f）</span></span><br><span class=\"line\">    <span class=\"comment\">//遍历前10个偶数</span></span><br><span class=\"line\">    Stream.iterate(<span class=\"number\">0</span>,t-&gt;t+<span class=\"number\">2</span>).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生成 public static&lt;T&gt; Stream&lt;T&gt; generate（Supplier&lt;T&gt;s）</span></span><br><span class=\"line\">    Stream.generate(Math::random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmployeeData</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Employee&gt; <span class=\"title\">getEmployees</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1001</span>,<span class=\"string\">&quot;马化腾&quot;</span>,<span class=\"number\">33</span>,<span class=\"number\">3333.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1002</span>,<span class=\"string\">&quot;马云&quot;</span>,<span class=\"number\">32</span>,<span class=\"number\">7233.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1003</span>,<span class=\"string\">&quot;刘强东&quot;</span>,<span class=\"number\">44</span>,<span class=\"number\">8343.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1004</span>,<span class=\"string\">&quot;雷军&quot;</span>,<span class=\"number\">55</span>,<span class=\"number\">5543.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1005</span>,<span class=\"string\">&quot;李彦宏&quot;</span>,<span class=\"number\">44</span>,<span class=\"number\">93233.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1006</span>,<span class=\"string\">&quot;比尔盖茨&quot;</span>,<span class=\"number\">31</span>,<span class=\"number\">5633.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1007</span>,<span class=\"string\">&quot;任正非&quot;</span>,<span class=\"number\">45</span>,<span class=\"number\">4353.23</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1008</span>,<span class=\"string\">&quot;扎克伯格&quot;</span>,<span class=\"number\">53</span>,<span class=\"number\">66733.23</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">    Employee(<span class=\"keyword\">int</span> id, String name, <span class=\"keyword\">int</span> age, <span class=\"keyword\">double</span> salary) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Employee(<span class=\"keyword\">int</span> id, String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getSalary</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSalary</span><span class=\"params\">(<span class=\"keyword\">double</span> salary)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Employee&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;id=&quot;</span> + id +</span><br><span class=\"line\">                <span class=\"string\">&quot;, name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, age=&quot;</span> + age +</span><br><span class=\"line\">                <span class=\"string\">&quot;, salary=&quot;</span> + salary +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Employee employee = (Employee) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id == employee.id &amp;&amp; age == employee.age &amp;&amp; Double.compare(employee.salary, salary) == <span class=\"number\">0</span> &amp;&amp; Objects.equals(name, employee.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hash(id, name, age, salary);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-中间操作\"><a href=\"#2-中间操作\" class=\"headerlink\" title=\"2.中间操作\"></a>2.中间操作</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yhc.java8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试Stream的中间操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Java8Stream2</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1 筛选与切片</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class=\"line\">            <span class=\"comment\">//filter(Predicate p) -接收Lambda，从流中排除某些元素。</span></span><br><span class=\"line\">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class=\"line\">            <span class=\"comment\">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class=\"line\">        stream.filter(e -&gt; e.getSalary()&gt;<span class=\"number\">7000</span>).limit(<span class=\"number\">2</span>).skip(<span class=\"number\">1</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//limit(n) -截断流，使其元素不超过给定数量。</span></span><br><span class=\"line\">            <span class=\"comment\">//注意一旦执行终止操作，就不能在执行别的中间操作了，需要重新生成</span></span><br><span class=\"line\">        list.stream().limit(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//skip(n) -跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit（n）互补</span></span><br><span class=\"line\">        list.stream().skip(<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//distinct() —筛选，通过流所生成元素的hashCode()和equals()去除重复元素</span></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1009</span>,<span class=\"string\">&quot;东哥&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">33433.3</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1009</span>,<span class=\"string\">&quot;东哥&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">33433.3</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1009</span>,<span class=\"string\">&quot;东哥&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">33433.3</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> Employee(<span class=\"number\">1010</span>,<span class=\"string\">&quot;东哥&quot;</span>,<span class=\"number\">40</span>,<span class=\"number\">33433.3</span>));</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        list.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2 映射</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//map（Function f）接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class=\"line\">        List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>);</span><br><span class=\"line\">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;String&gt; namesStream = employees.stream().map(e -&gt; e.getName());</span><br><span class=\"line\">        namesStream.filter(name -&gt; name.length()&gt;<span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//练习2：</span></span><br><span class=\"line\">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(Java8Stream2::fromStringToStream);</span><br><span class=\"line\">        streamStream.forEach(s -&gt;s.forEach(System.out::println));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//flatMap（Function f）接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(Java8Stream2::fromStringToStream);</span><br><span class=\"line\">        characterStream.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;Character&gt; <span class=\"title\">fromStringToStream</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        ArrayList&lt;Character&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Character c:str.toCharArray())&#123;</span><br><span class=\"line\">            list.add(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ArrayList list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">        list.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">        list.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList list1 = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        list1.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">        list1.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">        list1.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//list.add(list1); [1, 2, 3, [4, 5, 6]]</span></span><br><span class=\"line\">        <span class=\"comment\">//list.addAll(list1); [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3 排序</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//sorted() -自然排序</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">12</span>,<span class=\"number\">34</span>,<span class=\"number\">35</span>,<span class=\"number\">66</span>,<span class=\"number\">44</span>,<span class=\"number\">76</span>);</span><br><span class=\"line\">        list.stream().sorted().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//抛异常，因为employees没有实现Comparable接口</span></span><br><span class=\"line\">    <span class=\"comment\">//    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class=\"line\">    <span class=\"comment\">//    employees.stream().sorted().forEach(System.out::println);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//sorted(Comparaator com) -定制排序</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        employees.stream().sorted((e1,e2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ageValue = Integer.compare(e1.getAge(),e2.getAge());</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ageValue != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ageValue;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-终止操作\"><a href=\"#3-终止操作\" class=\"headerlink\" title=\"3.终止操作\"></a>3.终止操作</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yhc.java8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Optional;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Collectors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *测试Stream的终止操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Java8Stream3</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1 匹配与查找</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//allMatch(Predicate p) ——检查是否匹配所有元素。练习：是否所有的员工的年龄都大于18</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">        System.out.println(allMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//anyMatch(Predicate p) ——检查是否至少匹配一个元素。练习：是否存在员工的工资大于10000</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class=\"number\">10000</span>);</span><br><span class=\"line\">        System.out.println(anyMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//noneMatch(Predicate p) ——检查是否没有匹配的元素。练习：是否存在员工姓“雷”</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class=\"string\">&quot;雷&quot;</span>));</span><br><span class=\"line\">        System.out.println(noneMatch);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//findFirst —返回第一个元素</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; firstemployee = employees.stream().findFirst();</span><br><span class=\"line\">        System.out.println(firstemployee);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//findAny 一返回当前流中的任意元素 ，parallelStream并行流</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; anyemployee = employees.parallelStream().findAny();</span><br><span class=\"line\">        System.out.println(anyemployee);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">            <span class=\"comment\">//count —返回流中元素的总个数</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = employees.stream().filter(e -&gt; e.getSalary()&gt;<span class=\"number\">6000</span>).count();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//max(Comparator c) —返回流中最大值 练习：返回最高的工资</span></span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class=\"line\">        Optional&lt;Double&gt; maxsalary = salaryStream.max(Double::compare);</span><br><span class=\"line\">        System.out.println(maxsalary);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//min(Comparator c) —返回流中最小值 练习：返回最低工资的员工</span></span><br><span class=\"line\">        Optional&lt;Employee&gt; minStream = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class=\"line\">        System.out.println(minStream);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//forEach(Comparator c) —内部送代</span></span><br><span class=\"line\">        employees.stream().forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//使用集合的内部迭代</span></span><br><span class=\"line\">        employees.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2 归约</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//reduce(T identity,BinaryOperator) -可以将流中元素反复结合起来，得到一个值。返回T</span></span><br><span class=\"line\">            <span class=\"comment\">//练习1：计算1-10的自然数的和</span></span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        Integer reduce = list.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">        System.out.println(reduce);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//reduce(BinaryOperator) -可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">//练习2：计算公司所有员工工资的总和</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        Stream&lt;Double&gt; salaryStream = employees.stream().map(employee -&gt; employee.getSalary());</span><br><span class=\"line\">        <span class=\"comment\">//Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class=\"line\">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1+d2);</span><br><span class=\"line\">        System.out.println(sumMoney);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3 收集</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//collect(Collector c) —将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class=\"line\">            <span class=\"comment\">//练习1：查找工资大于6000的员工，结果返回一个list 或 Set</span></span><br><span class=\"line\">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toList());</span><br><span class=\"line\">        employeeList.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class=\"number\">6000</span>).collect(Collectors.toSet());</span><br><span class=\"line\">        employeeSet.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["java"],"tags":["新特性"]},{"title":"MySql和Spring中事物的实现原理","url":"/2021-03-23-MySql%E5%92%8CSpring%E4%B8%AD%E4%BA%8B%E7%89%A9%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html","content":"<h2 id=\"一、MySql中事物的实现原理\"><a href=\"#一、MySql中事物的实现原理\" class=\"headerlink\" title=\"一、MySql中事物的实现原理\"></a>一、MySql中事物的实现原理</h2><h3 id=\"1、什么是事物\"><a href=\"#1、什么是事物\" class=\"headerlink\" title=\"1、什么是事物\"></a>1、什么是事物</h3><p>事务由单独单元的一个或者多个sql语句组成，在这个单元中，每个mysql语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或者产生错误，整个单元将会回滚，也就是所有受到影响的数据将会返回到事务开始以前的状态；如果单元中的所有sql语句均执行成功，则事务才会被顺利执行。</p>\n<p><strong>MySQL默认采用的是自动提交的方式</strong>，也就是说如果不是显示的开始一个事务，则系统会自动向数据库提交结果。在当前连接中，还可以通过设置AUTOCONNIT变量来启用或者禁用自动提交模式。</p>\n<p>正常我们在提交sql时，是有</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">start</span> <span class=\"keyword\">transaction</span>;  </span><br><span class=\"line\">sql...</span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#开启</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> AUTOCOMMIT = <span class=\"number\">1</span>;</span><br><span class=\"line\">关闭自动提交功能后，只用当执行<span class=\"keyword\">COMMIT</span>命令后，MySQL才将数据表中的资料提交到数据库中。如果执行<span class=\"keyword\">ROLLBACK</span>命令，数据将会被回滚。如果不提交事务，而终止MySQL会话，数据库将会自动执行回滚操作。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、事物必须满足的四个特性\"><a href=\"#2、事物必须满足的四个特性\" class=\"headerlink\" title=\"2、事物必须满足的四个特性\"></a>2、事物必须满足的四个特性</h3><ul>\n<li>原子性：一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作。</li>\n<li>一致性：一个事务的执行会使数据从一个一致状态切换到另一个一致的状态。</li>\n<li>隔离性：事务一旦提交，其所做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</li>\n<li>持久性： 一个事务一旦提交，则会永久的改变数据库的数据</li>\n</ul>\n<p>在mysql中，有很多存储引擎，都是以插件形式存在的，现在较为流行的是innodb存储引擎，他是支持事物的。（实际上支持事务的只有<code>InnoDB</code>跟<code>NDB Cluster</code>）</p>\n<h3 id=\"3、具体mysql是怎么做到的，最最底层（抠到祖坟上）\"><a href=\"#3、具体mysql是怎么做到的，最最底层（抠到祖坟上）\" class=\"headerlink\" title=\"3、具体mysql是怎么做到的，最最底层（抠到祖坟上）\"></a>3、具体mysql是怎么做到的，最最底层（抠到祖坟上）</h3><p>在这里先了解一些概念：</p>\n<h4 id=\"1-redo-log\"><a href=\"#1-redo-log\" class=\"headerlink\" title=\"1.redo log\"></a>1.redo log</h4><h5 id=\"什么是redo-log\"><a href=\"#什么是redo-log\" class=\"headerlink\" title=\"什么是redo log\"></a>什么是redo log</h5><p>redo log叫做重做日志，用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。<strong>当事务提交之后会把所有<code>修改后的信息</code>存到该日志中。</strong></p>\n<p>注：redo log存在于innodb引擎中。</p>\n<p>流程示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">start</span> <span class=\"keyword\">transaction</span>;                                     </span><br><span class=\"line\"><span class=\"keyword\">select</span> balance <span class=\"keyword\">from</span> bank <span class=\"keyword\">where</span> <span class=\"keyword\">name</span>=<span class=\"string\">&quot;zhangsan&quot;</span>;         </span><br><span class=\"line\">// 生成 重做日志 balance=600                                 </span><br><span class=\"line\"><span class=\"keyword\">update</span> bank <span class=\"keyword\">set</span> balance = balance - <span class=\"number\">400</span>;                </span><br><span class=\"line\">// 生成 重做日志 amount=400                               </span><br><span class=\"line\"><span class=\"keyword\">update</span> finance <span class=\"keyword\">set</span> amount = amount + <span class=\"number\">400</span>;          </span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\ds.jpg\" alt=\"ds\" loading=\"lazy\"></p>\n<h5 id=\"redo-log-的作用\"><a href=\"#redo-log-的作用\" class=\"headerlink\" title=\"redo log 的作用\"></a>redo log 的作用</h5><p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。</p>\n<p>那么，如果数据同步之前宕机宕机或断电了怎么办？未来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</p>\n<p>所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</p>\n<h5 id=\"redo-log-的实现（持久性的实现）\"><a href=\"#redo-log-的实现（持久性的实现）\" class=\"headerlink\" title=\"redo log 的实现（持久性的实现）\"></a>redo log 的实现（持久性的实现）</h5><p>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：</p>\n<blockquote>\n<p><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取再放入缓冲池；</p>\n<p><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p>\n</blockquote>\n<p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！</p>\n<p>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。redo log就派上用处了。</p>\n<p>既然redo log也需要存储，也涉及磁盘IO为啥还用上面的方式呢？</p>\n<blockquote>\n<p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p>\n<p>（2）缓存同步是以数据页为单位的，每次传输的数据量大于redo log。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<p>redo log是用来恢复数据的 用于保障已提交事务的持久化特性。</p>\n<h4 id=\"2-undo-log\"><a href=\"#2-undo-log\" class=\"headerlink\" title=\"2.undo log\"></a>2.undo log</h4><h5 id=\"什么是-undo-log\"><a href=\"#什么是-undo-log\" class=\"headerlink\" title=\"什么是 undo log\"></a>什么是 undo log</h5><p>undo log 叫做回滚日志，用于<strong>记录数据被修改前的信息</strong>。与重做日志所记录的数据相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\sdd.jpg\" alt=\"sdd\" loading=\"lazy\"></p>\n<h5 id=\"undo-log-的作用\"><a href=\"#undo-log-的作用\" class=\"headerlink\" title=\"undo log 的作用\"></a>undo log 的作用</h5><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p>\n<h5 id=\"undo-log-的实现（原子性的实现）\"><a href=\"#undo-log-的实现（原子性的实现）\" class=\"headerlink\" title=\"undo log 的实现（原子性的实现）\"></a>undo log 的实现（原子性的实现）</h5><p>undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，如:</p>\n<ul>\n<li>如果你在执行了一个insert语句，那么此时在Undo log日志中，对这个操作记录的回滚日志就生成对应的delete操作。</li>\n<li> 如果你你要执行的是delete操作，那么要把你删除的那条数据数据记录下来，如果要回滚，就应该执行一个insert操作把那条数据插入回去。</li>\n<li>如果你要是执行的是update语句，那么你要把你更新之前的那个值记录下来，回滚的时候重新update一下，把你之前更新前的旧值给他更新回去。</li>\n</ul>\n<p>所以：</p>\n<ol>\n<li>每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,<strong>并且回滚日志必须先于数据持久化到磁盘上</strong></li>\n<li>所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</li>\n</ol>\n<p><strong>总结：</strong></p>\n<p>undo log是用来回滚数据的用于保障 未提交事务的原子性</p>\n<p>所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样</p>\n<blockquote>\n<p>正确理解回滚：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建表：</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test`</span> (</span><br><span class=\"line\"><span class=\"string\">`f1`</span>  <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> ,</span><br><span class=\"line\"><span class=\"string\">`f2`</span>  <span class=\"built_in\">varchar</span>(<span class=\"number\">11</span>)  <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span> ,</span><br><span class=\"line\">PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`f1`</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span></span><br><span class=\"line\"></span><br><span class=\"line\">//执行事务：</span><br><span class=\"line\"><span class=\"keyword\">START</span> <span class=\"keyword\">TRANSACTION</span>;</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">test</span> <span class=\"keyword\">VALUES</span>    (<span class=\"number\">1</span>, <span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">test</span> <span class=\"keyword\">VALUES</span>    (<span class=\"number\">1</span>, <span class=\"string\">&#x27;3&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这时已经开启了一个事务，并且已经执行了一条正确的插入语句，虽然没有体现在数据库中，但如果以后在该连接中又执行了一条commit 或begin或start transaction（新开一个事务会将该链接中的其他未提交的事务提交，相当于commit！）你会发现已经将刚才的INSERT INTO test_tab VALUES (1, &#39;2&#39;);写进了数据库。</p>\n<p> <strong>正确的理解应该是，如果事务中所有sql语句执行正确则需要自己手动提交commit；否则有任何一条执行错误，需要自己提交一条<u>rollback</u>，这时会回滚所有操作，而不是<u>commit</u>会给你自动判断和回滚。</strong></p>\n</blockquote>\n<h4 id=\"3-mysql锁技术和MVCC基础\"><a href=\"#3-mysql锁技术和MVCC基础\" class=\"headerlink\" title=\"3.mysql锁技术和MVCC基础\"></a>3.mysql锁技术和MVCC基础</h4><h5 id=\"mysql锁技术\"><a href=\"#mysql锁技术\" class=\"headerlink\" title=\"mysql锁技术\"></a>mysql锁技术</h5><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。</p>\n<p><strong>读写锁</strong></p>\n<p>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可</p>\n<blockquote>\n<ol>\n<li>共享锁(shared lock),又叫做&quot;读锁&quot;，读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</li>\n<li>排他锁(exclusive lock),又叫做&quot;写锁&quot;，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</li>\n</ol>\n<p>通过读写锁，可以做到并行读操作，但是不能做到写读，并行写操作</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<blockquote>\n<p>事务的隔离性通过<strong>读写锁</strong>来实现！</p>\n</blockquote>\n<h5 id=\"MVCC基础\"><a href=\"#MVCC基础\" class=\"headerlink\" title=\"MVCC基础\"></a>MVCC基础</h5><blockquote>\n<p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。是用来在数据库中控制并发的方法，实现对数据库的并发访问用的。在MySQL中，MVCC只在读取已提交（Read Committed）和可重复读（Repeatable Read）两个事务级别下有效。其是通过Undo日志中的版本链和ReadView一致性视图来实现的。MVCC就是在多个事务同时存在时，SELECT语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。</p>\n<p>他的主要实现思想是通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行。</p>\n<p>MVCC在mysql中的实现依赖的是undo log与read view</p>\n<ul>\n<li>undo log :undo log 中记录某行数据的多个版本的数据。</li>\n<li>read view :用来判断当前版本数据的可见性</li>\n</ul>\n</blockquote>\n<h5 id=\"MVCC实现原理\"><a href=\"#MVCC实现原理\" class=\"headerlink\" title=\"MVCC实现原理\"></a>MVCC实现原理</h5><p>在MySQL中，MVCC只在读取已提交（Read Committed）和可重复读（Repeatable Read）两个事务级别下有效。其是通过Undo日志中的版本链和ReadView一致性视图来实现的。MVCC就是在多个事务同时存在时，SELECT语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。</p>\n<p>1、首先需要知道的是，在MySQL中，会默认为我们的表后面添加三个隐藏字段：</p>\n<blockquote>\n<p><strong>DB_ROW_ID</strong>：行ID，MySQL的B+树索引特性要求每个表必须要有一个主键。如果没有设置的话，会自动寻找第一个不包含NULL的唯一索引列作为主键。如果还是找不到，就会在这个DB_ROW_ID上自动生成一个唯一值，以此来当作主键（该列和MVCC的关系不大）；<br><strong>DB_TRX_ID</strong>：事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID（DELETE语句被当做是UPDATE语句的特殊情况，后面会进行说明）<strong>所以事务ID是执行一条更新操作（增删改）的语句后才会生成；</strong><br><strong>DB_ROLL_PTR</strong>：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针。</p>\n</blockquote>\n<p>2 、ReadView</p>\n<blockquote>\n<p>ReadView一致性视图主要是由两部分组成：</p>\n<p>所有未提交事务的ID数组 和 已经创建的最大事务ID组成（实际上ReadView还有其他的字段，但不影响这里对MVCC的讲解）。比如：[100,200],300。事务100和200是当前未提交的事务，而事务300是当前创建的最大事务（已经提交了）。</p>\n<p>当<strong>执行</strong>SELECT语句的时候会创建<strong>ReadView</strong></p>\n<p>但是<strong>在读取已提交和可重复读两个事务级别下，生成ReadView的策略是不一样的</strong>： 在一个事务的前提下</p>\n<p>读取已提交级别是<strong>每执行一次</strong>SELECT语句就会重新生成一份ReadView，而可重复读级别是<strong>只会在第一次</strong>SELECT语句执行的时候会生成一份，后续的SELECT语句会沿用之前生成的ReadView（即使后面有更新语句的话，也会继续沿用）。</p>\n</blockquote>\n<p>3 、版本链</p>\n<blockquote>\n<p>所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。</p>\n</blockquote>\n<h5 id=\"隔离性的实现\"><a href=\"#隔离性的实现\" class=\"headerlink\" title=\"隔离性的实现\"></a>隔离性的实现</h5><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。</p>\n<p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p>\n<p>MySQL隔离级别有以下四种（级别由低到高）：</p>\n<blockquote>\n<ol>\n<li>READUNCOMMITED(未提交读)</li>\n<li>READCOMMITED(已提交读)</li>\n<li>REPEATABLEREAD(可重复读)</li>\n<li>SERIALIZABLE (串行化)</li>\n</ol>\n</blockquote>\n<p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p>\n<p>那么隔离性是要做到什么呢？ 隔离性是要管理<strong>多个并发读写请求的访问顺序</strong>。 这种顺序包括串行或者是并行</p>\n<p>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>总之，从隔离性的实现可以看出这是一场数据的<strong>可靠性与性能之间的权衡</strong>：</p>\n<blockquote>\n<p>可靠性性高的，并发性能低(比如Serializable)。可靠性低的，并发性能高(比如 Read Uncommited)</p>\n</blockquote>\n<p><strong>READ UNCOMMITTED</strong></p>\n<blockquote>\n<p>在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。</p>\n<p>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到读写并行。</p>\n<p>换句话说，读的操作不能排斥写请求。</p>\n</blockquote>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\formaddt,png\" alt=\"img\" loading=\"lazy\"></p>\n<blockquote>\n<p>优点：读写并行，性能高</p>\n<p>缺点：造成脏读</p>\n</blockquote>\n<p><strong>READ COMMITTED</strong></p>\n<blockquote>\n<p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。</p>\n<p>InnoDB在 READ COMMITTED，<strong>写数据使用排它锁,读取数据不加锁而是使用了MVCC机制</strong>。或者换句话说他采用了读写分离机制。</p>\n<p>但是该级别会产生不可重读以及幻读问题。</p>\n</blockquote>\n<p><strong>什么是不可重读？</strong></p>\n<blockquote>\n<p>在一个事务内多次读取的结果不一样。</p>\n</blockquote>\n<p><strong>为什么会产生不可重复读？</strong></p>\n<blockquote>\n<p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新生成一个版本号，所以每次select的时候读的不是一个副本而是不同的副本。</p>\n<p>在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读</p>\n<p>REPEATABLE READ(Mysql默认隔离级别)</p>\n<p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p>\n</blockquote>\n<p><strong>采用读写锁实现：</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\formssat,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>为什么能可重复读？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。</p>\n<blockquote>\n<p>优点：实现起来简单</p>\n<p>缺点：无法做到读写并行</p>\n</blockquote>\n<p><strong>采用MVCC实现：</strong></p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\forssssmat,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>为什么能可重复读？因为多次读取只生成一个版本，读到的自然是相同数据。</p>\n<blockquote>\n<p>优点：读写并行</p>\n<p>缺点：实现的复杂度高</p>\n</blockquote>\n<p>但是在该隔离级别下仍会存在幻读的问题。</p>\n<p><strong>SERIALIZABLE</strong></p>\n<p>该隔离级别理解起来最简单，实现也最简单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p>\n<p><img data-src=\"D:\\SoftwareInstallation\\Typora\\file\\记事本\\pictures\\fggormat,png\" alt=\"img\" loading=\"lazy\"></p>\n<h4 id=\"4-事务的实现总结\"><a href=\"#4-事务的实现总结\" class=\"headerlink\" title=\"4.事务的实现总结\"></a>4.事务的实现总结</h4><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p>\n<blockquote>\n<ul>\n<li>事务的原子性是通过undo log来实现。</li>\n<li>事务的持久性性是通过redo log来实现</li>\n<li>事务的隔离性是通过(读写锁+MVCC)来实现</li>\n<li><strong>事务的一致性是通过原子性，持久性，隔离性共同实现</strong></li>\n</ul>\n</blockquote>\n<p>原子性，持久性，隔离性的目的也是为了保障数据的一致性！</p>\n<p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p>\n<h2 id=\"二、spring-中的事务\"><a href=\"#二、spring-中的事务\" class=\"headerlink\" title=\"二、spring 中的事务\"></a>二、spring 中的事务</h2><h4 id=\"spring-和数据库事物之间的联系\"><a href=\"#spring-和数据库事物之间的联系\" class=\"headerlink\" title=\"spring 和数据库事物之间的联系\"></a>spring 和数据库事物之间的联系</h4><p><strong>spring的事务是建立在数据库的事务支持上的，如果你选择的数据库引擎不支持事务，如mysql的MyISAM引擎不支持事务，那么spring的事务也不会生效。</strong></p>\n<p>具体内容是spring对事务传播行为和隔离级别的二次封装，因为不同项目可能在一个mysql的不同数据库上，所以可以在项目中配置数据库的传播行为和隔离级别。</p>\n<h3 id=\"1、分类\"><a href=\"#1、分类\" class=\"headerlink\" title=\"1、分类\"></a>1、分类</h3><h4 id=\"1-声明式事务配置（XML方式）\"><a href=\"#1-声明式事务配置（XML方式）\" class=\"headerlink\" title=\"1.声明式事务配置（XML方式）\"></a>1.声明式事务配置（XML方式）</h4><ul>\n<li><p>1-pom文件中，添加 AOP Aspectj 的支持</p>\n</li>\n<li><p>2-准备给deleteUser()增加事务操作</p>\n</li>\n<li><p>3-Spring配置文件中，配置声明式事务管理器 DataSourceTransactionManager</p>\n</li>\n<li><p>4-配置事务通知 ，“确定为哪个/哪些方法配置事务”</p>\n</li>\n<li><p>5-配置事务切入，“确定切入点（哪个类）”</p>\n</li>\n<li><p>6-测试</p>\n</li>\n</ul>\n<h4 id=\"2-声明式事务配置（-Transactional注解方式）\"><a href=\"#2-声明式事务配置（-Transactional注解方式）\" class=\"headerlink\" title=\"2.声明式事务配置（@Transactional注解方式）\"></a>2.声明式事务配置（@Transactional注解方式）</h4><ul>\n<li><p>1-在deleteUser()上增加@Transactional注解</p>\n</li>\n<li><p>2-pom文件里，启用事务注解</p>\n</li>\n</ul>\n<h4 id=\"3-编程式事务\"><a href=\"#3-编程式事务\" class=\"headerlink\" title=\"3.编程式事务\"></a>3.编程式事务</h4><ul>\n<li><p>1-pom引入driver和DataSource</p>\n</li>\n<li><p>2-编程式事务内核：在代码中侵入式控制事务</p>\n</li>\n</ul>\n<p>声明式（注解配置）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 注册事务管理类，Spring 基于数据源的事务管理器 --&gt;</span><br><span class=\"line\">    &lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class=\"line\">        class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class=\"line\">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 以 @Transactional 标注来定义事务 --&gt;</span><br><span class=\"line\">&lt;!-- 启用annotation的事务支持  --&gt;</span><br><span class=\"line\">&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;  proxy-target-class&#x3D;&quot;true&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h4><ul>\n<li>声明式事务：非侵入式，本质是AOP，推荐！</li>\n<li>编程式事务：侵入式，需要在代码中调用 commit()、rollback()等事务管方法，还需要在代码中通过try catch，不推荐！</li>\n</ul>\n<p>优缺点：</p>\n<p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。</p>\n<p>唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>\n<h3 id=\"2、原理：\"><a href=\"#2、原理：\" class=\"headerlink\" title=\"2、原理：\"></a>2、原理：</h3><p>Spring的事务管理机制实现的原理，是通过<strong>通过AOP的方式被织入</strong>了我们的业务逻辑中的，AOP的实现机制有两种：Proxy-based和Weaving-based。前者是依赖动态代理的方式达到对代理类增强的目的。后者应该是通过字节码增强的方式达到增强的目的。</p>\n<p>常用的就是通过这样一个动态代理对所有需要事务管理的Bean进行加载，并根据配置在invoke方法中对当前调用的 方法名进行判定，并在method.invoke方法前后为其加上合适的事务管理代码，这样就实现了Spring式的事务管理。Spring中的AOP实 现更为复杂和灵活，不过基本原理是一致的。</p>\n<h3 id=\"3、具体实现\"><a href=\"#3、具体实现\" class=\"headerlink\" title=\"3、具体实现\"></a>3、具体实现</h3><p>在serviceImpl类中方法上的使用，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span> <span class=\"comment\">//默认是遇到运行时异常回滚，调用rollbackfor,mysqlde rollback</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">create</span><span class=\"params\">(FoBasicInfo foBasicInfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rows = foBasicInfoMapper.insert(foBasicInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rows != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;新增异常&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、spring事务的传播性、隔离性。\"><a href=\"#4、spring事务的传播性、隔离性。\" class=\"headerlink\" title=\"4、spring事务的传播性、隔离性。\"></a>4、spring事务的传播性、隔离性。</h3><p><strong>事务的传播性、隔离性级别一般设置在service层。</strong></p>\n<p><strong>@Transactional</strong><br>（1）这里说明一下，有的把这个注解放在类名称上面了，这样你配置的这个@Transactional 对这个类中的所有public方法都起作用.<br>（2）@Transactional 方法方法名上，只对这个方法有作用，同样必须是public的方法</p>\n<p>我们在使用Spring声明式事务时，有一个非常重要的概念就是事务的属性。事务属性通常由事务的传播行为、事务的隔离级别、事务的超时值和事务的只读标识组成。我们在进行事务划分时，需要进行事务定义，也就是配置事务的属性。</p>\n<p>Spring在TransactionDefinition接口中定义这些属性,以供PlatfromTransactionManager使用, PlatfromTransactionManager是spring事务管理的核心接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">TransactionDefinition  </span><br><span class=\"line\">public interface TransactionDefinition &#123;  </span><br><span class=\"line\">    int getPropagationBehavior();  </span><br><span class=\"line\">    int getIsolationLevel();  </span><br><span class=\"line\">    int getTimeout();  </span><br><span class=\"line\">    boolean isReadOnly();  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>getTimeout()方法，它返回事务必须在多少秒内完成。<br>isReadOnly(),事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的。<br>getIsolationLevel()方法返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据。</p>\n<p>getPropagationBehavior()返回事务的传播行为，由是否有一个活动的事务来决定一个事务调用。</p>\n<h4 id=\"1-事务的隔离级别\"><a href=\"#1-事务的隔离级别\" class=\"headerlink\" title=\"1.事务的隔离级别\"></a>1.事务的隔离级别</h4><p>在TransactionDefinition接口中定义了五个不同的事务隔离级别 ：<br><strong>（a）</strong> ISOLATION_DEFAULT：（PlatfromTransactionManager的）默认的隔离级别。使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应 。<br><strong>（b）</strong>ISOLATION_READ_UNCOMMITTED：这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。<br>例如：<br>Mary的原工资为1000,财务人员将Mary的工资改为了8000，但未提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Connection con1 &#x3D; getConnection();  </span><br><span class=\"line\">con.setAutoCommit(false);  </span><br><span class=\"line\">update employee set salary &#x3D; 8000 where empId &#x3D;&quot;Mary&quot;; </span><br></pre></td></tr></table></figure>\n\n<p>与此同时，Mary正在读取自己的工资 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Connection con2 &#x3D; getConnection();  </span><br><span class=\"line\">select  salary from employee where empId &#x3D;&quot;Mary&quot;;  </span><br><span class=\"line\">con2.commit();</span><br></pre></td></tr></table></figure>\n\n<p>Mary发现自己的工资变为了8000，欢天喜地！<br>而财务发现操作有误，而回滚了事务,Mary的工资又变为了1000 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">con1.rollback(); 12</span><br></pre></td></tr></table></figure>\n\n<p>像这样,Mary记取的工资数8000是一个脏数据。</p>\n<p><strong>（c）</strong>ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p>\n<p><strong>（d）</strong>ISOLATION_REPEATABLE_READ ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p>\n<p>例如：<br>在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">con1 &#x3D; getConnection();  </span><br><span class=\"line\">select salary from employee empId &#x3D;&quot;Mary&quot;;  </span><br></pre></td></tr></table></figure>\n\n<p>在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">con2 &#x3D; getConnection();  </span><br><span class=\"line\">update employee set salary &#x3D; 2000;  </span><br><span class=\"line\">con2.commit();  </span><br></pre></td></tr></table></figure>\n\n<p>在事务1中，Mary 再次读取自己的工资时，工资变为了2000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select salary from employee empId &#x3D;&quot;Mary&quot;;  </span><br></pre></td></tr></table></figure>\n\n<p>在一个事务中前后两次读取的结果并不致，导致了不可重复读。<br>使用ISOLATION_REPEATABLE_READ可以避免这种情况发生。</p>\n<p><strong>（e）</strong>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p>\n<p>目前工资为1000的员工有10人。<br>事务1,读取所有工资为1000的员工。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">con1 &#x3D; getConnection();  </span><br><span class=\"line\">Select * from employee where salary &#x3D;1000; </span><br></pre></td></tr></table></figure>\n\n<p>共读取10条记录</p>\n<p>这时另一个事务向employee表插入了一条员工记录，工资也为1000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">con2 &#x3D; getConnection();  </span><br><span class=\"line\">Insert into employee(empId,salary) values(&quot;Lili&quot;,1000);  </span><br><span class=\"line\">con2.commit();  </span><br></pre></td></tr></table></figure>\n\n<p>事务1再次读取所有工资为1000的员工</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from employee where salary &#x3D;1000;  </span><br></pre></td></tr></table></figure>\n\n<p>共读取到了11条记录，这就产生了幻像读。<br>ISOLATION_SERIALIZABLE能避免这样的情况发生。但是这样也耗费了最大的资源。</p>\n<h4 id=\"2-事务的传播性：\"><a href=\"#2-事务的传播性：\" class=\"headerlink\" title=\"2.事务的传播性：\"></a>2.事务的传播性：</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PROPAGATION_REQUIRED 支持当前事务，如果不存在，就新建一个(默认)</span><br><span class=\"line\"></span><br><span class=\"line\">PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就以非事务的方式</span><br><span class=\"line\"></span><br><span class=\"line\">PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</span><br><span class=\"line\"></span><br><span class=\"line\">PROPAGATION_REQUIRES_NEW  总是开启一个新的事务，挂起当前事务，创建一个新的事务</span><br><span class=\"line\"></span><br><span class=\"line\">PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务</span><br><span class=\"line\"></span><br><span class=\"line\">PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常</span><br><span class=\"line\"></span><br><span class=\"line\">PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</span><br></pre></td></tr></table></figure>\n\n<p>在TransactionDefinition接口中定义了七个事务传播行为。</p>\n<p>假如我写了两个service类。名字分别为ServiceA和ServiceB。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Service(&quot;ServiceA&quot;)</span><br><span class=\"line\">public class ServiceA &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource(name&#x3D;&quot;ServiceB&quot;)</span><br><span class=\"line\">    private ServiceB serviceB;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Transactional(propagation&#x3D;Propagation.REQUIRED)</span><br><span class=\"line\">    public methodA()&#123;</span><br><span class=\"line\">       &#x2F;&#x2F;doSomething</span><br><span class=\"line\">       serviceB.methodB(); </span><br><span class=\"line\">       &#x2F;&#x2F;doSomething</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(&quot;ServiceB&quot;)</span><br><span class=\"line\">public class ServiceB &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Transactional(propagation&#x3D;Propagation.REQUIRED)</span><br><span class=\"line\">    public methodB()&#123;</span><br><span class=\"line\">       &#x2F;&#x2F;doSomething</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。</p>\n<p><strong>（a）</strong>PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。<br>如果单独调用serviceB.methodB方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">main &#123;</span><br><span class=\"line\">   serviceB.methodB();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Main&#123;  </span><br><span class=\"line\">  Connection con&#x3D;null;  </span><br><span class=\"line\">  try&#123;  </span><br><span class=\"line\">      con &#x3D; getConnection();  </span><br><span class=\"line\">      con.setAutoCommit(false);  </span><br><span class=\"line\">      &#x2F;&#x2F;方法调用  </span><br><span class=\"line\">      methodB();  </span><br><span class=\"line\">      &#x2F;&#x2F;提交事务  </span><br><span class=\"line\">      con.commit();  </span><br><span class=\"line\"> &#125;Catch(RuntimeException ex)&#123;  </span><br><span class=\"line\">    &#x2F;&#x2F;回滚事务  </span><br><span class=\"line\">    con.rollback();    </span><br><span class=\"line\"> &#125;finally&#123;  </span><br><span class=\"line\">    &#x2F;&#x2F;释放资源  </span><br><span class=\"line\">    closeCon();  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。</p>\n<p>如果单独调用MethodA时，在MethodA内又会调用MethodB.<br>执行效果相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">main&#123;  </span><br><span class=\"line\">   Connection con &#x3D; null;  </span><br><span class=\"line\">   try&#123;  </span><br><span class=\"line\">      con &#x3D; getConnection();  </span><br><span class=\"line\">      methodA();  </span><br><span class=\"line\">      con.commit();  </span><br><span class=\"line\">   &#125;cathc(RuntimeException ex)&#123;  </span><br><span class=\"line\">      con.rollback();  </span><br><span class=\"line\">   &#125;finally&#123;  </span><br><span class=\"line\">      closeCon();  </span><br><span class=\"line\">   &#125;   </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>调用MethodA时，环境中没有事务，所以开启一个新的事务.<br>当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。</p>\n<p><strong>（b）</strong>PROPAGATION_SUPPORTS ：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class=\"line\">methodA()&#123;  </span><br><span class=\"line\">  serviceB.methodB();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_SUPPORTS   </span><br><span class=\"line\">methodB()&#123;  </span><br><span class=\"line\">  ……  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>单纯的调用methodB时，methodB方法是非事务的执行的。<br>当调用methdA时,methodB则加入了methodA的事务中,事务地执行。</p>\n<p><strong>（c）</strong>PROPAGATION_MANDATORY ：如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class=\"line\">methodA()&#123;  </span><br><span class=\"line\">  serviceB.methodB();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_MANDATORY   </span><br><span class=\"line\">methodB()&#123;  </span><br><span class=\"line\">  ……  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常<br>throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);</p>\n<p>当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</p>\n<p><strong>（d）</strong>PROPAGATION_REQUIRES_NEW ：如果一个事务已经存在，则将这个存在的事务挂起。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class=\"line\">methodA()&#123;  </span><br><span class=\"line\">   doSomeThingA();  </span><br><span class=\"line\">   serviceB.methodB();  </span><br><span class=\"line\">   doSomeThingB();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRES_NEW   </span><br><span class=\"line\">methodB()&#123;  </span><br><span class=\"line\">  ……  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>当单独调用methodB时，相当于把methodb声明为REQUIRED。开启一个新的事务，事务地执行。</p>\n<p>当调用methodA时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">main()&#123;  </span><br><span class=\"line\">  methodA();  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>情况就大不一样了，相当于下面的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">main()&#123;  </span><br><span class=\"line\"> TransactionManager tm &#x3D; null;  </span><br><span class=\"line\"> try&#123;  </span><br><span class=\"line\">  &#x2F;&#x2F;获得一个JTA事务管理器  </span><br><span class=\"line\">   tm &#x3D; getTransactionManager();  </span><br><span class=\"line\">   tm.begin();&#x2F;&#x2F;开启一个新的事务  </span><br><span class=\"line\">   Transaction ts1 &#x3D; tm.getTransaction();  </span><br><span class=\"line\">   doSomeThing();  </span><br><span class=\"line\">   tm.suspend();&#x2F;&#x2F;挂起当前事务  </span><br><span class=\"line\">   try&#123;  </span><br><span class=\"line\">     tm.begin();&#x2F;&#x2F;重新开启第二个事务  </span><br><span class=\"line\">     Transaction ts2 &#x3D; tm.getTransaction();  </span><br><span class=\"line\">     methodB();  </span><br><span class=\"line\">     ts2.commit();&#x2F;&#x2F;提交第二个事务  </span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;Catch(RunTimeException ex)&#123;  </span><br><span class=\"line\">     ts2.rollback();&#x2F;&#x2F;回滚第二个事务  </span><br><span class=\"line\">   &#125;finally&#123;  </span><br><span class=\"line\">    &#x2F;&#x2F;释放资源  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">   &#x2F;&#x2F;methodB执行完后，复恢第一个事务  </span><br><span class=\"line\">   tm.resume(ts1);  </span><br><span class=\"line\">   doSomeThingB();  </span><br><span class=\"line\">   ts1.commit();&#x2F;&#x2F;提交第一个事务  </span><br><span class=\"line\"> &#125;catch(RunTimeException ex)&#123;  </span><br><span class=\"line\">  ts1.rollback();&#x2F;&#x2F;回滚第一个事务  </span><br><span class=\"line\"> &#125;finally&#123;  </span><br><span class=\"line\">  &#x2F;&#x2F;释放资源  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了methodB之外的其它代码导致的结果却被回滚了。<br>使用PROPAGATION_REQUIRES_NEW,需要使用JtaTransactionManager作为事务管理器。</p>\n<p><strong>（e）</strong>PROPAGATION_NOT_SUPPORTED： 总是非事务地执行，并挂起任何存在的事务。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class=\"line\">methodA()&#123;  </span><br><span class=\"line\">  doSomeThingA();  </span><br><span class=\"line\">  serviceB.methodB();  </span><br><span class=\"line\">  doSomeThingB();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_NOT_SUPPORTED   </span><br><span class=\"line\">methodB()&#123;  </span><br><span class=\"line\">  ……  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>当单独调用methodB时，不启用任何事务机制，非事务地执行。</p>\n<p>当调用methodA时，相当于下面的效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">main()&#123;  </span><br><span class=\"line\"> TransactionManager tm &#x3D; null;  </span><br><span class=\"line\"> try&#123;  </span><br><span class=\"line\">  &#x2F;&#x2F;获得一个JTA事务管理器  </span><br><span class=\"line\">   tm &#x3D; getTransactionManager();  </span><br><span class=\"line\">   tm.begin();&#x2F;&#x2F;开启一个新的事务  </span><br><span class=\"line\">   Transaction ts1 &#x3D; tm.getTransaction();  </span><br><span class=\"line\">   doSomeThing();  </span><br><span class=\"line\">   tm.suspend();&#x2F;&#x2F;挂起当前事务  </span><br><span class=\"line\">   methodB();  </span><br><span class=\"line\">   &#x2F;&#x2F;methodB执行完后，复恢第一个事务  </span><br><span class=\"line\">   tm.resume(ts1);  </span><br><span class=\"line\">   doSomeThingB();  </span><br><span class=\"line\">   ts1.commit();&#x2F;&#x2F;提交第一个事务  </span><br><span class=\"line\"> &#125;catch(RunTimeException ex)&#123;  </span><br><span class=\"line\">   ts1.rollback();&#x2F;&#x2F;回滚第一个事务  </span><br><span class=\"line\"> &#125;finally&#123;  </span><br><span class=\"line\">  &#x2F;&#x2F;释放资源  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。</p>\n<p><strong>（f）</strong>PROPAGATION_NEVER ：总是非事务地执行，如果存在一个活动事务，则抛出异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class=\"line\">methodA()&#123;  </span><br><span class=\"line\">  doSomeThingA();  </span><br><span class=\"line\">  seviceB.methodB();  </span><br><span class=\"line\">  doSomeThingB();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_NEVER   </span><br><span class=\"line\">methodB()&#123;  </span><br><span class=\"line\">  ……  </span><br><span class=\"line\">&#125;  1234567891011</span><br></pre></td></tr></table></figure>\n\n<p>单独调用methodB，则非事务的执行。<br>调用methodA则会抛出异常<br>throw new IllegalTransactionStateException(<br>“Transaction propagation ‘never’ but existing transaction found”);</p>\n<p><strong>（g）</strong>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p>\n<p>这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。</p>\n<p>使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;<br>而nestedTransactionAllowed属性值默认为false;<br>例如如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;system.platformTransactionManager&quot; class&#x3D;&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;  </span><br><span class=\"line\">        &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;system.sessionFactory&quot;&#x2F;&gt;  </span><br><span class=\"line\">        &lt;property name&#x3D;&quot;nestedTransactionAllowed&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;  </span><br><span class=\"line\">    &lt;&#x2F;bean&gt;1234</span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class=\"line\">methodA()&#123;  </span><br><span class=\"line\">  doSomeThingA();  </span><br><span class=\"line\">  serviceB.methodB();  </span><br><span class=\"line\">  doSomeThingB();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;事务属性 PROPAGATION_NESTED  </span><br><span class=\"line\">methodB()&#123;  </span><br><span class=\"line\">  ……  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>如果单独调用methodB方法，则按REQUIRED属性执行。</p>\n<p>如果调用methodA方法，相当于下面的效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">main()&#123;  </span><br><span class=\"line\">Connection con &#x3D; null;  </span><br><span class=\"line\">Savepoint savepoint &#x3D; null;  </span><br><span class=\"line\">try&#123;  </span><br><span class=\"line\">  con &#x3D; getConnection();  </span><br><span class=\"line\">  con.setAutoCommit(false);  </span><br><span class=\"line\">  doSomeThingA(); </span><br><span class=\"line\">  &#x2F;&#x2F;创造一个事务的保存点 </span><br><span class=\"line\">  savepoint &#x3D; con2.setSavepoint();  </span><br><span class=\"line\">  try  </span><br><span class=\"line\">      methodB();  </span><br><span class=\"line\">  &#125;catch(RuntimeException ex)&#123;  </span><br><span class=\"line\">     con.rollback(savepoint);  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  finally&#123;  </span><br><span class=\"line\">    &#x2F;&#x2F;释放资源  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  doSomeThingB();  </span><br><span class=\"line\">  con.commit();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">catch(RuntimeException ex)&#123;  </span><br><span class=\"line\">  con.rollback();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">finally&#123;  </span><br><span class=\"line\">  &#x2F;&#x2F;释放资源  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。</p>\n<p><strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p>\n<p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。<br>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。</p>\n<p>PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p>\n<h4 id=\"3-事务的超时性、回滚和只读\"><a href=\"#3-事务的超时性、回滚和只读\" class=\"headerlink\" title=\"3.事务的超时性、回滚和只读\"></a>3.事务的超时性、回滚和只读</h4><p><strong>超时：</strong><br>@Transactional(timeout=30) //默认是30秒</p>\n<p><strong>异常回滚：</strong><br>指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)</p>\n<p>指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})<br>该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。</p>\n<p><strong>正常的情况下也可以回滚：</strong></p>\n<p>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</p>\n<p><strong>只读</strong>：<br>@Transactional(readOnly=true)<br>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。</p>\n<h3 id=\"5、注意的地方\"><a href=\"#5、注意的地方\" class=\"headerlink\" title=\"5、注意的地方\"></a>5、注意的地方</h3><p>1.@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.</p>\n<p>2.用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚</p>\n<p>3.默认遇到运行期异常（非受检查型异常）(throw new RuntimeException(&quot;注释&quot;);)会回滚；而遇到需要非运行时异常（受检查的异，捕获的异常）(throw new Exception(&quot;注释&quot;);)不会回滚；</p>\n<p>要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .</p>\n<p>如果让运行时异常不回滚： @Transactional(notRollbackFor=RunTimeException.class)</p>\n<p>指定回滚,遇到异常Exception时回滚@Transactional(rollbackFor=Exception.class) </p>\n","categories":["事务"]},{"title":"集合容器","url":"/2020-11-18-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8.html","content":"<h2 id=\"集合容器概述\"><a href=\"#集合容器概述\" class=\"headerlink\" title=\"集合容器概述\"></a>集合容器概述</h2><h3 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h3><p><strong>集合框架</strong>：用于存储数据的容器。</p>\n<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p>\n<p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>\n<p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p>\n<p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p>\n<p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。它减少了程序设计的辛劳。</p>\n<p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。<br>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p>\n<h3 id=\"集合的特点\"><a href=\"#集合的特点\" class=\"headerlink\" title=\"集合的特点\"></a>集合的特点</h3><p>集合的特点主要有如下两点：</p>\n<ul>\n<li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li>\n<li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li>\n</ul>\n<h3 id=\"集合和数组的区别\"><a href=\"#集合和数组的区别\" class=\"headerlink\" title=\"集合和数组的区别\"></a>集合和数组的区别</h3><ul>\n<li>数组是固定长度的；集合可变长度的。</li>\n<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>\n<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li>\n</ul>\n<p><strong>数据结构</strong>：就是容器中存储数据的方式。</p>\n<p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p>\n<p>集合容器在不断向上抽取过程中，出现了集合体系。<strong>在使用一个体系的原则：参阅顶层内容。建立底层对象。</strong></p>\n<h3 id=\"使用集合框架的好处\"><a href=\"#使用集合框架的好处\" class=\"headerlink\" title=\"使用集合框架的好处\"></a>使用集合框架的好处</h3><ol>\n<li>容量自增长；</li>\n<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li>\n<li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li>\n<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>\n<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>\n</ol>\n<h3 id=\"常用的集合类有哪些？\"><a href=\"#常用的集合类有哪些？\" class=\"headerlink\" title=\"常用的集合类有哪些？\"></a>常用的集合类有哪些？</h3><p>Map接口和Collection接口是所有集合框架的父接口：</p>\n<ol>\n<li>Collection接口的子接口包括：Set接口和List接口</li>\n<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>\n<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>\n<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>\n</ol>\n<h3 id=\"List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？\"><a href=\"#List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？\" class=\"headerlink\" title=\"List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？\"></a>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</h3><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p>\n<p>Collection集合主要有List和Set两大接口</p>\n<ul>\n<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>\n<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>\n<li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</li>\n</ul>\n<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>\n<h3 id=\"集合框架底层数据结构\"><a href=\"#集合框架底层数据结构\" class=\"headerlink\" title=\"集合框架底层数据结构\"></a>集合框架底层数据结构</h3><p>Collection</p>\n<ol>\n<li>List</li>\n</ol>\n<ul>\n<li>Arraylist： Object数组</li>\n<li>Vector： Object数组</li>\n<li>LinkedList： 双向循环链表</li>\n</ul>\n<ol>\n<li>Set</li>\n</ol>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>\n</ul>\n<p>Map</p>\n<ul>\n<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，并且判断数组长度是否小于64，小于则扩容数组，否则将链表转化为红黑树，以减少搜索时间</li>\n<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>\n<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><ul>\n<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>\n<li>statck：堆栈类，先进后出。</li>\n<li>hashtable：就比hashmap多了个线程安全。</li>\n<li>enumeration：枚举，相当于迭代器。</li>\n</ul>\n<h3 id=\"Java集合的快速失败机制-“fail-fast”？\"><a href=\"#Java集合的快速失败机制-“fail-fast”？\" class=\"headerlink\" title=\"Java集合的快速失败机制 “fail-fast”？\"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>是java集合的一种错误检测机制，当多个线程对集合进行<strong>结构上的改变</strong>的操作时，有可能会产生 fail-fast 机制。</p>\n<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>\n<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>\n<p>解决办法：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>\n<li>使用CopyOnWriteArrayList来替换ArrayList</li>\n</ol>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list. add(<span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class=\"line\">clist. add(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// 运行时此行报错</span></span><br><span class=\"line\">System. out. println(list. size());</span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;String&gt; it = list. iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it. hasNext())&#123;</span><br><span class=\"line\">  String obj = it. next();</span><br><span class=\"line\">  System. out. println(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h4 id=\"如何边遍历边移除-Collection-中的元素？\"><a href=\"#如何边遍历边移除-Collection-中的元素？\" class=\"headerlink\" title=\"如何边遍历边移除 Collection 中的元素？\"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">   *<span class=\"comment\">// do something*</span></span><br><span class=\"line\">   it.remove();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<p>一种最常见的<strong>错误</strong>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Integer i : list)&#123;</span><br><span class=\"line\">   list.remove(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>\n<h4 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h4><ul>\n<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>\n<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>\n<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>\n</ul>\n<h4 id=\"遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？\"><a href=\"#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？\" class=\"headerlink\" title=\"遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？\"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><p>遍历方式有以下几种：</p>\n<ol>\n<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>\n<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>\n<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>\n<ul>\n<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>\n<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>\n</ul>\n<p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p>\n<h4 id=\"说一下-ArrayList-的优缺点\"><a href=\"#说一下-ArrayList-的优缺点\" class=\"headerlink\" title=\"说一下 ArrayList 的优缺点\"></a>说一下 ArrayList 的优缺点</h4><p>ArrayList的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>\n<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>\n</ul>\n<p>ArrayList 比较适合顺序添加、随机访问的场景。</p>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// list to array</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">list.toArray();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// array to list</span></span><br><span class=\"line\">String[] array = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;123&quot;</span>,<span class=\"string\">&quot;456&quot;</span>&#125;;</span><br><span class=\"line\">Arrays.asList(array);</span><br><span class=\"line\"><span class=\"number\">123456789</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>\n<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>\n<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>\n</ul>\n<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>\n<p>补充：数据结构基础之双向链表</p>\n<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p>\n<ul>\n<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>\n<li>性能：ArrayList 在性能方面要优于 Vector。</li>\n<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>\n</ul>\n<p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>\n<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>\n<h4 id=\"插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？\"><a href=\"#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？\" class=\"headerlink\" title=\"插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？\"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>\n<p>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</p>\n<p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</p>\n<h4 id=\"多线程场景下如何使用-ArrayList？\"><a href=\"#多线程场景下如何使用-ArrayList？\" class=\"headerlink\" title=\"多线程场景下如何使用 ArrayList？\"></a>多线程场景下如何使用 ArrayList？</h4><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class=\"line\">synchronizedList.add(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">synchronizedList.add(<span class=\"string\">&quot;bbb&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class=\"line\">    System.out.println(synchronizedList.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234567</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么-ArrayList-的-elementData-加上-transient-修饰？\"><a href=\"#为什么-ArrayList-的-elementData-加上-transient-修饰？\" class=\"headerlink\" title=\"为什么 ArrayList 的 elementData 加上 transient 修饰？\"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 中的数组定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>再看一下 ArrayList 的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">     <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(java.io.ObjectOutputStream s)</span> <span class=\"keyword\">throws</span> java.io.IOException</span>&#123;</span><br><span class=\"line\">    *<span class=\"comment\">// Write out element count, and any hidden stuff*</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">    s.defaultWriteObject();</span><br><span class=\"line\">    *<span class=\"comment\">// Write out array length*</span></span><br><span class=\"line\">        s.writeInt(elementData.length);</span><br><span class=\"line\">    *<span class=\"comment\">// Write out all elements in the proper order.*</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;size; i++)</span><br><span class=\"line\">            s.writeObject(elementData[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123456789101112</span></span><br></pre></td></tr></table></figure>\n\n<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>\n<h4 id=\"List-和-Set-的区别\"><a href=\"#List-和-Set-的区别\" class=\"headerlink\" title=\"List 和 Set 的区别\"></a>List 和 Set 的区别</h4><p>List , Set 都是继承自Collection 接口</p>\n<p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p>\n<p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p>\n<p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p>\n<p>Set和List对比</p>\n<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p>\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"说一下-HashSet-的实现原理？\"><a href=\"#说一下-HashSet-的实现原理？\" class=\"headerlink\" title=\"说一下 HashSet 的实现原理？\"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n<h4 id=\"HashSet如何检查重复？HashSet是如何保证数据不可重复的？\"><a href=\"#HashSet如何检查重复？HashSet是如何保证数据不可重复的？\" class=\"headerlink\" title=\"HashSet如何检查重复？HashSet是如何保证数据不可重复的？\"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p>\n<p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p>\n<p>以下是HashSet 部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234567891011</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>hashCode（）与equals（）的相关规定</strong>：</p>\n<ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个equals方法返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>\n</ol>\n<p><strong>==与equals的区别</strong></p>\n<ol>\n<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>\n<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</li>\n</ol>\n<h4 id=\"HashSet与HashMap的区别\"><a href=\"#HashSet与HashMap的区别\" class=\"headerlink\" title=\"HashSet与HashMap的区别\"></a>HashSet与HashMap的区别</h4><table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现了Map接口</td>\n<td>实现Set接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用put（）向map中添加元素</td>\n<td>调用add（）方法向Set中添加元素</td>\n</tr>\n<tr>\n<td>HashMap使用键（Key）计算Hashcode</td>\n<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>\n</tr>\n<tr>\n<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>\n<td>HashSet较HashMap来说比较慢</td>\n</tr>\n</tbody></table>\n<h3 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h3><h4 id=\"BlockingQueue是什么？\"><a href=\"#BlockingQueue是什么？\" class=\"headerlink\" title=\"BlockingQueue是什么？\"></a>BlockingQueue是什么？</h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>\n<h4 id=\"在-Queue-中-poll-和-remove-有什么区别？\"><a href=\"#在-Queue-中-poll-和-remove-有什么区别？\" class=\"headerlink\" title=\"在 Queue 中 poll()和 remove()有什么区别？\"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><ul>\n<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>\n<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>\n</ul>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;String&gt;();</span><br><span class=\"line\">queue. offer(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// add</span></span><br><span class=\"line\">System. out. println(queue. poll());</span><br><span class=\"line\">System. out. println(queue. remove());</span><br><span class=\"line\">System. out. println(queue. size());</span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"说一下-HashMap-的实现原理？\"><a href=\"#说一下-HashMap-的实现原理？\" class=\"headerlink\" title=\"说一下 HashMap 的实现原理？\"></a>说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>\n<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>HashMap 基于 Hash 算法实现的</p>\n<ol>\n<li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li>\n<li>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li>\n<li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li>\n<li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li>\n</ol>\n<p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p>\n<h3 id=\"HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现\"><a href=\"#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现\" class=\"headerlink\" title=\"HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现\"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；\\</strong>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法**的方式可以解决哈希冲突。</p>\n<h4 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h4><p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2019121422243983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"jdk1.7中HashMap数据结构\" loading=\"lazy\"></p>\n<h4 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20191214222452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"jdk1.8中HashMap数据结构\" loading=\"lazy\"></p>\n<h4 id=\"JDK1-7-VS-JDK1-8-比较\"><a href=\"#JDK1-7-VS-JDK1-8-比较\" class=\"headerlink\" title=\"JDK1.7 VS JDK1.8 比较\"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p>\n<ol>\n<li>resize 扩容优化</li>\n<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li>\n<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储结构</td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td>初始化方式</td>\n<td>单独函数：<code>inflateTable()</code></td>\n<td>直接集成到了扩容函数<code>resize()</code>中</td>\n</tr>\n<tr>\n<td>hash值计算方式</td>\n<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>\n<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td>存放数据的规则</td>\n<td>无冲突时，存放数组；冲突时，存放链表</td>\n<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>\n</tr>\n<tr>\n<td>插入数据方式</td>\n<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>\n<td>尾插法（直接插入到链表尾部/红黑树）</td>\n</tr>\n<tr>\n<td>扩容后存储位置的计算方式</td>\n<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>\n<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>\n</tr>\n</tbody></table>\n<h3 id=\"HashMap的put方法的具体流程？\"><a href=\"#HashMap的put方法的具体流程？\" class=\"headerlink\" title=\"HashMap的put方法的具体流程？\"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>\n<p>putVal方法执行流程图</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70\" alt=\"putVal方法执行流程图\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Map.put和相关方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤①：tab为空则创建 </span></span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤②：计算index，并对null做处理  </span></span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤④：判断该链为红黑树 </span></span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 步骤⑤：该链为链表 </span></span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//判断该链表尾部指针是不是空的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">//链表结构转树形结构</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687</span></span><br></pre></td></tr></table></figure>\n\n<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>\n<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>\n<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>\n<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>\n<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>\n<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>\n<h3 id=\"HashMap的扩容操作是怎么实现的？\"><a href=\"#HashMap的扩容操作是怎么实现的？\" class=\"headerlink\" title=\"HashMap的扩容操作是怎么实现的？\"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>\n<p>②.每次扩展的时候，都是扩展2倍；</p>\n<p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>\n<p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//oldTab指向hash桶数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class=\"comment\">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;<span class=\"comment\">//返回</span></span><br><span class=\"line\">        &#125;<span class=\"comment\">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold 双倍扩容阀值threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将该值赋给新的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新的threshold = 新的cap * 0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];<span class=\"comment\">//新建hash桶数组</span></span><br><span class=\"line\">    table = newTab;<span class=\"comment\">//将新数组的值复制给旧的hash桶数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历新数组的所有桶下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"comment\">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;             </span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class=\"line\">                                <span class=\"comment\">// 代表下标保持不变的链表的头元素</span></span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                </span><br><span class=\"line\">                                <span class=\"comment\">// loTail.next指向当前e</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            <span class=\"comment\">// loTail指向当前的元素e</span></span><br><span class=\"line\">                            <span class=\"comment\">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class=\"line\">                            <span class=\"comment\">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class=\"line\">                            <span class=\"comment\">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class=\"line\">                            loTail = e;                           </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap是怎么解决哈希冲突的？\"><a href=\"#HashMap是怎么解决哈希冲突的？\" class=\"headerlink\" title=\"HashMap是怎么解决哈希冲突的？\"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>\n<h4 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h4><p><strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）</strong>；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p>\n<p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p>\n<h4 id=\"什么是哈希冲突？\"><a href=\"#什么是哈希冲突？\" class=\"headerlink\" title=\"什么是哈希冲突？\"></a>什么是哈希冲突？</h4><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易</strong>；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化</p>\n<h4 id=\"hash-函数\"><a href=\"#hash-函数\" class=\"headerlink\" title=\"hash()函数\"></a>hash()函数</h4><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);<span class=\"comment\">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br></pre></td></tr></table></figure>\n\n<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<h4 id=\"JDK1-8新增红黑树\"><a href=\"#JDK1-8新增红黑树\" class=\"headerlink\" title=\"JDK1.8新增红黑树\"></a>JDK1.8新增红黑树</h4><p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTc5OGYxMzg3ZTNmOGRlOWEucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>通过上面的<strong>链地址法（使用散列表）\\</strong>和**扰动函数**我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>\n<p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p>\n<h3 id=\"能否使用任何类作为-Map-的-key？\"><a href=\"#能否使用任何类作为-Map-的-key？\" class=\"headerlink\" title=\"能否使用任何类作为 Map 的 key？\"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p>\n<ul>\n<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>\n<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>\n<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>\n<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>\n</ul>\n<h3 id=\"为什么HashMap中String、Integer这样的包装类适合作为K？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为K？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为K？\"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h3><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>\n<ol>\n<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>\n<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>\n</ol>\n<h3 id=\"如果使用Object作为HashMap的Key，应该怎么办呢？\"><a href=\"#如果使用Object作为HashMap的Key，应该怎么办呢？\" class=\"headerlink\" title=\"如果使用Object作为HashMap的Key，应该怎么办呢？\"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p>\n<ol>\n<li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>\n<li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>\n</ol>\n<h3 id=\"HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？\"><a href=\"#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？\" class=\"headerlink\" title=\"HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？\"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>\n<p><strong>那怎么解决呢？</strong></p>\n<ol>\n<li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li>\n<li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>\n</ol>\n<h3 id=\"HashMap-的长度为什么是2的幂次方\"><a href=\"#HashMap-的长度为什么是2的幂次方\" class=\"headerlink\" title=\"HashMap 的长度为什么是2的幂次方\"></a>HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>\n<p><strong>这个算法应该如何设计呢？</strong></p>\n<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>\n<p><strong>那为什么是两次扰动呢？</strong></p>\n<p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>\n<h3 id=\"HashMap-与-HashTable-有什么区别？\"><a href=\"#HashMap-与-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 与 HashTable 有什么区别？\"></a>HashMap 与 HashTable 有什么区别？</h3><ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>\n<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>\n<li>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>\n</ol>\n<h3 id=\"如何决定使用-HashMap-还是-TreeMap？\"><a href=\"#如何决定使用-HashMap-还是-TreeMap？\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap？\"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>\n<h3 id=\"HashMap-和-ConcurrentHashMap-的区别\"><a href=\"#HashMap-和-ConcurrentHashMap-的区别\" class=\"headerlink\" title=\"HashMap 和 ConcurrentHashMap 的区别\"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol>\n<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li>\n<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-和-Hashtable-的区别？\"><a href=\"#ConcurrentHashMap-和-Hashtable-的区别？\" class=\"headerlink\" title=\"ConcurrentHashMap 和 Hashtable 的区别？\"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）</strong>： ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>JDK1.7的ConcurrentHashMap：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>\n<h3 id=\"ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？\"><a href=\"#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？\"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><p><strong>JDK1.7</strong></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>\n<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<ol>\n<li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>\n<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>\n</ol>\n<p><strong>JDK1.8</strong></p>\n<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>\n<p>结构如下：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n?x-oss-process=image/format,png\" alt=\"img\" loading=\"lazy\"></p>\n<p><strong>附加源码，有需要的可以看看</strong></p>\n<p>插入元素过程（建议去看看源码）：</p>\n<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br></pre></td></tr></table></figure>\n\n<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">        K ek;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((ek = e.key) == key ||</span><br><span class=\"line\">             (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">            oldVal = e.val;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                e.val = value;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>\n<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>\n</ol>\n<h2 id=\"辅助工具类\"><a href=\"#辅助工具类\" class=\"headerlink\" title=\"辅助工具类\"></a>辅助工具类</h2><h3 id=\"Array-和-ArrayList-有何区别？\"><a href=\"#Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"Array 和 ArrayList 有何区别？\"></a>Array 和 ArrayList 有何区别？</h3><ul>\n<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>\n<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>\n<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>\n</ul>\n<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>\n<h3 id=\"如何实现-Array-和-List-之间的转换？\"><a href=\"#如何实现-Array-和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现 Array 和 List 之间的转换？\"></a>如何实现 Array 和 List 之间的转换？</h3><ul>\n<li>Array 转 List： Arrays. asList(array) ；</li>\n<li>List 转 Array：List 的 toArray() 方法。</li>\n</ul>\n<h3 id=\"comparable-和-comparator的区别？\"><a href=\"#comparable-和-comparator的区别？\" class=\"headerlink\" title=\"comparable 和 comparator的区别？\"></a>comparable 和 comparator的区别？</h3><ul>\n<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>\n<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>\n</ul>\n<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>\n<h3 id=\"Collection-和-Collections-有什么区别？\"><a href=\"#Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别？\"></a>Collection 和 Collections 有什么区别？</h3><ul>\n<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>\n<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>\n</ul>\n<h3 id=\"TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？\"><a href=\"#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？\" class=\"headerlink\" title=\"TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？\"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p>\n<p>Collections 工具类的 sort 方法有两种重载的形式，</p>\n<p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p>\n<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>\n","categories":["集合"],"tags":["集合"]},{"title":"第二次面试（线上+线下）","url":"/2020-11-09-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%E5%A4%A9%E4%B8%A4%E5%AE%B6%E7%BA%BF%E4%B8%8B+%E7%BA%BF%E4%B8%8A%EF%BC%89.html","content":"<h2 id=\"第一个视频面\"><a href=\"#第一个视频面\" class=\"headerlink\" title=\"第一个视频面\"></a>第一个视频面</h2><h3 id=\"1-看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令\"><a href=\"#1-看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令\" class=\"headerlink\" title=\"1.看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令\"></a>1.看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令</h3><p>Servlet的生命周期和人类的参与次数是一样的1  1  n  1  1 次</p>\n<p>阶段 ：    加载         初始化（init)     服务（service）   销毁（destroy）     卸载</p>\n<h3 id=\"2-你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别\"><a href=\"#2-你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别\" class=\"headerlink\" title=\"2.你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别\"></a>2.你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别</h3><h5 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。<strong>JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序</strong>，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>\n<h5 id=\"便于理解：\"><a href=\"#便于理解：\" class=\"headerlink\" title=\"便于理解：\"></a>便于理解：</h5><p>Java -&gt; .java -&gt; .class</p>\n<p>Jsp和Servlet诞生的先后顺序？</p>\n<p>先有的Servlet，后有的Jsp</p>\n<p>​        Servlet :只有Servlet，可以完成页面视图的编写</p>\n<p>​        Jsp：优化Servlet视图编写时遇到的编写困难，效率低等问题</p>\n<ul>\n<li>Jsp在翻译阶段，从.jsp文件会被翻译成.java的Servlet</li>\n<li>编译阶段会将Jsp生成的Servlet编译成可执行的.class</li>\n</ul>\n<h5 id=\"普通Java类，Servlet和Jsp三者之间的关系：\"><a href=\"#普通Java类，Servlet和Jsp三者之间的关系：\" class=\"headerlink\" title=\"普通Java类，Servlet和Jsp三者之间的关系：\"></a>普通Java类，Servlet和Jsp三者之间的关系：</h5><ul>\n<li>Jsp是一个特殊的Servlet，专门用于进行视图呈现</li>\n<li>Servlet是一个特殊的Java类，可以进行对于网络相关功能的实现</li>\n</ul>\n<h5 id=\"jsp定义：\"><a href=\"#jsp定义：\" class=\"headerlink\" title=\"jsp定义：\"></a>jsp定义：</h5><p>jsp的完整形式是Java Server Pages。 它是一项允许开发支持动态内容的网页的技术。 JSP使开发人员可以使用特殊的JSP标记在HTML网页中插入Java代码，这些标记通常以*&lt;％*开头，以*％&gt;*结尾。</p>\n<h5 id=\"Servlet定义：\"><a href=\"#Servlet定义：\" class=\"headerlink\" title=\"Servlet定义：\"></a>Servlet定义：</h5><p>Servlet是一种纯粹是用Java编写的，在Web或应用程序服务器上运行的程序，充当来自Web浏览器或其他HTTP客户端的请求与HTTP服务器上的数据库或应用程序之间的中间层。</p>\n<h3 id=\"3-你用过mysql数据库吗，那么如何清空一张表\"><a href=\"#3-你用过mysql数据库吗，那么如何清空一张表\" class=\"headerlink\" title=\"3.你用过mysql数据库吗，那么如何清空一张表\"></a>3.你用过mysql数据库吗，那么如何清空一张表</h3><ul>\n<li><p>truncate table表名：清空数据表内容使用TRUNCATE语句，它会将您的整张表全部删除掉后再次创建一个新的表，表中没有任何的内容，而且这种操作还是不可逆的。TRUNCATE语句具体的语法为：truncate table表名。</p>\n<p>注意:要先选择好数据库、选择好表别误删 show databases-&gt;use 库名  show table -&gt;truncate table表名 </p>\n</li>\n<li><p>delete from 表名：delete 删除以后， 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p>\n</li>\n</ul>\n<h5 id=\"比-较：\"><a href=\"#比-较：\" class=\"headerlink\" title=\"比 较：\"></a>比 较：</h5><p>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件。</p>\n<h5 id=\"那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？\"><a href=\"#那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？\" class=\"headerlink\" title=\"那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？\"></a>那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？</h5><p><strong>解决该问题主要分两种情况：</strong></p>\n<p>如果不需要保留数据库中所有表的结构，那么答案很简单，执行命令drop database 数据库名  即可达到目的。</p>\n<p>但是如果需要保留该数据库中所有表的结构，只想删除所有表中的数据，又该怎么解决呢？有人会说可以多执行几次truncate操作就OK啦，没错，多执行几次truncate确实可以达到目的，但是，如果要删除的数据库中有很多张表，几十张上百张表，执行上百次truncate操作显然不是好的办法？至此，就是本文要说讲到的办法了。删除的办法其实还是执行truncat方法，只是不需要每次手动的输入truncate命令进行删除。通过sql命令的方式生成所有的truncate语句并写入到.sql脚本文件中，然后执行脚本即可完成删除操作，并且保留了表结构。</p>\n<h3 id=\"4-arraylist、linkedlist、vector的区别\"><a href=\"#4-arraylist、linkedlist、vector的区别\" class=\"headerlink\" title=\"4.arraylist、linkedlist、vector的区别\"></a>4.arraylist、linkedlist、vector的区别</h3><ol>\n<li><p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；vector是线程安全的，Vector类的所有⽅法都是同步的（每个方法都使用了synchronized关键字）。</p>\n</li>\n<li><p><strong>底层数据结构</strong>： Arraylist 底层使⽤的是 Object 数组；vector它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步； LinkedList 底层使⽤的是双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下⾯有介绍到！）</p>\n</li>\n<li><p><strong>插⼊和删除是否受元素位置的影响</strong>：</p>\n<p> ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e)⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插⼊和删除元素的话（ add(int index, E element)）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。</p>\n<p> ② LinkedList 采⽤链表存储，所以对于 add(E e)⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element)） 时间复杂度近似为 o(n))因为需要先移动到指定位置再插⼊。</p>\n</li>\n<li><p><strong>是否⽀持快速随机访问</strong>： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index)⽅法)。</p>\n</li>\n<li><p><strong>内存空间占⽤</strong>： ArrayList的空 间浪费主要体现在在list列表的结尾会预留⼀定的容量空间，⽽LinkedList的空间花费则体现在它的每⼀个元素都需要消耗⽐ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>\n</li>\n</ol>\n<h5 id=\"ArraryList的刨根问底：\"><a href=\"#ArraryList的刨根问底：\" class=\"headerlink\" title=\"ArraryList的刨根问底：\"></a>ArraryList的刨根问底：</h5><h5 id=\"ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\"><a href=\"#ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\" class=\"headerlink\" title=\"ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\"></a>ArrayList有用过吗？它是一个什么东西？可以用来干嘛？</h5><p>有用过；ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组Object[] elementData。</p>\n<p>与它类似的是LinkedList，和LinkedList相比，它的<strong>查找</strong>和<strong>访问</strong>元素的<strong>速度较快</strong>，但新增，删除的速度较慢。</p>\n<h5 id=\"ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？\"><a href=\"#ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？\" class=\"headerlink\" title=\"ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？\"></a>ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</h5><p>通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组**Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}**所以数组容量为0，只有真正对数据进行添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组</span></span><br><span class=\"line\"><span class=\"comment\">//Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;所以数组容量为0，只有真正对数据进行添加</span></span><br><span class=\"line\"><span class=\"comment\">//add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</span></span><br><span class=\"line\">\t </span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Default initial capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;<span class=\"comment\">//ArrayList默认的大小是10。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？\"><a href=\"#数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？\" class=\"headerlink\" title=\"数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？\"></a>数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？</h5><p>其实实现方式比较简单，他就是通过<strong>数组扩容</strong>的方式去实现的。</p>\n<p>就比如我们现在有一个长度为10的数组，现在我们要新增一个元素，发现已经满了，那ArrayList会怎么做呢？</p>\n<p>第一步他会重新定义一个长度为10+10/2的数组也就是新增一个长度为15的数组。</p>\n<p>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址换到新数组，ArrayList就这样完成了一次改头换面。</p>\n<h5 id=\"我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。\"><a href=\"#我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。\" class=\"headerlink\" title=\"我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。\"></a>我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。</h5><p>有指定index新增，也有直接新增的，在这之前他会有一步校验长度的判断<strong>ensureCapacityInternal</strong>，就是说如果长度不够，是需要扩容的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在扩容的时候，老版本的jdk和8以后的版本是有区别的，8之后的效率更高了，采用了位运算，<strong>右移</strong>一位，其实就是除以2这个操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);<span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>指定位置新增的时候，在校验之后的操作很简单，就是数组的copy，大家可以看下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                         size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如有下面这样一个数组我需要在index 5的位置去新增一个元素A</p>\n<p>1 2 3 4 5 6 7 8 9 _</p>\n<p>那从代码里面我们可以看到，他复制了一个数组，是从index 5的位置开始的，然后把它放在了index 5+1的位置</p>\n<p>1 2 3 4 _ 5 6 7 8 9</p>\n<p>给我们要新增的元素腾出了位置，然后在index的位置放入元素A就完成了新增的操作了</p>\n<p>1 2 3 4 A 5 6 7 8 9</p>\n<p>至于为啥说他效率低，我想我不说你也应该知道了，我这只是在一个这么小的List里面操作，要是我去一个几百几千几万大小的List新增一个元素，那就需要后面所有的元素都复制，然后如果再涉及到扩容啥的就更慢了不是嘛。</p>\n<h5 id=\"我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int-initialCapacity）会不会初始化数组大小？\"><a href=\"#我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int-initialCapacity）会不会初始化数组大小？\" class=\"headerlink\" title=\"我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int initialCapacity）会不会初始化数组大小？\"></a>我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int initialCapacity）会不会初始化数组大小？</h5><p><strong>答：不会初始化数组大小！</strong></p>\n<p>而且将构造函数与initialCapacity结合使用，然后使用set（）会抛出异常，尽管该数组已创建，但是大小设置不正确。</p>\n<p>使用sureCapacity（）也不起作用，因为它基于elementData数组而不是大小。</p>\n<p>还有其他副作用，这是因为带有sureCapacity（）的静态DEFAULT_CAPACITY。</p>\n<p>进行此工作的唯一方法是在使用构造函数后，根据需要使用add（）多次。</p>\n<p>大家可能有点懵，我直接操作一下代码，大家会发现我们虽然对ArrayList设置了初始大小，但是我们打印List大小的时候还是0，我们操作下标set值的时候也会报错，数组下标越界。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ArrayList插入删除一定慢么？\"><a href=\"#ArrayList插入删除一定慢么？\" class=\"headerlink\" title=\"ArrayList插入删除一定慢么？\"></a>ArrayList插入删除一定慢么？</h5><p>取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。</p>\n<h5 id=\"那他的删除怎么实现的呢？\"><a href=\"#那他的删除怎么实现的呢？\" class=\"headerlink\" title=\"那他的删除怎么实现的呢？\"></a>那他的删除怎么实现的呢？</h5><p>删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在copy一个数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">       rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">       modCount++;</span><br><span class=\"line\">       E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                            numMoved);</span><br><span class=\"line\">       elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续打个比方，我们现在要删除下面这个数组中的index5这个位置</p>\n<p>1 2 3 4 5 6 7 8 9 _</p>\n<p>那代码他就复制一个index5+1开始到最后的数组，然后把它放到index开始的位置</p>\n<p>1 2 3 4 6 7 8 9 _ _</p>\n<p>index5的位置就成功被”删除“了其实就是被覆盖了，给了你被删除的感觉。</p>\n<p>同理他的效率也低，因为数组如果很大的话，一样需要复制和移动的位置就大了。</p>\n<h5 id=\"ArrayList是线程安全的么？\"><a href=\"#ArrayList是线程安全的么？\" class=\"headerlink\" title=\"ArrayList是线程安全的么？\"></a>ArrayList是线程安全的么？</h5><p>当然不是，线程安全版本的数组容器是Vector。</p>\n<p>Vector的实现很简单，就是把所有的方法统统加上synchronized就完事了。</p>\n<p>你也可以不使用Vector，用Collections.synchronizedList把一个普通ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized。</p>\n<h5 id=\"ArrayList用来做队列合适么？\"><a href=\"#ArrayList用来做队列合适么？\" class=\"headerlink\" title=\"ArrayList用来做队列合适么？\"></a>ArrayList用来做队列合适么？</h5><p>队列一般是FIFO（先入先出）的，如果用ArrayList做队列，就需要在数组尾部追加数据，数组头部删除数组，反过来也可以。</p>\n<p>但是无论如何总会有一个操作会涉及到数组的数据搬迁，这个是比较耗费性能的。</p>\n<p><strong>结论</strong>：ArrayList不适合做队列。</p>\n<h5 id=\"那数组适合用来做队列么？\"><a href=\"#那数组适合用来做队列么？\" class=\"headerlink\" title=\"那数组适合用来做队列么？\"></a>那数组适合用来做队列么？</h5><p>数组是非常合适的。</p>\n<p>简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。</p>\n<h5 id=\"ArrayList的遍历和LinkedList遍历性能比较如何？\"><a href=\"#ArrayList的遍历和LinkedList遍历性能比较如何？\" class=\"headerlink\" title=\"ArrayList的遍历和LinkedList遍历性能比较如何？\"></a>ArrayList的遍历和LinkedList遍历性能比较如何？</h5><p>论遍历ArrayList要比LinkedList快得多，<strong>ArrayList遍历最大的优势在于内存的连续性</strong>，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>ArrayList就是动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了动态的增加和减少元素，实现了Collection和List接口，灵活的设置数组的大小等好处。</p>\n<p>面试里面问的时候没HashMap，ConcurrentHashMap啥的这么常问，但是也有一定概率问到的，还是那句话，<strong>不打没把握的仗</strong>。</p>\n<p>我们在源码阅读过程中，不需要全部都读懂，需要做的就是读懂核心的源码，加深自己对概念的理解就好了，用的时候不至于啥都不知道，不要为了用而用就好了。</p>\n<h3 id=\"补充内容：\"><a href=\"#补充内容：\" class=\"headerlink\" title=\"补充内容：\"></a>补充内容：</h3><h5 id=\"1-RandomAccess-接口：\"><a href=\"#1-RandomAccess-接口：\" class=\"headerlink\" title=\"1.RandomAccess 接口：\"></a>1.RandomAccess 接口：</h5><p>ArrayList 实现了 RandomAccess 接⼝， ⽽ LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ ArrayList 底层是数组，⽽ LinkedList 底层是链表。数组天然⽀持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不⽀持快速随机访问。， ArrayList 实现了 RandomAccess 接⼝，就表明了他具有快速随机访问功能。 RandomAccess 接⼝只是标识，并不是说 ArrayList 实现 RandomAccess 接⼝才具有快速随机访问功能的！</p>\n<h5 id=\"2-下⾯再总结⼀下-list-的遍历⽅式选择：\"><a href=\"#2-下⾯再总结⼀下-list-的遍历⽅式选择：\" class=\"headerlink\" title=\"2.下⾯再总结⼀下 list 的遍历⽅式选择：\"></a>2.下⾯再总结⼀下 list 的遍历⽅式选择：</h5><p>实现了 RandomAccess 接⼝的list，优先选择普通 for 循环 ，其次 foreach,未实现 RandomAccess接⼝的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），⼤size的数据，千万不要使⽤普通for循环</p>\n<h5 id=\"3-双向链表和双向循环链表\"><a href=\"#3-双向链表和双向循环链表\" class=\"headerlink\" title=\"3.双向链表和双向循环链表\"></a>3.双向链表和双向循环链表</h5><p>双向链表： 包含两个指针，⼀个prev指向前⼀个节点，⼀个next指向后⼀个节点。</p>\n<p>双向循环链表： 最后⼀个节点的 next 指向head，⽽ head 的prev指向最后⼀个节点，构成⼀个环。</p>\n<h3 id=\"5-说一说session和cookie，区别\"><a href=\"#5-说一说session和cookie，区别\" class=\"headerlink\" title=\"5.说一说session和cookie，区别\"></a>5.说一说session和cookie，区别</h3><p><strong>session和cookie，都是解决http无状态的问题</strong></p>\n<p><strong>Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样；</strong></p>\n<p>维基百科是这样定义 <strong>Cookie</strong> 的：Cookies是某些⽹站为了<strong>辨别⽤户身份⽽储存在⽤户本地终端上的数据</strong>（通常经过加密）。简单来说： Cookie 存放在客户端，⼀般⽤来保存⽤户信息。典型的场景是我们在 Cookie 中保存已经登录过的⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了。除此之外，Cookie 还能保存⽤户⾸选项，主题和其他设置信息。</p>\n<p><strong>Session</strong> 的主要作⽤就是通过<strong>服务端记录⽤户的状态</strong>。 典型的场景是购物⻋，当你要添加商品到购物<br>⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定<br>的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。</p>\n<h5 id=\"区别：-1\"><a href=\"#区别：-1\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p><strong>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端；session有效期相对cookie较短。</strong>相对来说 Session 安全性更⾼。如果使⽤ Cookie 的⼀些敏感信息不要写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。</p>\n<h3 id=\"补充内容：-1\"><a href=\"#补充内容：-1\" class=\"headerlink\" title=\"补充内容：\"></a>补充内容：</h3><h5 id=\"1-如何使⽤Session进⾏身份验证？\"><a href=\"#1-如何使⽤Session进⾏身份验证？\" class=\"headerlink\" title=\"1.如何使⽤Session进⾏身份验证？\"></a>1.如何使⽤Session进⾏身份验证？</h5><p>很多时候我们都是通过 SessionID 来实现特定的⽤户，SessionID ⼀般会选择存放在 Redis 中。举个例⼦：⽤户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当⽤户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证⽅式更详细的过程如下：</p>\n<ol>\n<li> ⽤户向服务器发送⽤户名和密码⽤于登陆系统。</li>\n<li> 服务器验证通过后，服务器为⽤户创建⼀个 Session，并将 Session信息存储 起来。</li>\n<li> 服务器向⽤户返回⼀个 SessionID，写⼊⽤户的 Cookie。</li>\n<li> 当⽤户保持登录状态时，Cookie 将与每个后续请求⼀起被发送出去。</li>\n<li> 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进⾏⽐较，以验证⽤户的身份，返回给⽤户客户端响应信息的时候会附带⽤户当前的状态。</li>\n</ol>\n<p>使⽤ Session 的时候需要注意下⾯⼏个点：</p>\n<ol>\n<li>依赖Session的关键业务⼀定要确保客户端开启了Cookie</li>\n<li>注意Session的过期时间</li>\n</ol>\n<h5 id=\"2-如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）\"><a href=\"#2-如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）\" class=\"headerlink\" title=\"2.如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）\"></a>2.如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）</h5><p>⼀般是通过 Cookie 来保存 SessionID ，假如你使⽤了 Cookie 保存 SessionID的⽅案的话， 如果客户端禁⽤了Cookie，那么Seesion就⽆法正常⼯作。例如：在访问网页端某东时禁用Cookie后就不能访问了。但是，并不是没有 Cookie 之后就不能⽤ Session 了，⽐如你可以将SessionID放在请求的 url ⾥⾯ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhZ3VpZGUuY24vP3Nlc3Npb25faWQ9eHh4\">https://javaguide.cn/?session_id=xxx<i class=\"fa fa-external-link-alt\"></i></span> 。这种⽅案的话可⾏，但是安全性和⽤户体验感降低。当然，为了你也可以对 SessionID 进⾏⼀次加密之后再传⼊后端。</p>\n<h5 id=\"3-为什么Cookie-⽆法防⽌CSRF攻击，⽽token可以？\"><a href=\"#3-为什么Cookie-⽆法防⽌CSRF攻击，⽽token可以？\" class=\"headerlink\" title=\"3.为什么Cookie ⽆法防⽌CSRF攻击，⽽token可以？\"></a>3.为什么Cookie ⽆法防⽌CSRF攻击，⽽token可以？</h5><p><strong>CSRF</strong>（Cross Site Request Forgery）⼀般被翻译为 <strong>跨站请求伪造</strong> 。那么什么是 跨站请求伪造 呢？说简单⽤你的身份去发送⼀些对你不友好的请求。举个简单的例⼦：</p>\n<p>⼩明登录了某⽹上银⾏，他来到了⽹上银⾏的帖⼦区，看到⼀个帖⼦下⾯有⼀个链接写着“科学理财，年盈利率过万”，⼩明好奇的点开了这个链接，&lt;a src=<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5teWJhbmsuY29tL1RyYW5zZmVyP2JhbmtJZD0xMSZhbXA7bW9uZXk9MTAwMDAmZ3Q7JUU3JUE3JTkxJUU1JUFEJUE2JUU3JTkwJTg2JUU4JUI0JUEyJUVGJUJDJThDJUU1JUI5JUI0JUU3JTlCJTg4JUU1JTg4JUE5JUU3JThFJTg3JUU4JUJGJTg3JUU0JUI4JTg3\">http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万<i class=\"fa fa-external-link-alt\"></i></span>&lt;/&gt;结果发现⾃⼰的账户少了10000元。这是这么回事呢？原来⿊客在链接中藏了⼀个请求，这个请求直接利⽤⼩壮的身份给银⾏发送了⼀个转账请求,也就是通过你的 Cookie 向银⾏发出请求。上⾯也提到过，进⾏Session 认证的时候，我们⼀般使⽤ Cookie 来存储 SessionId,当我们登陆后后端⽣成⼀个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储⼯具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个⼈。如果别⼈通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让⽤户误点攻击链接，达到攻击效果。但是，我们使⽤ token 的话就不会存在这个问题，<strong>在我们登录成功获得 token 之后，⼀般会选择存放在 local storage 中。</strong>然后我们在前端通过某些⽅式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了⾮法链接发送了请求到服务端，这个⾮法请求是不会携带 token 的，所以这个请求将是⾮法的。<strong>需要注意的是不论是 Cookie 还是 token 都⽆法避免跨站脚本攻击（Cross Site Scripting）XSS</strong>。跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading StyleSheets，CSS）的缩写混淆。因此，有⼈将跨站脚本攻击缩写为XSS。<strong>XSS中攻击者会⽤各种⽅式将恶意代码注⼊到其他⽤户的⻚⾯中。就可以通过脚本盗⽤信息⽐如cookie。</strong><br>推荐阅读：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMTAvMTEvZmUtc2VjdXJpdHktY3NyZi5odG1s\">如何防⽌CSRF攻击？——美团技术团队<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h5 id=\"4-什么是-Token-什么是-JWT-如何基于Token进⾏身份验证？\"><a href=\"#4-什么是-Token-什么是-JWT-如何基于Token进⾏身份验证？\" class=\"headerlink\" title=\"4.什么是 Token?什么是 JWT?如何基于Token进⾏身份验证？\"></a>4.什么是 Token?什么是 JWT?如何基于Token进⾏身份验证？</h5><p>Token：Token不需要⾃⼰存放 Session 信息就能实现身份验证的⽅式；</p>\n<p>JWT ：JWT （JSON Web Token） 就是这种⽅式的实现，通过这种⽅式服务器端就不需要保存 Session 数据了，只⽤在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。JWT  本质上就⼀段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p>\n<h5 id=\"JWT-由-3-部分构成\"><a href=\"#JWT-由-3-部分构成\" class=\"headerlink\" title=\"JWT 由 3 部分构成:\"></a>JWT 由 3 部分构成:</h5><ol>\n<li>Header :描述 JWT 的元数据。定义了⽣成签名的算法以及 Token 的类型。</li>\n<li>Payload（负载）:⽤来存放实际需要传递的数据</li>\n<li>Signature（签名）：服务器通过 Payload、 Header和⼀个密钥(secret)使⽤ Header ⾥⾯指定的签名算法（默认是 HMAC SHA256）⽣成。</li>\n</ol>\n<p><strong>实现原理</strong>：在基于 Token 进⾏身份验证的的应⽤程序中，服务器通过 Payload、 Header和⼀个密钥(secret)创建令牌（ Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage ⾥⾯，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie ⾥⾯⾃动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中： Authorization: Bearer Token。</p>\n<h5 id=\"具体过程：\"><a href=\"#具体过程：\" class=\"headerlink\" title=\"具体过程：\"></a>具体过程：</h5><ol>\n<li>⽤户向服务器发送⽤户名和密码⽤于登陆系统。</li>\n<li>身份验证服务响应并返回了签名的 JWT，上⾯包含了⽤户是谁的内容。</li>\n<li>⽤户以后每次向后端发请求都在Header中带上 JWT。</li>\n<li>服务端检查 JWT 并从中获取⽤户相关信息。</li>\n</ol>\n<h3 id=\"6-用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢\"><a href=\"#6-用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢\" class=\"headerlink\" title=\"6.用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢\"></a>6.用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢</h3><p><strong>HashMap</strong>不能保证元素的顺序,HashMap能够将键设为<strong>null (一个key,实现map接口)**，也可以将值设为</strong>null（多个null）<strong>。与之对应的是</strong>Hashtable**,(注意大小写：不是HashTable)，Hashtable不能将键和值设为null，否则运行时会报空指针异常错误。</p>\n<h5 id=\"原因：\"><a href=\"#原因：\" class=\"headerlink\" title=\"原因：\"></a>原因：</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HashMap的put</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    ....</span><br><span class=\"line\"><span class=\"comment\">//Hashtable的put</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Make sure the value is not null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别:\"></a>区别:</h5><ol>\n<li><p>线程是否安全： HashMap 是⾮线程安全的，Hashtable 是线程安全的；<strong>Hashtable 内部的⽅法基本都经过 synchronized 修饰</strong>。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap吧！）；</p>\n</li>\n<li><p>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，Hashtable 基本被淘汰，不要在代码中使⽤它；</p>\n</li>\n<li><p>对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有⼀个 null，直接抛出 NullPointerException。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①<strong>创建时如果不指定容量初始值，Hashtable 默认的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后每次扩充（resize（）），容量变为原来的2倍</strong>。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 <strong>tableSizeFor</strong>()⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是2的幂次⽅。</li>\n<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n<li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</li>\n</ol>\n<p><strong>HashMap中的key可以是任何对象或数据类型吗</strong></p>\n<ul>\n<li><strong>可以为null，但不能是可变对象</strong>，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li>\n<li><strong>如果可变对象在 HashMap 中被用作键</strong>，<strong>那就要小心在改变对象状态的时候，不要改变它的哈希值了</strong>。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li>\n</ul>\n<p><strong>HashMap 中的构造函数：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal initial </span></span><br><span class=\"line\"><span class=\"string\">capacity: &quot;</span> + initialCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal load factor: &quot;</span> +</span><br><span class=\"line\">                                               loadFactor);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    <span class=\"comment\">//最终也会调用到上面的构造函数，不过这个默认的负载因子就是 HashMap 的默认负载因子也就是 0.75f</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class=\"comment\">//带有 Map 的构造函数，会直接把外部元素批量放入 HashMap 中。</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">  putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;                                               </span><br><span class=\"line\">                                               </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>下⾯这个⽅法（tableSizeFor）保证了 HashMap 总是使⽤2的幂作为哈希表的⼤⼩。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a power of two size for the given target capacity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY </span><br><span class=\"line\">: n + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//  &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  比如7的二进制是0111，7&gt;&gt;&gt;2表示右移2位，变成001，即为1</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  cap=8;n=7;n=0111  n|n&gt;&gt;&gt;1 = 0111 | 0011 = 0111 n|n&gt;&gt;&gt;2 0111 | 0001 = 0111</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//\tn|n&gt;&gt;&gt;4 0111 | 0000 = 0111 最后一步 return=n+1=8</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  综上可得，当hashMap指定初始值的时候，会调用tableSizeFor方法，总是返回2的n次方的值；</span></span><br><span class=\"line\">        <span class=\"comment\">//  并且总是等于该算法接近该初始值并比它大的那个值;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//  就是让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。当指定初始值入参</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//\t为0时，返回实际容量为1。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;<span class=\"comment\">//最大容量为2的30次方\t </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        \t <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">     \t    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">   \t\t\t &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//DK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的</span></span><br><span class=\"line\">    <span class=\"comment\">//hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置</span></span><br><span class=\"line\"> \t<span class=\"comment\">//（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash</span></span><br><span class=\"line\">\t<span class=\"comment\">//值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span><br><span class=\"line\">\t<span class=\"comment\">//所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现</span></span><br><span class=\"line\">\t<span class=\"comment\">//⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t <span class=\"comment\">// 1. HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash \t     </span></span><br><span class=\"line\">\t <span class=\"comment\">//的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</span></span><br><span class=\"line\">\t <span class=\"comment\">// 2. 由于HashMap规定了其容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小。使用位运算同时\t </span></span><br><span class=\"line\">     <span class=\"comment\">//还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于\t           </span></span><br><span class=\"line\">     <span class=\"comment\">//HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运\t</span></span><br><span class=\"line\">     <span class=\"comment\">//算符表示就是 1 &lt;&lt; 30，int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16;</span></span><br><span class=\"line\">      <span class=\"comment\">// 默认初始容量为16，必须为2的幂</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;<span class=\"comment\">// 默认加载因子0.75；</span></span><br><span class=\"line\">\t<span class=\"comment\">//HashMap默认初始容量16，加载因子0.75，也就是说最多能放16*0.75=12个元素，当put第13个时，HashMap\t</span></span><br><span class=\"line\">    <span class=\"comment\">//将发生rehash，rehash的一系列处理比较影响性能，所以当我们需要向HashMap存放较多元素时，最好指定合   </span></span><br><span class=\"line\">    <span class=\"comment\">//适的初始容量和加载因子，否则HashMap默认只能存12个元素，将会发生多次rehash操作。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\"><a href=\"#HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩\" class=\"headerlink\" title=\"HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩\"></a>HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩</h5><ol>\n<li>HashMap<strong>在确定数组下标Index的时候</strong>，采用的是( length-1) &amp; hash 的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</li>\n<li>由于HashMap规定了其<strong>容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小</strong>。使用位运算同时还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30，<strong>int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</strong></li>\n</ol>\n<h2 id=\"讲一讲-HashMap-put-的全过程\"><a href=\"#讲一讲-HashMap-put-的全过程\" class=\"headerlink\" title=\"讲一讲 HashMap put 的全过程\"></a>讲一讲 HashMap put 的全过程</h2><p>以 JDK 1.8 为基准进行分析，后面也是。先贴出整段代码，后面会逐行进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">  <span class=\"comment\">// 如果table 为null 或者没有为 table 分配内存，就resize一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    n = (tab = resize()).length;</span><br><span class=\"line\">  <span class=\"comment\">// 指定hash值节点为空则直接插入，这个(n - 1) &amp; hash才是表中真正的哈希</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果不为空</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">    <span class=\"comment\">// 计算表中的这个真正的哈希值与要插入的key.hash相比</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\">    <span class=\"comment\">// 若不同的话，并且当前节点已经在 TreeNode 上了</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">      <span class=\"comment\">// 采用红黑树存储方式</span></span><br><span class=\"line\">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">    <span class=\"comment\">// key.hash 不同并且也不再 TreeNode 上，在链表上找到 p.next==null</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 在表尾插入</span></span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 新增节点后如果节点个数到达阈值，则进入 treeifyBin() 进行再次判断</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了同 hash、key 的节点，那么直接退出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 p 指向下一节点</span></span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// map中含有旧值，返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">      afterNodeAccess(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// map调整次数 + 1</span></span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"comment\">// 键值对的数量达到阈值，需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    resize();</span><br><span class=\"line\">  afterNodeInsertion(evict);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先看一下 <code>putVal</code> 方法，这个方法是 final 的，如果你自已定义 HashMap 继承的话，是不允许你自己重写 put 方法的，然后这个方法涉及五个参数</p>\n<ul>\n<li>hash -&gt; put 放在桶中的位置，在 put 之前，会进行 hash 函数的计算。</li>\n<li>key -&gt; 参数的 key 值</li>\n<li>value -&gt; 参数的 value 值</li>\n<li>onlyIfAbsent -&gt; 是否改变已经存在的值，也就是是否进行 value 值的替换标志</li>\n<li>evict -&gt; 是否是刚创建 HashMap 的标志</li>\n</ul>\n<p><strong>在调用到 putVal 方法时，首先会进行 hash 函数计算应该插入的位置</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哈希函数的源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>hash 函数会根据你传递的 key 值进行计算，首先计算 key 的 <code>hashCode</code> 值，然后再对 hashcode 进行无符号右移操作，最后再和 hashCode 进行<code>异或 ^</code> 操作。</p>\n<ul>\n<li><code>&gt;&gt;&gt;</code>: 无符号右移操作，它指的是 <strong>无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong> ，也就是不管是正数还是负数，右移都会在空缺位补 0 。</li>\n</ul>\n<p>在得到 hash 值后，就会进行 put 过程。</p>\n<p>首先会判断 HashMap 中的 Node 数组是否为 null，如果第一次创建 HashMap 并进行第一次插入元素，首先会进行数组的 resize，也就是<code>重新分配</code>，这里还涉及到一个 <code>resize()</code> 扩容机制源码分析，我们后面会介绍。<strong>扩容完毕后，会计算出 HashMap 的存放位置，通过使用 ( n - 1 ) &amp; hash 进行计算得出。</strong></p>\n<p>然后会把这个位置作为数组的下标作为存放元素的位置。如果不为空，那么计算表中的这个真正的哈希值与要插入的 key.hash 相比。如果哈希值相同，key-value 不一样，再判断是否是树的实例，如果是的话，那么就把它插入到树上。如果不是，就执行尾插法在 entry 链尾进行插入。</p>\n<h3 id=\"扩容机制\"><a href=\"#扩容机制\" class=\"headerlink\" title=\"扩容机制\"></a>扩容机制</h3><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。好在 HashMap 是一种自动扩容的数据结构，在这种基于变长的数据结构中，扩容机制是非常重要的。</p>\n<p>在 HashMap 中，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。HashMap 中的扩容机制是由 <code>resize()</code> 方法来实现的，下面我们就来一次认识下。（贴出中文注释，便于复制）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  <span class=\"comment\">// 存储old table 的大小</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  <span class=\"comment\">// 存储扩容阈值</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果old table数据已达最大，那么threshold也被设置成最大</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">      threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 左移扩大二倍,</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">      <span class=\"comment\">// 扩容成原来二倍</span></span><br><span class=\"line\">      newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果oldThr                                                                                                                                               !&gt; 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">    newCap = oldThr;</span><br><span class=\"line\">  <span class=\"comment\">// 如果old table &lt;= 0 并且 存储的阈值 &lt;= 0</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">    newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果扩充阈值为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容阈值为 初始容量*负载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">              (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 重新给负载因子赋值</span></span><br><span class=\"line\">  threshold = newThr;</span><br><span class=\"line\">  <span class=\"comment\">// 获取扩容后的数组</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">  table = newTab;</span><br><span class=\"line\">  <span class=\"comment\">// 如果第一次进行table 初始化不会走下面的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 扩容之后需要重新把节点放在新扩容的数组中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt; e;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">          <span class=\"comment\">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class=\"line\">          ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">          Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; next;</span><br><span class=\"line\">          <span class=\"comment\">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">              loTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">              hiTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 将分组后的链表映射到新桶中</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j] = loHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们以 if...else if...else 逻辑进行拆分，上面代码主要做了这几个事情</p>\n<ul>\n<li>判断 HashMap 中的数组的长度，也就是 <code>(Node&lt;K,V&gt;[])oldTab.length()</code> ，再判断数组的长度是否比最大的的长度也就是 2^30 次幂要大，大的话直接取最大长度，否则利用位运算 <code>&lt;&lt;</code>扩容为原来的两倍</li>\n<li>如果数组长度不大于0 ，再判断扩容阈值 <code>threshold</code> 是否大于 0 ，也就是看有无外部指定的扩容阈值，若有则使用，这里需要说明一下 threshold 何时是 <code>oldThr &gt; 0</code>，因为 oldThr = threshold ，这里其实比较的就是 threshold，因为 HashMap 中的每个构造方法都会调用 <code>HashMap(initCapacity,loadFactor)</code> 这个构造方法，所以如果没有外部指定 initialCapacity，初始容量使用的就是 16，然后根据 <code>this.threshold = tableSizeFor(initialCapacity);</code> 求得 threshold 的值。</li>\n</ul>\n<p>然后会判断 newThr 是否为 0 ，笔者在刚开始研究时发现 <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code> 一直以为这是常量做乘法，怎么会为 0 ，其实不是这部分的问题，在于上面逻辑判断中的扩容操作，可能会导致<code>位溢出</code>。</p>\n<p>导致位溢出的示例：oldCap = 2^28 次幂，threshold &gt; 2 的三次方整数次幂。在进入到 <code>float ft = (float)newCap * loadFactor;</code> 这个方法是 2^28 * 2^(3+n) 会直接 &gt; 2^31 次幂，导致全部归零。</p>\n<p><strong>在扩容后需要把节点放在新扩容的数组中，这里也涉及到三个步骤</strong></p>\n<ul>\n<li>循环桶中的每个 Node 节点，判断 Node[i] 是否为空，为空直接返回，不为空则遍历桶数组，并将键值对映射到新的桶数组中。</li>\n<li>如果不为空，再判断是否是树形结构，如果是树形结构则按照树形结构进行拆分，拆分方法在 <code>split</code> 方法中。</li>\n<li>如果不是树形结构，则遍历链表，并将链表节点按原顺序进行分组。</li>\n</ul>\n<h3 id=\"讲一讲-get-方法全过程\"><a href=\"#讲一讲-get-方法全过程\" class=\"headerlink\" title=\"讲一讲 get 方法全过程\"></a>讲一讲 get 方法全过程</h3><p>我们上面讲了 HashMap 中的 put 方法全过程，下面我们来看一下 <code>get</code> 方法的过程，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 找到真实的元素位置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 总是会check 一下第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">        ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是第一个元素，并且下一个元素不是空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 判断是否属于 TreeNode，如果是 TreeNode 实例，直接从 TreeNode.getTreeNode 取</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果还不是 TreeNode 实例，就直接循环数组元素，直到找到指定元素位置</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来简单介绍下吧，首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<p><code>getNode</code> 方法有一个比较重要的过程就是 <strong>(n - 1) &amp; hash</strong>，这段代码是确定需要查找的桶的位置的，那么，为什么要 (n - 1) &amp; hash 呢？</p>\n<p>n 就是 HashMap 中桶的数量，这句话的意思也就是说 (n - 1) &amp; hash 就是 (桶的容量 - 1) &amp; hash</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为什么 HashMap 的检索位置是 (table.size - 1) &amp; hash</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 49</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 50</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// debug 得知 1 的 hash 值算出来是 51</span></span><br><span class=\"line\">  map.put(<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;cxuan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么每次算完之后的 (n - 1) &amp; hash ，依次为1 2 3 </p>\n<h3 id=\"HashMap-的遍历方式\"><a href=\"#HashMap-的遍历方式\" class=\"headerlink\" title=\"HashMap 的遍历方式\"></a>HashMap 的遍历方式</h3><p>HashMap 的遍历，也是一个使用频次特别高的操作</p>\n<p>HashMap 遍历的基类是 <code>HashIterator</code>，它是一个 Hash 迭代器，它是一个 HashMap 内部的抽象类，它的构造比较简单，只有三种方法，<strong>hasNext 、 remove 和 nextNode</strong> 方法，其中 nextNode 方法是由三种迭代器实现的</p>\n<p>这三种迭代器就就是</p>\n<ul>\n<li><code>KeyIterator</code> ，对 key 进行遍历</li>\n<li><code>ValueIterator</code>，对 value 进行遍历</li>\n<li><code>EntryIterator</code>， 对 Entry 链进行遍历</li>\n</ul>\n<p>虽然说看着迭代器比较多，但其实他们的遍历顺序都是一样的，构造也非常简单，都是使用 <code>HashIterator</code> 中的 <code>nextNode</code> 方法进行遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().key; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValueIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode().value; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EntryIterator</span> <span class=\"keyword\">extends</span> <span class=\"title\">HashIterator</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Map.<span class=\"function\">Entry&lt;K,V&gt; <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nextNode(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HashIterator 中的遍历方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashIterator</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; next;        <span class=\"comment\">// 下一个 entry 节点</span></span><br><span class=\"line\">  Node&lt;K,V&gt; current;     <span class=\"comment\">// 当前 entry 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> expectedModCount;  <span class=\"comment\">// fail-fast 的判断标识</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> index;             <span class=\"comment\">// 当前槽</span></span><br><span class=\"line\"></span><br><span class=\"line\">  HashIterator() &#123;</span><br><span class=\"line\">    expectedModCount = modCount;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t = table;</span><br><span class=\"line\">    current = next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// advance to first entry</span></span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">nextNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] t;</span><br><span class=\"line\">    Node&lt;K,V&gt; e = next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((next = (current = e).next) == <span class=\"keyword\">null</span> &amp;&amp; (t = table) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">do</span> &#123;&#125; <span class=\"keyword\">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>next 和 current 分别表示下一个 Node 节点和当前的 Node 节点，HashIterator 在初始化时会遍历所有的节点。下面我们用图来表示一下他们的遍历顺序</p>\n<p>你会发现 <code>nextNode()</code> 方法的遍历方式和 HashIterator 的遍历方式一样，只不过判断条件不一样，构造 HashIterator 的时候判断条件是有没有链表，桶是否为 null，而遍历 nextNode 的判断条件变为下一个 node 节点是不是 null ，并且桶是不是为 null。</p>\n<h3 id=\"HashMap-中的移除方法\"><a href=\"#HashMap-中的移除方法\" class=\"headerlink\" title=\"HashMap 中的移除方法\"></a>HashMap 中的移除方法</h3><p>HashMap 中的移除方法也比较简单了，源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt; e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">    <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      (p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      node = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">              ((k = e.key) == key ||</span><br><span class=\"line\">               (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">            node = e;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          p = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">                         (value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">        tab[index] = node.next;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        p.next = node.next;</span><br><span class=\"line\">      ++modCount;</span><br><span class=\"line\">      --size;</span><br><span class=\"line\">      afterNodeRemoval(node);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>remove 方法有很多，最终都会调用到 removeNode 方法，只不过传递的参数值不同，我们拿 remove(object) 来演示一下。</p>\n<p>首先会通过 hash 来找到对应的 bucket，然后通过遍历链表，找到键值相等的节点，然后把对应的节点进行删除。</p>\n<h2 id=\"关于-HashMap-的面试题\"><a href=\"#关于-HashMap-的面试题\" class=\"headerlink\" title=\"关于 HashMap 的面试题\"></a>关于 HashMap 的面试题</h2><h3 id=\"HashMap-的数据结构\"><a href=\"#HashMap-的数据结构\" class=\"headerlink\" title=\"HashMap 的数据结构\"></a>HashMap 的数据结构</h3><p>JDK1.7 中，HashMap 采用<code>位桶 + 链表</code>的实现，即使用<code>链表</code>来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。</p>\n<p>所以，与 JDK 1.7 相比，JDK 1.8 在底层结构方面做了一些改变，当每个桶中元素大于 8 的时候，会转变为红黑树，目的就是优化查询效率。</p>\n<h3 id=\"HashMap-的-put-过程\"><a href=\"#HashMap-的-put-过程\" class=\"headerlink\" title=\"HashMap 的 put 过程\"></a>HashMap 的 put 过程</h3><p>大致过程如下，首先会使用 hash 方法计算对象的哈希码，根据哈希码来确定在 bucket 中存放的位置，如果 bucket 中没有 Node 节点则直接进行 put，如果对应 bucket 已经有 Node 节点，会对链表长度进行分析，判断长度是否大于 8，如果链表长度小于 8 ，在 JDK1.7 前会使用头插法，在 JDK1.8 之后更改为尾插法。如果链表长度大于 8 会进行树化操作，把链表转换为红黑树，在红黑树上进行存储。</p>\n<h3 id=\"HashMap-为啥线程不安全\"><a href=\"#HashMap-为啥线程不安全\" class=\"headerlink\" title=\"HashMap 为啥线程不安全\"></a>HashMap 为啥线程不安全</h3><p>HashMap 不是一个线程安全的容器，不安全性体现在多线程并发对 HashMap 进行 put 操作上。如果有两个线程 A 和 B ，首先 A 希望插入一个键值对到 HashMap 中，在决定好桶的位置进行 put 时，此时 A 的时间片正好用完了，轮到 B 运行，B 运行后执行和 A 一样的操作，只不过 B 成功把键值对插入进去了。如果 A 和 B 插入的位置（桶）是一样的，那么线程 A 继续执行后就会覆盖 B 的记录，造成了数据不一致问题。</p>\n<p>还有一点在于 HashMap 在扩容时，因 resize 方法会形成环，造成死循环，导致 CPU 飙高。</p>\n<h3 id=\"HashMap-是如何处理哈希（冲突）碰撞的\"><a href=\"#HashMap-是如何处理哈希（冲突）碰撞的\" class=\"headerlink\" title=\"HashMap 是如何处理哈希（冲突）碰撞的\"></a>HashMap 是如何处理哈希（冲突）碰撞的</h3><p>HashMap 底层是使用位桶 + 链表实现的，位桶决定元素的插入位置，位桶是由 hash 方法决定的，当多个元素的 hash 计算得到相同的哈希值后，HashMap 会把多个 Node 元素都放在对应的位桶中，形成链表，这种处理哈希碰撞的方式被称为链地址法。</p>\n<p>其他处理 hash 碰撞的方式还有 <strong>开放地址法、rehash 方法、建立一个公共溢出区</strong>这几种方法。</p>\n<h3 id=\"HashMap-是如何-get-元素的\"><a href=\"#HashMap-是如何-get-元素的\" class=\"headerlink\" title=\"HashMap 是如何 get 元素的\"></a>HashMap 是如何 get 元素的</h3><p>首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p>\n<h3 id=\"HashMap-和-HashTable-有什么区别\"><a href=\"#HashMap-和-HashTable-有什么区别\" class=\"headerlink\" title=\"HashMap 和 HashTable 有什么区别\"></a>HashMap 和 HashTable 有什么区别</h3><p>父类不同：HashMap 继承了 <code>AbstractMap</code> 类，而 HashTable 继承了 <code>Dictionary</code> 类</p>\n<p>空值不同：HashMap 允许空的 key 和 value 值，HashTable 不允许空的 key 和 value 值。HashMap 会把 Null key 当做普通的 key 对待。不允许 null key 重复。</p>\n<p>线程安全性：HashMap 不是线程安全的，如果多个外部操作同时修改 HashMap 的数据结构比如 add 或者是 delete，必须进行同步操作，仅仅对 key 或者 value 的修改不是改变数据结构的操作。可以选择构造线程安全的 Map 比如 <code>Collections.synchronizedMap</code> 或者是 <code>ConcurrentHashMap</code>。而 HashTable 本身就是线程安全的容器。</p>\n<p>性能方面：虽然 HashMap 和 HashTable 都是基于单链表的，但是 HashMap 进行 put 或者 get􏱤 操作，可以达到常数时间的性能；而 HashTable 的 put 和 get 操作都是加了 <code>synchronized</code> 锁的，所以效率很差。</p>\n<h3 id=\"HashMap-和-HashSet-的区别\"><a href=\"#HashMap-和-HashSet-的区别\" class=\"headerlink\" title=\"HashMap 和 HashSet 的区别\"></a>HashMap 和 HashSet 的区别</h3><p>HashSet 继承于 AbstractSet 接口，实现了 Set、Cloneable,、java.io.Serializable 接口。HashSet 不允许集合中出现重复的值。HashSet 底层其实就是 HashMap，所有对 HashSet 的操作其实就是对 HashMap 的操作。所以 HashSet 也不保证集合的顺序。</p>\n<h3 id=\"HashMap-是如何扩容的\"><a href=\"#HashMap-是如何扩容的\" class=\"headerlink\" title=\"HashMap 是如何扩容的\"></a>HashMap 是如何扩容的</h3><p>HashMap 中有两个非常重要的变量，一个是 <code>loadFactor</code> ，一个是 <code>threshold</code> ，loadFactor 表示的就是负载因子，threshold 表示的是下一次要扩容的阈值，当 threshold = loadFactor * 数组长度时，数组长度扩大位原来的两倍，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。</p>\n<h3 id=\"HashMap-的长度为什么是-2-的幂次方\"><a href=\"#HashMap-的长度为什么是-2-的幂次方\" class=\"headerlink\" title=\"HashMap 的长度为什么是 2 的幂次方\"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>这道题我想了几天，之前和群里小伙伴们探讨每日一题的时候，问他们为什么 length%hash == (n - 1) &amp; hash，它们说相等的前提是 length 的长度 2 的幂次方，然后我回了一句难道 length 还能不是 2 的幂次方吗？其实是我没有搞懂因果关系，因为 HashMap 的长度是 2 的幂次方，所以使用余数来判断在桶中的下标。如果 length 的长度不是 2 的幂次方，小伙伴们可以举个例子来试试</p>\n<blockquote>\n<p>例如长度为 9 时候，3 &amp; (9-1) = 0，2 &amp; (9-1) = 0 ，都在 0 上，碰撞了；</p>\n</blockquote>\n<p>这样会增大 HashMap 碰撞的几率。</p>\n<h3 id=\"HashMap-线程安全的实现有哪些\"><a href=\"#HashMap-线程安全的实现有哪些\" class=\"headerlink\" title=\"HashMap 线程安全的实现有哪些\"></a>HashMap 线程安全的实现有哪些</h3><p>因为 HashMap 不是一个线程安全的容器，所以并发场景下推荐使用 <code>ConcurrentHashMap</code> ，或者使用线程安全的 HashMap，使用 <code>Collections</code> 包下的线程安全的容器，比如说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Collections.synchronizedMap(<span class=\"keyword\">new</span> HashMap());</span><br></pre></td></tr></table></figure>\n\n<p>还可以使用 HashTable ，它也是线程安全的容器，基于 key-value 存储，经常用 HashMap 和 HashTable 做比较就是因为 HashTable 的数据结构和 HashMap 相同。</p>\n<p>上面效率最高的就是 ConcurrentHashMap。</p>\n<h3 id=\"7-说说你了解的springcloud-里面有什么组件呢\"><a href=\"#7-说说你了解的springcloud-里面有什么组件呢\" class=\"headerlink\" title=\"7.说说你了解的springcloud,里面有什么组件呢\"></a>7.说说你了解的springcloud,里面有什么组件呢</h3><p>SpringCloud：分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶</p>\n<p>Spring Cloud是一个微服务框架，相比Dubbo等RPC框架, <strong>Spring Cloud提供的全套的分布式系统解决方案</strong>。</p>\n<p>Spring Cloud对微服务基础框架Netflix的多个开源组件进行了封装，同时又实现了和云端平台以及和Spring Boot开发框架的集成。 </p>\n<p>Spring Cloud为微服务架构开发涉及的<strong>配置管理，服务治理，熔断机制，智能路由，微代理，控制总线，一次性token，全局一致性锁，leader选举，分布式session，集群状态</strong>管理等操作提供了一种简单的开发方式。</p>\n<p>Spring Cloud 为开发者提供了快速构建<strong>分布式系统的工具</strong>，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。  </p>\n<h4 id=\"常见组件\"><a href=\"#常见组件\" class=\"headerlink\" title=\"常见组件\"></a>常见组件</h4><ul>\n<li>Eureka：注册中心；各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</li>\n<li>Zuul、Gateway：网关；如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</li>\n<li>Ribbon：负载均衡；服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</li>\n<li>Feign：服务调用；基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</li>\n<li>Hystrix或Resilience4j：熔断器；发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</li>\n</ul>\n<p><img data-src=\"https://i.loli.net/2020/11/01/3u8IwCHq7N4Fvif.jpg\" loading=\"lazy\"></p>\n<h3 id=\"8-说说你了解的spring-Boot\"><a href=\"#8-说说你了解的spring-Boot\" class=\"headerlink\" title=\"8.说说你了解的spring Boot\"></a>8.说说你了解的spring Boot</h3><p>Spring Boot是Spring开源组织下的一个子项目，也是Spring组件一站式解决方案，主要是为了简化使用Spring框架的难度，简省繁重的配置。</p>\n<p>设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>\n<p>SpringBoot所具备的特征有：</p>\n<ol>\n<li>可以创建独立的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TcHJpbmcvODUwNjE=\">Spring<i class=\"fa fa-external-link-alt\"></i></span>应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</li>\n<li>内嵌Tomcat或Jetty等Servlet容器,Spring Boot 只要打成一个可执行的jar包就能独立运行，所有的依赖包都    在一个jar包内。</li>\n<li>提供自动配置的“starter”项目对象模型（POMS）以简化<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NYXZlbi82MDk0OTA5\">Maven<i class=\"fa fa-external-link-alt\"></i></span>配置；</li>\n<li>尽可能自动配置Spring容器；</li>\n<li>提供准备好的特性，如指标、健康检查和外部化配置；</li>\n<li>绝对没有代码生成，不需要XML配置。 </li>\n</ol>\n<p>SpringBoot框架中还有两个非常重要的策略：开箱即用和约定优于配置。开箱即用，Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。</p>\n<h2 id=\"第二个现场面试\"><a href=\"#第二个现场面试\" class=\"headerlink\" title=\"第二个现场面试\"></a>第二个现场面试</h2><p>问的很基础，具体我都快忘了，写这个时已经过好几天了；</p>\n<h3 id=\"1-java类和接口的理解\"><a href=\"#1-java类和接口的理解\" class=\"headerlink\" title=\"1.java类和接口的理解\"></a>1.java类和接口的理解</h3><p>java类只能单继承，扩展单一，但一个类可以实现多个接口；而接口可以进行多继承。</p>\n<h3 id=\"2-多线程\"><a href=\"#2-多线程\" class=\"headerlink\" title=\"2.多线程\"></a>2.多线程</h3><p>一个程序在运行开始会产生一个进程，一个进程可以产生多个线程，实现多线程的方法有继承Thread类、实现Runnable接口、使用Callable接口和Future接口。</p>\n<h3 id=\"3-io，怎么读一个文件，给你一个路径\"><a href=\"#3-io，怎么读一个文件，给你一个路径\" class=\"headerlink\" title=\"3.io，怎么读一个文件，给你一个路径\"></a>3.io，怎么读一个文件，给你一个路径</h3><p>我们可以根据文件类型，选择不同io子类来读取文件。</p>\n<p>如果是二进制文件，使用FileInputStream读取；如果是文本文件，使用FileReader读取；</p>\n<p>这两个类允许我们从文件开始至文件结尾一个字节或字符的读取文件，或者将读取的文件写入字节数组或字符数组。</p>\n<p>如果我们想随机的读取文件内容，可以使用RandomAccessFile。</p>\n<p><img data-src=\"https://i.loli.net/2020/11/01/o8iax6JsrGzPpT7.png\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个只是读文件</span></span><br><span class=\"line\">FileInputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> asc= -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//FileInputStream的read()返回的数字是ASCII码 //注意：其中包括着“\\r和\\n”两个字符(\\r:13,\\n:10)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>((asc=in.read())!=-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将char型强行转制为int型得到的是Ascii码//将int型强行转制为char型得到的是字符</span></span><br><span class=\"line\">    System.out.print((<span class=\"keyword\">char</span>)asc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> in.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取文件(字节流)</span></span><br><span class=\"line\">InputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//写入相应的文件</span></span><br><span class=\"line\">OutputStream out = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;d:\\\\2.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//读取数据</span></span><br><span class=\"line\"><span class=\"comment\">//一次性取多少字节</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2048</span>];</span><br><span class=\"line\"><span class=\"comment\">//接受读取的内容(返回的n是读入数组bytes[]的总字节数)</span></span><br><span class=\"line\"><span class=\"comment\">//read返回值是读入缓冲区的字节总数,如果因为已经到达文件末尾而没有更多的数据,则返回 -1.意思是已经到达末尾.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//循环取出数据</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ((n = in.read(bytes)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//转换成字符串</span></span><br><span class=\"line\">    String str = new String(bytes,0,n,&quot;GBK&quot;); #这里可以实现字节到字符串的转换，比较实用</span><br><span class=\"line\">    <span class=\"comment\">//String str = new String(bytes,&quot;GBK&quot;);//这个也行</span></span><br><span class=\"line\">    System.out.println(str);</span><br><span class=\"line\">    <span class=\"comment\">//写入相关文件</span></span><br><span class=\"line\">    out.write(bytes, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">    <span class=\"comment\">//out.write(bytes);//这个也行</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//把缓存在内存中残留的数据压入文件中，并清除缓存</span></span><br><span class=\"line\">out.flush();</span><br><span class=\"line\"><span class=\"comment\">//关闭流</span></span><br><span class=\"line\">in.close();</span><br><span class=\"line\">out.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取文件(缓存字节流)</span></span><br><span class=\"line\">BufferedInputStream in = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//写入相应的文件</span></span><br><span class=\"line\">BufferedOutputStream out = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;d:\\\\2.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//读取数据</span></span><br><span class=\"line\"><span class=\"comment\">//一次性取多少字节</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2048</span>];</span><br><span class=\"line\"><span class=\"comment\">//接受读取的内容(返回的n是读入数组bytes[]的总字节数)</span></span><br><span class=\"line\"><span class=\"comment\">//read返回值是读入缓冲区的字节总数,如果因为已经到达文件末尾而没有更多的数据,则返回 -1.意思是已经到达末尾.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//循环取出数据</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ((n = in.read(bytes)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//转换成字符串</span></span><br><span class=\"line\">    String str = <span class=\"keyword\">new</span> String(bytes,<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    System.out.println(str);</span><br><span class=\"line\">    <span class=\"comment\">//写入相关文件</span></span><br><span class=\"line\">    out.write(bytes);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把缓存在内存中残留的数据压入文件中，并清除缓存</span></span><br><span class=\"line\">out.flush();</span><br><span class=\"line\"><span class=\"comment\">//关闭流</span></span><br><span class=\"line\">in.close();</span><br><span class=\"line\">out.close();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-mysql索引优化\"><a href=\"#4-mysql索引优化\" class=\"headerlink\" title=\"4.mysql索引优化\"></a>4.mysql索引优化</h3><h3 id=\"5-springcloud是什么\"><a href=\"#5-springcloud是什么\" class=\"headerlink\" title=\"5.springcloud是什么\"></a>5.springcloud是什么</h3><h3 id=\"6-冒泡排序原理\"><a href=\"#6-冒泡排序原理\" class=\"headerlink\" title=\"6.冒泡排序原理\"></a>6.冒泡排序原理</h3><h3 id=\"7-前端技术html，CSS，ajax，jquery，javascript是什么\"><a href=\"#7-前端技术html，CSS，ajax，jquery，javascript是什么\" class=\"headerlink\" title=\"7.前端技术html，CSS，ajax，jquery，javascript是什么\"></a>7.前端技术html，CSS，ajax，jquery，javascript是什么</h3><h5 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h5><p>HTML代表超文本标记语言（Hyper Text Markup Language），它不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。它是静态的。与之相对应的是jsp动态网页。</p>\n<p>作用</p>\n<p>静态网站是指全部由<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M\">HTML<i class=\"fa fa-external-link-alt\"></i></span>（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==\">标准通用标记语言<i class=\"fa fa-external-link-alt\"></i></span>的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种视觉动态效果，如GIF动画、FLASH动画、滚动字幕等，而网站主要是静态化的页面和代码组成，一般文件名均以<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9odG0vMzIxMzMzNg==\">htm<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9odG1sLzk3MDQ5\">html<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zaHRtbC81OTQ5MjE=\">shtml<i class=\"fa fa-external-link-alt\"></i></span>等为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEUlRTclQkMlODAvMTEwMTE2ODM=\">后缀<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<h5 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h5><p>CSS层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M\">HTML<i class=\"fa fa-external-link-alt\"></i></span>（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==\">标准通用标记语言<i class=\"fa fa-external-link-alt\"></i></span>的一个应用）或<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9YTUw=\">XML<i class=\"fa fa-external-link-alt\"></i></span>（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，**还可以配合各种脚本语言动态地对网页各元素进行格式化。 ** </p>\n<p>作用：</p>\n<p>丰富的样式、定义易于使用和修改、多页面应用、层叠、页面压缩</p>\n<h5 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h5><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>\n<p>Ajax不是一个技术，它实际上是几种技术，每种技术都有其独特这处，合在一起就成了一个功能强大的新技术</p>\n<p>Ajax包括： </p>\n<ul>\n<li>XHTML和CSS</li>\n<li>使用文档对象模型(DocumentObjectModel)作动态显示和交互 </li>\n<li>使用XML和XSLT做数据交互和操作 </li>\n<li>使用XMLHttpRequest进行异步数据接收 </li>\n<li>使用JavaScript将它们绑定在一起 </li>\n</ul>\n<p>作用：</p>\n<p>Ajax，异步JavaScript与XML，是使用客户端脚本与Web服务器交换数据的Web应用开发方法。这样，Web页面不用打断交互流程进行重新加裁，就可以动态地更新。使用Ajax，你可以创建接近本地桌面应用的，直接的、高可用的、更丰富的、更动态的Web用户接口界面。 </p>\n<h5 id=\"JQuery\"><a href=\"#JQuery\" class=\"headerlink\" title=\"JQuery\"></a>JQuery</h5><p>JQuery实际上就是对现有的JavaScript的一种扩展，它非常轻量级，压缩后大概32KB，它兼容于各种浏览器，这样就可以非常方便地添加适用于多种浏览器的特效。</p>\n<p>作用：</p>\n<p>jQuery本身是一个基于插件的JavaScript库，它的各种功能可以通过新的插件进行增强。jQuery为Web编程提供了一个抽象的层，使得它可以兼容于任何浏览器，并且大大简化了原先用JavaScript做的工作，总而言之， jQuery可以完成如下所示的工作。</p>\n<p>优点</p>\n<ul>\n<li><p>利用css的选择器提供高速的元素查找行为。</p>\n</li>\n<li><p>提供了一个抽象层来标准化各种常见的任务，可以解决各种浏览器的兼容问题。</p>\n</li>\n<li><p>将复杂的代码简化，提供连缀编程模式，大大简化了代码的操作。</p>\n</li>\n</ul>\n<h5 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h5><p>JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的是一种解释性脚本语言（代码不进行预编译）主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。</p>\n<h3 id=\"8-什么是redis\"><a href=\"#8-什么是redis\" class=\"headerlink\" title=\"8.什么是redis\"></a>8.什么是redis</h3><p>开源免费的，c编译的，是一个<strong>高效能的键值分布式内存数据库</strong>，<strong>基于内存运行并支持持久化的NOSQL数据库。</strong></p>\n","categories":["面试"],"tags":["应届面试"]},{"title":"404 Not Found：该页无法显示","url":"//404.html","content":"<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homepagename='返回主页' homepageurl=\"/\" charset=\"utf-8\"></script>"},{"title":"分类","url":"/categories/index.html","content":""},{"title":"标签","url":"/tags/index.html","content":""},{"url":"/js/cursor/candy.min.js","content":"class Circle{constructor({origin:t,speed:i,color:e,angle:s,context:n}){this.origin=t,this.position={...this.origin},this.color=e,this.speed=i,this.angle=s,this.context=n,this.renderCount=0}draw(){this.context.fillStyle=this.color,this.context.beginPath(),this.context.arc(this.position.x,this.position.y,2,0,2*Math.PI),this.context.fill()}move(){this.position.x=Math.sin(this.angle)*this.speed+this.position.x,this.position.y=Math.cos(this.angle)*this.speed+this.position.y+.3*this.renderCount,this.renderCount++}}class Boom{constructor({origin:t,context:i,circleCount:e=10,area:s}){this.origin=t,this.context=i,this.circleCount=e,this.area=s,this.stop=!1,this.circles=[]}randomArray(t){const i=t.length;return t[Math.floor(i*Math.random())]}randomColor(){const t=[\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"];return\"#\"+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)+this.randomArray(t)}randomRange(t,i){return(i-t)*Math.random()+t}init(){for(let t=0;t<this.circleCount;t++){const t=new Circle({context:this.context,origin:this.origin,color:this.randomColor(),angle:this.randomRange(Math.PI-1,Math.PI+1),speed:this.randomRange(1,6)});this.circles.push(t)}}move(){this.circles.forEach((t,i)=>{if(t.position.x>this.area.width||t.position.y>this.area.height)return this.circles.splice(i,1);t.move()}),0==this.circles.length&&(this.stop=!0)}draw(){this.circles.forEach(t=>t.draw())}}class CursorSpecialEffects{constructor(){this.computerCanvas=document.createElement(\"canvas\"),this.renderCanvas=document.createElement(\"canvas\"),this.computerContext=this.computerCanvas.getContext(\"2d\"),this.renderContext=this.renderCanvas.getContext(\"2d\"),this.globalWidth=window.innerWidth,this.globalHeight=window.innerHeight,this.booms=[],this.running=!1}handleMouseDown(t){const i=new Boom({origin:{x:t.clientX,y:t.clientY},context:this.computerContext,area:{width:this.globalWidth,height:this.globalHeight}});i.init(),this.booms.push(i),this.running||this.run()}handlePageHide(){this.booms=[],this.running=!1}init(){const t=this.renderCanvas.style;t.position=\"fixed\",t.top=t.left=0,t.zIndex=\"999999999999999999999999999999999999999999\",t.pointerEvents=\"none\",t.width=this.renderCanvas.width=this.computerCanvas.width=this.globalWidth,t.height=this.renderCanvas.height=this.computerCanvas.height=this.globalHeight,document.body.append(this.renderCanvas),window.addEventListener(\"mousedown\",this.handleMouseDown.bind(this)),window.addEventListener(\"pagehide\",this.handlePageHide.bind(this))}run(){if(this.running=!0,0==this.booms.length)return this.running=!1;requestAnimationFrame(this.run.bind(this)),this.computerContext.clearRect(0,0,this.globalWidth,this.globalHeight),this.renderContext.clearRect(0,0,this.globalWidth,this.globalHeight),this.booms.forEach((t,i)=>{if(t.stop)return this.booms.splice(i,1);t.move(),t.draw()}),this.renderContext.drawImage(this.computerCanvas,0,0,this.globalWidth,this.globalHeight)}}const cursorSpecialEffects=new CursorSpecialEffects;cursorSpecialEffects.init();"},{"url":"/js/cursor/fireworks.js","content":"class Circle {\n  constructor({ origin, speed, color, angle, context }) {\n    this.origin = origin\n    this.position = { ...this.origin }\n    this.color = color\n    this.speed = speed\n    this.angle = angle\n    this.context = context\n    this.renderCount = 0\n  }\n\n  draw() {\n    this.context.fillStyle = this.color\n    this.context.beginPath()\n    this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2)\n    this.context.fill()\n  }\n\n  move() {\n    this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x\n    this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3)\n    this.renderCount++\n  }\n}\n\nclass Boom {\n  constructor ({ origin, context, circleCount = 16, area }) {\n    this.origin = origin\n    this.context = context\n    this.circleCount = circleCount\n    this.area = area\n    this.stop = false\n    this.circles = []\n  }\n\n  randomArray(range) {\n    const length = range.length\n    const randomIndex = Math.floor(length * Math.random())\n    return range[randomIndex]\n  }\n\n  randomColor() {\n    const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n    return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range)\n  }\n\n  randomRange(start, end) {\n    return (end - start) * Math.random() + start\n  }\n\n  init() {\n    for(let i = 0; i < this.circleCount; i++) {\n      const circle = new Circle({\n        context: this.context,\n        origin: this.origin,\n        color: this.randomColor(),\n        angle: this.randomRange(Math.PI - 1, Math.PI + 1),\n        speed: this.randomRange(1, 6)\n      })\n      this.circles.push(circle)\n    }\n  }\n\n  move() {\n    this.circles.forEach((circle, index) => {\n      if (circle.position.x > this.area.width || circle.position.y > this.area.height) {\n        return this.circles.splice(index, 1)\n      }\n      circle.move()\n    })\n    if (this.circles.length == 0) {\n      this.stop = true\n    }\n  }\n\n  draw() {\n    this.circles.forEach(circle => circle.draw())\n  }\n}\n\nclass CursorSpecialEffects {\n  constructor() {\n    this.computerCanvas = document.createElement('canvas')\n    this.renderCanvas = document.createElement('canvas')\n\n    this.computerContext = this.computerCanvas.getContext('2d')\n    this.renderContext = this.renderCanvas.getContext('2d')\n\n    this.globalWidth = window.innerWidth\n    this.globalHeight = window.innerHeight\n\n    this.booms = []\n    this.running = false\n  }\n\n  handleMouseDown(e) {\n    const boom = new Boom({\n      origin: { x: e.clientX, y: e.clientY },\n      context: this.computerContext,\n      area: {\n        width: this.globalWidth,\n        height: this.globalHeight\n      }\n    })\n    boom.init()\n    this.booms.push(boom)\n    this.running || this.run()\n  }\n\n  handlePageHide() {\n    this.booms = []\n    this.running = false\n  }\n\n  init() {\n    const style = this.renderCanvas.style\n    style.position = 'fixed'\n    style.top = style.left = 0\n    style.zIndex = '999999999999999999999999999999999999999999'\n    style.pointerEvents = 'none'\n\n    style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth\n    style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight\n\n    document.body.append(this.renderCanvas)\n\n    window.addEventListener('mousedown', this.handleMouseDown.bind(this))\n    window.addEventListener('pagehide', this.handlePageHide.bind(this))\n  }\n\n  run() {\n    this.running = true\n    if (this.booms.length == 0) {\n      return this.running = false\n    }\n\n    requestAnimationFrame(this.run.bind(this))\n\n    this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n    this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight)\n\n    this.booms.forEach((boom, index) => {\n      if (boom.stop) {\n        return this.booms.splice(index, 1)\n      }\n      boom.move()\n      boom.draw()\n    })\n    this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight)\n  }\n}\n\nconst cursorSpecialEffects = new CursorSpecialEffects()\ncursorSpecialEffects.init()\n"},{"url":"/js/cursor/love.min.js","content":"! function (e, t, a) {\n    function n() {\n        c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r()\n    }\n\n    function r() {\n        for (var e = 0; e < d.length; e++) d[e].alpha <= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = \"left:\" + d[e].x + \"px;top:\" + d[e].y + \"px;opacity:\" + d[e].alpha + \";transform:scale(\" + d[e].scale + \",\" + d[e].scale + \") rotate(45deg);background:\" + d[e].color + \";z-index:99999\");\n        requestAnimationFrame(r)\n    }\n\n    function o() {\n        var t = \"function\" == typeof e.onclick && e.onclick;\n        e.onclick = function (e) {\n            t && t(), i(e)\n        }\n    }\n\n    function i(e) {\n        var a = t.createElement(\"div\");\n        a.className = \"heart\", d.push({\n            el: a,\n            x: e.clientX - 5,\n            y: e.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: s()\n        }), t.body.appendChild(a)\n    }\n\n    function c(e) {\n        var a = t.createElement(\"style\");\n        a.type = \"text/css\";\n        try {\n            a.appendChild(t.createTextNode(e))\n        } catch (t) {\n            a.styleSheet.cssText = e\n        }\n        t.getElementsByTagName(\"head\")[0].appendChild(a)\n    }\n\n    function s() {\n        return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n    }\n    var d = [];\n    e.requestAnimationFrame = function () {\n        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {\n            setTimeout(e, 1e3 / 60)\n        }\n    }(), n()\n}(window, document);\n"},{"url":"/js/cursor/text.js","content":"/* 社会主体核心价值观效果 */\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    $(\"body\").click(function(e) {\n        // var a = new Array(\"❤富强❤\",\"❤民主❤\",\"❤文明❤\",\"❤和谐❤\",\"❤自由❤\",\"❤平等❤\",\"❤公正❤\",\"❤法治❤\",\"❤爱国❤\",\"❤敬业❤\",\"❤诚信❤\",\"❤友善❤\");\n        var a = new Array(\"富强\",\"民主\",\"文明\",\"和谐\",\"自由\",\"平等\",\"公正\",\"法治\",\"爱国\",\"敬业\",\"诚信\",\"友善\");\n        var $i = $(\"<span></span>\").text(a[a_idx]);\n        a_idx = (a_idx + 1) % a.length;\n        var x = e.pageX,\n        y = e.pageY;\n        $i.css({\n            \"z-index\": 999999999999999999999999999999999999999999999999999999999999999999999,\n            \"top\": y - 20,\n            \"left\": x,\n            \"position\": \"absolute\",\n            \"font-weight\": \"bold\",\n            \"color\": \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"\n        });\n        $(\"body\").append($i);\n        $i.animate({\n            \"top\": y - 180,\n            \"opacity\": 0\n        },\n        1500,\n        function() {\n            $i.remove();\n        });\n    });\n});"},{"url":"/js/src/jinrishici.js","content":"/**\n * 今日诗词V2 JS-SDK 1.2.2\n * 今日诗词API 是一个可以免费调用的诗词接口：https://www.jinrishici.com\n */\n!function(e){var n,t={},o=\"jinrishici-token\";function i(){return document.getElementById(\"jinrishici-sentence\")||0!=document.getElementsByClassName(\"jinrishici-sentence\").length}function c(){t.load(function(e){var n=document.getElementById(\"jinrishici-sentence\"),t=document.getElementsByClassName(\"jinrishici-sentence\");if(n&&(n.innerText=e.data.content),0!==t.length)for(var o=0;o<t.length;o++)t[o].innerText=e.data.content})}function r(e,n){var t=new XMLHttpRequest;t.open(\"get\",n),t.withCredentials=!0,t.send(),t.onreadystatechange=function(n){if(4===t.readyState){var o=JSON.parse(t.responseText);\"success\"===o.status?e(o):console.error(\"今日诗词API加载失败，错误原因：\"+o.errMessage)}}}t.load=function(n){return e.localStorage&&e.localStorage.getItem(o)?function(e,n){return r(e,\"https://v2.jinrishici.com/one.json?client=browser-sdk/1.2&X-User-Token=\"+encodeURIComponent(n))}(n,e.localStorage.getItem(o)):function(n){return r(function(t){e.localStorage.setItem(o,t.token),n(t)},\"https://v2.jinrishici.com/one.json?client=browser-sdk/1.2\")}(n)},e.jinrishici=t,i()?c():(n=function(){i()&&c()},\"loading\"!=document.readyState?n():document.addEventListener?document.addEventListener(\"DOMContentLoaded\",n):document.attachEvent(\"onreadystatechange\",function(){\"complete\"==document.readyState&&n()}))}(window);"},{"url":"/js/src/snow.min.js","content":"notMobile&&(()=>{let e={flakeCount:100,minDist:150,color:\"255, 255, 255\",size:2,speed:.5,opacity:.2,stepsize:.5};const t=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1e3/60)};window.requestAnimationFrame=t;const i=document.getElementById(\"snow\"),n=i.getContext(\"2d\"),o=e.flakeCount;let a=-100,s=-100,d=[];i.width=window.innerWidth,i.height=window.innerHeight;const h=()=>{n.clearRect(0,0,i.width,i.height);const r=e.minDist;for(let t=0;t<o;t++){let o=d[t];const h=a,m=s,w=o.x,c=o.y,p=Math.sqrt((h-w)*(h-w)+(m-c)*(m-c));if(p<r){const e=(h-w)/p,t=(m-c)/p,i=r/(p*p)/2;o.velX-=i*e,o.velY-=i*t}else o.velX*=.98,o.velY<o.speed&&o.speed-o.velY>.01&&(o.velY+=.01*(o.speed-o.velY)),o.velX+=Math.cos(o.step+=.05)*o.stepSize;n.fillStyle=\"rgba(\"+e.color+\", \"+o.opacity+\")\",o.y+=o.velY,o.x+=o.velX,(o.y>=i.height||o.y<=0)&&l(o),(o.x>=i.width||o.x<=0)&&l(o),n.beginPath(),n.arc(o.x,o.y,o.size,0,2*Math.PI),n.fill()}t(h)},l=e=>{e.x=Math.floor(Math.random()*i.width),e.y=0,e.size=3*Math.random()+2,e.speed=1*Math.random()+.5,e.velY=e.speed,e.velX=0,e.opacity=.5*Math.random()+.3};document.addEventListener(\"mousemove\",e=>{a=e.clientX,s=e.clientY}),window.addEventListener(\"resize\",()=>{i.width=window.innerWidth,i.height=window.innerHeight}),(()=>{for(let t=0;t<o;t++){const t=Math.floor(Math.random()*i.width),n=Math.floor(Math.random()*i.height),o=3*Math.random()+e.size,a=1*Math.random()+e.speed,s=.5*Math.random()+e.opacity;d.push({speed:a,velX:0,velY:a,x:t,y:n,size:o,stepSize:Math.random()/30*e.stepsize,step:0,angle:180,opacity:s})}h()})()})();"},{"url":"/js/src/time.js","content":"(function(){\n\n    var digit=\n     [\n         [\n             [0,0,1,1,1,0,0],\n             [0,1,1,0,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,0,1,1,0],\n             [0,0,1,1,1,0,0]\n         ],//0\n         [\n             [0,0,0,1,1,0,0],\n             [0,1,1,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [1,1,1,1,1,1,1]\n         ],//1\n         [\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,0,1,1,0,0,0],\n             [0,1,1,0,0,0,0],\n             [1,1,0,0,0,0,0],\n             [1,1,0,0,0,1,1],\n             [1,1,1,1,1,1,1]\n         ],//2\n         [\n             [1,1,1,1,1,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//3\n         [\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,1,0],\n             [0,0,1,1,1,1,0],\n             [0,1,1,0,1,1,0],\n             [1,1,0,0,1,1,0],\n             [1,1,1,1,1,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,1,1]\n         ],//4\n         [\n             [1,1,1,1,1,1,1],\n             [1,1,0,0,0,0,0],\n             [1,1,0,0,0,0,0],\n             [1,1,1,1,1,1,0],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//5\n         [\n             [0,0,0,0,1,1,0],\n             [0,0,1,1,0,0,0],\n             [0,1,1,0,0,0,0],\n             [1,1,0,0,0,0,0],\n             [1,1,0,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//6\n         [\n             [1,1,1,1,1,1,1],\n             [1,1,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,0,0,1,1,0,0],\n             [0,0,1,1,0,0,0],\n             [0,0,1,1,0,0,0],\n             [0,0,1,1,0,0,0],\n             [0,0,1,1,0,0,0]\n         ],//7\n         [\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,1,1,0]\n         ],//8\n         [\n             [0,1,1,1,1,1,0],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [1,1,0,0,0,1,1],\n             [0,1,1,1,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,0,1,1],\n             [0,0,0,0,1,1,0],\n             [0,0,0,1,1,0,0],\n             [0,1,1,0,0,0,0]\n         ],//9\n         [\n             [0,0,0,0,0,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,0,0,0,0,0],\n             [0,0,0,0,0,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,1,1,1,0,0],\n             [0,0,0,0,0,0,0]\n         ]//:\n     ];\n \n var canvas = document.getElementById('canvas');\n \n if(canvas.getContext){\n     var cxt = canvas.getContext('2d');\n     //声明canvas的宽高\n     var H = 100,W = 700;\n     canvas.height = H;\n     canvas.width = W;\n     cxt.fillStyle = '#f00';\n     cxt.fillRect(10,10,50,50);\n \n     //存储时间数据\n     var data = [];\n     //存储运动的小球\n     var balls = [];\n     //设置粒子半径\n     var R = canvas.height/20-1;\n     (function(){\n         var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n         //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成\n         data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n     })();\n \n     /*生成点阵数字*/\n     function renderDigit(index,num){\n         for(var i = 0; i < digit[num].length; i++){\n             for(var j = 0; j < digit[num][i].length; j++){\n                 if(digit[num][i][j] == 1){\n                     cxt.beginPath();\n                     //cxt.fillStyle = '#f00';/*红色数字*/\n                     //cxt.fillStyle = '#fff';/*白色数字*/\n                     cxt.fillStyle = '#FAF0BB';/*代码黄数字*/\n                     cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);\n                     cxt.closePath();\n                     cxt.fill();\n                 }\n             }\n         }\n     }\n \n     /*更新时钟*/\n     function updateDigitTime(){\n         var changeNumArray = [];\n         var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n         var NewData = [];\n         NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n         for(var i = data.length-1; i >=0 ; i--){\n             //时间发生变化\n             if(NewData[i] !== data[i]){\n                 //将变化的数字值和在data数组中的索引存储在changeNumArray数组中\n                 changeNumArray.push(i+'_'+(Number(data[i])+1)%10);\n             }\n         }\n         //增加小球\n         for(var i = 0; i< changeNumArray.length; i++){\n             addBalls.apply(this,changeNumArray[i].split('_'));\n         }\n         data = NewData.concat();\n     }\n \n     /*更新小球状态*/\n     function updateBalls(){\n         for(var i = 0; i < balls.length; i++){\n             balls[i].stepY += balls[i].disY;\n             balls[i].x += balls[i].stepX;\n             balls[i].y += balls[i].stepY;\n             if(balls[i].x > W + R || balls[i].y > H + R){\n                 balls.splice(i,1);\n                 i--;\n             }\n         }\n     }\n \n     /*增加要运动的小球*/\n     function addBalls(index,num){\n         var numArray = [1,2,3];\n         var colorArray =  [\"#3BE\",\"#09C\",\"#A6C\",\"#93C\",\"#9C0\",\"#690\",\"#FB3\",\"#F80\",\"#F44\",\"#C00\"];\n         for(var i = 0; i < digit[num].length; i++){\n             for(var j = 0; j < digit[num][i].length; j++){\n                 if(digit[num][i][j] == 1){\n                     var ball = {\n                         x:14*(R+2)*index + j*2*(R+1)+(R+1),\n                         y:i*2*(R+1)+(R+1),\n                         stepX:Math.floor(Math.random() * 4 -2),\n                         stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],\n                         color:colorArray[Math.floor(Math.random()*colorArray.length)],\n                         disY:1\n                     };\n                     balls.push(ball);\n                 }\n             }\n         }\n     }\n \n     /*渲染*/\n     function render(){\n         //重置画布宽度，达到清空画布的效果\n         canvas.height = 100;\n         //渲染时钟\n         for(var i = 0; i < data.length; i++){\n             renderDigit(i,data[i]);\n         }\n         //渲染小球\n         for(var i = 0; i < balls.length; i++){\n             cxt.beginPath();\n             cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);\n             cxt.fillStyle = balls[i].color;\n             cxt.closePath();\n             cxt.fill();\n         }\n     }\n \n     clearInterval(oTimer);\n     var oTimer = setInterval(function(){\n         //更新时钟\n         updateDigitTime();\n         //更新小球状态\n         updateBalls();\n         //渲染\n         render();\n     },50);\n }\n \n })();"},{"url":"/js/src/word.js","content":"var binft =function (r) {function t() {return b[Math.floor(Math.random() *b.length)]\n}\nfunction e() {return String.fromCharCode(94 *Math.random() + 33)\n}\nfunction n(r) {for (var n =document.createDocumentFragment(),i =0;r >i;i++) {var l =document.createElement(\"span\");l.textContent =e(),l.style.color =t(),n.appendChild(l)\n}\nreturn n\n}\nfunction i() {var t =o[c.skillI];c.step ?c.step-- :(c.step =g,c.prefixP < l.length ?(c.prefixP >=0 &&(c.text +=l[c.prefixP]),c.prefixP++) :\"forward\" ===c.direction ?c.skillP < t.length ?(c.text +=t[c.skillP],c.skillP++) :c.delay ?c.delay-- :(c.direction =\"backward\",c.delay =a) :c.skillP >0 ?(c.text =c.text.slice(0,-1),c.skillP--) :(c.skillI =(c.skillI + 1) % o.length,c.direction =\"forward\")),r.textContent =c.text,r.appendChild(n(c.prefixP < l.length ?Math.min(s,s + c.prefixP) :Math.min(s,t.length - c.skillP))),setTimeout(i,d)\n}\nvar l =\"\",o =[\"山有木兮木有枝，心悦君兮君不知。\",\"人生若只如初见，何事秋风悲画扇。\",\"十年生死两茫茫，不思量，自难忘。\",\"曾经沧海难为水，除却巫山不是云。\",\"洛中何郁郁，冠带自相索。\",\"只愿君心似我心，定不负相思意。\",\"愿得一心人，白头不相离。\",\"入我相思门，知我相思苦。\"].map(function (r) {return r + \"\"\n}),a =2,g =1,s =5,d =75,b =[\"rgb(110,64,170)\",\"rgb(150,61,179)\",\"rgb(191,60,175)\",\"rgb(228,65,157)\",\"rgb(254,75,131)\",\"rgb(255,94,99)\",\"rgb(255,120,71)\",\"rgb(251,150,51)\",\"rgb(226,183,47)\",\"rgb(198,214,60)\",\"rgb(175,240,91)\",\"rgb(127,246,88)\",\"rgb(82,246,103)\",\"rgb(48,239,130)\",\"rgb(29,223,163)\",\"rgb(26,199,194)\",\"rgb(35,171,216)\",\"rgb(54,140,225)\",\"rgb(76,110,219)\",\"rgb(96,84,200)\"],c ={text:\"\",prefixP:-s,skillI:0,skillP:0,direction:\"forward\",delay:a,step:g\n};i()\n};binft(document.getElementById('binft'));"},{"url":"/js/tw_cn.js","content":"var defaultEncoding = 2; // 网站默认语言，1: 繁體中文, 2: 简体中文\nvar translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0\nvar cookieDomain = \"https://tding.top/\"; //更改为你的博客网址\nvar msgToTraditionalChinese = \"繁體\"; //此处可以更改为你想要显示的文字\nvar msgToSimplifiedChinese = \"简体\"; //同上，但两处均不建议更改\nvar translateButtonId = \"translateLink\"; //默认互换id\nvar currentEncoding = defaultEncoding;\nvar targetEncodingCookie = \"targetEncoding\" + cookieDomain.replace(/\\./g, \"\");\nvar targetEncoding = (getCookie(targetEncodingCookie) == null ? defaultEncoding: getCookie(targetEncodingCookie));\nvar translateButtonObject;\nfunction translateText(txt) {\n\tif (txt == \"\" || txt == null) return \"\";\n\tif (currentEncoding == 1 && targetEncoding == 2) return Simplized(txt);\n\telse if (currentEncoding == 2 && targetEncoding == 1) return Traditionalized(txt);\n\telse return txt\n}\nfunction translateBody(fobj) {\n\tif (typeof(fobj) == \"object\") var objs = fobj.childNodes;\n\telse var objs = document.body.childNodes;\n\tfor (var i = 0; i < objs.length; i++) {\n\t\tvar obj = objs.item(i);\n\t\tif (\"||BR|HR|TEXTAREA|\".indexOf(\"|\" + obj.tagName + \"|\") > 0 || obj == translateButtonObject) continue;\n\t\tif (obj.title != \"\" && obj.title != null) obj.title = translateText(obj.title);\n\t\tif (obj.alt != \"\" && obj.alt != null) obj.alt = translateText(obj.alt);\n\t\tif (obj.tagName == \"INPUT\" && obj.value != \"\" && obj.type != \"text\" && obj.type != \"hidden\") obj.value = translateText(obj.value);\n\t\tif (obj.nodeType == 3) obj.data = translateText(obj.data);\n\t\telse translateBody(obj)\n\t}\n}\nfunction translatePage() {\n\tif (targetEncoding == 1) {\n\t\tcurrentEncoding = 1;\n\t\ttargetEncoding = 2;\n\t\ttranslateButtonObject.innerHTML = msgToTraditionalChinese;\n\t\tsetCookie(targetEncodingCookie, targetEncoding, 7);\n\t\ttranslateBody()\n\t} else if (targetEncoding == 2) {\n\t\tcurrentEncoding = 2;\n\t\ttargetEncoding = 1;\n\t\ttranslateButtonObject.innerHTML = msgToSimplifiedChinese;\n\t\tsetCookie(targetEncodingCookie, targetEncoding, 7);\n\t\ttranslateBody()\n\t}\n}\nfunction JTPYStr() {\n\treturn '万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾鼋鼌鼍鼗鼹齄齐齑齿龀龁龂龃龄龅龆龇龈龉龊龋龌龙龚龛龟志制咨只里系范松没尝尝闹面准钟别闲干尽脏拼'\n}\nfunction FTPYStr() {\n\treturn '萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽黿鼂鼉鞀鼴齇齊齏齒齔齕齗齟齡齙齠齜齦齬齪齲齷龍龔龕龜誌製谘隻裡係範鬆冇嚐嘗鬨麵準鐘彆閒乾儘臟拚'\n}\nfunction Traditionalized(cc) {\n\tvar str = '';\n\tvar ss = JTPYStr();\n\tvar tt = FTPYStr();\n\tfor (var i = 0; i < cc.length; i++) {\n\t\tif (cc.charCodeAt(i) > 10000 && ss.indexOf(cc.charAt(i)) != -1) str += tt.charAt(ss.indexOf(cc.charAt(i)));\n\t\telse str += cc.charAt(i)\n\t}\n\treturn str\n}\nfunction Simplized(cc) {\n\tvar str = '';\n\tvar ss = JTPYStr();\n\tvar tt = FTPYStr();\n\tfor (var i = 0; i < cc.length; i++) {\n\t\tif (cc.charCodeAt(i) > 10000 && tt.indexOf(cc.charAt(i)) != -1) str += ss.charAt(tt.indexOf(cc.charAt(i)));\n\t\telse str += cc.charAt(i)\n\t}\n\treturn str\n}\nfunction setCookie(name, value, days) {\n\tif (days) {\n\t\tvar date = new Date();\n\t\tdate.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n\t\tvar expires = \"; expires=\" + date.toGMTString()\n\t} else var expires = \"\";\n\tdocument.cookie = name + \"=\" + value + expires + \"; path=/\"\n}\nfunction getCookie(name) {\n\tvar nameEQ = name + \"=\";\n\tvar ca = document.cookie.split(';');\n\tfor (var i = 0; i < ca.length; i++) {\n\t\tvar c = ca[i];\n\t\twhile (c.charAt(0) == ' ') c = c.substring(1, c.length);\n\t\tif (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length)\n\t}\n\treturn null\n}\nfunction translateInitilization() {\n\ttranslateButtonObject = document.getElementById(translateButtonId);\n\tif (translateButtonObject) {\n\t\twith(translateButtonObject) {\n\t\t\tif (typeof(document.all) != \"object\") {\n\t\t\t\thref = \"javascript:translatePage();\"\n\t\t\t} else {\n\t\t\t\thref = \"#\";\n\t\t\t\tonclick = new Function(\"translatePage(); return false;\")\n\t\t\t}\n\t\t}\n\t\tif (currentEncoding != targetEncoding) {\n\t\t\tsetTimeout(\"translateBody()\", translateDelay);\n\t\t\tif (targetEncoding == 1) translateButtonObject.innerHTML = msgToSimplifiedChinese;\n\t\t\telse translateButtonObject.innerHTML = msgToTraditionalChinese\n\t\t}\n\t}\n}\n"}]