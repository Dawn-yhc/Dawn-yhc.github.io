<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曙光苑</title>
  
  <subtitle>有朋自远方来，不亦乐乎</subtitle>
  <link href="https://yuhaicheng.xyz/atom.xml" rel="self"/>
  
  <link href="https://yuhaicheng.xyz/"/>
  <updated>2020-12-17T08:05:14.000Z</updated>
  <id>https://yuhaicheng.xyz/</id>
  
  <author>
    <name>Dawn-yhc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSM中的过滤器和拦截器</title>
    <link href="https://yuhaicheng.xyz/2020-11-13-SSM%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
    <id>https://yuhaicheng.xyz/2020-11-13-SSM%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.html</id>
    <published>2020-11-17T07:05:14.000Z</published>
    <updated>2020-12-17T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器-Filter-和拦截器-Interceptor"><a href="#过滤器-Filter-和拦截器-Interceptor" class="headerlink" title="过滤器(Filter)和拦截器(Interceptor)"></a>过滤器(Filter)和拦截器(Interceptor)</h3><p>过滤器(Filter)和拦截器(Interceptor)都是可以作用于若干种不同的请求路径的组件，都可以对某种请求进行阻止，不允许继续向后执行，也可以选择放行，按照原本设定的处理流程继续执行！并且，在同一个项目中，允许同时存在若干个过滤器或拦截器，以形成过滤器链或拦截器链，如果某个请求涉及多个过滤器或拦截器，必须每个过滤器或拦截器都放行，才可以继续执行！</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>过滤器是Java EE中的组件，而拦截器是SpringMVC中的组件！只要是Java EE(web)项目，都可以使用过滤器，但是，只有使用了SpringMVC框架，才可以使用拦截器，并且，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！</li><li>过滤器和拦截器的执行时间节点、执行的方法的数量都不相同，过滤器是在所有Servlet组件之前执行的！而拦截器的第1次执行是在DispatcherServlet之后，且在Controller组件之前执行的，而且，当拦截器选择“放行”时，在Controller执行之后，和执行最终的响应之前，还会各执行1次！</li><li>过滤器和拦截器的配置也不相同，过滤器是在<strong>web.xml</strong>中配置的，在配置过程中，可以配置若干个请求路径，也可以使用星号(*)作为通配符，但是，无法配置例外路径（白名单），而拦截器是在Spring的配置文件中进行配置的，其配置方式非常灵活，可以配置若干个请求路径，也可以使用通配符，还可以配置若干个例外路径！</li></ol><p>在一般情况下，我们更关注项目的管理，由于过滤器和拦截器都会出现在真正处理请求的组件之前，所以，都可以实现“阻止”和“放行”的效果，那么，哪个简单、易用、功能更强大，就使用哪个！所以，更优先推荐使用拦截器解决项目中的问题！但是，这也并不代表拦截器就可以完全取代过滤器，例如，某些处理过程应该出现在更早的执行时间节点，就必须使用过滤器，而不能使用拦截器！</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p><p>过滤器</p><ul><li>servlet规范中的一部分，任何java web工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对<strong>所有要访问的资源</strong>进行拦截</li></ul><p>拦截器</p><ul><li>拦截器是springMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器只会<strong>拦截访问的控制器方法</strong>，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！，如果访问的是jsp/html/css/image/js是不会进行拦截</li></ul>]]></content>
    
    
    <summary type="html">过滤器和拦截器的区别</summary>
    
    
    
    <category term="SSM" scheme="https://yuhaicheng.xyz/categories/SSM/"/>
    
    
    <category term="SSM框架" scheme="https://yuhaicheng.xyz/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>http status 301/302 &amp; java重定向/转发</title>
    <link href="https://yuhaicheng.xyz/2020-11-17-http-status-301302-&amp;-java%E9%87%8D%E5%AE%9A%E5%90%91%E8%BD%AC%E5%8F%91.html"/>
    <id>https://yuhaicheng.xyz/2020-11-17-http-status-301302-&amp;-java%E9%87%8D%E5%AE%9A%E5%90%91%E8%BD%AC%E5%8F%91.html</id>
    <published>2020-11-17T07:05:14.000Z</published>
    <updated>2020-12-17T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、301-302"><a href="#一、301-302" class="headerlink" title="一、301/302"></a><strong>一、301/302</strong></h2><h3 id="1、什么是301转向-什么是301重定向"><a href="#1、什么是301转向-什么是301重定向" class="headerlink" title="1、什么是301转向?什么是301重定向?"></a>1、什么是301转向?什么是301重定向?</h3><p>　　301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p><h3 id="2、什么是302重定向"><a href="#2、什么是302重定向" class="headerlink" title="2、什么是302重定向?"></a>2、什么是302重定向?</h3><p>　　302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向(temporary redirect)，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服 务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</p><h3 id="3、301重定向与302重定向的区别"><a href="#3、301重定向与302重定向的区别" class="headerlink" title="3、301重定向与302重定向的区别"></a>3、301重定向与302重定向的区别</h3><p>　　302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p><p>　　301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p><h3 id="4、为什么302-重定向和网址劫持有关联"><a href="#4、为什么302-重定向和网址劫持有关联" class="headerlink" title="4、为什么302 重定向和网址劫持有关联"></a>4、为什么302 重定向和网址劫持有关联</h3><p>　　从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A 随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302 重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL 劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</p><p>　　比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p><p>　　302 重定向所造成的网址URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p><h2 id="二、重定向-转发"><a href="#二、重定向-转发" class="headerlink" title="二、重定向/转发"></a><strong>二、重定向/转发</strong></h2><h3 id="1、什么是重定向"><a href="#1、什么是重定向" class="headerlink" title="1、什么是重定向?"></a>1、什么是重定向?</h3><p>​      服务器向浏览器发送一个302状态码及一个Location消息头(该消息头的值是一个地址)。浏览器在收到之后，会立即向这个地址发送请求。</p><p>如果是按照通俗一点的按照流程里说就是这样：发送请求 --&gt;服务器处理请求--&gt;响应请求，返回给浏览器一个新的地址与响应码（302状态 码）--&gt;浏览器根据响应码（302状态码），判定该响应为重定向，自动发送一个新的请求给服务器，请求地址为之前返回的地址--&gt;服务器运 行--&gt;响应请求给浏览器</p><p>在编程的时候怎么写：</p><p> response.sendRedirect(String url);很简单的一句代码就行了。但是有两个问题是要注意的：</p><ul><li>①重定向之前，不能够有任何的输出，否则会发生错误。</li><li>②重定向之前，会先清空response中缓存的数据。 </li></ul><p>特点是：</p><ul><li>①重定向的地址是任意的。</li><li>②重定向之后，浏览器地址栏的地址会变成Location所指定的地址。</li></ul><h3 id="2、什么是转发"><a href="#2、什么是转发" class="headerlink" title="2、什么是转发?"></a>2、什么是转发?</h3><p>​    一个web组件(servlet/jsp) 将未完成的处理交给另外一个web组件继续完成。</p><p>​    一般应用的场合：一个servlet处理请求之后，将处理结果交给一个jsp，让jsp依据处理结果生成相应的界面。如果是按照通俗一点的按照流程里说就是这样：发送请求 --&gt;服务器处理请求--&gt;进行请求的重新设置，例如通过 request.setAttribute(name,value)--&gt;根据转发的地址，获取该地址的jsp网页--&gt;响应请求给浏览器。<br>编程的时候怎么写？这个比重定向要复杂一点：</p><p>① 将处理结果绑订定到request对象上。request.setAttribute(String name,Object obj);//如果name对应的值不存在，则返回null。Object request.getAttribute(String name);request.removeAttribute(String name);</p><p>② 获得转发器</p><p>//uri:是要转发的目的地，目的地只能是同一个应用的内部。RequestDispatcher rd = request.getRequestDispatcher(String uri);</p><p>③ 转发</p><p>rd.forward(request,response);需要注意的是：转发之前，不要有任何的刷新操作，否则会出错。转发之前，如果response当中缓存有数据，会先清空。</p><p><strong>转发的特点</strong></p><p>① 转发的目的地只能是同一个应用内部的各个组件之间。</p><p>② 转发之后，浏览器地址栏的地址不会变。</p><p>综合上面解说：总结下重定向和转发的区别：</p><p>区别①：</p><p>重定向时，浏览器上的网址改变</p><p>转发时，浏览器上的网址不变</p><p>区别②：</p><p>重定向实际上产生了两次请求</p><p>转发只有一次请求</p><p>区别③：</p><p>重定向的时候网址可以是任何的网址</p><p>转发的网址只能是本站点的网址</p><p>根据上面的分析，所以说，用重定向和转发不是一个习惯不习惯的问题，而是在什么情况下必须用的问题。</p>]]></content>
    
    
    <summary type="html">过滤器和拦截器的区别</summary>
    
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/categories/java/"/>
    
    
    <category term="重定向/转发" scheme="https://yuhaicheng.xyz/tags/%E9%87%8D%E5%AE%9A%E5%90%91-%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-12-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-12-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-12T07:05:14.000Z</published>
    <updated>2020-12-17T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原理：</strong>希尔排序法就是将一组无序的数据分割成若干个小的子序列分别进行插入排序的方法。因此希尔排序首先要选定一个增量值作为分组的依据，通过增量值的间隔来得到不同的插入排序组，然后对每一组的数据进行插入排序，但增量值要不断地进行递减才能达到排序的目的。</p><p><strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><p><strong>说明：</strong>希尔排序法的本质是插入排序法，通过递减增量值的方式使得排序变得更加高效，因此希尔排序法也可以叫做缩小增量法。</p><ul><li><strong>时间复杂度：</strong>O(nlogn)</li><li><strong>空间复杂度：</strong>O(1)</li><li><strong>稳定性：</strong>不稳定</li><li><strong>排序位置：</strong>原地排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> h = data.length/<span class="number">2</span>;<span class="comment">//每次的最大的增量是数组长度的一半，一直到1后排序完成并结束       </span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; data.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - h; j &gt;= <span class="number">0</span>; j -= h) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (data[j] &gt; data[i]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = data[i];</span><br><span class="line">                        data[i] = data[j];</span><br><span class="line">                        data[j] = temp;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;h等于&quot;</span>+h+<span class="string">&quot;排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">            h /= <span class="number">2</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">Demo_Sort.shellSorting(data);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line">排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">h等于<span class="number">5</span>排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>]</span><br><span class="line">h等于<span class="number">2</span>排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">h等于<span class="number">1</span>排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">排序后[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高级排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高级排序" scheme="https://yuhaicheng.xyz/tags/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-12-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-12-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-12T07:05:14.000Z</published>
    <updated>2020-12-17T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原理：</strong>进行归并排序法时首先将一组数据尽可能的拆分成两个个数均等的子组，然后对两个子组继续进行拆分，直到将每个子组的元素个数拆分到1为止，然后开始对相邻的两个子组进行归并，重复归并操作直至所有子组归并为一组时排序完成。</p><p><strong>说明：</strong>归并排序法就是将一组数据先进行连续的拆分后再进行连续的归并，类似于快速排序法也是一种“分治法”的体现。</p><ul><li><strong>时间复杂度：</strong>O(nlogn)</li><li><strong>空间复杂度：</strong>O(n)</li><li><strong>稳定性：</strong>稳定</li><li><strong>排序位置：</strong>非原地排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSorting</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assist = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = data.length - <span class="number">1</span>;</span><br><span class="line">        sort(data, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] assist;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low     指向数组第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high      指向数组最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid =(high + low) / <span class="number">2</span>; <span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">        sort(data, low, mid);<span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">        sort(data, mid + <span class="number">1</span>, high); <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">        merge(data, low, mid, high);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[p1] &gt; data[p2]) &#123;</span><br><span class="line">                assist[i++] = data[p2++];                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assist[i++] = data[p1++];               </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            assist[i++] = data[p1++];           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= high) &#123;</span><br><span class="line">            assist[i++] = data[p2++];            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖原data数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = low; index &lt;= high; index++) &#123;</span><br><span class="line">        data[index] = assist[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">Demo_Sort.mergeSorting(data);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">排序后[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]    </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高级排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高级排序" scheme="https://yuhaicheng.xyz/tags/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-13-%E5%A0%86%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-13-%E5%A0%86%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-12T07:05:14.000Z</published>
    <updated>2020-12-17T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>原理：</strong>堆排序法顾名思义采用了堆的数据结构来进行排序。堆排序法就是把堆顶的元素与最后一个元素交换，因为交换后破坏了堆的特性，因此需要把堆中剩余的元素重建成一个满足堆的性质的堆，然后再把堆顶的元素与倒数第二个元素交换，再次进行堆的重建，以此类推直至堆中仅剩最后一个元素排序完成</p><ul><li><strong>时间复杂度：</strong>O(nlogn)</li><li><strong>空间复杂度：</strong>O(1)</li><li><strong>稳定性：</strong>不稳定</li><li><strong>排序位置：</strong>原地排序</li></ul><p><strong>堆：</strong>因为堆顶的元素是一个最值，当堆是大顶堆时堆顶就是最大值，采用堆排序法时可将数据进行升序排列；若堆为小顶堆则堆顶就是最小值，采用堆排序法时可将数据进行降序排列。</p><ul><li>堆中节点的值总是大于或小于其父节点的值</li><li>堆总是一棵完全二叉树</li></ul><p><strong>堆的数组实现：</strong></p><ul><li>下标为i的节点的父节点下标为：(i-1)/2</li><li>下标为i的节点的左孩子下标为：i*2+1</li><li>下标为i的节点的右孩子下标为：i*2+2</li></ul><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p><img data-src="https://i.loli.net/2020/11/13/Zf13XhilSju7T5y.png" alt="堆" loading="lazy"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = data.length;</span><br><span class="line">        <span class="comment">//创建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子节点从下到上，从右到左调整结构</span></span><br><span class="line">            standardization(data, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">            <span class="keyword">int</span> temp = data[<span class="number">0</span>];</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = temp;</span><br><span class="line">            <span class="comment">//重新对堆进行调整,因为第一次已经调成大顶堆了，所以在调只需要在1、2中找一个最大的</span></span><br><span class="line">            standardization(data, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">standardization</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        <span class="keyword">int</span> leftSon = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSon = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftSon &lt; n &amp;&amp; data[leftSon] &gt; data[largest]) &#123;</span><br><span class="line">            largest = leftSon;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightSon &lt; n &amp;&amp; data[rightSon] &gt; data[largest]) &#123;</span><br><span class="line">            largest = rightSon;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            data[i] = data[largest];</span><br><span class="line">            data[largest] = temp;</span><br><span class="line">            <span class="comment">//保证下一层也是大顶堆的情况</span></span><br><span class="line">            standardization(data, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">Demo_Sort.heapSort(data);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">排序后[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高级排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高级排序" scheme="https://yuhaicheng.xyz/tags/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-12-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-12-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-12T06:05:14.000Z</published>
    <updated>2020-11-12T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原理：</strong>快速排序法就是通过一次排序将待排序的一组数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程采用递归的方式进行，以此达到所有数据变成有序的序列。</p><p><strong>说明：</strong>快速排序是一种“分治法”的体现，将原本的问题进行拆分成两个子问题，然后再分别的去解决这两个子问题，达到“分而治之”的效果。 </p><ul><li><strong>时间复杂度：</strong>O(nlogn)</li><li><strong>空间复杂度：</strong>O(logn)</li><li><strong>稳定性：</strong>不稳定</li><li><strong>排序位置：</strong>原地排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,temp,t;</span><br><span class="line"><span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">i=low;</span><br><span class="line">j=high;</span><br><span class="line">temp=data[low];<span class="comment">//选中的基准数  选左面第一位为基准数 一定要从右面先动</span></span><br><span class="line">System.out.println(<span class="string">&quot;基准位&quot;</span>+temp);</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="comment">//先看右边</span></span><br><span class="line"><span class="keyword">while</span>(temp&lt;=data[j] &amp;&amp; i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后看左边</span></span><br><span class="line"><span class="keyword">while</span>(temp&gt;=data[i] &amp;&amp; i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果满足条件则交换</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;交换数据:&quot;</span>+data[i]+<span class="string">&quot;和&quot;</span>+data[j]);</span><br><span class="line">t=data[j];</span><br><span class="line">data[j]=data[i];</span><br><span class="line">data[i]=t;</span><br><span class="line">System.out.println(java.util.Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后将基准位与i和j相等的位置交换</span></span><br><span class="line">System.out.println(<span class="string">&quot;基准位&quot;</span>+temp+<span class="string">&quot;和i、j相遇的位置&quot;</span>+data[i]+<span class="string">&quot;交换&quot;</span>);</span><br><span class="line">data[low]=data[i];</span><br><span class="line">data[i]=temp;</span><br><span class="line">System.out.println(java.util.Arrays.toString(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归调用左半边数组</span></span><br><span class="line">quickSort(data, low, j-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//递归调用右半边数组</span></span><br><span class="line">quickSort(data, j+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">9</span>&#125;;</span><br><span class="line">demo1_01 d =<span class="keyword">new</span> demo1_01();</span><br><span class="line">System.out.println(<span class="string">&quot;排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">d.quickSort(data, <span class="number">0</span>, data.length-<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;排序后&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">&#125;</span><br><span class="line">排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>]</span><br><span class="line">基准位<span class="number">36</span></span><br><span class="line">交换数据:<span class="number">55</span>和<span class="number">9</span></span><br><span class="line">[<span class="number">36</span>, <span class="number">22</span>, <span class="number">9</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">55</span>]</span><br><span class="line">交换数据:<span class="number">66</span>和<span class="number">18</span></span><br><span class="line">[<span class="number">36</span>, <span class="number">22</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">36</span>和i、j相遇的位置<span class="number">6</span>交换</span><br><span class="line">[<span class="number">6</span>, <span class="number">22</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">6</span></span><br><span class="line">交换数据:<span class="number">22</span>和<span class="number">4</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">6</span>和i、j相遇的位置<span class="number">4</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">4</span></span><br><span class="line">基准位<span class="number">4</span>和i、j相遇的位置<span class="number">4</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">9</span></span><br><span class="line">基准位<span class="number">9</span>和i、j相遇的位置<span class="number">9</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">18</span></span><br><span class="line">基准位<span class="number">18</span>和i、j相遇的位置<span class="number">18</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">31</span></span><br><span class="line">基准位<span class="number">31</span>和i、j相遇的位置<span class="number">22</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">22</span></span><br><span class="line">基准位<span class="number">22</span>和i、j相遇的位置<span class="number">22</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>]</span><br><span class="line">基准位<span class="number">66</span></span><br><span class="line">基准位<span class="number">66</span>和i、j相遇的位置<span class="number">55</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">基准位<span class="number">55</span></span><br><span class="line">基准位<span class="number">55</span>和i、j相遇的位置<span class="number">55</span>交换</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">排序后[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高级排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高级排序" scheme="https://yuhaicheng.xyz/tags/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-11-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-11-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-11T06:05:14.000Z</published>
    <updated>2020-11-07T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>原理：</strong>插入排序法就是先选定一个待插入的元素，然后将待插入的元素插入到已经有序的一组数据中。当开始进行遍历时，待插入的元素会和前一个元素进行比较，如果前一个元素大于待插入的元素，就会进行交换元素位置或进行位置移动，直到遇到前一个元素小于当前元素，才会结束当前遍历。继续选定待插入元素继续遍历，当所有待插入元素都已经插入到有序的序列中时排序完成。</p><p><strong>得名：</strong>因为每一次都是将待插入元素插入到一个有序的一组数据中，故得名插入排序法。</p><ul><li><strong>时间复杂度：</strong>O(n²)</li><li><strong>空间复杂度：</strong>O(1)</li><li><strong>稳定性：</strong>稳定</li><li><strong>排序位置：</strong>原地排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[j - <span class="number">1</span>] &gt; data[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = data[j];</span><br><span class="line">                    data[j] = data[j - <span class="number">1</span>];</span><br><span class="line">                    data[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">demo1_01 d =<span class="keyword">new</span> demo1_01();</span><br><span class="line">System.out.println(<span class="string">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">d.insertSorting(data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">    System.out.print(data[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">没排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">1</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">31</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">4</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">4</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">22</span>, <span class="number">4</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">22</span> <span class="number">31</span> <span class="number">36</span> <span class="number">55</span> <span class="number">66</span> <span class="number">77</span> <span class="number">88</span> <span class="number">99</span> </span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> []data)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">int</span> cur=data[i+<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">int</span> per =i;</span><br><span class="line">       <span class="keyword">while</span>(per &gt;=<span class="number">0</span> &amp;&amp; data[per]&gt;cur)&#123;</span><br><span class="line">       data[per+<span class="number">1</span>]=data[per];</span><br><span class="line">       per--;</span><br><span class="line">       &#125;</span><br><span class="line">       data[per+<span class="number">1</span>]= cur;</span><br><span class="line">       System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">没排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">0</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">1</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">2</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">3</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">6</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">7</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">22</span> <span class="number">31</span> <span class="number">36</span> <span class="number">55</span> <span class="number">66</span> <span class="number">77</span> <span class="number">88</span> <span class="number">99</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基础排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="简单排序" scheme="https://yuhaicheng.xyz/tags/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-11-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-11-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-11T04:05:14.000Z</published>
    <updated>2020-11-07T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>原理：</strong>选择排序法就是在遍历一组数据之前先选择一个元素，如果后面的元素小于选择的元素，则将后面的元素与选择的元素进行交换，直到遍历到最后一个元素，这样经过一次遍历后就会得到这组数据的最小的元素也就是有序数据的第一个元素。按照这样的方式继续选择元素继续遍历，直到遍历到这组数据完全有序。</p><p><strong>得名：</strong>因为每一次遍历前都要选择一个元素作为基准，跟后面的元素进行比较后交换元素位置，故得名选择排序法。</p><ul><li><strong>时间复杂度：</strong>O(n²)</li><li><strong>空间复杂度：</strong>O(1)</li><li><strong>稳定性：</strong>不稳定</li><li><strong>排序位置：</strong>原地排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> data[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> &amp;&amp; data.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;data.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;data[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=data[i];</span><br><span class="line">                data[i]=data[j];</span><br><span class="line">                data[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">demo1_01 d =<span class="keyword">new</span> demo1_01();</span><br><span class="line">System.out.println(<span class="string">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">d.selectSort(data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">    System.out.print(data[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">没排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">0</span>次排序[<span class="number">4</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">1</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">2</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">66</span>, <span class="number">55</span>, <span class="number">36</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">3</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">66</span>, <span class="number">55</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">6</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">7</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">22</span> <span class="number">31</span> <span class="number">36</span> <span class="number">55</span> <span class="number">66</span> <span class="number">77</span> <span class="number">88</span> <span class="number">99</span> </span><br></pre></td></tr></table></figure><p><strong>优化：</strong>在排序过程中可能会出现这种情况，当我们进行一趟排序的过程中找到的最小数字就是当前需要交换的位置，也就是说当前位置就是当躺最小的值，就不需要在比较了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort1</span><span class="params">(<span class="keyword">int</span> []data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(data==<span class="keyword">null</span> &amp;&amp; data.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">int</span> selectminindex=i;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;data.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[j]&lt;data[selectminindex])&#123;</span><br><span class="line">            selectminindex=j;</span><br><span class="line">                    &#125; </span><br><span class="line">               &#125;</span><br><span class="line">       <span class="keyword">if</span>(selectminindex!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=data[i];</span><br><span class="line">            data[i]=data[selectminindex];</span><br><span class="line">            data[selectminindex]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">第<span class="number">0</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">1</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">2</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">66</span>, <span class="number">55</span>, <span class="number">36</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">3</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">6</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">第<span class="number">7</span>次排序[<span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">22</span> <span class="number">31</span> <span class="number">36</span> <span class="number">55</span> <span class="number">66</span> <span class="number">77</span> <span class="number">88</span> <span class="number">99</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基础排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="简单排序" scheme="https://yuhaicheng.xyz/tags/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://yuhaicheng.xyz/2020-11-11-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-11-11-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-11-11T02:05:14.000Z</published>
    <updated>2020-11-07T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>原理：</strong>冒泡排序法是对一组数据进行两两比较，也就是说第一个元素和第二个元素进行比较，如果第一个元素大于第二个元素，两个元素就交换位置，然后第二个元素再和第三个元素进行比较、交换位置，以此类推到倒数第二个元素结束和倒数第一个元素比较交换。这样经过一次遍历就会得到一组数据中的最大元素，然后再进行一组遍历又会得到剩下元素中最大的元素，直到遍历到排序完成。</p><p><strong>得名：</strong>因为每一次遍历都是从第一个元素开始，中间可能会进行多次两两交换，直到遍历结束获得最大的元素。将元素形象的比作气泡，交换到最后的元素就是这组数据中的最大元素也就是最后浮出水面的气泡，因此得名冒泡排序法。</p><ul><li><strong>时间复杂度（平均）：</strong>O(n²) ；最好O(n²)，最差O(n²)</li><li><strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTklQkElRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYvOTY2NDI1Nz9mcj1hbGFkZGlu">空间复杂度<i class="fa fa-external-link-alt"></i></span>：</strong>O(1)</li><li><strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlOTIlRTUlQkElOEYlRTclQUUlOTclRTYlQjMlOTUlRTclQTglQjMlRTUlQUUlOUElRTYlODAlQTcvOTc2MzI1MA==">稳定性<i class="fa fa-external-link-alt"></i></span>：</strong>稳定</li><li><strong>排序位置：</strong>原地排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">publiv <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> data[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(data==<span class="keyword">null</span> &amp;&amp; data.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;data.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(data[j]&gt;data[j+<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">int</span> temp=data[j];</span><br><span class="line">               data[j]=data[j+<span class="number">1</span>];</span><br><span class="line">               data[j+<span class="number">1</span>]=temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>  data[]=&#123;<span class="number">36</span>,<span class="number">22</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">31</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">9</span>&#125;;</span><br><span class="line">demo1_01 d =<span class="keyword">new</span> demo1_01();</span><br><span class="line">System.out.println(<span class="string">&quot;没排序前&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">d.bubbleSort(data);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">    System.out.print(data[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">没排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">0</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">1</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">2</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">3</span>次排序[<span class="number">22</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">6</span>次排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">7</span>次排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">18</span> <span class="number">22</span> <span class="number">31</span> <span class="number">36</span> <span class="number">55</span> <span class="number">66</span> </span><br></pre></td></tr></table></figure><p><strong>优化：</strong>看上面的测试可知，在第5次排序时就已经排好序了，但是程序自己不知道，还会一层一层的比较。所以我们可以进行一下优化，设置一个标志位让程序知道什么时候已经排好序了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> []data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> &amp;&amp; data.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;data.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[j]&gt;data[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=data[j];</span><br><span class="line">                data[j]=data[j+<span class="number">1</span>];</span><br><span class="line">                data[j+<span class="number">1</span>]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">           <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>+java.util.Arrays.toString(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">没排序前[<span class="number">36</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">0</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">1</span>次排序[<span class="number">22</span>, <span class="number">36</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">2</span>次排序[<span class="number">22</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">3</span>次排序[<span class="number">22</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">4</span>次排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">第<span class="number">5</span>次排序[<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">36</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">18</span> <span class="number">22</span> <span class="number">31</span> <span class="number">36</span> <span class="number">55</span> <span class="number">66</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基础排序</summary>
    
    
    
    <category term="排序算法" scheme="https://yuhaicheng.xyz/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="简单排序" scheme="https://yuhaicheng.xyz/tags/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://yuhaicheng.xyz/2020-11-08-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html"/>
    <id>https://yuhaicheng.xyz/2020-11-08-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</id>
    <published>2020-11-07T02:05:14.000Z</published>
    <updated>2020-11-07T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在以下的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p><h3 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1.分配饼干"></a>1.分配饼干</h3><ol start="455"><li>Assign Cookies (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYXNzaWduLWNvb2tpZXMvZGVzY3JpcHRpb24v">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXNzaWduLWNvb2tpZXMvZGVzY3JpcHRpb24v">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：每个孩子都有一个满足度 g，每个饼干都有一个大小 s，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</p></li><li><p>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</p></li></ol><p>每个孩子的满足度和饼干的大小不是顺序排序的，所以首先我们要把这两个数组进行顺序排序，选择升序排序，因为我们要输出可以满足孩子的数量，所以要先满足满足度最小的孩子后，在满足比他大的，具体怎么比较呢：</p><p>因为我们不知道有多少个g、s，不知道循环次数，所以用while来判断s、g是否超出边界；每次第一个孩子满足度（最小的）和饼干大小（最小的）比较；第一种情况：g&lt;=s,记录满足孩子数量，进行第二个组g、s，相当于g、s +1；第二种情况：g&gt;s,不记录满足孩子数量，进行第二个组g、s+1比较，相当于g、s+1;总结来说s是一直要+1的，也就是说满不满足s都要+1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g==<span class="keyword">null</span> || s==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Array.sort(g);</span><br><span class="line">        Array.sort(s);</span><br><span class="line">        <span class="keyword">int</span> gi=<span class="number">0</span>;<span class="keyword">int</span> si=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(gi&lt;g.length &amp;&amp; si&lt;s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[gi]&lt;=s[si])&#123;</span><br><span class="line">                gi++;</span><br><span class="line">            &#125;</span><br><span class="line">            si++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不重叠的区间个数"><a href="#2-不重叠的区间个数" class="headerlink" title="2.不重叠的区间个数"></a>2.不重叠的区间个数</h3><ol start="435"><li>Non-overlapping Intervals (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p><ul><li>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</li><li>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</li><li>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析：进行二维数组中第二位数升序排序，输入: [ [1,2], [2,3], [3,4], [1,3] ]，排完序后是[ [1,2], [2,3], [1,3], [3,4] ]，把第一个结束校验的位置放到end = intervals[0][1],因为第一组区间一定存在，然后往后面判断不重复的区间，所以存在不重复区间cnt=1，默认第一个区间存在；如果end &gt; intervals[i][0]成立,说明第二组区间和第一组区间重合，跳出（continue），不计cnt，然后i+1，继续判断end &gt; intervals[i][0],如果不成立，cnt+1、更新end的值end=ntervals[i][1] 因为这个区间和上一个区间不重复，并且本区间中后面的数较大，所以end等于本区间最大值，i+1,一直到循环结束，用还数组长度-cnt=重复的区间数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//二维数组，第二个元素排序，另一个元素跟随</span></span><br><span class="line">        <span class="comment">//Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o[]));</span></span><br><span class="line">        <span class="comment">//二维数组，第一个元素排序 ，另一个元素跟随                          </span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; end )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">                end=intervals[i][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length-cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-投飞镖刺破气球"><a href="#3-投飞镖刺破气球" class="headerlink" title="3. 投飞镖刺破气球"></a>3. 投飞镖刺破气球</h3><ol start="452"><li>Minimum Number of Arrows to Burst Balloons (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1udW1iZXItb2YtYXJyb3dzLXRvLWJ1cnN0LWJhbGxvb25zL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1udW1iZXItb2YtYXJyb3dzLXRvLWJ1cnN0LWJhbGxvb25zL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p><p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：points = [[<span class="number">10</span>,<span class="number">16</span>],[<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：对于该样例，x = <span class="number">6</span> 可以射爆 [<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>] 两个气球，以及 x = <span class="number">11</span> 射爆另外两个气球</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">输入：points = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Array.sort(points,Comparator.comparingInt(o-&gt;o[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                end=points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-根据身高和序号重组队列"><a href="#4-根据身高和序号重组队列" class="headerlink" title="4.根据身高和序号重组队列"></a>4.根据身高和序号重组队列</h3><ol start="406"><li>Queue Reconstruction by Height(Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcXVldWUtcmVjb25zdHJ1Y3Rpb24tYnktaGVpZ2h0L2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcXVldWUtcmVjb25zdHJ1Y3Rpb24tYnktaGVpZ2h0L2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p><p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</p><p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[<span class="number">7</span>,<span class="number">0</span>], [<span class="number">4</span>,<span class="number">4</span>], [<span class="number">7</span>,<span class="number">1</span>], [<span class="number">5</span>,<span class="number">0</span>], [<span class="number">6</span>,<span class="number">1</span>], [<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[<span class="number">5</span>,<span class="number">0</span>], [<span class="number">7</span>,<span class="number">0</span>], [<span class="number">5</span>,<span class="number">2</span>], [<span class="number">6</span>,<span class="number">1</span>], [<span class="number">4</span>,<span class="number">4</span>], [<span class="number">7</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p> 解释：身高从高到低排序的好处是，对于前面已经排好的队</p><p>1.如果下一个人(h,k)比前面所有人都矮，那么，他插入队列的k处，使其达到k的要求，对其他人没影响，达到要求！</p><p> 2.如果下一个人跟之前排好队的人中最矮的身高一样，这时候，就体现为什么之前排序时候，先考虑身高，再按照k的升序了，这时候，新来的人虽然与之前最矮之人身高一样，但是由于他的k比之前最矮的人的k都大，所以，他插入的地方一定在已经排好队的，和他身高一样的，最矮之人的后面，对这些最矮人们没有影响，当然，对其他比他高的人就更没有影响了。</p><p>其只要了解一点：我们一个一个地排队，对于前面已经排好的队，如果我们在k的位置插入一个新人，那么对k之前的人没有任何影响，对于k之后比新人高的人也没有任何影响，因此，我们每插入一个人的时候，要么保证前面所有人都比新人高，要么至少保证插入的位置后面的所有人都比新人高。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="keyword">null</span> || people.length == <span class="number">0</span> || people[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 当第一维相等时比较第二维的</span></span><br><span class="line">    Arrays.sort(people, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>]));</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *for(元素类型t 元素变量x : 遍历对象obj)&#123; </span></span><br><span class="line"><span class="comment">    *引用了x的java语句; </span></span><br><span class="line"><span class="comment">*&#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : people) &#123;</span><br><span class="line">        queue.add(p[<span class="number">1</span>], p);<span class="comment">//因为之前的已经排过序了，所以直接插入自己的位置就可以了</span></span><br><span class="line">        <span class="comment">//相对于[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]经过h降序、k升序</span></span><br><span class="line">        <span class="comment">//-&gt; [[7,0], [7,1], [6,1],[5,0],[5,2]，[4,4],]</span></span><br><span class="line">        <span class="comment">//经过foreach后 p[1]= 0 1 1 0 2 4</span></span><br><span class="line">        <span class="comment">// [7,0], [7,1], [6,1], [5,0], [5,2], [4,4]</span></span><br><span class="line">        <span class="comment">// 再一个一个插入。</span></span><br><span class="line">        <span class="comment">// [7,0]</span></span><br><span class="line">        <span class="comment">// [7,0], [7,1]</span></span><br><span class="line">        <span class="comment">// [7,0], [6,1], [7,1]</span></span><br><span class="line">        <span class="comment">// [5,0], [7,0], [6,1], [7,1]</span></span><br><span class="line">        <span class="comment">// [5,0], [7,0], [5,2], [6,1], [7,1]</span></span><br><span class="line">        <span class="comment">// [5,0], [7,0], [5,2], [6,1], [4,4], [7,1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个数组，该数组按正确顺序（从第一个元素到最后一个元素）包含此列表中的所有元素。</span></span><br><span class="line">    <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[queue.size()][]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-买卖股票最大的收益"><a href="#5-买卖股票最大的收益" class="headerlink" title="5. 买卖股票最大的收益"></a>5. 买卖股票最大的收益</h3><ol start="121"><li>Best Time to Buy and Sell Stock (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p><p>解释：只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> minf=prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(minf&gt;prices[i])&#123;</span><br><span class="line">               minf=prices[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               max = Math.max(max,prices[i]-minf);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-买卖股票的最大收益-II"><a href="#6-买卖股票的最大收益-II" class="headerlink" title="6. 买卖股票的最大收益 II"></a>6. 买卖股票的最大收益 II</h3><ol start="122"><li>Best Time to Buy and Sell Stock II (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay1paS9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay1paS9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>解释：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此**当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0**，那么就把 prices[i] - prices[i-1] 添加到收益中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span> 。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if a&lt;=b&lt;=c&lt;=d</span></span><br><span class="line">    <span class="comment">//max=d-a</span></span><br><span class="line">    <span class="comment">//d-a=(d-c)+(c-b)+(b-a)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>])&#123;</span><br><span class="line">                sum+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-种植花朵"><a href="#7-种植花朵" class="headerlink" title="7. 种植花朵"></a>7. 种植花朵</h3><ol start="605"><li>Can Place Flowers (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMvZGVzY3JpcHRpb24v">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMvZGVzY3JpcHRpb24v">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。也就是flowerbed 数组中 1 表示已经种下了花朵，0代表每种下。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: flowerbed = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出: True</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">输入: flowerbed = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], n = <span class="number">2</span></span><br><span class="line">输出: False</span><br><span class="line">注意：</span><br><span class="line">    数组内已种好的花不会违反种植规则。</span><br><span class="line">输入的数组长度范围为 [<span class="number">1</span>, <span class="number">20000</span>]。</span><br><span class="line">n 是非负整数，且不会超过输入数组的大小。    </span><br></pre></td></tr></table></figure><p>解释：在[1,0,0,0,1],插入1，并且需怕满足一个1的前后都是0，所以我们可以换一个思路想，我们找0，如果0的前后都是0，那么这个o就可以置为1了（这里要特殊判断一下，数组的0、data.length-1索引，因为要判断到最前面和最后面后出现数组越界），并且记录插入的值，因为最后要返回的是是否种下了n朵花，用插入的cnt和n比较，如果cnt&gt;=n，代表能够种下n多花。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;flowerbed.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">0</span> &amp;&amp; (i==<span class="number">0</span> || flowerbed[i-<span class="number">1</span>]==<span class="number">0</span>) &amp;&amp; (i==flowerbed.length-<span class="number">1</span> || flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-判断是否为子序列"><a href="#8-判断是否为子序列" class="headerlink" title="8. 判断是否为子序列"></a>8. 判断是否为子序列</h3><ol start="392"><li>Is Subsequence (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;abc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">返回 <span class="keyword">true</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;axc&quot;</span>, t = <span class="string">&quot;ahbgdc&quot;</span></span><br><span class="line">返回 <span class="keyword">false</span>.</span><br></pre></td></tr></table></figure><p>解释：这道题如果你会java的一些常见API就会很简单了，首先把子序列用toCharArray()转成一个字符数组，然后用int indexOf(String str, int index)返回从 index位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1；把index初始值赋为-1，如果在遍历中index==-1则返回false,否则返回true.</p><p>//toCharArray() 方法将字符串转换为字符数组。<br>public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。<br>int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><p>foreach语句是java5的新特征之一，在遍历数组、集合方面，foreach为开发人员提供了极大的方便。<br>foreach 语法格式如下：<br>for(元素类型t 元素变量x : 遍历对象obj){<br>     引用了x的java语句; } </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">    int index &#x3D; -1;</span><br><span class="line">    for(char c : s.toCharArray())&#123;</span><br><span class="line">        index &#x3D; t.indexOf(c,index+1);</span><br><span class="line">        if(index &#x3D;&#x3D; -1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">     return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-修改一个数成为非递减数组"><a href="#9-修改一个数成为非递减数组" class="headerlink" title="9. 修改一个数成为非递减数组"></a>9. 修改一个数成为非递减数组</h3><ol start="665"><li>Non-decreasing Array (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbm9uLWRlY3JlYXNpbmctYXJyYXkvZGVzY3JpcHRpb24v">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLWRlY3JlYXNpbmctYXJyYXkvZGVzY3JpcHRpb24v">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p><p>解释：这道题主要就是判断两种情况，判断5 7 4 6这样的数   判断4 2 1这样的数，第一种是把4变成7，第二种是把4变成2</p><p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 你可以通过把第一个<span class="number">4</span>变成<span class="number">1</span>来使得它成为一个非递减数列。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。  </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 你可以通过把第一个<span class="number">4</span>变成<span class="number">7</span>来使得它成为一个非递减数列。        </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length&amp;&amp;cnt&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//使用cnt&lt;2 当出现第二个比前面大的数，直接停止循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i]&lt;nums[i-<span class="number">2</span>])&#123;<span class="comment">//判断5 7 4 8这样的数</span></span><br><span class="line">            <span class="comment">//7&gt;5 ,4&lt;7  只能让4的位置换成7才能不是递减</span></span><br><span class="line">                nums[i]=nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                nums[i-<span class="number">1</span>]=nums[i];<span class="comment">//判断4 2 3这样的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt&lt;<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-子数组最大的和"><a href="#10-子数组最大的和" class="headerlink" title="10. 子数组最大的和"></a>10. 子数组最大的和</h3><ol start="53"><li>Maximum Subarray (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>解释：要找到一个连续数组的最大和，首先要找到一个大于0的数，然后判断，取一个temp中间值，如果temp大于0 temp=temp+nums[i];只有返回的temp大于0，才会使连续的数组，如果中间出现temp小于0，就代表放弃前面的数组了，重新开始从本nums[i]加起。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp = temp&gt;<span class="number">0</span> ? nums[i]+temp:nums[i];</span><br><span class="line">            max = Math.max(temp,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-分隔字符串使同种字符出现在一起"><a href="#11-分隔字符串使同种字符出现在一起" class="headerlink" title="11. 分隔字符串使同种字符出现在一起"></a>11. 分隔字符串使同种字符出现在一起</h3><ol start="763"><li>Partition Labels (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>解释：一想到分割字符串就想到了回溯，但本题其实不用那么复杂。</p><p>可以分为如下两步：</p><p>统计每一个字符最后出现的位置<br>从头遍历字符，如果找到之前字符最大出现位置下标和当前下标相等，则找到了分割点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>, <span class="string">&quot;defegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span>。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计每个字母出现的最大下标</span></span><br><span class="line">    <span class="keyword">int</span>[] lastIndexsOfChar = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        lastIndexsOfChar[char2Index(S.charAt(i))] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个集合装返回的数据</span></span><br><span class="line">    List&lt;Integer&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> firstIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (firstIndex &lt; S.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = firstIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = firstIndex; i &lt; S.length() &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = lastIndexsOfChar[char2Index(S.charAt(i))];</span><br><span class="line">            <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">                lastIndex = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//装每个分割点的字符数</span></span><br><span class="line">        partitions.add(lastIndex - firstIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//重新遍历下一个字符开始的字符串</span></span><br><span class="line">        firstIndex = lastIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">char2Index</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基本上是用贪心算法解决的算法题</summary>
    
    
    
    <category term="算法" scheme="https://yuhaicheng.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心算法" scheme="https://yuhaicheng.xyz/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://yuhaicheng.xyz/2020-11-07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html"/>
    <id>https://yuhaicheng.xyz/2020-11-07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95.html</id>
    <published>2020-11-07T02:05:14.000Z</published>
    <updated>2020-11-07T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><h2 id="一、斐波那契数列"><a href="#一、斐波那契数列" class="headerlink" title="一、斐波那契数列"></a>一、斐波那契数列</h2><h3 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1. 爬楼梯"></a>1. 爬楼梯</h3><ol start="70"><li>Climbing Stairs (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p><p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p><p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p><p>即dp[i] = dp[i-1] + dp[i-2]</p><p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br><span class="line">    </span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2=<span class="number">1</span>; <span class="keyword">int</span> pre1=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur=pre2+pre1;</span><br><span class="line">            pre2=pre1;</span><br><span class="line">            pre1=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-强盗抢劫"><a href="#2-强盗抢劫" class="headerlink" title="2. 强盗抢劫"></a>2. 强盗抢劫</h3><ol start="198"><li>House Robber (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</p><p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p><p>dp[i]=max(dp[i-2]+dp[i],dp[i-1])</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.max(pre1+nums[i],pre2);</span><br><span class="line">            pre1=pre2;</span><br><span class="line">            pre2=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-强盗在环形街区抢劫"><a href="#3-强盗在环形街区抢劫" class="headerlink" title="3. 强盗在环形街区抢劫"></a>3. 强盗在环形街区抢劫</h3><ol start="213"><li>House Robber II (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：抢劫一排住户，但是不能抢邻近的住户，第一家和最后一家是连在一起的，求最大抢劫量。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br><span class="line">    输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]    </span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(pre1, pre2 + nums[i]);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-信件错排"><a href="#4-信件错排" class="headerlink" title="4. 信件错排"></a>4. 信件错排</h3><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p><p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p><ul><li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li><li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li></ul><p>综上所述，错误装信数量方式数量为：</p><h2 id="二、矩阵路径"><a href="#二、矩阵路径" class="headerlink" title="二、矩阵路径"></a>二、矩阵路径</h2><h3 id="1-矩阵的最小路径和"><a href="#1-矩阵的最小路径和" class="headerlink" title="1. 矩阵的最小路径和"></a>1. 矩阵的最小路径和</h3><ol start="64"><li>Minimum Path Sum (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1wYXRoLXN1bS9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小，且每次只能<strong>向右和向下</strong>移动，也就是求从矩阵的左上角到右下角的最小路径和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><p>解释：</p><p>由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p><p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。<strong>由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</strong></p><p>创建二维数组dp，与原始网格的大小相同，dp[i][j]表示从左上角出发到 (i,j)位置的最小路径和。显然，dp[0][0]=grid[0][0]。对于dp中的其余元素，通过以下状态转移方程计算元素值。</p><p>当 i&gt;0 且j=0 时，dp[i][0]=dp[i-1][0]+grid[i][0]</p><p>当i=0 且 j&gt;0 时，dp[0][j]=dp[0][j-1]+grid[0][j]</p><p>当 i&gt;0 且 j&gt;0 时，dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]</p><p>最后得到 dp[m-1][n-1] 的值即为从网格左上角到网格右下角的最小路径和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid==<span class="keyword">null</span> &amp;&amp; grid.length==<span class="number">0</span> &amp;&amp; grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=grid.length; <span class="keyword">int</span> m=grid[<span class="number">0</span>].length;<span class="comment">//注意二维数组取内的长度</span></span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j-<span class="number">1</span>]+grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-矩阵的总路径数"><a href="#2-矩阵的总路径数" class="headerlink" title="2. 矩阵的总路径数"></a>2. 矩阵的总路径数</h3><ol start="62"><li>Unique Paths (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>解释：我们令 dp[i][j] 是到达 i, j 最多路径动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]，注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p><p>时间复杂度：O(m*n)O(m∗n)</p><p>空间复杂度：O(m * n)O(m∗n)</p><p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">             dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">             dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                 dp[i][j]=dp[i][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[]= <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);<span class="comment">//填充数组中的数都为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               dp[j]+=dp[j-<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">//相当于我们每次只需要 dp[i-1][j],dp[i][j-1],哪[4][3]举例</span></span><br><span class="line">                             <span class="comment">//i=1 j=1 dp[1]=1+1=2</span></span><br><span class="line">                             <span class="comment">//     j=2 dp[2]=1+2=3</span></span><br><span class="line">                             <span class="comment">//i=2 j=1 dp[1]=2+1=3</span></span><br><span class="line">                             <span class="comment">//    j=2 dp[2]=3+3=6</span></span><br><span class="line">                             <span class="comment">//i=3 j=1 dp[1]=3+1=4</span></span><br><span class="line">                             <span class="comment">//    j=2 dp[2]=6+4=10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、数组区间"><a href="#三、数组区间" class="headerlink" title="三、数组区间"></a>三、数组区间</h2><h3 id="1-数组区间和"><a href="#1-数组区间和" class="headerlink" title="1. 数组区间和"></a>1. 数组区间和</h3><ol start="303"><li>Range Sum Query - Immutable (Easy)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LWltbXV0YWJsZS9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LWltbXV0YWJsZS9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given nums = [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">2</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -&gt; -<span class="number">1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -&gt; -<span class="number">3</span></span><br></pre></td></tr></table></figure><p>解释：本题提供了有参的构造方法和调用方法，首先我们传进一个数组，然后输入数组的下标索引（初始，结束）包括本身，如果是（0，2）那就是前三个数相加，（1，2）第二个数和第三个数相加，综上我们可以算出每个数之和，也就是前几个数之和，再详细的就是[-2, 0, 3, -5, 2, -1]中0下标总数和sum[1]=-2，sum[2]=-2+0+3=1;sum[0]=0是因为我们算（1，2）是sum[3]-sum[1]=1-（-2）=3，（sum[3]=sum[1]+sum[2]+sum[3]）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];<span class="comment">//创建一个属数组装我们传进的数组，大小+1，因为做减法，第一个-0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length+<span class="number">1</span>;i++)&#123;<span class="comment">//=第一个的值</span></span><br><span class="line">            sum[i]=sum[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];<span class="comment">//循环遍历出从nums数组中的前i的数之和，从1开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j+<span class="number">1</span>]-sum[i];<span class="comment">//下标大的+1 （0，2）-&gt;(3-1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-数组中等差递增子区间的个数"><a href="#2-数组中等差递增子区间的个数" class="headerlink" title="2. 数组中等差递增子区间的个数"></a>2. 数组中等差递增子区间的个数</h3><ol start="413"><li>Arithmetic Slices (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMvZGVzY3JpcHRpb24v">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMvZGVzY3JpcHRpb24v">力扣<i class="fa fa-external-link-alt"></i></span></p><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p><p>如果满足条件：</p><p>元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q ；函数要返回数组 A 中所有为等差数组的子数组个数。则称子数组(P, Q)为等差数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>: <span class="number">6</span>, <span class="keyword">for</span> <span class="number">3</span> arithmetic slices in A:</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>解释:</p><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p><p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;规律...</span><br><span class="line">dp[2] &#x3D; 1</span><br><span class="line">    [0, 1, 2]</span><br><span class="line">dp[3] &#x3D; dp[2] + 1 &#x3D; 2</span><br><span class="line">    [0, 1, 2, 3], &#x2F;&#x2F; [0, 1, 2] 之后加一个 3</span><br><span class="line">    [1, 2, 3]     &#x2F;&#x2F; 新的递增子区间</span><br><span class="line">dp[4] &#x3D; dp[3] + 1 &#x3D; 3</span><br><span class="line">    [0, 1, 2, 3, 4], &#x2F;&#x2F; [0, 1, 2, 3] 之后加一个 4</span><br><span class="line">    [1, 2, 3, 4],    &#x2F;&#x2F; [1, 2, 3] 之后加一个 4</span><br><span class="line">    [2, 3, 4]        &#x2F;&#x2F; 新的递增子区间</span><br></pre></td></tr></table></figure><p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p><p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> &amp;&amp; A.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>])&#123;</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cnt:dp)&#123;</span><br><span class="line">            sum+=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、分割整数"><a href="#四、分割整数" class="headerlink" title="四、分割整数"></a>四、分割整数</h2><h3 id="1-分割整数的最大乘积"><a href="#1-分割整数的最大乘积" class="headerlink" title="1. 分割整数的最大乘积"></a>1. 分割整数的最大乘积</h3><ol start="343"><li>Integer Break (Medim)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>。</span><br></pre></td></tr></table></figure><p>解释1：</p><p>对于正整数 n，当 n ≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。</p><p>创建数组 dp，其中dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。</p><p>当 i ≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j&lt;i），则有以下两种方案：</p><p>将 i 拆分成 j 和 i-j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 (i-j)×j；</p><p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 dp[i-j]×j。</p><p>因此，当 j 固定时，有 dp[i]=max(j × (i-j),j × dp[i-j])。由于 j 的取值范围是 1 到 i-1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如下：</p><p>dp[<em>i</em>]=1≤<em>j</em>&lt;<em>i</em>max{max(<em>j</em>×(<em>i</em>−<em>j</em>),<em>j</em>×dp[<em>i</em>−<em>j</em>])}</p><p>最终得到 dp[n] 的值即为将正整数 n 拆分成至少两个正整数的和之后，这些正整数的最大乘积。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;   </span><br><span class="line">                cnt=Math.max(cnt,Math.max((j*(i-j)),j*dp[i-j]));</span><br><span class="line">            &#125;    </span><br><span class="line">            dp[i]=cnt;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//另一种方法</span></span><br><span class="line">        <span class="comment">//因为4可拆分2x2 5拆分2x3 6拆分3x3 7拆分成2x2x3 8拆分3x3x2最大，所以可以把转换成</span></span><br><span class="line">        <span class="comment">//2和3的，尽可能的满足3，然后剩下的满足2</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n-<span class="number">1</span>; <span class="comment">//1-&gt;0 2-&gt;1 3-&gt;2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q1=n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> q2=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(q2==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,q1); </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q2==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">3</span>,q1-<span class="number">1</span>)*<span class="number">4</span>);<span class="comment">//7%3=1 7/3=2 3x2x2 10%3=1 10/3=3 3x3x2x2</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">3</span>,q1)*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-按平方数来分割整数"><a href="#2-按平方数来分割整数" class="headerlink" title="2. 按平方数来分割整数"></a>2. 按平方数来分割整数</h3><ol start="279"><li>Perfect Squares(Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGVyZmVjdC1zcXVhcmVzL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVyZmVjdC1zcXVhcmVzL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给你一个整数n，求他的若干个完全平方数的最少数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9.</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>思路：动态规划<br>首先初始化长度为 n+1 的数组 dp，每个位置都为 0<br>如果 n 为 0，则结果为 0<br>对数组进行遍历，下标为 i，每次都将当前数字先更新为最大的结果，即 dp[i]=i，比如 i=4，最坏结果为4=1+1+1+1 即为 4 个数字<br>动态转移方程为：dp[i] = MIN(dp[i], dp[i - j * j] + 1)，i 表示当前数字，j<em>j 表示平方数<br>时间复杂度：O(n</em>sqrt(n))，sqrt 为平方根</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">// 默认初始化值都为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=i;<span class="comment">//最坏的情况就是每次+1，不变化本值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j*j&gt;=<span class="number">0</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//n=5</span></span><br><span class="line">                <span class="comment">//i=4时，4-2*2=0 dp[4]=d[0]+1=1 </span></span><br><span class="line">                <span class="comment">//i=5时,5-2*2=1 dp[1]=1+0=2   &lt; 5-1*1=3 dp[3]=3</span></span><br><span class="line">                <span class="comment">//所以取dp[n] 最少两个我完全平方数可以构成n(n=5)</span></span><br><span class="line">                dp[i]=Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);<span class="comment">// 动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-分割整数构成字母字符串"><a href="#3-分割整数构成字母字符串" class="headerlink" title="3. 分割整数构成字母字符串"></a>3. 分割整数构成字母字符串</h3><ol start="91"><li>Decode Ways (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVjb2RlLXdheXMvZGVzY3JpcHRpb24v">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGVjb2RlLXdheXMvZGVzY3JpcHRpb24v">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：Given encoded message &quot;12&quot;, it could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p><p>解释：</p><p>这是一题典型的动态问题，但是需要考的情况较多：<br>dp数组表示长度为i的字符可以表示的解码次数；初始化 dp[0] = 1;<br>情况讨论：<br>1.当一个数为0时，结果肯定是0；<br>2.当长度为1时，肯定是1（此处排除了0）<br>3.当字符大于等于2时的情形：</p><ul><li>1.当前字符为0且上一个字符为0或者当前字符为0上一个字符大于2（即012，130，301）这种情况下不能解码，返回0</li><li>2.当前字符为0，那么当前字符只能与前一个字符组成组合 dp[i] = dp[i-2]</li><li>3.当前字符不是0，但前一个字符是，这种情况下，该字符只能独立解码，dp[i] = dp[i-1];</li><li>4.常规情况，当前字符与上一个字符的和&gt;26(直接拼成string与26比较也可)，如果大于26，那么这2字符只能一组，dp[i] = dp[i-2],否则，dp[i] = dp[i-2]+dp[i-1]</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;<span class="string">&#x27;7&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//判断第一位为1或2的第二位小于7的，以为第一位和二位不能超过27</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>) dp[i + <span class="number">1</span>] = dp[i - <span class="number">1</span>];<span class="comment">//如果第二位为0，只能和第一位组合</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>] = dp[i] + dp[i - <span class="number">1</span>];<span class="comment">//否则</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>)&#123;<span class="comment">//第一位不是2或1 且第二位&gt;7</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i];<span class="comment">//否则就是正常情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、最长递增子序列"><a href="#五、最长递增子序列" class="headerlink" title="五、最长递增子序列"></a>五、最长递增子序列</h2><p>已知一个序列 {S1, S2,...,Sn}，取出若干数组成新的序列 {Si1, Si2,..., Sim}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p><p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p><p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,...,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,..., Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。</p><p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p><p><a href="https://camo.githubusercontent.com/c6b76b65c1880a507bf1cb0250456121db57a1ab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65653939346461342d306663372d343433642d616335362d6330386361663030613230342e6a7067"><img data-src="https://camo.githubusercontent.com/c6b76b65c1880a507bf1cb0250456121db57a1ab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65653939346461342d306663372d343433642d616335362d6330386361663030613230342e6a7067" alt="img" loading="lazy"></a></p><p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p><h3 id="1-最长递增子序列"><a href="#1-最长递增子序列" class="headerlink" title="1. 最长递增子序列"></a>1. 最长递增子序列</h3><ol start="300"><li>Longest Increasing Subsequence (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>解释：</p><p>定义 dp[i]dp[i] 为考虑前 ii 个元素，以第 ii 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p><p>我们从小到大计算 dp[] 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：<br>dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</p><p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个nums[i]。由于dp[j] 代表 nums[0…j] 中以nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p><p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    max=Math.max(max,dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ref=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">             ref=Math.max(ref,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-一组整数对能够构成的最长链"><a href="#2-一组整数对能够构成的最长链" class="headerlink" title="2. 一组整数对能够构成的最长链"></a>2. 一组整数对能够构成的最长链</h3><ol start="646"><li>Maximum Length of Pair Chain (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1sZW5ndGgtb2YtcGFpci1jaGFpbi9kZXNjcmlwdGlvbi8=">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1sZW5ndGgtb2YtcGFpci1jaGFpbi9kZXNjcmlwdGlvbi8=">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The longest chain is [<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>解释 ：</p><p>在一个长度为 k，以 pairs[i] 结尾的数对链中，如果 pairs[i][1] &lt; pairs[j][0]，则将该数对加入链中，数对链长度变为 k+1。</p><p>根据数对的第一个数排序所有的数对，dp[i] 存储以 pairs[i] 结尾的最长链的长度。当 i &lt; j 且 pairs[i][1] &lt; pairs[j][0] 时，扩展数对链，更新 dp[j] = max(dp[j], dp[i] + 1)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs==<span class="keyword">null</span> &amp;&amp;pairs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(pairs,Comparator.comparingInt(o-&gt;o[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[pairs.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pairs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pairs[j][<span class="number">1</span>]&lt;pairs[i][<span class="number">0</span>])&#123;</span><br><span class="line">                   dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int cnt=0;</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;pairs.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cnt = Math.max(cnt,dp[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return cnt;</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-最长摆动子序列"><a href="#3-最长摆动子序列" class="headerlink" title="3. 最长摆动子序列"></a>3. 最长摆动子序列</h3><ol start="376"><li>Wiggle Subsequence (Medium)</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlL2Rlc2NyaXB0aW9uLw==">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。使用 O(N) 时间复杂度求解。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一个差存在正数或负数也是摆动序列</span><br></pre></td></tr></table></figure><p>解释：相当于只有第二个数大小第一个数、紧接着下一个数小于前一个数才算时有3个摆动序列,例如[1,7,8,9,2,1] 7&gt;1 up=2, 8&gt;7 9&gt;8 -&gt;dp=1+1=2 , 然后2&lt;9  down=up+1=2+1=3, 最后1&lt;2 down=2+1=3 ;反之一样的道理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//O(n)</span></span><br><span class="line">        <span class="keyword">int</span> up=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> down=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//相当于只有先时第二个数大小第一个数、紧接着下一个数小于前一个数才算时有3个摆动序列</span></span><br><span class="line"><span class="comment">//例如[1,7,8,9,2,1] 7&gt;1 up=2,8&gt;7 9&gt;8 -&gt;dp=2 然后2&lt;9 down=up+1=2+1=3,最后1&lt;2 down=2+1=3  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up=down+<span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                down=up+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up,down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、最长公共子序列"><a href="#六、最长公共子序列" class="headerlink" title="六、最长公共子序列"></a>六、最长公共子序列</h2><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p><p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p><ul><li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li><li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li></ul><p>综上，最长公共子序列的状态转移方程为：</p><p><img data-src="https://i.loli.net/2020/11/14/NHAh5oIfcDZ2aLK.png" loading="lazy"></p><p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p><p>与最长递增子序列相比，最长公共子序列有以下不同点：</p><ul><li>针对的是两个序列，求它们的最长公共子序列。</li><li>在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j。</li><li>在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</li></ul><h3 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1. 最长公共子序列"></a>1. 最长公共子序列</h3><ol start="143"><li>Longest Common Subsequence</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv">Leetcode<i class="fa fa-external-link-alt"></i></span> / <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv">力扣<i class="fa fa-external-link-alt"></i></span></p><p>题目描述：给定两个字符串 S1 和 S2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span>，它的长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span>，它的长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=text1.length();</span><br><span class="line">        <span class="keyword">int</span> n=text2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、0-1-背包"><a href="#七、0-1-背包" class="headerlink" title="七、0-1 背包"></a>七、0-1 背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p><ul><li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li><li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li></ul><p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p><p>dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);</p>]]></content>
    
    
    <summary type="html">基本上是用动态规划算法解决的算法题</summary>
    
    
    
    <category term="算法" scheme="https://yuhaicheng.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://yuhaicheng.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>面试常问题</title>
    <link href="https://yuhaicheng.xyz/2020-11-06-%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84%E9%A2%98.html"/>
    <id>https://yuhaicheng.xyz/2020-11-06-%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84%E9%A2%98.html</id>
    <published>2020-11-05T02:05:14.000Z</published>
    <updated>2020-11-06T06:48:51.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="一、JVM"><a href="#一、JVM" class="headerlink" title="一、JVM"></a>一、JVM</h2><h3 id="1如何判断哪些对象已经死亡了，可以回收了？"><a href="#1如何判断哪些对象已经死亡了，可以回收了？" class="headerlink" title="1如何判断哪些对象已经死亡了，可以回收了？"></a>1如何判断哪些对象已经死亡了，可以回收了？</h3><p><strong>1.使用引用计数法</strong></p><p>给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。</p><p>总结：但是原始引用计数无法解决循环引用的问题</p><p><strong>2.可达性分析算法</strong></p><p>这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。</p><p>在Java 语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（Native方法）引用的对象</li></ul><h3 id="2-垃圾回收算法都有哪些？"><a href="#2-垃圾回收算法都有哪些？" class="headerlink" title="2.垃圾回收算法都有哪些？"></a>2.垃圾回收算法都有哪些？</h3><p><strong>1.标记-清除算法</strong></p><p>该算法分为“标记”和“清除”两个阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的象。它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到的。</p><p>这种垃圾收集算法会带来两个明显的问题：</p><ul><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ul><p><img data-src="https://i.loli.net/2020/11/06/8LZ5c9TNjwvnHRF.png" alt="图片" loading="lazy"></p><p><strong>2.复制算法</strong></p><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。</p><p>优点：解决了效率低的问题</p><p>缺点：造成空间的浪费，使用一块内存，真正只使用了他的一半</p><p><img data-src="https://i.loli.net/2020/11/06/i3vfuLBRtVydUc4.png" loading="lazy"></p><p><strong>3.标记-整理（压缩）算法</strong></p><p>根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，<strong>⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。</strong></p><p>优点：不会造成空间问题产生大量碎片</p><p>缺点：但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p><p><img data-src="https://i.loli.net/2020/11/06/GuPFaKpw6iLcV7z.png" loading="lazy"></p><p><strong>4.分代收集算法</strong></p><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收呢，来看一下对象的分配有啥规律。</p><p><strong>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</strong></p><p>细节问题（敲黑板，咳咳）：</p><p>大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p><p><img data-src="https://i.loli.net/2020/11/06/jBbFgwu3Q5yfZsR.png" loading="lazy"></p><p><strong>分代收集工作原理</strong></p><p><strong>1、对象在新生代的分配与回收</strong></p><ol><li>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</li><li>当 Eden 区将满时，触发 Minor GC</li><li>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间</li><li>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</li><li>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</li></ol><p><strong>2、对象何时晋升老年代</strong></p><ul><li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li><li>年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li><li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li><li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li></ul><p><strong>3、空间分配担保</strong></p><p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p><p><strong>4、Stop The World</strong></p><p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p><p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p><p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p><p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p><p>由于 Full GC（或Minor GC） 会影响性能，<strong>所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，</strong>这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p><ul><li>循环的末尾</li><li>方法返回前</li><li>调用方法的 call 之后</li><li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li></ul><h3 id="3-垃圾收集器都有哪些？"><a href="#3-垃圾收集器都有哪些？" class="headerlink" title="3.垃圾收集器都有哪些？"></a>3.垃圾收集器都有哪些？</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p><p><img data-src="https://i.loli.net/2020/11/06/epE8AaUqD1CYnj2.png" loading="lazy"></p><ul><li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li><li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li><li>同时在新老生代工作的垃圾回收器：G1</li></ul><p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p><h4 id="Ⅰ-新生代垃圾回收器"><a href="#Ⅰ-新生代垃圾回收器" class="headerlink" title="Ⅰ.新生代垃圾回收器"></a>Ⅰ.新生代垃圾回收器</h4><p><strong>1.Serial 收集器</strong></p><p>Serial收集器是工作在新生代的，<strong>单线程的垃圾收集器</strong>，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说<strong>在 GC 期间，此时的应用不可用。</strong></p><p>但是Serial收集器有没有优于其他垃圾收集器的地⽅呢？</p><p>当然有，它简单⽽⾼效（与其他收集器的单线程相⽐）。Serial收集器由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。Serial收集器对于运⾏在Client模式下的虚拟机来说是个不错的选择。</p><p><strong>2.ParNew 收集器</strong> </p><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完全一样，在底层上，这两种收集器也共用了相当多的代码。</p><p><strong>ParNew 主要工作在 Server 模式</strong>，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为<strong>除了 Serial  收集器，只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p><p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p><p><strong>3.Parallel Scavenge 收集器</strong> </p><p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p><p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 <strong>Parallel Scavenge 目标是达到一个可控制的吞吐量（</strong>吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 <strong>CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</strong></p><p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p><p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p><h4 id="Ⅱ-老年代垃圾回收器"><a href="#Ⅱ-老年代垃圾回收器" class="headerlink" title="Ⅱ.老年代垃圾回收器"></a>Ⅱ.老年代垃圾回收器</h4><p><strong>1.Serial Old 收集器</strong> </p><p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p><p><img data-src="https://i.loli.net/2020/11/06/CsQVw6y7xSzthai.png" loading="lazy"></p><p>**2.Parallel Old 收集器 **</p><p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p><p><img data-src="https://i.loli.net/2020/11/06/Q8jx3FaohNR5G4D.png" loading="lazy"></p><p><strong>3.CMS 收集器</strong> </p><p>CMS（Concurrent Mark Sweep）收集器是⼀种以<strong>获取最短回收停顿时间为⽬标的收集器</strong>。它⽽⾮常符合<br>在注重⽤户体验的应⽤上使⽤。<br>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第⼀款真正意义上的并发收集器，它第⼀次实<br>现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。</p><p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤：</p><ol><li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li><li>并发标记：同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以GC线程⽆法保证可达性分析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。</li><li>重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对象的标记记录，这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短</li><li>并发清除：开启⽤户线程，同时GC线程开始对为标记的区域做清扫。</li></ol><p><img data-src="https://i.loli.net/2020/11/06/jHqgf4yWZR3unL7.png" loading="lazy"></p><p>从它的名字就可以看出它是⼀款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下⾯三个明显的缺点：</p><ul><li>对CPU资源敏感；</li><li>⽆法处理浮动垃圾；</li><li>它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。</li></ul><p><strong>4.G1（Garbage First） 收集器</strong></p><p>G1 (Garbage-First)是⼀款⾯向服务器的垃圾收集器,被称为驾驭一切的垃圾回收器；主要针对配备多颗处理器及⼤容量内存的机器以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征.</p><p>G1 收集器的工作步骤如下</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol><p><img data-src="https://i.loli.net/2020/11/06/XLRkuels7qVa3SN.png" loading="lazy"></p><p>G1收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的Region也就是它的名字Garbage-First的由来)。这种使⽤Region划分内存空间以及有优先级的区域回收⽅式保证了GF收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。</p><h2 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h2><h3 id="1-什么是进程和线程？"><a href="#1-什么是进程和线程？" class="headerlink" title="1.什么是进程和线程？"></a>1.什么是进程和线程？</h3><p>进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</p><p>线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。</p><p>举个例子：进程和线程区别，用java内存区域来说；线程与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。</p><h3 id="2-多线程是什么？"><a href="#2-多线程是什么？" class="headerlink" title="2.多线程是什么？"></a>2.多线程是什么？</h3><p>提到多线程这里要说两个概念，就是<strong>串行和并行</strong>，搞清楚这个我们才能更好的理解多线程。</p><p>所谓串行其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子，我们下载多个文件，在串行中它是按照一定的顺序去进行下载的，也就是说必须等下载完A之后，才能开始下载B，它们在时间上是不可能发生重叠的。</p><p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的在同一时刻发生的，并行在时间上是重叠的。</p><p>了解了这两个概念之后我们再来说说什么是多线程，举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能，按照单线程来说，你想要清理垃圾还要病毒查杀，那么你必须先做完其中的一件事才能做下一件事，是有一个执行的顺序的，如果是多线程的话，我们其实在清理垃圾的时候还可以查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行的先后顺序。</p><p><strong>所以：多线程就是一个进程运行中产生了多个线程</strong></p><h3 id="3-什么是线程安全？线程安全级别有什么？"><a href="#3-什么是线程安全？线程安全级别有什么？" class="headerlink" title="3.什么是线程安全？线程安全级别有什么？"></a>3.什么是线程安全？线程安全级别有什么？</h3><p>既然是线程安全问题，那么毫无疑问所有的隐患都是出现在多个线程访问的情况下产生的，也就是我们要确保在多条线程访问的时候，<u>我们的程序还能按照我们预期的行为去执行</u>，<strong>也就是说：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。</strong></p><p>线程安全级别：</p><ol><li><p>不可变：不变的对象绝对是线程安全的，不需要线程同步，如String、Long、BigInteger</p></li><li><p>绝对的线程安全：对象自身做了 足够的内部同步，也不需要外部同步，如 Random 、ConcurrentHashMap、Concurrent集合、atomic</p></li><li><p>相对的线程安全：对象的部分方法可以无条件安全使用，但是有些方法需要外部同步，需要Collections.synchronized；有条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器</p></li><li><p>线程兼容：对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如ArrayList HashMap</p></li><li><p>线程对立：即使外部进行了同步调用，也不能保证线程安全，这种情况非常少，如System.setOut()、System.runFinalizersOnExit()</p></li></ol><h3 id="4-怎么保证线程安全？"><a href="#4-怎么保证线程安全？" class="headerlink" title="4.怎么保证线程安全？"></a>4.怎么保证线程安全？</h3><p><strong>当多个线程要共享一个实例对象的值得时候，那么在考虑安全的多线程并发编程时就要保证下面3个要素：</strong></p><ul><li>原子性（Synchronized, Lock）</li><li>有序性(Volatile，Synchronized, Lock)</li><li>可见性(Volatile，Synchronized,Lock)</li></ul><p>但是由于synchronized和Lock保证每个时刻只有一个线程执行同步代码，所以是线程安全的，也可以实现这一功能，<strong>但是由于线程是同步执行的，所以会影响效率。</strong></p><p><strong>下面是对3个要素的详细解释：</strong></p><ul><li><strong>原子性</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，<strong>基本数据类型的变量的读取和赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</li><li><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</li></ul><p><strong>volatile的作用：保证数据的可见性和防止指令重排。</strong></p><ul><li>volatile仅能用在变量级别，而synchronized可用在变量和方法中。</li><li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取共享变量时，它会去内存中读取新值。</li><li>普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li><li>更新主存的步骤：当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效，然后当前线程将变量的值跟新到主存，更新成功后将其他线程的缓存行更新为新的主存地址</li><li>其他线程读取变量时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</li><li> 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li></ul><p><strong>1、使用安全类，比如 Java. util. concurrent</strong></p><p>**2、使用synchronized关键字，自动锁 **</p><p><strong>定义</strong>：synchronized关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</strong>当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 <strong>Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销；主要解决以下三种场景:</strong></p><ul><li>只有一个线程进入临界区，偏向锁</li><li>多线程未竞争，轻量级锁</li><li>多线程竞争，重量级锁</li></ul><p>偏向锁→轻量级锁→重量级锁过程，<strong>锁可以升级但不能降级</strong>，这种策略是为了提高获得锁和释放锁的效率</p><p><strong>底层原理：</strong></p><p>① synchronized 同步语句块的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执⾏monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因)的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p><p>② synchronized 修饰⽅法的的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronized ⽅法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，JVM 通过该 ACC_SYNCHRONIZED 访问<br>标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。</p><p><strong>3、使用Lock类，手动锁</strong></p><p>先来说说它跟synchronized有什么区别吧，Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，什么意思？</p><p>就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。我们先来看下一般是如何使用的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// ReentrantLock是Lock的子类</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">      lock.lock(); <span class="comment">// 获取锁对象</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">          <span class="comment">// Thread.sleep(2000);</span></span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">          lock.unlock(); <span class="comment">// 释放锁对象</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-多线程的实现方式和区别"><a href="#5-多线程的实现方式和区别" class="headerlink" title="5.多线程的实现方式和区别"></a>5.多线程的实现方式和区别</h3><p>①继承Thread类</p><p>②实现Rannable接口</p><p>③使用Callable和Future创建线程</p><ul><li><p>上面的两种方式都有这两个问题;二第三个方法就是解决这两个问题的</p><ul><li>无法获取子线程的返回值</li><li>run方法不可以抛出异常</li></ul></li></ul><p><strong>前三种实现多线程的比较：</strong></p><p>第一种和后面两种的对比：</p><ul><li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li><li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li></ul><p>第二种和第三种方式对比：</p><ul><li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li><li>第三种方法有两个优点：有返回值、可以抛出异常</li></ul><h3 id="6-怎么启动多线程？"><a href="#6-怎么启动多线程？" class="headerlink" title="6.怎么启动多线程？"></a>6.怎么启动多线程？</h3><p>调用start()方法；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String name2 = Thread.currentThread().getName();</span><br><span class="line">System.out.println(name2+<span class="string">&quot;:你好啊 我是一个线程!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">threadTest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">没错就是这么简单,只需要<span class="keyword">new</span> Thread()然后重写run方法就可以实现创建一个线程,使用start方法即可启动该线程.</span><br></pre></td></tr></table></figure><h3 id="7-有几种线程池-是怎么实现的？"><a href="#7-有几种线程池-是怎么实现的？" class="headerlink" title="7.有几种线程池,是怎么实现的？"></a>7.有几种线程池,是怎么实现的？</h3><ol><li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li><li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li><li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li><li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li></ol><p><strong>底层具体实现：</strong></p><p>通过Executor 框架的⼯具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：</p><ul><li><strong>newSingleThreadExecutor</strong></li><li><strong>newFixedThreadPool</strong></li><li><strong>newCachedThreadPool</strong></li></ul><p>下⾯这些对创建 ⾮常重要，在后⾯使⽤线程池的过程中你⼀定会⽤到！所以，务必拿着⼩本本记清楚。</p><p><strong>ThreadPoolExecutor构造函数重要参数分析</strong> </p><ul><li>corePoolSize : 核⼼线程数线程数定义了<strong>最⼩可以同时运⾏的线程数量</strong>。</li><li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数<br>量变为最⼤线程数。</li><li>workQueue: 当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到<br>的话，新任务就会被存放在队列中。</li></ul><p>ThreadPoolExecutor其他常⻅参数:</p><ol><li><p>keepAliveTime:当线程池中的线程数量⼤于 corePoolSize 的时候，如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁；</p></li><li><p>unit : keepAliveTime 参数的时间单位。</p></li><li><p>threadFactory :executor 创建新线程的时候会⽤到。</p></li><li><p>handler :饱和策略。关于饱和策略下⾯单独介绍⼀下。<br>ThreadPoolExecutor 饱和策略<br>ThreadPoolExecutor 饱和策略定义:<br>如果当前同时运⾏的线程数量达到最⼤线程数量并且队列也已经被放满了任时， ThreadPoolTaskExecutor 定义⼀些策略:ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。ThreadPoolExecutor.CallerRunsPolicy：调⽤执⾏⾃⼰的线程运⾏任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应⽤程序可以承受此延迟并且你不能任务丢弃任何⼀个任务请求的话，你可以选择这个策略。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //线程池的核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, //最大线程数。</span></span></span><br><span class="line"><span class="function"><span class="params">                          Long keepAliveTime,// 设置线程超时时间。</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params">                          BLockingQueue&lt;Runnable&gt;workQueue,   //阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, //线程工厂,线程池利用该工厂创建线程 </span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandLer handler)</span></span>&#123;<span class="comment">//  线程任务拒绝策略。</span></span><br></pre></td></tr></table></figure><h3 id="8-说说-sleep-⽅法和-wait-⽅法区别和共同点"><a href="#8-说说-sleep-⽅法和-wait-⽅法区别和共同点" class="headerlink" title="8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?"></a>8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h3><p>两者最主要的区别在于：sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</p><ul><li>两者都可以暂停线程的执⾏。</li><li>Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</li><li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者notifyAll() ⽅法。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。</li><li>sleep() ⽅法执⾏完成后，线程会⾃动苏醒。</li></ul><h3 id="9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？"><a href="#9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？" class="headerlink" title="9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？"></a>9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</h3><p>这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都回答不上来！</p><p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。</p><p>总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="面试题" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://yuhaicheng.xyz/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>第二次面试（线上+线下）</title>
    <link href="https://yuhaicheng.xyz/2020-11-09-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%E5%A4%A9%E4%B8%A4%E5%AE%B6%E7%BA%BF%E4%B8%8B+%E7%BA%BF%E4%B8%8A%EF%BC%89.html"/>
    <id>https://yuhaicheng.xyz/2020-11-09-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%E5%A4%A9%E4%B8%A4%E5%AE%B6%E7%BA%BF%E4%B8%8B+%E7%BA%BF%E4%B8%8A%EF%BC%89.html</id>
    <published>2020-10-30T14:05:14.000Z</published>
    <updated>2020-10-31T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个视频面"><a href="#第一个视频面" class="headerlink" title="第一个视频面"></a>第一个视频面</h2><h3 id="1-看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令"><a href="#1-看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令" class="headerlink" title="1.看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令"></a>1.看你简历上Servlet用的很多啊，说一说Servlet得生命周期，说说初始化命令，说说销毁命令</h3><p>Servlet的生命周期和人类的参与次数是一样的1  1  n  1  1 次</p><p>阶段 ：    加载         初始化（init)     服务（service）   销毁（destroy）     卸载</p><h3 id="2-你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别"><a href="#2-你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别" class="headerlink" title="2.你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别"></a>2.你做web项目肯定写过jsp页面吧，说说jsp和Servlet得区别</h3><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。<strong>JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序</strong>，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p><h5 id="便于理解："><a href="#便于理解：" class="headerlink" title="便于理解："></a>便于理解：</h5><p>Java -&gt; .java -&gt; .class</p><p>Jsp和Servlet诞生的先后顺序？</p><p>先有的Servlet，后有的Jsp</p><p>​        Servlet :只有Servlet，可以完成页面视图的编写</p><p>​        Jsp：优化Servlet视图编写时遇到的编写困难，效率低等问题</p><ul><li>Jsp在翻译阶段，从.jsp文件会被翻译成.java的Servlet</li><li>编译阶段会将Jsp生成的Servlet编译成可执行的.class</li></ul><h5 id="普通Java类，Servlet和Jsp三者之间的关系："><a href="#普通Java类，Servlet和Jsp三者之间的关系：" class="headerlink" title="普通Java类，Servlet和Jsp三者之间的关系："></a>普通Java类，Servlet和Jsp三者之间的关系：</h5><ul><li>Jsp是一个特殊的Servlet，专门用于进行视图呈现</li><li>Servlet是一个特殊的Java类，可以进行对于网络相关功能的实现</li></ul><h5 id="jsp定义："><a href="#jsp定义：" class="headerlink" title="jsp定义："></a>jsp定义：</h5><p>jsp的完整形式是Java Server Pages。 它是一项允许开发支持动态内容的网页的技术。 JSP使开发人员可以使用特殊的JSP标记在HTML网页中插入Java代码，这些标记通常以*&lt;％*开头，以*％&gt;*结尾。</p><h5 id="Servlet定义："><a href="#Servlet定义：" class="headerlink" title="Servlet定义："></a>Servlet定义：</h5><p>Servlet是一种纯粹是用Java编写的，在Web或应用程序服务器上运行的程序，充当来自Web浏览器或其他HTTP客户端的请求与HTTP服务器上的数据库或应用程序之间的中间层。</p><h3 id="3-你用过mysql数据库吗，那么如何清空一张表"><a href="#3-你用过mysql数据库吗，那么如何清空一张表" class="headerlink" title="3.你用过mysql数据库吗，那么如何清空一张表"></a>3.你用过mysql数据库吗，那么如何清空一张表</h3><ul><li><p>truncate table表名：清空数据表内容使用TRUNCATE语句，它会将您的整张表全部删除掉后再次创建一个新的表，表中没有任何的内容，而且这种操作还是不可逆的。TRUNCATE语句具体的语法为：truncate table表名。</p><p>注意:要先选择好数据库、选择好表别误删 show databases-&gt;use 库名  show table -&gt;truncate table表名 </p></li><li><p>delete from 表名：delete 删除以后， 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件</p></li></ul><h5 id="比-较："><a href="#比-较：" class="headerlink" title="比 较："></a>比 较：</h5><p>1&gt; truncate 是整体删除 (速度较快)，delete是逐条删除 (速度较慢)<br>2&gt; truncate 不写服务器 log，delete 写服务器 log，也就是 truncate 效率比 delete高的原因<br>3&gt; truncate 不激活trigger (触发器)，但是会重置Identity (标识列、自增字段)，相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的 ID数。而 delete 删除以后，identity 依旧是接着被删除的最近的那一条记录ID加1后进行记录。如果只需删除表中的部分记录，只能使用 DELETE语句配合 where条件。</p><h5 id="那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？"><a href="#那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？" class="headerlink" title="那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？"></a>那么问题来了，如果某一个数据库中有很多张表，此时我想将该数据库中所有表中的数据全部删掉，该如何操作呢？</h5><p><strong>解决该问题主要分两种情况：</strong></p><p>如果不需要保留数据库中所有表的结构，那么答案很简单，执行命令drop database 数据库名  即可达到目的。</p><p>但是如果需要保留该数据库中所有表的结构，只想删除所有表中的数据，又该怎么解决呢？有人会说可以多执行几次truncate操作就OK啦，没错，多执行几次truncate确实可以达到目的，但是，如果要删除的数据库中有很多张表，几十张上百张表，执行上百次truncate操作显然不是好的办法？至此，就是本文要说讲到的办法了。删除的办法其实还是执行truncat方法，只是不需要每次手动的输入truncate命令进行删除。通过sql命令的方式生成所有的truncate语句并写入到.sql脚本文件中，然后执行脚本即可完成删除操作，并且保留了表结构。</p><h3 id="4-arraylist、linkedlist、vector的区别"><a href="#4-arraylist、linkedlist、vector的区别" class="headerlink" title="4.arraylist、linkedlist、vector的区别"></a>4.arraylist、linkedlist、vector的区别</h3><ol><li><p><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；vector是线程安全的，Vector类的所有⽅法都是同步的（每个方法都使用了synchronized关键字）。</p></li><li><p><strong>底层数据结构</strong>： Arraylist 底层使⽤的是 Object 数组；vector它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步； LinkedList 底层使⽤的是双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下⾯有介绍到！）</p></li><li><p><strong>插⼊和删除是否受元素位置的影响</strong>：</p><p> ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e)⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插⼊和删除元素的话（ add(int index, E element)）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。</p><p> ② LinkedList 采⽤链表存储，所以对于 add(E e)⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element)） 时间复杂度近似为 o(n))因为需要先移动到指定位置再插⼊。</p></li><li><p><strong>是否⽀持快速随机访问</strong>： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index)⽅法)。</p></li><li><p><strong>内存空间占⽤</strong>： ArrayList的空 间浪费主要体现在在list列表的结尾会预留⼀定的容量空间，⽽LinkedList的空间花费则体现在它的每⼀个元素都需要消耗⽐ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ol><h5 id="ArraryList的刨根问底："><a href="#ArraryList的刨根问底：" class="headerlink" title="ArraryList的刨根问底："></a>ArraryList的刨根问底：</h5><h5 id="ArrayList有用过吗？它是一个什么东西？可以用来干嘛？"><a href="#ArrayList有用过吗？它是一个什么东西？可以用来干嘛？" class="headerlink" title="ArrayList有用过吗？它是一个什么东西？可以用来干嘛？"></a>ArrayList有用过吗？它是一个什么东西？可以用来干嘛？</h5><p>有用过；ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组Object[] elementData。</p><p>与它类似的是LinkedList，和LinkedList相比，它的<strong>查找</strong>和<strong>访问</strong>元素的<strong>速度较快</strong>，但新增，删除的速度较慢。</p><h5 id="ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"><a href="#ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？" class="headerlink" title="ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"></a>ArraryList底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</h5><p>通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组**Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}**所以数组容量为0，只有真正对数据进行添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过无参构造方法的方式ArrayList()初始化，则赋值底层数Object[] elementData为一个默认空数组</span></span><br><span class="line"><span class="comment">//Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;所以数组容量为0，只有真正对数据进行添加</span></span><br><span class="line"><span class="comment">//add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//ArrayList默认的大小是10。</span></span><br></pre></td></tr></table></figure><h5 id="数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？"><a href="#数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？" class="headerlink" title="数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？"></a>数组的长度是有限制的，而ArrayList是可以存放任意数量对象，长度不受限制，那么他是怎么实现的呢？</h5><p>其实实现方式比较简单，他就是通过<strong>数组扩容</strong>的方式去实现的。</p><p>就比如我们现在有一个长度为10的数组，现在我们要新增一个元素，发现已经满了，那ArrayList会怎么做呢？</p><p>第一步他会重新定义一个长度为10+10/2的数组也就是新增一个长度为15的数组。</p><p>然后把原数组的数据，原封不动的复制到新数组中，这个时候再把指向原数组的地址换到新数组，ArrayList就这样完成了一次改头换面。</p><h5 id="我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。"><a href="#我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。" class="headerlink" title="我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。"></a>我记得你说到了，他增删很慢，你能说一下ArrayList在增删的时候是怎么做的么？主要说一下他为啥慢。</h5><p>有指定index新增，也有直接新增的，在这之前他会有一步校验长度的判断<strong>ensureCapacityInternal</strong>，就是说如果长度不够，是需要扩容的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在扩容的时候，老版本的jdk和8以后的版本是有区别的，8之后的效率更高了，采用了位运算，<strong>右移</strong>一位，其实就是除以2这个操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定位置新增的时候，在校验之后的操作很简单，就是数组的copy，大家可以看下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比如有下面这样一个数组我需要在index 5的位置去新增一个元素A</p><p>1 2 3 4 5 6 7 8 9 _</p><p>那从代码里面我们可以看到，他复制了一个数组，是从index 5的位置开始的，然后把它放在了index 5+1的位置</p><p>1 2 3 4 _ 5 6 7 8 9</p><p>给我们要新增的元素腾出了位置，然后在index的位置放入元素A就完成了新增的操作了</p><p>1 2 3 4 A 5 6 7 8 9</p><p>至于为啥说他效率低，我想我不说你也应该知道了，我这只是在一个这么小的List里面操作，要是我去一个几百几千几万大小的List新增一个元素，那就需要后面所有的元素都复制，然后如果再涉及到扩容啥的就更慢了不是嘛。</p><h5 id="我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int-initialCapacity）会不会初始化数组大小？"><a href="#我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int-initialCapacity）会不会初始化数组大小？" class="headerlink" title="我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int initialCapacity）会不会初始化数组大小？"></a>我问你个真实的场景，这个问题很少人知道，你可要好好回答哟！ArrayList（int initialCapacity）会不会初始化数组大小？</h5><p><strong>答：不会初始化数组大小！</strong></p><p>而且将构造函数与initialCapacity结合使用，然后使用set（）会抛出异常，尽管该数组已创建，但是大小设置不正确。</p><p>使用sureCapacity（）也不起作用，因为它基于elementData数组而不是大小。</p><p>还有其他副作用，这是因为带有sureCapacity（）的静态DEFAULT_CAPACITY。</p><p>进行此工作的唯一方法是在使用构造函数后，根据需要使用add（）多次。</p><p>大家可能有点懵，我直接操作一下代码，大家会发现我们虽然对ArrayList设置了初始大小，但是我们打印List大小的时候还是0，我们操作下标set值的时候也会报错，数组下标越界。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList插入删除一定慢么？"><a href="#ArrayList插入删除一定慢么？" class="headerlink" title="ArrayList插入删除一定慢么？"></a>ArrayList插入删除一定慢么？</h5><p>取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。</p><h5 id="那他的删除怎么实现的呢？"><a href="#那他的删除怎么实现的呢？" class="headerlink" title="那他的删除怎么实现的呢？"></a>那他的删除怎么实现的呢？</h5><p>删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在copy一个数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>继续打个比方，我们现在要删除下面这个数组中的index5这个位置</p><p>1 2 3 4 5 6 7 8 9 _</p><p>那代码他就复制一个index5+1开始到最后的数组，然后把它放到index开始的位置</p><p>1 2 3 4 6 7 8 9 _ _</p><p>index5的位置就成功被”删除“了其实就是被覆盖了，给了你被删除的感觉。</p><p>同理他的效率也低，因为数组如果很大的话，一样需要复制和移动的位置就大了。</p><h5 id="ArrayList是线程安全的么？"><a href="#ArrayList是线程安全的么？" class="headerlink" title="ArrayList是线程安全的么？"></a>ArrayList是线程安全的么？</h5><p>当然不是，线程安全版本的数组容器是Vector。</p><p>Vector的实现很简单，就是把所有的方法统统加上synchronized就完事了。</p><p>你也可以不使用Vector，用Collections.synchronizedList把一个普通ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized。</p><h5 id="ArrayList用来做队列合适么？"><a href="#ArrayList用来做队列合适么？" class="headerlink" title="ArrayList用来做队列合适么？"></a>ArrayList用来做队列合适么？</h5><p>队列一般是FIFO（先入先出）的，如果用ArrayList做队列，就需要在数组尾部追加数据，数组头部删除数组，反过来也可以。</p><p>但是无论如何总会有一个操作会涉及到数组的数据搬迁，这个是比较耗费性能的。</p><p><strong>结论</strong>：ArrayList不适合做队列。</p><h5 id="那数组适合用来做队列么？"><a href="#那数组适合用来做队列么？" class="headerlink" title="那数组适合用来做队列么？"></a>那数组适合用来做队列么？</h5><p>数组是非常合适的。</p><p>简单点说就是使用两个偏移量来标记数组的读位置和写位置，如果超过长度就折回到数组开头，前提是它们是定长数组。</p><h5 id="ArrayList的遍历和LinkedList遍历性能比较如何？"><a href="#ArrayList的遍历和LinkedList遍历性能比较如何？" class="headerlink" title="ArrayList的遍历和LinkedList遍历性能比较如何？"></a>ArrayList的遍历和LinkedList遍历性能比较如何？</h5><p>论遍历ArrayList要比LinkedList快得多，<strong>ArrayList遍历最大的优势在于内存的连续性</strong>，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>ArrayList就是动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了动态的增加和减少元素，实现了Collection和List接口，灵活的设置数组的大小等好处。</p><p>面试里面问的时候没HashMap，ConcurrentHashMap啥的这么常问，但是也有一定概率问到的，还是那句话，<strong>不打没把握的仗</strong>。</p><p>我们在源码阅读过程中，不需要全部都读懂，需要做的就是读懂核心的源码，加深自己对概念的理解就好了，用的时候不至于啥都不知道，不要为了用而用就好了。</p><h3 id="补充内容："><a href="#补充内容：" class="headerlink" title="补充内容："></a>补充内容：</h3><h5 id="1-RandomAccess-接口："><a href="#1-RandomAccess-接口：" class="headerlink" title="1.RandomAccess 接口："></a>1.RandomAccess 接口：</h5><p>ArrayList 实现了 RandomAccess 接⼝， ⽽ LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ ArrayList 底层是数组，⽽ LinkedList 底层是链表。数组天然⽀持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不⽀持快速随机访问。， ArrayList 实现了 RandomAccess 接⼝，就表明了他具有快速随机访问功能。 RandomAccess 接⼝只是标识，并不是说 ArrayList 实现 RandomAccess 接⼝才具有快速随机访问功能的！</p><h5 id="2-下⾯再总结⼀下-list-的遍历⽅式选择："><a href="#2-下⾯再总结⼀下-list-的遍历⽅式选择：" class="headerlink" title="2.下⾯再总结⼀下 list 的遍历⽅式选择："></a>2.下⾯再总结⼀下 list 的遍历⽅式选择：</h5><p>实现了 RandomAccess 接⼝的list，优先选择普通 for 循环 ，其次 foreach,未实现 RandomAccess接⼝的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），⼤size的数据，千万不要使⽤普通for循环</p><h5 id="3-双向链表和双向循环链表"><a href="#3-双向链表和双向循环链表" class="headerlink" title="3.双向链表和双向循环链表"></a>3.双向链表和双向循环链表</h5><p>双向链表： 包含两个指针，⼀个prev指向前⼀个节点，⼀个next指向后⼀个节点。</p><p>双向循环链表： 最后⼀个节点的 next 指向head，⽽ head 的prev指向最后⼀个节点，构成⼀个环。</p><h3 id="5-说一说session和cookie，区别"><a href="#5-说一说session和cookie，区别" class="headerlink" title="5.说一说session和cookie，区别"></a>5.说一说session和cookie，区别</h3><p><strong>session和cookie，都是解决http无状态的问题</strong></p><p><strong>Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样；</strong></p><p>维基百科是这样定义 <strong>Cookie</strong> 的：Cookies是某些⽹站为了<strong>辨别⽤户身份⽽储存在⽤户本地终端上的数据</strong>（通常经过加密）。简单来说： Cookie 存放在客户端，⼀般⽤来保存⽤户信息。典型的场景是我们在 Cookie 中保存已经登录过的⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了。除此之外，Cookie 还能保存⽤户⾸选项，主题和其他设置信息。</p><p><strong>Session</strong> 的主要作⽤就是通过<strong>服务端记录⽤户的状态</strong>。 典型的场景是购物⻋，当你要添加商品到购物<br>⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定<br>的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。</p><h5 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a>区别：</h5><p><strong>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端；session有效期相对cookie较短。</strong>相对来说 Session 安全性更⾼。如果使⽤ Cookie 的⼀些敏感信息不要写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。</p><h3 id="补充内容：-1"><a href="#补充内容：-1" class="headerlink" title="补充内容："></a>补充内容：</h3><h5 id="1-如何使⽤Session进⾏身份验证？"><a href="#1-如何使⽤Session进⾏身份验证？" class="headerlink" title="1.如何使⽤Session进⾏身份验证？"></a>1.如何使⽤Session进⾏身份验证？</h5><p>很多时候我们都是通过 SessionID 来实现特定的⽤户，SessionID ⼀般会选择存放在 Redis 中。举个例⼦：⽤户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当⽤户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证⽅式更详细的过程如下：</p><ol><li> ⽤户向服务器发送⽤户名和密码⽤于登陆系统。</li><li> 服务器验证通过后，服务器为⽤户创建⼀个 Session，并将 Session信息存储 起来。</li><li> 服务器向⽤户返回⼀个 SessionID，写⼊⽤户的 Cookie。</li><li> 当⽤户保持登录状态时，Cookie 将与每个后续请求⼀起被发送出去。</li><li> 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进⾏⽐较，以验证⽤户的身份，返回给⽤户客户端响应信息的时候会附带⽤户当前的状态。</li></ol><p>使⽤ Session 的时候需要注意下⾯⼏个点：</p><ol><li>依赖Session的关键业务⼀定要确保客户端开启了Cookie</li><li>注意Session的过期时间</li></ol><h5 id="2-如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）"><a href="#2-如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）" class="headerlink" title="2.如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）"></a>2.如果没有Cookie的话Session还能⽤吗？（经典的⾯试题）</h5><p>⼀般是通过 Cookie 来保存 SessionID ，假如你使⽤了 Cookie 保存 SessionID的⽅案的话， 如果客户端禁⽤了Cookie，那么Seesion就⽆法正常⼯作。例如：在访问网页端某东时禁用Cookie后就不能访问了。但是，并不是没有 Cookie 之后就不能⽤ Session 了，⽐如你可以将SessionID放在请求的 url ⾥⾯ <span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vP3Nlc3Npb25faWQ9eHh4">https://javaguide.cn/?session_id=xxx<i class="fa fa-external-link-alt"></i></span> 。这种⽅案的话可⾏，但是安全性和⽤户体验感降低。当然，为了你也可以对 SessionID 进⾏⼀次加密之后再传⼊后端。</p><h5 id="3-为什么Cookie-⽆法防⽌CSRF攻击，⽽token可以？"><a href="#3-为什么Cookie-⽆法防⽌CSRF攻击，⽽token可以？" class="headerlink" title="3.为什么Cookie ⽆法防⽌CSRF攻击，⽽token可以？"></a>3.为什么Cookie ⽆法防⽌CSRF攻击，⽽token可以？</h5><p><strong>CSRF</strong>（Cross Site Request Forgery）⼀般被翻译为 <strong>跨站请求伪造</strong> 。那么什么是 跨站请求伪造 呢？说简单⽤你的身份去发送⼀些对你不友好的请求。举个简单的例⼦：</p><p>⼩明登录了某⽹上银⾏，他来到了⽹上银⾏的帖⼦区，看到⼀个帖⼦下⾯有⼀个链接写着“科学理财，年盈利率过万”，⼩明好奇的点开了这个链接，&lt;a src=<span class="exturl" data-url="aHR0cDovL3d3dy5teWJhbmsuY29tL1RyYW5zZmVyP2JhbmtJZD0xMSZhbXA7bW9uZXk9MTAwMDAmZ3Q7JUU3JUE3JTkxJUU1JUFEJUE2JUU3JTkwJTg2JUU4JUI0JUEyJUVGJUJDJThDJUU1JUI5JUI0JUU3JTlCJTg4JUU1JTg4JUE5JUU3JThFJTg3JUU4JUJGJTg3JUU0JUI4JTg3">http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万<i class="fa fa-external-link-alt"></i></span>&lt;/&gt;结果发现⾃⼰的账户少了10000元。这是这么回事呢？原来⿊客在链接中藏了⼀个请求，这个请求直接利⽤⼩壮的身份给银⾏发送了⼀个转账请求,也就是通过你的 Cookie 向银⾏发出请求。上⾯也提到过，进⾏Session 认证的时候，我们⼀般使⽤ Cookie 来存储 SessionId,当我们登陆后后端⽣成⼀个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储⼯具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个⼈。如果别⼈通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让⽤户误点攻击链接，达到攻击效果。但是，我们使⽤ token 的话就不会存在这个问题，<strong>在我们登录成功获得 token 之后，⼀般会选择存放在 local storage 中。</strong>然后我们在前端通过某些⽅式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了⾮法链接发送了请求到服务端，这个⾮法请求是不会携带 token 的，所以这个请求将是⾮法的。<strong>需要注意的是不论是 Cookie 还是 token 都⽆法避免跨站脚本攻击（Cross Site Scripting）XSS</strong>。跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading StyleSheets，CSS）的缩写混淆。因此，有⼈将跨站脚本攻击缩写为XSS。<strong>XSS中攻击者会⽤各种⽅式将恶意代码注⼊到其他⽤户的⻚⾯中。就可以通过脚本盗⽤信息⽐如cookie。</strong><br>推荐阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMTAvMTEvZmUtc2VjdXJpdHktY3NyZi5odG1s">如何防⽌CSRF攻击？——美团技术团队<i class="fa fa-external-link-alt"></i></span></p><h5 id="4-什么是-Token-什么是-JWT-如何基于Token进⾏身份验证？"><a href="#4-什么是-Token-什么是-JWT-如何基于Token进⾏身份验证？" class="headerlink" title="4.什么是 Token?什么是 JWT?如何基于Token进⾏身份验证？"></a>4.什么是 Token?什么是 JWT?如何基于Token进⾏身份验证？</h5><p>Token：Token不需要⾃⼰存放 Session 信息就能实现身份验证的⽅式；</p><p>JWT ：JWT （JSON Web Token） 就是这种⽅式的实现，通过这种⽅式服务器端就不需要保存 Session 数据了，只⽤在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。JWT  本质上就⼀段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p><h5 id="JWT-由-3-部分构成"><a href="#JWT-由-3-部分构成" class="headerlink" title="JWT 由 3 部分构成:"></a>JWT 由 3 部分构成:</h5><ol><li>Header :描述 JWT 的元数据。定义了⽣成签名的算法以及 Token 的类型。</li><li>Payload（负载）:⽤来存放实际需要传递的数据</li><li>Signature（签名）：服务器通过 Payload、 Header和⼀个密钥(secret)使⽤ Header ⾥⾯指定的签名算法（默认是 HMAC SHA256）⽣成。</li></ol><p><strong>实现原理</strong>：在基于 Token 进⾏身份验证的的应⽤程序中，服务器通过 Payload、 Header和⼀个密钥(secret)创建令牌（ Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage ⾥⾯，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie ⾥⾯⾃动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中： Authorization: Bearer Token。</p><h5 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h5><ol><li>⽤户向服务器发送⽤户名和密码⽤于登陆系统。</li><li>身份验证服务响应并返回了签名的 JWT，上⾯包含了⽤户是谁的内容。</li><li>⽤户以后每次向后端发请求都在Header中带上 JWT。</li><li>服务端检查 JWT 并从中获取⽤户相关信息。</li></ol><h3 id="6-用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢"><a href="#6-用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢" class="headerlink" title="6.用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢"></a>6.用过hashmap吗，hashmap的键和值可以存取null吗，hashtable的键和值可以存取null吗；他俩的本质区别是什么；我现在用一个hashmap初始容量12，那么这个hashmap的初始容量是多少呢</h3><p><strong>HashMap</strong>不能保证元素的顺序,HashMap能够将键设为<strong>null (一个key,实现map接口)**，也可以将值设为</strong>null（多个null）<strong>。与之对应的是</strong>Hashtable**,(注意大小写：不是HashTable)，Hashtable不能将键和值设为null，否则运行时会报空指针异常错误。</p><h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    ....</span><br><span class="line"><span class="comment">//Hashtable的put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h5><ol><li><p>线程是否安全： HashMap 是⾮线程安全的，Hashtable 是线程安全的；<strong>Hashtable 内部的⽅法基本都经过 synchronized 修饰</strong>。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap吧！）；</p></li><li><p>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，Hashtable 基本被淘汰，不要在代码中使⽤它；</p></li><li><p>对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有⼀个 null，直接抛出 NullPointerException。</p></li></ol><ol start="4"><li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①<strong>创建时如果不指定容量初始值，Hashtable 默认的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后每次扩充（resize（）），容量变为原来的2倍</strong>。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 <strong>tableSizeFor</strong>()⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是2的幂次⽅。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</li></ol><p><strong>HashMap中的key可以是任何对象或数据类型吗</strong></p><ul><li><strong>可以为null，但不能是可变对象</strong>，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li><li><strong>如果可变对象在 HashMap 中被用作键</strong>，<strong>那就要小心在改变对象状态的时候，不要改变它的哈希值了</strong>。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li></ul><p><strong>HashMap 中的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial </span></span><br><span class="line"><span class="string">capacity: &quot;</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">                                               </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    <span class="comment">//最终也会调用到上面的构造函数，不过这个默认的负载因子就是 HashMap 的默认负载因子也就是 0.75f</span></span><br><span class="line">    &#125;</span><br><span class="line">                                               </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class="comment">//带有 Map 的构造函数，会直接把外部元素批量放入 HashMap 中。</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;                                               </span><br><span class="line">                                               </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p><strong>下⾯这个⽅法（tableSizeFor）保证了 HashMap 总是使⽤2的幂作为哈希表的⼤⼩。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY </span><br><span class="line">: n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0</span></span><br><span class="line"><span class="comment">//  比如7的二进制是0111，7&gt;&gt;&gt;2表示右移2位，变成001，即为1</span></span><br><span class="line"><span class="comment">//  cap=8;n=7;n=0111  n|n&gt;&gt;&gt;1 = 0111 | 0011 = 0111 n|n&gt;&gt;&gt;2 0111 | 0001 = 0111</span></span><br><span class="line"><span class="comment">//n|n&gt;&gt;&gt;4 0111 | 0000 = 0111 最后一步 return=n+1=8</span></span><br><span class="line"><span class="comment">//  综上可得，当hashMap指定初始值的时候，会调用tableSizeFor方法，总是返回2的n次方的值；</span></span><br><span class="line">        <span class="comment">//  并且总是等于该算法接近该初始值并比它大的那个值;</span></span><br><span class="line"><span class="comment">//  就是让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。当指定初始值入参</span></span><br><span class="line"><span class="comment">//为0时，返回实际容量为1。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//最大容量为2的30次方 </span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> h;</span><br><span class="line">         <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//DK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的</span></span><br><span class="line">    <span class="comment">//hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置</span></span><br><span class="line"> <span class="comment">//（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash</span></span><br><span class="line"><span class="comment">//值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span><br><span class="line"><span class="comment">//所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现</span></span><br><span class="line"><span class="comment">//⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"> <span class="comment">// 1. HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash      </span></span><br><span class="line"> <span class="comment">//的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</span></span><br><span class="line"> <span class="comment">// 2. 由于HashMap规定了其容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小。使用位运算同时 </span></span><br><span class="line">     <span class="comment">//还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于           </span></span><br><span class="line">     <span class="comment">//HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运</span></span><br><span class="line">     <span class="comment">//算符表示就是 1 &lt;&lt; 30，int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16;</span></span><br><span class="line">      <span class="comment">// 默认初始容量为16，必须为2的幂</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">// 默认加载因子0.75；</span></span><br><span class="line"><span class="comment">//HashMap默认初始容量16，加载因子0.75，也就是说最多能放16*0.75=12个元素，当put第13个时，HashMap</span></span><br><span class="line">    <span class="comment">//将发生rehash，rehash的一系列处理比较影响性能，所以当我们需要向HashMap存放较多元素时，最好指定合   </span></span><br><span class="line">    <span class="comment">//适的初始容量和加载因子，否则HashMap默认只能存12个元素，将会发生多次rehash操作。</span></span><br></pre></td></tr></table></figure><h5 id="HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩"><a href="#HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩" class="headerlink" title="HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩"></a>HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩</h5><ol><li>HashMap<strong>在确定数组下标Index的时候</strong>，采用的是( length-1) &amp; hash 的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</li><li>由于HashMap规定了其<strong>容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小</strong>。使用位运算同时还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30，<strong>int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</strong></li></ol><h2 id="讲一讲-HashMap-put-的全过程"><a href="#讲一讲-HashMap-put-的全过程" class="headerlink" title="讲一讲 HashMap put 的全过程"></a>讲一讲 HashMap put 的全过程</h2><p>以 JDK 1.8 为基准进行分析，后面也是。先贴出整段代码，后面会逐行进行分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">// 如果table 为null 或者没有为 table 分配内存，就resize一次</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">// 指定hash值节点为空则直接插入，这个(n - 1) &amp; hash才是表中真正的哈希</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 如果不为空</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">// 计算表中的这个真正的哈希值与要插入的key.hash相比</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 若不同的话，并且当前节点已经在 TreeNode 上了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      <span class="comment">// 采用红黑树存储方式</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">// key.hash 不同并且也不再 TreeNode 上，在链表上找到 p.next==null</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 在表尾插入</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 新增节点后如果节点个数到达阈值，则进入 treeifyBin() 进行再次判断</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了同 hash、key 的节点，那么直接退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 更新 p 指向下一节点</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map中含有旧值，返回旧值</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map调整次数 + 1</span></span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">// 键值对的数量达到阈值，需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下 <code>putVal</code> 方法，这个方法是 final 的，如果你自已定义 HashMap 继承的话，是不允许你自己重写 put 方法的，然后这个方法涉及五个参数</p><ul><li>hash -&gt; put 放在桶中的位置，在 put 之前，会进行 hash 函数的计算。</li><li>key -&gt; 参数的 key 值</li><li>value -&gt; 参数的 value 值</li><li>onlyIfAbsent -&gt; 是否改变已经存在的值，也就是是否进行 value 值的替换标志</li><li>evict -&gt; 是否是刚创建 HashMap 的标志</li></ul><p><strong>在调用到 putVal 方法时，首先会进行 hash 函数计算应该插入的位置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希函数的源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hash 函数会根据你传递的 key 值进行计算，首先计算 key 的 <code>hashCode</code> 值，然后再对 hashcode 进行无符号右移操作，最后再和 hashCode 进行<code>异或 ^</code> 操作。</p><ul><li><code>&gt;&gt;&gt;</code>: 无符号右移操作，它指的是 <strong>无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong> ，也就是不管是正数还是负数，右移都会在空缺位补 0 。</li></ul><p>在得到 hash 值后，就会进行 put 过程。</p><p>首先会判断 HashMap 中的 Node 数组是否为 null，如果第一次创建 HashMap 并进行第一次插入元素，首先会进行数组的 resize，也就是<code>重新分配</code>，这里还涉及到一个 <code>resize()</code> 扩容机制源码分析，我们后面会介绍。<strong>扩容完毕后，会计算出 HashMap 的存放位置，通过使用 ( n - 1 ) &amp; hash 进行计算得出。</strong></p><p>然后会把这个位置作为数组的下标作为存放元素的位置。如果不为空，那么计算表中的这个真正的哈希值与要插入的 key.hash 相比。如果哈希值相同，key-value 不一样，再判断是否是树的实例，如果是的话，那么就把它插入到树上。如果不是，就执行尾插法在 entry 链尾进行插入。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。好在 HashMap 是一种自动扩容的数据结构，在这种基于变长的数据结构中，扩容机制是非常重要的。</p><p>在 HashMap 中，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。HashMap 中的扩容机制是由 <code>resize()</code> 方法来实现的，下面我们就来一次认识下。（贴出中文注释，便于复制）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">// 存储old table 的大小</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">// 存储扩容阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果old table数据已达最大，那么threshold也被设置成最大</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左移扩大二倍,</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">// 扩容成原来二倍</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果oldThr                                                                                                                                               !&gt; 0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="comment">// 如果old table &lt;= 0 并且 存储的阈值 &lt;= 0</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果扩充阈值为0</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 扩容阈值为 初始容量*负载因子</span></span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重新给负载因子赋值</span></span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="comment">// 获取扩容后的数组</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="comment">// 如果第一次进行table 初始化不会走下面的代码</span></span><br><span class="line">  <span class="comment">// 扩容之后需要重新把节点放在新扩容的数组中</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以 if...else if...else 逻辑进行拆分，上面代码主要做了这几个事情</p><ul><li>判断 HashMap 中的数组的长度，也就是 <code>(Node&lt;K,V&gt;[])oldTab.length()</code> ，再判断数组的长度是否比最大的的长度也就是 2^30 次幂要大，大的话直接取最大长度，否则利用位运算 <code>&lt;&lt;</code>扩容为原来的两倍</li><li>如果数组长度不大于0 ，再判断扩容阈值 <code>threshold</code> 是否大于 0 ，也就是看有无外部指定的扩容阈值，若有则使用，这里需要说明一下 threshold 何时是 <code>oldThr &gt; 0</code>，因为 oldThr = threshold ，这里其实比较的就是 threshold，因为 HashMap 中的每个构造方法都会调用 <code>HashMap(initCapacity,loadFactor)</code> 这个构造方法，所以如果没有外部指定 initialCapacity，初始容量使用的就是 16，然后根据 <code>this.threshold = tableSizeFor(initialCapacity);</code> 求得 threshold 的值。</li></ul><p>然后会判断 newThr 是否为 0 ，笔者在刚开始研究时发现 <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code> 一直以为这是常量做乘法，怎么会为 0 ，其实不是这部分的问题，在于上面逻辑判断中的扩容操作，可能会导致<code>位溢出</code>。</p><p>导致位溢出的示例：oldCap = 2^28 次幂，threshold &gt; 2 的三次方整数次幂。在进入到 <code>float ft = (float)newCap * loadFactor;</code> 这个方法是 2^28 * 2^(3+n) 会直接 &gt; 2^31 次幂，导致全部归零。</p><p><strong>在扩容后需要把节点放在新扩容的数组中，这里也涉及到三个步骤</strong></p><ul><li>循环桶中的每个 Node 节点，判断 Node[i] 是否为空，为空直接返回，不为空则遍历桶数组，并将键值对映射到新的桶数组中。</li><li>如果不为空，再判断是否是树形结构，如果是树形结构则按照树形结构进行拆分，拆分方法在 <code>split</code> 方法中。</li><li>如果不是树形结构，则遍历链表，并将链表节点按原顺序进行分组。</li></ul><h3 id="讲一讲-get-方法全过程"><a href="#讲一讲-get-方法全过程" class="headerlink" title="讲一讲 get 方法全过程"></a>讲一讲 get 方法全过程</h3><p>我们上面讲了 HashMap 中的 put 方法全过程，下面我们来看一下 <code>get</code> 方法的过程，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到真实的元素位置</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会check 一下第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">        ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是第一个元素，并且下一个元素不是空的</span></span><br><span class="line">    <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否属于 TreeNode，如果是 TreeNode 实例，直接从 TreeNode.getTreeNode 取</span></span><br><span class="line">      <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果还不是 TreeNode 实例，就直接循环数组元素，直到找到指定元素位置</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来简单介绍下吧，首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p><p><code>getNode</code> 方法有一个比较重要的过程就是 <strong>(n - 1) &amp; hash</strong>，这段代码是确定需要查找的桶的位置的，那么，为什么要 (n - 1) &amp; hash 呢？</p><p>n 就是 HashMap 中桶的数量，这句话的意思也就是说 (n - 1) &amp; hash 就是 (桶的容量 - 1) &amp; hash</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么 HashMap 的检索位置是 (table.size - 1) &amp; hash</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debug 得知 1 的 hash 值算出来是 49</span></span><br><span class="line">  map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line">  <span class="comment">// debug 得知 1 的 hash 值算出来是 50</span></span><br><span class="line">  map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line">  <span class="comment">// debug 得知 1 的 hash 值算出来是 51</span></span><br><span class="line">  map.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么每次算完之后的 (n - 1) &amp; hash ，依次为1 2 3 </p><h3 id="HashMap-的遍历方式"><a href="#HashMap-的遍历方式" class="headerlink" title="HashMap 的遍历方式"></a>HashMap 的遍历方式</h3><p>HashMap 的遍历，也是一个使用频次特别高的操作</p><p>HashMap 遍历的基类是 <code>HashIterator</code>，它是一个 Hash 迭代器，它是一个 HashMap 内部的抽象类，它的构造比较简单，只有三种方法，<strong>hasNext 、 remove 和 nextNode</strong> 方法，其中 nextNode 方法是由三种迭代器实现的</p><p>这三种迭代器就就是</p><ul><li><code>KeyIterator</code> ，对 key 进行遍历</li><li><code>ValueIterator</code>，对 value 进行遍历</li><li><code>EntryIterator</code>， 对 Entry 链进行遍历</li></ul><p>虽然说看着迭代器比较多，但其实他们的遍历顺序都是一样的，构造也非常简单，都是使用 <code>HashIterator</code> 中的 <code>nextNode</code> 方法进行遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashIterator 中的遍历方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; next;        <span class="comment">// 下一个 entry 节点</span></span><br><span class="line">  Node&lt;K,V&gt; current;     <span class="comment">// 当前 entry 节点</span></span><br><span class="line">  <span class="keyword">int</span> expectedModCount;  <span class="comment">// fail-fast 的判断标识</span></span><br><span class="line">  <span class="keyword">int</span> index;             <span class="comment">// 当前槽</span></span><br><span class="line"></span><br><span class="line">  HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = <span class="keyword">null</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">      <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next 和 current 分别表示下一个 Node 节点和当前的 Node 节点，HashIterator 在初始化时会遍历所有的节点。下面我们用图来表示一下他们的遍历顺序</p><p>你会发现 <code>nextNode()</code> 方法的遍历方式和 HashIterator 的遍历方式一样，只不过判断条件不一样，构造 HashIterator 的时候判断条件是有没有链表，桶是否为 null，而遍历 nextNode 的判断条件变为下一个 node 节点是不是 null ，并且桶是不是为 null。</p><h3 id="HashMap-中的移除方法"><a href="#HashMap-中的移除方法" class="headerlink" title="HashMap 中的移除方法"></a>HashMap 中的移除方法</h3><p>HashMap 中的移除方法也比较简单了，源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">    <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      node = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key ||</span><br><span class="line">               (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            node = e;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          p = e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                         (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">        tab[index] = node.next;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        p.next = node.next;</span><br><span class="line">      ++modCount;</span><br><span class="line">      --size;</span><br><span class="line">      afterNodeRemoval(node);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法有很多，最终都会调用到 removeNode 方法，只不过传递的参数值不同，我们拿 remove(object) 来演示一下。</p><p>首先会通过 hash 来找到对应的 bucket，然后通过遍历链表，找到键值相等的节点，然后把对应的节点进行删除。</p><h2 id="关于-HashMap-的面试题"><a href="#关于-HashMap-的面试题" class="headerlink" title="关于 HashMap 的面试题"></a>关于 HashMap 的面试题</h2><h3 id="HashMap-的数据结构"><a href="#HashMap-的数据结构" class="headerlink" title="HashMap 的数据结构"></a>HashMap 的数据结构</h3><p>JDK1.7 中，HashMap 采用<code>位桶 + 链表</code>的实现，即使用<code>链表</code>来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。</p><p>所以，与 JDK 1.7 相比，JDK 1.8 在底层结构方面做了一些改变，当每个桶中元素大于 8 的时候，会转变为红黑树，目的就是优化查询效率。</p><h3 id="HashMap-的-put-过程"><a href="#HashMap-的-put-过程" class="headerlink" title="HashMap 的 put 过程"></a>HashMap 的 put 过程</h3><p>大致过程如下，首先会使用 hash 方法计算对象的哈希码，根据哈希码来确定在 bucket 中存放的位置，如果 bucket 中没有 Node 节点则直接进行 put，如果对应 bucket 已经有 Node 节点，会对链表长度进行分析，判断长度是否大于 8，如果链表长度小于 8 ，在 JDK1.7 前会使用头插法，在 JDK1.8 之后更改为尾插法。如果链表长度大于 8 会进行树化操作，把链表转换为红黑树，在红黑树上进行存储。</p><h3 id="HashMap-为啥线程不安全"><a href="#HashMap-为啥线程不安全" class="headerlink" title="HashMap 为啥线程不安全"></a>HashMap 为啥线程不安全</h3><p>HashMap 不是一个线程安全的容器，不安全性体现在多线程并发对 HashMap 进行 put 操作上。如果有两个线程 A 和 B ，首先 A 希望插入一个键值对到 HashMap 中，在决定好桶的位置进行 put 时，此时 A 的时间片正好用完了，轮到 B 运行，B 运行后执行和 A 一样的操作，只不过 B 成功把键值对插入进去了。如果 A 和 B 插入的位置（桶）是一样的，那么线程 A 继续执行后就会覆盖 B 的记录，造成了数据不一致问题。</p><p>还有一点在于 HashMap 在扩容时，因 resize 方法会形成环，造成死循环，导致 CPU 飙高。</p><h3 id="HashMap-是如何处理哈希（冲突）碰撞的"><a href="#HashMap-是如何处理哈希（冲突）碰撞的" class="headerlink" title="HashMap 是如何处理哈希（冲突）碰撞的"></a>HashMap 是如何处理哈希（冲突）碰撞的</h3><p>HashMap 底层是使用位桶 + 链表实现的，位桶决定元素的插入位置，位桶是由 hash 方法决定的，当多个元素的 hash 计算得到相同的哈希值后，HashMap 会把多个 Node 元素都放在对应的位桶中，形成链表，这种处理哈希碰撞的方式被称为链地址法。</p><p>其他处理 hash 碰撞的方式还有 <strong>开放地址法、rehash 方法、建立一个公共溢出区</strong>这几种方法。</p><h3 id="HashMap-是如何-get-元素的"><a href="#HashMap-是如何-get-元素的" class="headerlink" title="HashMap 是如何 get 元素的"></a>HashMap 是如何 get 元素的</h3><p>首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p><h3 id="HashMap-和-HashTable-有什么区别"><a href="#HashMap-和-HashTable-有什么区别" class="headerlink" title="HashMap 和 HashTable 有什么区别"></a>HashMap 和 HashTable 有什么区别</h3><p>父类不同：HashMap 继承了 <code>AbstractMap</code> 类，而 HashTable 继承了 <code>Dictionary</code> 类</p><p>空值不同：HashMap 允许空的 key 和 value 值，HashTable 不允许空的 key 和 value 值。HashMap 会把 Null key 当做普通的 key 对待。不允许 null key 重复。</p><p>线程安全性：HashMap 不是线程安全的，如果多个外部操作同时修改 HashMap 的数据结构比如 add 或者是 delete，必须进行同步操作，仅仅对 key 或者 value 的修改不是改变数据结构的操作。可以选择构造线程安全的 Map 比如 <code>Collections.synchronizedMap</code> 或者是 <code>ConcurrentHashMap</code>。而 HashTable 本身就是线程安全的容器。</p><p>性能方面：虽然 HashMap 和 HashTable 都是基于单链表的，但是 HashMap 进行 put 或者 get􏱤 操作，可以达到常数时间的性能；而 HashTable 的 put 和 get 操作都是加了 <code>synchronized</code> 锁的，所以效率很差。</p><h3 id="HashMap-和-HashSet-的区别"><a href="#HashMap-和-HashSet-的区别" class="headerlink" title="HashMap 和 HashSet 的区别"></a>HashMap 和 HashSet 的区别</h3><p>HashSet 继承于 AbstractSet 接口，实现了 Set、Cloneable,、java.io.Serializable 接口。HashSet 不允许集合中出现重复的值。HashSet 底层其实就是 HashMap，所有对 HashSet 的操作其实就是对 HashMap 的操作。所以 HashSet 也不保证集合的顺序。</p><h3 id="HashMap-是如何扩容的"><a href="#HashMap-是如何扩容的" class="headerlink" title="HashMap 是如何扩容的"></a>HashMap 是如何扩容的</h3><p>HashMap 中有两个非常重要的变量，一个是 <code>loadFactor</code> ，一个是 <code>threshold</code> ，loadFactor 表示的就是负载因子，threshold 表示的是下一次要扩容的阈值，当 threshold = loadFactor * 数组长度时，数组长度扩大位原来的两倍，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。</p><h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>这道题我想了几天，之前和群里小伙伴们探讨每日一题的时候，问他们为什么 length%hash == (n - 1) &amp; hash，它们说相等的前提是 length 的长度 2 的幂次方，然后我回了一句难道 length 还能不是 2 的幂次方吗？其实是我没有搞懂因果关系，因为 HashMap 的长度是 2 的幂次方，所以使用余数来判断在桶中的下标。如果 length 的长度不是 2 的幂次方，小伙伴们可以举个例子来试试</p><blockquote><p>例如长度为 9 时候，3 &amp; (9-1) = 0，2 &amp; (9-1) = 0 ，都在 0 上，碰撞了；</p></blockquote><p>这样会增大 HashMap 碰撞的几率。</p><h3 id="HashMap-线程安全的实现有哪些"><a href="#HashMap-线程安全的实现有哪些" class="headerlink" title="HashMap 线程安全的实现有哪些"></a>HashMap 线程安全的实现有哪些</h3><p>因为 HashMap 不是一个线程安全的容器，所以并发场景下推荐使用 <code>ConcurrentHashMap</code> ，或者使用线程安全的 HashMap，使用 <code>Collections</code> 包下的线程安全的容器，比如说</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure><p>还可以使用 HashTable ，它也是线程安全的容器，基于 key-value 存储，经常用 HashMap 和 HashTable 做比较就是因为 HashTable 的数据结构和 HashMap 相同。</p><p>上面效率最高的就是 ConcurrentHashMap。</p><h3 id="7-说说你了解的springcloud-里面有什么组件呢"><a href="#7-说说你了解的springcloud-里面有什么组件呢" class="headerlink" title="7.说说你了解的springcloud,里面有什么组件呢"></a>7.说说你了解的springcloud,里面有什么组件呢</h3><p>SpringCloud：分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶</p><p>Spring Cloud是一个微服务框架，相比Dubbo等RPC框架, <strong>Spring Cloud提供的全套的分布式系统解决方案</strong>。</p><p>Spring Cloud对微服务基础框架Netflix的多个开源组件进行了封装，同时又实现了和云端平台以及和Spring Boot开发框架的集成。 </p><p>Spring Cloud为微服务架构开发涉及的<strong>配置管理，服务治理，熔断机制，智能路由，微代理，控制总线，一次性token，全局一致性锁，leader选举，分布式session，集群状态</strong>管理等操作提供了一种简单的开发方式。</p><p>Spring Cloud 为开发者提供了快速构建<strong>分布式系统的工具</strong>，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。  </p><h4 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h4><ul><li>Eureka：注册中心；各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</li><li>Zuul、Gateway：网关；如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</li><li>Ribbon：负载均衡；服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</li><li>Feign：服务调用；基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</li><li>Hystrix或Resilience4j：熔断器；发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</li></ul><p><img data-src="https://i.loli.net/2020/11/01/3u8IwCHq7N4Fvif.jpg" loading="lazy"></p><h3 id="8-说说你了解的spring-Boot"><a href="#8-说说你了解的spring-Boot" class="headerlink" title="8.说说你了解的spring Boot"></a>8.说说你了解的spring Boot</h3><p>Spring Boot是Spring开源组织下的一个子项目，也是Spring组件一站式解决方案，主要是为了简化使用Spring框架的难度，简省繁重的配置。</p><p>设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><p>SpringBoot所具备的特征有：</p><ol><li>可以创建独立的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TcHJpbmcvODUwNjE=">Spring<i class="fa fa-external-link-alt"></i></span>应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</li><li>内嵌Tomcat或Jetty等Servlet容器,Spring Boot 只要打成一个可执行的jar包就能独立运行，所有的依赖包都    在一个jar包内。</li><li>提供自动配置的“starter”项目对象模型（POMS）以简化<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NYXZlbi82MDk0OTA5">Maven<i class="fa fa-external-link-alt"></i></span>配置；</li><li>尽可能自动配置Spring容器；</li><li>提供准备好的特性，如指标、健康检查和外部化配置；</li><li>绝对没有代码生成，不需要XML配置。 </li></ol><p>SpringBoot框架中还有两个非常重要的策略：开箱即用和约定优于配置。开箱即用，Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。</p><h2 id="第二个现场面试"><a href="#第二个现场面试" class="headerlink" title="第二个现场面试"></a>第二个现场面试</h2><p>问的很基础，具体我都快忘了，写这个时已经过好几天了；</p><h3 id="1-java类和接口的理解"><a href="#1-java类和接口的理解" class="headerlink" title="1.java类和接口的理解"></a>1.java类和接口的理解</h3><p>java类只能单继承，扩展单一，但一个类可以实现多个接口；而接口可以进行多继承。</p><h3 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h3><p>一个程序在运行开始会产生一个进程，一个进程可以产生多个线程，实现多线程的方法有继承Thread类、实现Runnable接口、使用Callable接口和Future接口。</p><h3 id="3-io，怎么读一个文件，给你一个路径"><a href="#3-io，怎么读一个文件，给你一个路径" class="headerlink" title="3.io，怎么读一个文件，给你一个路径"></a>3.io，怎么读一个文件，给你一个路径</h3><p>我们可以根据文件类型，选择不同io子类来读取文件。</p><p>如果是二进制文件，使用FileInputStream读取；如果是文本文件，使用FileReader读取；</p><p>这两个类允许我们从文件开始至文件结尾一个字节或字符的读取文件，或者将读取的文件写入字节数组或字符数组。</p><p>如果我们想随机的读取文件内容，可以使用RandomAccessFile。</p><p><img data-src="https://i.loli.net/2020/11/01/o8iax6JsrGzPpT7.png" loading="lazy"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个只是读文件</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> asc= -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//FileInputStream的read()返回的数字是ASCII码 //注意：其中包括着“\r和\n”两个字符(\r:13,\n:10)</span></span><br><span class="line"><span class="keyword">while</span>((asc=in.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//将char型强行转制为int型得到的是Ascii码//将int型强行转制为char型得到的是字符</span></span><br><span class="line">    System.out.print((<span class="keyword">char</span>)asc);</span><br><span class="line">&#125;</span><br><span class="line"> in.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件(字节流)</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>);</span><br><span class="line"><span class="comment">//写入相应的文件</span></span><br><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\2.txt&quot;</span>);</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="comment">//一次性取多少字节</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line"><span class="comment">//接受读取的内容(返回的n是读入数组bytes[]的总字节数)</span></span><br><span class="line"><span class="comment">//read返回值是读入缓冲区的字节总数,如果因为已经到达文件末尾而没有更多的数据,则返回 -1.意思是已经到达末尾.</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//循环取出数据</span></span><br><span class="line"><span class="keyword">while</span> ((n = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//转换成字符串</span></span><br><span class="line">    String str = new String(bytes,0,n,&quot;GBK&quot;); #这里可以实现字节到字符串的转换，比较实用</span><br><span class="line">    <span class="comment">//String str = new String(bytes,&quot;GBK&quot;);//这个也行</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">//写入相关文件</span></span><br><span class="line">    out.write(bytes, <span class="number">0</span>, n);</span><br><span class="line">    <span class="comment">//out.write(bytes);//这个也行</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//把缓存在内存中残留的数据压入文件中，并清除缓存</span></span><br><span class="line">out.flush();</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件(缓存字节流)</span></span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>));</span><br><span class="line"><span class="comment">//写入相应的文件</span></span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\2.txt&quot;</span>));</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="comment">//一次性取多少字节</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line"><span class="comment">//接受读取的内容(返回的n是读入数组bytes[]的总字节数)</span></span><br><span class="line"><span class="comment">//read返回值是读入缓冲区的字节总数,如果因为已经到达文件末尾而没有更多的数据,则返回 -1.意思是已经到达末尾.</span></span><br><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环取出数据</span></span><br><span class="line"><span class="keyword">while</span> ((n = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//转换成字符串</span></span><br><span class="line">    String str = <span class="keyword">new</span> String(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">//写入相关文件</span></span><br><span class="line">    out.write(bytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把缓存在内存中残留的数据压入文件中，并清除缓存</span></span><br><span class="line">out.flush();</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h3 id="4-mysql索引优化"><a href="#4-mysql索引优化" class="headerlink" title="4.mysql索引优化"></a>4.mysql索引优化</h3><h3 id="5-springcloud是什么"><a href="#5-springcloud是什么" class="headerlink" title="5.springcloud是什么"></a>5.springcloud是什么</h3><h3 id="6-冒泡排序原理"><a href="#6-冒泡排序原理" class="headerlink" title="6.冒泡排序原理"></a>6.冒泡排序原理</h3><h3 id="7-前端技术html，CSS，ajax，jquery，javascript是什么"><a href="#7-前端技术html，CSS，ajax，jquery，javascript是什么" class="headerlink" title="7.前端技术html，CSS，ajax，jquery，javascript是什么"></a>7.前端技术html，CSS，ajax，jquery，javascript是什么</h3><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p>HTML代表超文本标记语言（Hyper Text Markup Language），它不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。它是静态的。与之相对应的是jsp动态网页。</p><p>作用</p><p>静态网站是指全部由<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M">HTML<i class="fa fa-external-link-alt"></i></span>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==">标准通用标记语言<i class="fa fa-external-link-alt"></i></span>的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种视觉动态效果，如GIF动画、FLASH动画、滚动字幕等，而网站主要是静态化的页面和代码组成，一般文件名均以<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9odG0vMzIxMzMzNg==">htm<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9odG1sLzk3MDQ5">html<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zaHRtbC81OTQ5MjE=">shtml<i class="fa fa-external-link-alt"></i></span>等为<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEUlRTclQkMlODAvMTEwMTE2ODM=">后缀<i class="fa fa-external-link-alt"></i></span>。</p><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p>CSS层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IVE1M">HTML<i class="fa fa-external-link-alt"></i></span>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTAlODclRTUlODclODYlRTklODAlOUElRTclOTQlQTglRTYlQTAlODclRTglQUUlQjAlRTglQUYlQUQlRTglQTglODAvNjgwNTA3Mw==">标准通用标记语言<i class="fa fa-external-link-alt"></i></span>的一个应用）或<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9YTUw=">XML<i class="fa fa-external-link-alt"></i></span>（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，**还可以配合各种脚本语言动态地对网页各元素进行格式化。 ** </p><p>作用：</p><p>丰富的样式、定义易于使用和修改、多页面应用、层叠、页面压缩</p><h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p><p>Ajax不是一个技术，它实际上是几种技术，每种技术都有其独特这处，合在一起就成了一个功能强大的新技术</p><p>Ajax包括： </p><ul><li>XHTML和CSS</li><li>使用文档对象模型(DocumentObjectModel)作动态显示和交互 </li><li>使用XML和XSLT做数据交互和操作 </li><li>使用XMLHttpRequest进行异步数据接收 </li><li>使用JavaScript将它们绑定在一起 </li></ul><p>作用：</p><p>Ajax，异步JavaScript与XML，是使用客户端脚本与Web服务器交换数据的Web应用开发方法。这样，Web页面不用打断交互流程进行重新加裁，就可以动态地更新。使用Ajax，你可以创建接近本地桌面应用的，直接的、高可用的、更丰富的、更动态的Web用户接口界面。 </p><h5 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h5><p>JQuery实际上就是对现有的JavaScript的一种扩展，它非常轻量级，压缩后大概32KB，它兼容于各种浏览器，这样就可以非常方便地添加适用于多种浏览器的特效。</p><p>作用：</p><p>jQuery本身是一个基于插件的JavaScript库，它的各种功能可以通过新的插件进行增强。jQuery为Web编程提供了一个抽象的层，使得它可以兼容于任何浏览器，并且大大简化了原先用JavaScript做的工作，总而言之， jQuery可以完成如下所示的工作。</p><p>优点</p><ul><li><p>利用css的选择器提供高速的元素查找行为。</p></li><li><p>提供了一个抽象层来标准化各种常见的任务，可以解决各种浏览器的兼容问题。</p></li><li><p>将复杂的代码简化，提供连缀编程模式，大大简化了代码的操作。</p></li></ul><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><p>JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的是一种解释性脚本语言（代码不进行预编译）主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。</p><h3 id="8-什么是redis"><a href="#8-什么是redis" class="headerlink" title="8.什么是redis"></a>8.什么是redis</h3><p>开源免费的，c编译的，是一个<strong>高效能的键值分布式内存数据库</strong>，<strong>基于内存运行并支持持久化的NOSQL数据库。</strong></p>]]></content>
    
    
    <summary type="html">作为纪念</summary>
    
    
    
    <category term="面试" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://yuhaicheng.xyz/2020-10-28-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://yuhaicheng.xyz/2020-10-28-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</id>
    <published>2020-10-28T02:05:14.000Z</published>
    <updated>2020-10-28T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>感觉现在网上介绍的单例模式大部分都很不全面，要不是种类不够，就是写的不够深，介绍的都不全面，所以我会花大量时间写一个单例模式的全面解析，包括介绍、优缺点、多线程下安全与否、模拟攻击单例模式。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​        单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>​        单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个 Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。</p><p>​        总之，选择单例模式就是为了避免不一致状态。 </p><h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式（立即加载）</span></span><br><span class="line"><span class="comment"> * 饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的</span></span><br><span class="line"><span class="comment"> * （事实上，通过 反射机制是能够实例化构造方法为 的类的，会使 单例实现失效） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;@&quot;</span>+Singleton.getInstance().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SingletonTest singleton = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">SingletonTest singleton1 = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">singleton.start();</span><br><span class="line">singleton1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">  </span><br><span class="line">线程Thread-<span class="number">0</span>@<span class="number">366712642</span></span><br><span class="line">线程Thread-<span class="number">1</span>@<span class="number">366712642</span></span><br></pre></td></tr></table></figure><h3 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式（延迟加载）：</span></span><br><span class="line"><span class="comment"> * 该示例虽然用延迟加载方式实现了懒汉式单例，但在多线程环境下会产生多个 对象  是不安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                s = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>+currentThread().getName()+<span class="string">&quot;@&quot;</span>+Singleton.getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonTest s = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">        SingletonTest s1= <span class="keyword">new</span> SingletonTest();</span><br><span class="line">        SingletonTest s2= <span class="keyword">new</span> SingletonTest();</span><br><span class="line">        s.start();</span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    线程Thread-<span class="number">0</span>@<span class="number">1089813737</span></span><br><span class="line">线程Thread-<span class="number">2</span>@<span class="number">2056467717</span></span><br><span class="line">线程Thread-<span class="number">1</span>@<span class="number">431309546</span></span><br></pre></td></tr></table></figure><h3 id="3-懒汉式（加同步锁、使之安全）"><a href="#3-懒汉式（加同步锁、使之安全）" class="headerlink" title="3.懒汉式（加同步锁、使之安全）"></a>3.懒汉式（加同步锁、使之安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同步锁（解决线程安全问题）： </span></span><br><span class="line"><span class="comment">在方法上加 synchronized 同步锁或是用同步代码块对类加同步锁，此种方式虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程</span></span><br><span class="line"><span class="comment">想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                instance=<span class="keyword">new</span> Singleton3();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;@&quot;</span>+Singleton3.getInstance().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SingletonTest3 s1 = <span class="keyword">new</span> SingletonTest3();</span><br><span class="line">SingletonTest3 s2 = <span class="keyword">new</span> SingletonTest3();</span><br><span class="line">SingletonTest3 s3 = <span class="keyword">new</span> SingletonTest3();</span><br><span class="line">s1.start();</span><br><span class="line">s2.start();</span><br><span class="line">s3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">    线程Thread-<span class="number">2</span>@<span class="number">280481333</span></span><br><span class="line">线程Thread-<span class="number">0</span>@<span class="number">280481333</span></span><br><span class="line">线程Thread-<span class="number">1</span>@<span class="number">280481333</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-双重检查锁（提高同步锁的效率）"><a href="#4-双重检查锁（提高同步锁的效率）" class="headerlink" title="4.双重检查锁（提高同步锁的效率）"></a>4.双重检查锁（提高同步锁的效率）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查锁（提高同步锁的效率）： </span></span><br><span class="line"><span class="comment">使用双重检查锁进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率。</span></span><br><span class="line"><span class="comment">        这里还用到了volatile关键字来修饰singleton，其最关键的作用是防止指令重排</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton4 instance=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"> instance=<span class="keyword">new</span> Singleton4();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5.静态内部类"></a>5.静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类： </span></span><br><span class="line"><span class="comment">这种方式引入了一个内部静态类（static class），静态内部类只有在调用时才会加载，它保证了Singleton 实例的延迟初始化，又保证了实例的唯一性。</span></span><br><span class="line"><span class="comment">它把singleton 的实例化操作放到一个静态内部类中，在第一次调用getInstance() 方法时，JVM 才会去加载InnerObject 类，同时初始化singleton 实例，</span></span><br><span class="line"><span class="comment">所以能让 getInstance() 方法线程安全。 </span></span><br><span class="line"><span class="comment">特点是：即能延迟加载，也能保证线程安全。 </span></span><br><span class="line"><span class="comment">静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance = <span class="keyword">new</span> Singleton5(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> InnerObject.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest5</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;@&quot;</span>+Singleton5.getInstance().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SingletonTest5 s1 = <span class="keyword">new</span> SingletonTest5();</span><br><span class="line">SingletonTest5 s2 = <span class="keyword">new</span> SingletonTest5();</span><br><span class="line">SingletonTest5 s3 = <span class="keyword">new</span> SingletonTest5();</span><br><span class="line">s1.start();</span><br><span class="line">s2.start();</span><br><span class="line">s3.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反射攻击</span></span><br><span class="line">Singleton5 singleton = Singleton5.getInstance();</span><br><span class="line">    Constructor&lt;Singleton5&gt; constructor = Singleton5.class.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Singleton5 newSingleton = constructor.newInstance();</span><br><span class="line">    System.out.println(singleton == newSingleton);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">    线程Thread-<span class="number">1</span>@<span class="number">1311878651</span></span><br><span class="line">线程Thread-<span class="number">2</span>@<span class="number">1311878651</span></span><br><span class="line">线程Thread-<span class="number">0</span>@<span class="number">1311878651</span></span><br><span class="line">    flase</span><br></pre></td></tr></table></figure><h3 id="6-枚举类实现（防止反射攻击）"><a href="#6-枚举类实现（防止反射攻击）" class="headerlink" title="6.枚举类实现（防止反射攻击）"></a>6.枚举类实现（防止反射攻击）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String objName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getObjName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjName</span><span class="params">(String objName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objName = objName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton firstSingleton = Singleton.INSTANCE;</span><br><span class="line">        firstSingleton.setObjName(<span class="string">&quot;firstName&quot;</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        Singleton secondSingleton = Singleton.INSTANCE;</span><br><span class="line">        secondSingleton.setObjName(<span class="string">&quot;secondName&quot;</span>);</span><br><span class="line">        System.out.println(firstSingleton.getObjName());</span><br><span class="line">        System.out.println(secondSingleton.getObjName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">            <span class="keyword">for</span> (Singleton enumConstant : enumConstants) &#123;</span><br><span class="line">                System.out.println(enumConstant.getObjName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    firstName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><p>最后一种还不算太会，等会了在说！！！</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="设计模式" scheme="https://yuhaicheng.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例设计" scheme="https://yuhaicheng.xyz/tags/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 基础笔试题</title>
    <link href="https://yuhaicheng.xyz/2020-10-27-java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98.html"/>
    <id>https://yuhaicheng.xyz/2020-10-27-java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AF%95%E9%A2%98.html</id>
    <published>2020-10-23T15:04:05.000Z</published>
    <updated>2020-10-23T15:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.笔试题：Java中子类和父类相关方法的执行顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sup</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是父类中的无参构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sup</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是父类中的有参构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;代码块_父类sup&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;static_sup&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Sup</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;我是子类中的无参构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是子类中的有参构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;代码块_子类sub&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;static_sub&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Sup s = new Sup();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> Sup s = <span class="keyword">new</span> Sup();</span><br><span class="line">  Sub s2 = <span class="keyword">new</span> Sub();</span><br><span class="line">  System.out.println(s2.p());</span><br><span class="line">  System.out.println(s.p());</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Sup s1 = new Sub();</span></span><br><span class="line"><span class="comment">//Sub s3 = new Sub(3);</span></span><br><span class="line"><span class="comment">//Sup s4 = new Sup(3);</span></span><br><span class="line"><span class="comment">//Sub s5 = new Sub(5);</span></span><br><span class="line"><span class="comment">//Sup s6 = new Sub(6);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(s.p());</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    结果</span><br><span class="line">        static_sup</span><br><span class="line">        static_sub</span><br><span class="line">        代码块_父类sup</span><br><span class="line">        我是父类中的无参构造方法</span><br><span class="line">        代码块_父类sup</span><br><span class="line">        我是父类中的有参构造方法</span><br><span class="line">        代码块_子类sub</span><br><span class="line">        我是子类中的无参构造方法</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">        <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结</p><p>new一个类对象，类中各部分执行顺序：静态代码块—非静态代码块—构造函数—一般方法。</p><p>子类继承父类各部分执行顺序为：父静态代码块–子静态代码块–父非静态代码–父无参构造函数–子静态代码块–子构造函数–方法。</p><p>注意：创建子类对象调用子类的构造方法的时候会先调用父类的构造方法，在子类的构造方法中调用父类的构造方法是用super()，如果没有写super()，则默认调用父类的无参构造方法。</p>]]></content>
    
    
    <summary type="html">分类 标签 描述的写法</summary>
    
    
    
    <category term="笔试题" scheme="https://yuhaicheng.xyz/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>最简单的使用 jsdelivr 加速网站</title>
    <link href="https://yuhaicheng.xyz/8.html"/>
    <id>https://yuhaicheng.xyz/8.html</id>
    <published>2020-10-23T15:04:05.000Z</published>
    <updated>2020-10-23T15:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="jsdelivr加速效果"><a href="#jsdelivr加速效果" class="headerlink" title="jsdelivr加速效果"></a>jsdelivr加速效果</h2><p>使用 jsDelivr 为 Hexo 博客提供高效免费的CDN加速，节省服务器流量且减少宽带占用</p><p><span class="exturl" data-url="aHR0cDovL3BpbmcuY2hpbmF6LmNvbS9jZG4uanNkZWxpdnIubmV0">http://ping.chinaz.com/cdn.jsdelivr.net<i class="fa fa-external-link-alt"></i></span></p><p>感受下jsdelivr的加速效果</p><a id="more"></a><h2 id="使用-jsdelivr-加速-Github-仓库资源背景等图"><a href="#使用-jsdelivr-加速-Github-仓库资源背景等图" class="headerlink" title="使用 jsdelivr 加速 Github 仓库资源背景等图"></a>使用 jsdelivr 加速 Github 仓库资源背景等图</h2><p>当我们使用 <code>Github</code> 仓库资源时，会因为一些奇怪的原因而掉链子，但我们可以通过 jsdelivr 做 CDN 加速</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==">jsdelivr<i class="fa fa-external-link-alt"></i></span> 是一个免费的开源 CDN</p><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p><code>https://cdn.jsdelivr.net/gh/</code> Github 用户名/仓库名/资源路径</p><p>默认会访问 <code>master</code> 分支下的资源，可以通过 仓库名拼接 @ + <code>release / commit / branch</code> 来访问特定版本下的资源</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlaWxpbmluZy9ibG9nLmlvL21hc3Rlci9pbWFnZXMvYmFja2dyb3VuZC1kYXJrLmpwZw==">https://raw.githubusercontent.com/weilining/blog.io/master/images/background-dark.jpg<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/background-dark.jpg<i class="fa fa-external-link-alt"></i></span></p><h3 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h3><p>GitHub仓库：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn">https://github.com/weilining/blog.io/blob/master/images/background-dark.jpg<i class="fa fa-external-link-alt"></i></span></p><p>对应jsdelivr地址：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9iYWNrZ3JvdW5kLWRhcmsuanBn">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/background-dark.jpg<i class="fa fa-external-link-alt"></i></span></p><p>修改地址：<code>blog/source/_data/styles.styl</code></p><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background:url(&#x2F;images&#x2F;background-dark.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="套jsdelivr作为CDN"><a href="#套jsdelivr作为CDN" class="headerlink" title="套jsdelivr作为CDN"></a>套jsdelivr作为CDN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background:url(&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;background-dark.jpg&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>GitHub地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2ltYWdlcy9sb2dvLnN2Zw==">https://github.com/weilining/blog.io/blob/master/images/logo.svg<i class="fa fa-external-link-alt"></i></span></p><p>jsdelivr地址：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2ltYWdlcy9sb2dvLnN2Zw==">https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg<i class="fa fa-external-link-alt"></i></span></p><p>修改地址：<code>_config.next.yml</code></p><h4 id="本地-1"><a href="#本地-1" class="headerlink" title="本地"></a>本地</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: &#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure><h4 id="套jsdelivr作为CDN-1"><a href="#套jsdelivr作为CDN-1" class="headerlink" title="套jsdelivr作为CDN"></a>套jsdelivr作为CDN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure><h3 id="鼠标点击特效：社会主义价值观"><a href="#鼠标点击特效：社会主义价值观" class="headerlink" title="鼠标点击特效：社会主义价值观"></a>鼠标点击特效：社会主义价值观</h3><p>GitHub地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlaWxpbmluZy9ibG9nLmlvL2Jsb2IvbWFzdGVyL2pzL2N1cnNvci9jbGljay13b3JkLmpz">https://github.com/weilining/blog.io/blob/master/js/cursor/click-word.js<i class="fa fa-external-link-alt"></i></span></p><p>jsdelivr地址：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2pzL2N1cnNvci9jbGljay13b3JkLmpz">https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/click-word.js<i class="fa fa-external-link-alt"></i></span></p><h4 id="本地-2"><a href="#本地-2" class="headerlink" title="本地"></a>本地</h4><p><code>source/_data/head.njk</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- jquery --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;click-loveword.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="套jsdelivr作为CDN-2"><a href="#套jsdelivr作为CDN-2" class="headerlink" title="套jsdelivr作为CDN"></a>套jsdelivr作为CDN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- jquery --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3.4.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;weilining&#x2F;blog.io&#x2F;js&#x2F;cursor&#x2F;click-loveword.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>click-loveword.js</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 社会主体核心价值观效果 *&#x2F;</span><br><span class="line">var a_idx &#x3D; 0;</span><br><span class="line">jQuery(document).ready(function($) &#123;</span><br><span class="line">    $(&quot;body&quot;).click(function(e) &#123;</span><br><span class="line">        &#x2F;&#x2F; var a &#x3D; new Array(&quot;❤富强❤&quot;,&quot;❤民主❤&quot;,&quot;❤文明❤&quot;,&quot;❤和谐❤&quot;,&quot;❤自由❤&quot;,&quot;❤平等❤&quot;,&quot;❤公正❤&quot;,&quot;❤法治❤&quot;,&quot;❤爱国❤&quot;,&quot;❤敬业❤&quot;,&quot;❤诚信❤&quot;,&quot;❤友善❤&quot;);</span><br><span class="line">        var a &#x3D; new Array(&quot;富强&quot;,&quot;民主&quot;,&quot;文明&quot;,&quot;和谐&quot;,&quot;自由&quot;,&quot;平等&quot;,&quot;公正&quot;,&quot;法治&quot;,&quot;爱国&quot;,&quot;敬业&quot;,&quot;诚信&quot;,&quot;友善&quot;);</span><br><span class="line">        var $i &#x3D; $(&quot;&lt;span&gt;&lt;&#x2F;span&gt;&quot;).text(a[a_idx]);</span><br><span class="line">        a_idx &#x3D; (a_idx + 1) % a.length;</span><br><span class="line">        var x &#x3D; e.pageX,</span><br><span class="line">        y &#x3D; e.pageY;</span><br><span class="line">        $i.css(&#123;</span><br><span class="line">            &quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999,</span><br><span class="line">            &quot;top&quot;: y - 20,</span><br><span class="line">            &quot;left&quot;: x,</span><br><span class="line">            &quot;position&quot;: &quot;absolute&quot;,</span><br><span class="line">            &quot;font-weight&quot;: &quot;bold&quot;,</span><br><span class="line">            &quot;color&quot;: &quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">        $(&quot;body&quot;).append($i);</span><br><span class="line">        $i.animate(&#123;</span><br><span class="line">            &quot;top&quot;: y - 180,</span><br><span class="line">            &quot;opacity&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        1500,</span><br><span class="line">        function() &#123;</span><br><span class="line">            $i.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;* 爱心特效 *&#x2F;</span><br><span class="line">! function (e, t, a) &#123;</span><br><span class="line">    function n() &#123;</span><br><span class="line">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function r() &#123;</span><br><span class="line">        for (var e &#x3D; 0; e &lt; d.length; e++) d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function o() &#123;</span><br><span class="line">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick &#x3D; function (e) &#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class="line">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - 5,</span><br><span class="line">            y: e.clientY - 5,</span><br><span class="line">            scale: 1,</span><br><span class="line">            alpha: 1,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function c(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class="line">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; catch (t) &#123;</span><br><span class="line">            a.styleSheet.cssText &#x3D; e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function s() &#123;</span><br><span class="line">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var d &#x3D; [];</span><br><span class="line">    e.requestAnimationFrame &#x3D; function () &#123;</span><br><span class="line">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123;</span><br><span class="line">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>jsdelivr github 延迟，建议使用<code>https://cdn.jsdelivr.net/gh/</code> Github 用户名/仓库名/资源路径</p><p>有延迟：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvQG1hc3Rlci9qcy9jdXJzb3Iv">https://cdn.jsdelivr.net/gh/weilining/blog.io@master/js/cursor/<i class="fa fa-external-link-alt"></i></span></p><p>无延迟：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvL2pzL2N1cnNvci8=">https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/<i class="fa fa-external-link-alt"></i></span></p><p>无延迟：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3dlaWxpbmluZy9ibG9nLmlvQDEuMC9qcy9jdXJzb3Iv">https://cdn.jsdelivr.net/gh/weilining/blog.io@1.0/js/cursor/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">default</summary>
    
    
    
    <category term="Hexo" scheme="https://yuhaicheng.xyz/categories/Hexo/"/>
    
    
    <category term="Next" scheme="https://yuhaicheng.xyz/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Hxeo 写一篇博客的具体细节</title>
    <link href="https://yuhaicheng.xyz/9.html"/>
    <id>https://yuhaicheng.xyz/9.html</id>
    <published>2020-10-23T15:04:05.000Z</published>
    <updated>2020-10-23T15:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以我用的Next主题为例"><a href="#以我用的Next主题为例" class="headerlink" title="以我用的Next主题为例"></a>以我用的Next主题为例</h1><p>一篇博客头写的内容</p><ul><li>toc: true  目录是否生成</li><li>comments: true  评论是否开启</li><li>sticky: 100  数值越大，置顶，相同取第一个写的</li><li>tags: - Next 标签名字</li><li>categories: - Hexo  分类名字</li><li>description: - 描述，一篇博客，不点开，只能看到题目+这个描述  </li><li>date: 2020-10-23 23:04:05  时间</li><li>updated: 2020-10-23 23:04:05    更新时间</li></ul>]]></content>
    
    
    <summary type="html">分类 标签 描述的写法</summary>
    
    
    
    <category term="Hexo" scheme="https://yuhaicheng.xyz/categories/Hexo/"/>
    
    
    <category term="Next" scheme="https://yuhaicheng.xyz/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>第一天线下笔试</title>
    <link href="https://yuhaicheng.xyz/2020-10-19-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8B%E9%9D%A2%E8%AF%95.html"/>
    <id>https://yuhaicheng.xyz/2020-10-19-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8B%E9%9D%A2%E8%AF%95.html</id>
    <published>2020-10-22T18:05:14.000Z</published>
    <updated>2020-10-25T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>今天第一次参加了线下的Java开发面试，和想象的有点不一样；参加面试的公司是海能达公司，去的是江北的分公司参加的面试，整个过程只有3轮面试，但我的第一次只献给了一面，还没见到二面，有点惨哦。</p><p>第一眼见到面试官，感觉很和蔼，他让我坐下并低头看着简历，他：先来个自我介绍，我：巴拉巴拉，期间他笑了一下，也许他感觉我太紧张，笑话我? 然后他就看着我的简历，他：你做过两个项目，我: 嗯 ！他：那就先说说你的项目，你的第一个项目是网上书店系统ssm，</p><h3 id="项目1"><a href="#项目1" class="headerlink" title="项目1"></a>项目1</h3><h4 id="1-他：问的问题："><a href="#1-他：问的问题：" class="headerlink" title="1.他：问的问题："></a>1.他：问的问题：</h4><h5 id="①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；"><a href="#①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；" class="headerlink" title="①那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；"></a>①<strong>那说说你这个项目是怎么搭建的的，具体文件中又是怎么配置的；</strong></h5><h5 id="②你前端发送的一个请求是怎么找到相应的Controller的"><a href="#②你前端发送的一个请求是怎么找到相应的Controller的" class="headerlink" title="②你前端发送的一个请求是怎么找到相应的Controller的"></a>②<strong>你前端发送的一个请求是怎么找到相应的Controller的</strong></h5><h5 id="③你的Spring-mvc是怎么工作的，工作原理"><a href="#③你的Spring-mvc是怎么工作的，工作原理" class="headerlink" title="③你的Spring mvc是怎么工作的，工作原理"></a>③<strong>你的Spring mvc是怎么工作的，工作原理</strong></h5><h5 id="④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况"><a href="#④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况" class="headerlink" title="④你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况"></a>④<strong>你的这个项目是怎么解决同一时间内多个用户购买书时，不会出现显示库存不准的情况</strong></h5><h5 id="⑤mybatis的一个知识-我忘"><a href="#⑤mybatis的一个知识-我忘" class="headerlink" title="⑤mybatis的一个知识 我忘..."></a>⑤mybatis的一个知识 我忘...</h5><h5 id="⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里"><a href="#⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里" class="headerlink" title="⑥你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里"></a>⑥<strong>你怎么保证你的dao层得接口和mapper文件之间是一一对应的，你的mapper文件在哪，怎么设置的，默认情况下放在哪里，正常开发放在哪里</strong></h5><h5 id="⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录-并追问怎么实现（表的字段等）；"><a href="#⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录-并追问怎么实现（表的字段等）；" class="headerlink" title="⑦你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录 并追问怎么实现（表的字段等）；"></a>⑦<strong>你的订单模块如果是一个人买了50本书，那你数据库的订单表是有50条记录吗，面试官希望是一条记录 并追问怎么实现（表的字段等）；</strong></h5><p>他：行，项目先问到着，问问你基础；我：嗯嗯，问了==和equal、hashcode和equals、public protected default private、线程的实现几种方式和区别、你理解的多态、有几种线程池并解释、说出几种NIO的实现类；</p><p>然后他又看简历，说：说说maven是做什么的，并说几条maven常见命令；你用过redis吗，在哪了用的，说说redis是干什么（具体用与什么场景）；他：那我再问问你下一个项目，你的自行车报名系统是干什么的、管理员都干了些什么；</p><p>最后帮我总结了一下，说我刚开始的框架知识给他的印象很差，但后来的基础知识答得很好，可以用自己得理解来答，希望你能好好看自己得框架部分，注意细节。---end---</p><h3 id="解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜"><a href="#解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜" class="headerlink" title="解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜..."></a>解答：以下答案是我后自己总结的，面试时答的都是自己理解答得，我认为框架这我有点菜...</h3><h5 id="①"><a href="#①" class="headerlink" title="①"></a><strong>①</strong></h5><p><strong>首先我用工具建立了一个web工程、导入ssm框架得jar包、配置对应得xml文件、写demo测试，没问题了就可以开发了。</strong></p><p>细节：</p><p>（对应得xml文件主要有applicationContext.xml、spring-mvc.xml、mybatis-config.xml、web.xml文件；</p><p>applicationContext.xml文件主要是：</p><p>a、配置注解扫描范围</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.haina.ssmbicycle.service&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>b、引用数据库配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>c、配置数据源（</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pooledDateSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>d、配置MyBatis的SqlSessionFactory，他是单个数据库映射关系经过编译后的内存镜像</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><span class="comment">&lt;!-- 配置mybatis全局配置文件 --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;pooledDateSource&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span><span class="comment">&lt;!-- 兼容xml方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>e、配置Dao所在包 Mybatis会动态创建实现类</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span></span></span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.haina.ssmbicycle.dao&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-config.xml文件主要是：</p><p>a、开启驼峰命名转换、打印sql语句                </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启驼峰命名转换 user_id ==&gt; userId --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驼峰规则：一般数据库表类似tb_user,里面字段都为uesr_id、uese_name等，而对应的实体类都为userId、userName --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 打印sql语句 STDOUT_LOGGING为标准日志输出 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springmvc.xml文件主要是：</p><p>a、配置注解扫描范围</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.haina.ssmbicycle.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>b、配置拦截器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c、配置多媒体文件解析器，用于文件上传）</p><p>web.xml文件：(在web/WEB-INF/web.xml)</p><p>（默认欢迎页面的配置、字符编码过滤器的配置、前端控制器、以及指定spring核心配置文件和SpringMVC的配置文件，DispatcherServlet是前端控制器;</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认主页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定spring配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置spring监听器 :可以在web容器启动的时候自动初始化spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 调用Spring的编码过滤器 ：</span></span><br><span class="line"><span class="comment">Spring中的字符集过滤器可以很方便的为我们解决项目中出现的中文乱码问题，而且使用方法也很简单，只需要在web.xml文件中配置一下该过滤器，设置两个重要的参数（encoding和forceEncoding）即可</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myencoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 编码过滤器映射路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myencoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里再解释一下@Controller：标名它是一个控制器，被Spring容器所管理，这个注解是在@Component后面出的，为了表示代码的分层，于是就有了@Controller、@Service、@Mapper这三个注解，他们的作用是一样的。</p><p>@RequestMapping：表示接受的请求，还是GetMapping、PostMapping等注解表示请求方法的不同。</p><p>@Autowired：表示自动注入，前提就是被注入的对象被Spring容器所管理。</p><p>ModelAndView：这个前面说过，它装的就是数据和逻辑视图名。）</p><h5 id="②"><a href="#②" class="headerlink" title="②"></a><strong>②</strong></h5><p><strong>前端jsp页面进行action请求到对应的servlet(springmvc)去处理，如果想要springmvc去处理，而不是普通的servlet，需要去web.xml文件去配置dispatcherServlet</strong></p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;/：一切请求，注意不是/ */ user：拦截以/ user开始的请求/user/abc.do：只拦截该请求.action：只拦截.action最后的请求</code></pre><p>）然后通过映射是去匹配@RequestMapping注解，找到相应的controller；如果面试官还问怎么扫描到你的@RequestMapping注解，是在springmvc-config.xml文件中配置扫描controller包；</p><p><strong>Jsp被访问时，执行的过程（使用Servlet）:</strong></p><ul><li>客户端-&gt;发起请求-&gt;服务器接收请求-&gt;Jsp本身-&gt;翻译-&gt;编译-&gt;执行</li></ul><p><strong>服务器是如何查找处理请求用的Servlet的呢？</strong></p><ul><li> 客户端-&gt;发出请求-&gt;服务器接收请求-&gt;web.xml-&gt;寻找与请求匹配的<url-pattern>-&gt;当前<servlet-mapping>中的同级<servlet-name>的值-&gt;利用该值寻找;与该<servlet-mapping>配对的<servlet>的<servlet-name>的值-&gt;获取<servlet-class>中的完整类路径</li></ul><h5 id="③"><a href="#③" class="headerlink" title="③"></a>③</h5><p>a.客户端（浏览器）发送请求，直接请求到DispatcherServlet（前端控制器）。</p><p>b.DispatcherServlet根据请求信息调用HandlerMapping(HandlerMapping,充当着url和Controller之间映射关系配置的角色;HandlerMapping是接口，Spring MVC提供了一系列HandlerMapping的实现，根据一定的规则选择controller。如果当前的HandlerMappign实现中没有能够满足你所需要的规则是，可以通过实现HandlerMapping接口进行扩展。它主要有三部分组成：HandlerMapping映射注册、根据url获取对应的处理器、拦截器注册。),解析请求对应的Handler。</p><p>c.解析到对应的Handler(也就是我们常说的Controller控制器)后，开始由HandlerAdapter适配器处理。</p><p>d.HandlerAdapter适配器会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。</p><p>e.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View</p><p>f.ViewResolver（视图解析器）会根据逻辑上的View查找实际的View</p><p>g.DispatcherServlt把返回的Model数据对象传给View（进行视图渲染）</p><p>h.把View返回给请求者（浏览器）</p><h5 id="④"><a href="#④" class="headerlink" title="④"></a>④</h5><p>首先用户想要买书，必须先要把书加入到购物车，在购物车里点击提交订单时会验证你数据库中图书的库存，如果购买图书大于库存数量，会提示购买图书的名字库存不足，并告诉库存有多少图书。</p><h5 id="⑤"><a href="#⑤" class="headerlink" title="⑤"></a>⑤</h5><h5 id="⑥"><a href="#⑥" class="headerlink" title="⑥"></a>⑥</h5><p><strong>Mybatis中接口和对应的mapper文件不一定要放在同一个包下，放在一起的目的是为了Mybatis进行自动扫描，并且要注意此时java接口的名称和mapper文件的名称要相同（mybatis会根据Mapper.xml中配置的信息创建一个实现了Maper.java接口的代理类(使用JDK动态代理)），否则会报异常，由于此时Mybatis会自动解析对应的接口和相应的配置文件，所以就不需要配置mapper文件的位置了。如果接口和mapper文件不在同一个包下，就不能进行自动扫描解析了，需要对接口和文件分别进行配置；使用Spring来配置</strong></p><pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;&lt;!-- 配置mybatis全局配置文件 --&gt;            &lt;property name=&quot;dataSource&quot; ref=&quot;pooledDateSource&quot;/&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;!-- 兼容xml方式 --&gt;&lt;/bean&gt;</code></pre><p>如果在工程中使用了maven构建工具，那么就会出现一个问题：我们知道在典型的maven工程中，目录结构有：src/main/java和src/main/resources，前者是用来存放java源代码的，后者则是存放一些资源文件，比如配置文件等，在默认的情况下maven打包的时候，对于src/main/java目录只打包源代码，而不会打包其他文件。所以此时如果把对应的mapper文件放到src/main/java目录下时，不会打包到最终的jar文件夹中，也不会输出到target文件夹中，由于在进行单元测试的时候执行的是/target目录下/test-classes下的代码，所以在测试的时候也不会成功。</p><h5 id="⑦"><a href="#⑦" class="headerlink" title="⑦"></a>⑦</h5><p><strong>一个人同时买多本书在数据库中订单表只产生一条记录，而记录表中产生多条记录；这个订单信息主要有订单id、总价、商品详情（书名 价格 数量）、收货信息（收货人、电话、收获地址）、订单状态（已付款、未付款、已完成）、支付方式（微信、支付宝、货到付款）、下单时间、操作；对应的数据库中有两个表，一个是记录表，主要是记录每一本书的价格、数量、订单id、图书id；另一个是订单表，主要记录记录订单id、总价、订单状态（已付款、未付款、已完成）、支付方式（微信、支付宝、货到付款）、收货人、电话、收货地址、下单时间、user_id。那么前端具体怎么实现的呢，是通过&lt;c:forEach var=&quot;order&quot; items=&quot;${orderList}&quot;&gt;jstl标签把后端循环遍历来的数据放到orderList，通过model.addAttribute(&quot;orderList&quot;, orderList)传到前端，然后每次取到的数据存放到val变量中，然后在前端jsp页面上写好死的显示页面，如果有单条记录有多个信息的，比如说是一个人的订单中的多本书的信息，可以用jstl表达式往出拿信息。</strong></p><h3 id="基础："><a href="#基础：" class="headerlink" title="基础："></a>基础：</h3><h4 id="1-与-equals-重要"><a href="#1-与-equals-重要" class="headerlink" title="1.== 与 equals(重要)"></a>1.<strong>== 与 equals(重要)</strong></h4><p>==:<br>   它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型⽐较的是值，引⽤数据类型⽐较的是内存地址)。</p><p>equals() :<br>   它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“==”⽐较这两个对象。情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><h4 id="2-hashcode和equals"><a href="#2-hashcode和equals" class="headerlink" title="2.hashcode和equals"></a>2.<strong>hashcode和equals</strong></h4><p>  hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode()在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。</p><p>hashCode（）与 equals（）的相关规定 </p><pre><code>    1. 如果两个对象相等，则 hashcode ⼀定也是相同的    2. 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true    3. 两个对象有相同的 hashcode 值，它们也不⼀定是相等的    4. 因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖    5. hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）</code></pre><h4 id="3-public-protected-default-private的访问权限修饰区别"><a href="#3-public-protected-default-private的访问权限修饰区别" class="headerlink" title="3.public protected default private的访问权限修饰区别"></a>3.<strong>public protected default private的访问权限修饰区别</strong></h4><p>  public在本类中、同一包中、子类中不在同一包中、其他包下都能访问<br>  protected在本类中、同一包中、子类中不在同一包中都能访问<br>  default在本类中、同一包中都能访问<br>  private在本类中能访问</p><h4 id="4-多线程的实现方式和区别"><a href="#4-多线程的实现方式和区别" class="headerlink" title="4.多线程的实现方式和区别"></a>4.<strong>多线程的实现方式和区别</strong></h4><p>①继承Thread类<br>    public class MyThread extends Thread {<br>    @Override<br>    public void run(){<br>        super.run();<br>        System.out.println(&quot;执行子线程...&quot;);<br>    }</p><p>测试用例</p><pre><code>public class Test &#123;public static void main(String[] args) &#123;    MyThread myThread = new MyThread();    myThread.start();    System.out.println(&quot;主线程...&quot;);    &#125;&#125;</code></pre><p>②实现Rannable接口</p><pre><code>public class MyRunnable implements Runnable &#123;@Overridepublic void run() &#123;    System.out.println(&quot;执行子线程...&quot;);        &#125;&#125;</code></pre><p>测试用例</p><pre><code> public class Test &#123;public static void main(String[] args) &#123;    Runnable runnable = new MyRunnable();    Thread thread = new Thread(runnable);    thread.start();    System.out.println(&quot;主线程运行结束!&quot;);&#125;</code></pre><p>③使用Callable和Future创建线程</p><p>上面的两种方式都有这两个问题：</p><ul><li>无法获取子线程的返回值</li><li>run方法不可以抛出异常</li></ul><p>为了解决这两个问题，我们就需要用到Callable这个接口了。说到接口，上面的Runnable接口实现类实例是作为Thread类的构造函数的参数传入的，之后通过Thread的start执行run方法中的内容。但是Callable并不是Runnable的子接口，是个全新的接口，它的实例不能直接传入给Thread构造，所以需要另一个接口来转换一下。</p><p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个实现类FutureTask，该实现类的继承关系如图所示：</p><pre><code>import java.util.concurrent.Callable;public class MyCallable implements Callable &#123;int i = 0;@Overridepublic Object call() throws Exception &#123;    System.out.println(Thread.currentThread().getName()+&quot;  i的值：&quot;+ i);    return i++; //call方法可以有返回值    &#125;&#125;    </code></pre><p>测试用例</p><pre><code>import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;public class Test &#123;public static void main(String[] args) &#123;    Callable callable = new MyCallable();    for (int i = 0; i &lt; 10; i++) &#123;        FutureTask task = new FutureTask(callable);        new Thread(task,&quot;子线程&quot;+ i).start();        try &#123;            //获取子线程的返回值            System.out.println(&quot;子线程返回值：&quot;+task.get() + &quot;\n&quot;);        &#125;  catch (Exception e) &#123;            e.printStackTrace();                &#125;        &#125;        &#125;&#125;</code></pre><p>④使用线程池</p><p><strong>前三种实现多线程的比较：</strong></p><p>第一种和后面两种的对比：</p><ul><li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li><li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li></ul><p>第二种和第三种方式对比：</p><ul><li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li><li>第三种方法有两个优点：有返回值、可以抛出异常</li></ul><p><strong>实现多线程的总结</strong></p><p><strong>实际开发中可能有更复杂的代码实现，需要继承其他的类，所以平时更推荐通过实现接口来实现多线程，也就是通过第二或第三种方式来实现，这样能保持代码灵活和解耦。<br>而选择第二还是第三种方式，则要根据run()方法是不是需要返回值或者捕获异常来决定，如果不需要，可以选择用第二种方式实现，代码更简洁。</strong></p><h4 id="5-有几种线程池并解释"><a href="#5-有几种线程池并解释" class="headerlink" title="5.有几种线程池并解释"></a><strong>5.有几种线程池并解释</strong></h4><ol><li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li><li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li><li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li><li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li></ol><h4 id="6-说出几种NIO的实现类"><a href="#6-说出几种NIO的实现类" class="headerlink" title="6.说出几种NIO的实现类"></a><strong>6.说出几种NIO的实现类</strong></h4><p>NIO 包含下面几个核心的组件：</p><ul><li>Channel(通道)</li><li>Buffer(缓冲区)</li><li>Selector(选择器)</li></ul><p>想到这扩展一下：BIO,NIO,AIO 有什么区别? </p><ul><li><strong>BIO（Blocking I/0）：同步阻塞I/0模式</strong>，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐较不错的，可以让每⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。</li><li><strong>NIO（Non-blocking/New I/0）：NIO是一种同步非阻塞的I/0模型</strong>，在Java 1.4中引入了NIO框架，对应java.nio包，提供了Channel，Selector，Buffer等抽象。</li><li><strong>AIO（Asynchronous I/0）：AIO也就是NIO 2，</strong>在Java 7中引入了NIO的改进版NIO 2，它是异步非阻塞的I0模型。异步10是基于事件和回调机制实现的,</li></ul><h4 id="7-你理解的多态"><a href="#7-你理解的多态" class="headerlink" title="7.你理解的多态"></a><strong>7.你理解的多态</strong></h4><p>所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，<strong>即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。</strong></p><p>在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖[又叫重写]接⼝中同一方法）。</p><h4 id="8-说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗"><a href="#8-说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗" class="headerlink" title="8.说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗"></a><strong>8.说说maven是做什么的，并说几条maven常见命令，你的项目中用到了maven吗</strong></h4><p><strong>概述</strong></p><ul><li>Maven是一个构建工具，服务与构建使用Maven配置好项目后，输入简单的命令如：mvn clean install，Maven会帮我们处理那些繁琐的任务</li></ul><ul><li><p>Maven是跨平台的</p></li><li><p>Maven最大化的消除了构建的重复</p></li><li><p>Maven可以帮助我们标准化构建过程所有的项目都是简单一致的，简化了学习成本总之Maven作为一个构建工具不仅帮我们自动化构建，还能抽象构建过程提供构建任务实现他跨平台，对外提供一致的操作接口，这一切足以使他成为优秀的，流行的构建工具</p></li><li><p>但是Maven不仅是构建工具，他还是一个依赖管理工具和项目信息管理工具，他还提供了中央仓库，能帮我们自动下载构件</p></li><li><p>使用Maven还能享受一个额外的好处，即Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则，只要遵循了这些成熟的规则，用户在项目间切换的时候就免去了额外的学习成本，可以说是约定优于配置Convention Over Configuration）</p></li></ul><p><strong><em>它是一个Apache的开源项目，主要服务于基于Java平台的项目构建、依赖管理和项目信息管理，还提供了中央仓库，能自动下载构件，为了不重复造轮子。</em></strong></p><p>例如：两个项目A B，项目A需要依赖一些jar包，项目B也需要依赖这些jar包，那么此时如果都把jar包引入到项目中，就是在重复造轮子，我们应该把这些所有的jar包放到一个地方，需要用的时候过去取即可。</p><p><strong>常用的maven命令：</strong></p><ul><li><p>maven clean：对项目进行清理，清理的过程中会删除删除target目录下编译的内容。</p></li><li><p>maven compile：编译项目源代码。</p></li><li><p>maven test：对项目的运行测试。</p></li><li><p>maven deploy： 发布项目</p></li><li><p>maven packet：可以打包后的文件存放到项目的 target 目录下，打包好的文件通常都是编译后生成的class文件。</p></li><li><p>maven install：在本地仓库生成仓库的安装包可以供其他项目引用，同时打包后的文件存放到项目的 target 目录下。对项目打包有三种打包方式，pom打包，jar包和war包。打包方式在pom.xml文件中进行指定。</p></li></ul><p><em>pom工程一般是聚合工程，代表父工程，负责管理jar包的版本、maven插件的版本等，主要做统一的依赖管理。</em></p><p><em>jar包就是普通的打包方式，可以是pom工程的子工程。</em></p><p><em>war包的都是web工程，是可以直接放到tomcat下运行的工程。</em></p><p>我的项目中主要是用maven来对项目中jar包依赖进行统一的管理。</p><h4 id="9-你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）"><a href="#9-你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）" class="headerlink" title="9.你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）"></a><strong>9.你用过redis吗，在哪了用的，说说redis是干什么（具体用在什么场景）</strong></h4><p><strong>简介</strong></p><p><strong>Redis:</strong> REmote DIctionary Server(远程字典服务器)是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。</p><p><strong>redis使用场景</strong></p><ol><li><p>热点数据的缓存<br>由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。</p></li><li><p>限时业务的运用<br>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p></li><li><p>计数器相关问题<br>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p></li><li><p>排行榜相关问题<br>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。例如：在奶茶活动中，我们需要展示各个部门的点赞排行榜，所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p></li><li><p>分布式锁<br>这个主要利用redis的setnx命令进行，setnx：&quot;set if not exists&quot;就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。<br>当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。</p></li><li><p>延时操作<br>这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。 当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p></li><li><p>队列<br>由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。　</p></li></ol><h3 id="项目2"><a href="#项目2" class="headerlink" title="项目2"></a>项目2</h3><p><strong>1.你的自行车报名系统是干什么的，管理员都干了些什么</strong></p><p>随着自行车赛事活动的增加，把赛事变得更加理性和规范，使赛事朝着IP化、品质化方向发展。参赛者可以线上报名为赛事提供诸多便利。</p><p>完成管理员的登录、完成管理员创建比赛、查看比赛列表、管理员查看赛事报名状态、<br>对赛事管理（修改、删除）</p>]]></content>
    
    
    <summary type="html">作为应届生，第一次线下笔试，虽然没啥可说的，自己留个纪念</summary>
    
    
    
    <category term="面试" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>最简单的 LaTeX 入门</title>
    <link href="https://yuhaicheng.xyz/7.html"/>
    <id>https://yuhaicheng.xyz/7.html</id>
    <published>2020-10-21T08:36:23.000Z</published>
    <updated>2020-10-21T08:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>mac下使用Typora添加数学公式<code>command+option+B</code></p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R_&#123;ij&#125;</span><br></pre></td></tr></table></figure><h2 id="长分式"><a href="#长分式" class="headerlink" title="长分式"></a>长分式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\frac&#123;X&#125;&#123;Y&#125;</span><br></pre></td></tr></table></figure><p>好用！</p><h2 id="练手"><a href="#练手" class="headerlink" title="练手"></a>练手</h2><p>$$<br>R_i=\sum_{i}^{n}{\frac{X_i}{x}}\ln(\frac{\frac{X_i}{X}}{\frac{Y_i}{Y}})<br>$$</p><p>$$<br>R_{ai}=\sum_{i}{\frac{X_{ji}}{X_j}}\ln(\frac{\frac{X_ji}{Xj}}{\frac{P_ji}{P_j}})<br>$$</p><p>$$<br>R_a=\sum_{j}{\frac{X_j}{x}}R_{ai}<br>$$</p><p>$$<br>R_b=\sum_{j}{\frac{Xj}{X}}\ln(\frac{\frac{X_j}{X}}{\frac{P_j}{P}})<br>$$</p><p>$$<br>R=R_a+{R_b}<br>$$</p><p>$$<br>Z_a=\frac{R_a}{R}<br>$$</p><p>$$<br>Z_b=\frac{R_b}{R}<br>$$</p><p>$$<br>Z_j=\frac{X_jR_{ai}}{XR}<br>$$</p>]]></content>
    
    
    <summary type="html">最简单的 LaTeX 入门</summary>
    
    
    
    <category term="Hexo" scheme="https://yuhaicheng.xyz/categories/Hexo/"/>
    
    
    <category term="Next" scheme="https://yuhaicheng.xyz/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>解决 GitHub Pages 出现独角兽</title>
    <link href="https://yuhaicheng.xyz/6.html"/>
    <id>https://yuhaicheng.xyz/6.html</id>
    <published>2020-10-20T18:36:23.000Z</published>
    <updated>2020-10-20T18:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/6/image-20201021023637217.png" alt="image-20201021023637217" loading="lazy"></p><a id="more"></a><p><strong>We&#39;re having a really bad day.</strong></p><p>The Unicorns have taken over. We&#39;re doing our best to get them under control and get GitHub back up and running.</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbnRhY3Q=">Contact Support<i class="fa fa-external-link-alt"></i></span> — <span class="exturl" data-url="aHR0cHM6Ly9zdGF0dXMuZ2l0aHViLmNvbS8=">GitHub Status<i class="fa fa-external-link-alt"></i></span> — <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9naXRodWJzdGF0dXM=">@githubstatus<i class="fa fa-external-link-alt"></i></span></p><p><a href="https://weilining.cf/"><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpEQUM1QkUxRUI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpEQUM1QkUxRkI0MUMxMUUyQUQzREIxQzRENUFFNUM5NiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUxNkJENjdGQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUxNkJENjgwQjNGMDExRTJBRDNEQjFDNEQ1QUU1Qzk2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hfPRaQAAB6lJREFUeNrsW2mME2UYbodtt+2222u35QheoCCYGBQligIJgkZJNPzgigoaTEj8AdFEMfADfyABkgWiiWcieK4S+QOiHAYUj2hMNKgYlEujpNttu9vttbvdw+chU1K6M535pt3ubHCSyezR+b73eb73+t7vrfXsufOW4bz6+vom9/b23ovnNNw34b5xYGAgODg46Mbt4mesVmsWd1qSpHhdXd2fuP/Afcput5/A88xwymcdBgLqenp6FuRyuWV4zu/v759QyWBjxoz5t76+/gun09mK5xFyakoCAPSaTCazNpvNPoYVbh6O1YKGRF0u13sNDQ27QMzfpiAAKj0lnU6/gBVfAZW2WWpwwVzy0IgP3G73FpjI6REhAGA9qVRqA1b9mVoBVyIC2tDi8Xg24+dUzQiAbS/s7Ox8G2o/3mKCC+Zw0efzPQEfcVjYrARX3dbV1bUtHo8fMgt42f+Mp0yUTVQbdWsAHVsikdiHkHaPxcQXQufXgUBgMRxme9U0AAxfH4vFvjM7eF6UkbJS5qoQwEQGA57Ac5JllFyUVZZ5ckUEgMVxsK2jlSYzI+QXJsiyjzNEAJyJAzb/KQa41jJKL8pODMQiTEAymXw5n8/P0IjD3bh7Rgog59aanxiIRTVvV/oj0tnHca/WMrVwODwB3raTGxzkBg/gnZVapFV62Wy2n5AO70HM/5wbJ0QnXyQSaVPDIuNZzY0V3ntHMwxiwHA0Gj2Np7ecIBDgaDAYXKCQJM1DhrgJ3nhulcPbl8j4NmHe46X/g60fwbz3aewjkqFQaAqebWU1AOqyQwt8Id6qEHMc97zu7u7FGGsn7HAiVuosVw7P35C1nccdgSCxop1dHeZswmfHMnxBo6ZTk+jN8dl/vF7vWofDsa+MLN9oEUBMxOb3+1eoEsBVw6Zmua49r8YmhAKDiEPcMwBsxMiqQ+ixzPFxZyqRpXARG/YOr1ObFJ0gUskXBbamcR1OKmMUvDxHRAu8/LmY3jFLMUpFqz9HxG65smYJdyKyECOxDiEAe/p1gjF2oonivZAsxVgl2daa4EQWCW6J55qFAFFZiJWYLxNQy2qOSUzGRsyXCUDIeliwAHEO4WSlWQBRFoZakXcKmCXmyXAKs0Ve9vl8q42WoIYpJU4hV3hKcNs8m9gl7p/xQ73eF5kB4j5mNrWmTJRNwAzqiV1CxjVTZCIkEq+Z1bZFZSN2CenmVAFVy4Plz8xKAGWjjAKFk6lCBMDR/MJjLLMSQNm43xAiQKTaA+9/wewhDjL+JVI1kkTSSOTcKbMTwPqESAot6dn6Fr1gHwVJju6IRuyiByPuUUBAg5DGkAgBmxlvdgIEK9gDkohdY/BJo4CAG0R8miRSsGABkgVQs4KXu098IgUXSSRsFAoKZiVAVDY2WUiiPTjYRi41KwGisrGsLtlsth8Fiwnz2fBkQvWfRtlE3iF2yW63/yCacXZ1dW02GwGyTFaRd4idJnCKHRaCxYRHoG5LTKT6SyiToP1fJHbmAYPYRR0UnZQtMnA6s0zg+GZBlt0Gdo7EPHgpE3Q6nZ8YyLhc8Xj8MJh/aKTAY+5FPAKHLE7RdwuYJZmNwzyCMkBCYyKROJBMJl9B/PXXCjjmCmDOVzH3fiPpObEWGqoKe4EBl8v1hlqsdLvd23mkxHM9pc9kMpmno9HoeTii7ewbHEZPPx1ztLS1tV3AnGuMjiNjvbQFuHw6zDo5By7dTPAQNBgMLrRarTkSls1mnwT7uwp9virx9QzbW/HuV/j5d/b+6jniKlllP8lkeONJDk+dq9GsQTnC4fB1heO0K47Hwe7WdDr9nAKgXwOBwHI+C45Htj1d6sd429TUNEcmUdc+PRaLHcvn87dXW4ugzdsaGxufL94NFv9zi1J7GVbhlvb2dnaJ3SVrxfc+n2+NTsZ7/H7/Mr3g5XdSIHyJSH1PZ+7fToyl2+ErqilgZ4NaLYB9goVGaHjR93Hv1ZrU4XDsFT20kH3PObzbWk0CgG1jacVIUnAQb9F+VexyLMzkpcLv0IJV7AHQIOCAUYHx7v5qgScmYHtTqSAyZLEJTK22Bie4iq3xsqpm4SAf9Hq9a2DnJ4uLK3SEULcdRvp3i3zHySqpficxEdsQc1NrlYXXvR+O7qASSezXB+h1SuUomgg9LL8BUoV4749EIolKh+EiqWmqVEZlDgHks2pxHw7xTqUQw9J5NcAXOK10AGIoZ6Zli6JY6Z1Q461KoZ4NiKLHarW+KDsxlDUPHZ5zPQZqUVDPJsTqb5n9malbpAh8C2XXDLl62+WZIDFRUlNVOiwencnNU3aQEkL+cDMSoLvZo2fQB7AJssNAuFuvorlDVVkkg2I87+jo2K2QAVphDrfyViK5VqtO34OkaxXCp+7drdDBCAdubm6eidX+2WwqT5komwh4YQLk+H4aE93h8Xg2gvHekQZOGSgLZTLyDTLJ4Lx9/KZWKBSainT4Iy3FqQBfnUZR42PKQFksBr9QKVXCPusD3OiA/RkQ5kP8qV/Jl1WywAp/6+dcmPM2zL1UrUahe4JqfnWWKXIul3uUbfP8njAFLW1OFr3gdFtZ72cNH+PtQT7/brW+NXqJAHh0y9V8/U/A1U7AfwIMAD7mS3pCbuWJAAAAAElFTkSuQmCC" alt="img" loading="lazy"></a> </p><p>[TOC]</p><h2 id="裸yourname-github-io"><a href="#裸yourname-github-io" class="headerlink" title="裸yourname.github.io"></a>裸yourname.github.io</h2><p>只能等GitHub Pages恢复正常</p><h2 id="域名绑定GitHub-Pages"><a href="#域名绑定GitHub-Pages" class="headerlink" title="域名绑定GitHub Pages"></a>域名绑定GitHub Pages</h2><p>当GitHub Pages出现独角兽，站点文件可以托管到<span class="exturl" data-url="aHR0cHM6Ly92ZXJjZWwuY29tLw==">vercel<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20v">netlify<i class="fa fa-external-link-alt"></i></span>，域名可以解析到托管平台。</p><h3 id="部署到vercel"><a href="#部署到vercel" class="headerlink" title="部署到vercel"></a>部署到vercel</h3><p>不支持QQ邮箱、163邮箱，换句话说，请使用谷歌邮箱</p><h4 id="使用谷歌邮箱注册登陆gitlab"><a href="#使用谷歌邮箱注册登陆gitlab" class="headerlink" title="使用谷歌邮箱注册登陆gitlab"></a>使用谷歌邮箱注册登陆gitlab</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIuY29tL3VzZXJzL3NpZ25faW4=">https://gitlab.com/users/sign_in<i class="fa fa-external-link-alt"></i></span></p><h4 id="使用gitlab注册登陆vercel"><a href="#使用gitlab注册登陆vercel" class="headerlink" title="使用gitlab注册登陆vercel"></a>使用gitlab注册登陆vercel</h4><p><span class="exturl" data-url="aHR0cHM6Ly92ZXJjZWwuY29tLw==">https://vercel.com<i class="fa fa-external-link-alt"></i></span></p><h4 id="导入github的repo"><a href="#导入github的repo" class="headerlink" title="导入github的repo"></a>导入github的repo</h4><h4 id="vercel的Domains绑定域名"><a href="#vercel的Domains绑定域名" class="headerlink" title="vercel的Domains绑定域名"></a>vercel的Domains绑定域名</h4><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A记录解析76.76.21.21 || CNAME记录解析cname.vercel-dns.com</span><br></pre></td></tr></table></figure><h3 id="部署到netlify"><a href="#部署到netlify" class="headerlink" title="部署到netlify"></a>部署到netlify</h3><p>要科学，<span class="exturl" data-url="aHR0cHM6Ly9hcGkubmV0bGlmeS5jb23miZPkuI3lvIDlsLHnp5HlrablkKcv">https://api.netlify.com打不开就科学吧<i class="fa fa-external-link-alt"></i></span></p><h4 id="GitHub登陆"><a href="#GitHub登陆" class="headerlink" title="GitHub登陆"></a>GitHub登陆</h4><h4 id="导入GitHub-repo"><a href="#导入GitHub-repo" class="headerlink" title="导入GitHub repo"></a>导入GitHub repo</h4><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><h4 id="域名解析-1"><a href="#域名解析-1" class="headerlink" title="域名解析"></a>域名解析</h4><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvZ2l0aHViL3dvcmtpbmctd2l0aC1naXRodWItcGFnZXMvYWJvdXQtZ2l0aHViLXBhZ2Vz">关于 GitHub Pages<i class="fa fa-external-link-alt"></i></span>流量每月100GB</p>]]></content>
    
    
    <summary type="html">解决 GitHub Pages 独角兽</summary>
    
    
    
    <category term="Hexo" scheme="https://yuhaicheng.xyz/categories/Hexo/"/>
    
    
    <category term="Next" scheme="https://yuhaicheng.xyz/tags/Next/"/>
    
  </entry>
  
</feed>
