<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曙光苑</title>
  
  <subtitle>有朋自远方来，不亦乐乎</subtitle>
  <link href="https://yuhaicheng.xyz/atom.xml" rel="self"/>
  
  <link href="https://yuhaicheng.xyz/"/>
  <updated>2021-03-25T03:05:14.000Z</updated>
  <id>https://yuhaicheng.xyz/</id>
  
  <author>
    <name>Dawn-yhc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gc类型、内存泄露和内存溢出</title>
    <link href="https://yuhaicheng.xyz/2021-04-10-gc%E3%80%81oom.html"/>
    <id>https://yuhaicheng.xyz/2021-04-10-gc%E3%80%81oom.html</id>
    <published>2021-04-10T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、怎么看自己项目的gc"><a href="#1、怎么看自己项目的gc" class="headerlink" title="1、怎么看自己项目的gc"></a>1、怎么看自己项目的gc</h1><h2 id="首先来看一下JVM中的GC有哪几种类型？"><a href="#首先来看一下JVM中的GC有哪几种类型？" class="headerlink" title="首先来看一下JVM中的GC有哪几种类型？"></a>首先来看一下JVM中的GC有哪几种类型？</h2><p>1.-XX:UseSerialGC</p><p>　　虚拟机运行在Client模式的默认值，打开此开关参数后，使用Serial+Serial Old收集器组合进行垃圾收集。</p><p>2.-XX:UseParNewGC</p><p>　　打开此开关参数后，使用ParNew+Serial Old收集器组合进行垃圾收集。</p><p>3.-XX:UseConcMarkSweepGC</p><p>　　打开此开关参数后，使用ParNew+CMS+Serial Old收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent Mode Failure的备用垃圾收集器。</p><p>4.-XX:UseParallelGC</p><p>　　虚拟机运行在Server模式的默认值，打开此开关参数后，使用Parallel Scavenge+Serial Old收集器组合进行垃圾收集。</p><p>5.-XX:UseParallelOldGC</p><p>　　打开此开关参数后，使用Parallel Scavenge+Parallel Old收集器组合进行垃圾收集。</p><h2 id="GC日志的查看"><a href="#GC日志的查看" class="headerlink" title="GC日志的查看"></a>GC日志的查看</h2><p>对应的参数列表</p><p>-XX:+PrintGC 　　                  输出GC日志<br>-XX:+PrintGCDetails              输出GC的详细日志<br>-XX:+PrintGCTimeStamps    输出GC的时间戳（以基准时间的形式）<br>-XX:+PrintGCDateStamps    输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）<br>-XX:+PrintHeapAtGC 　　    在进行GC的前后打印出堆的信息<br>-Xloggc:../logs/gc.log             日志文件的输出路径<br>例如:eclipse.ini中配置下面代码启动后会在同一目录下生成gc.log</p><p>-Xloggc:gc.log<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintGCDetails</p><p>当 JVM 内存严重不足时，就会抛出 java.lang.OutOfMemoryError 错误。</p><h1 id="2、内存泄露和内存溢出"><a href="#2、内存泄露和内存溢出" class="headerlink" title="2、内存泄露和内存溢出"></a>2、内存泄露和内存溢出</h1><h2 id="1、内存泄漏"><a href="#1、内存泄漏" class="headerlink" title="1、内存泄漏"></a>1、内存泄漏</h2><p>memory leak ，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p><h2 id="2、内存溢出"><a href="#2、内存溢出" class="headerlink" title="2、内存溢出"></a>2、内存溢出</h2><p>out of memory ，指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p><h2 id="3、二者的关系"><a href="#3、二者的关系" class="headerlink" title="3、二者的关系"></a>3、二者的关系</h2><p>内存泄漏的堆积最终会导致内存溢出。</p><p>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</p><p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。</p><h2 id="4、内存泄露的具体原因及解决方法"><a href="#4、内存泄露的具体原因及解决方法" class="headerlink" title="4、内存泄露的具体原因及解决方法"></a>4、内存泄露的具体原因及解决方法</h2><h3 id="（1）-内存泄露原因"><a href="#（1）-内存泄露原因" class="headerlink" title="（1） 内存泄露原因"></a>（1） 内存泄露原因</h3><ol><li>资源未关闭造成的内存泄漏</li><li>集合容器中的内存泄露</li><li>单例造成的内存泄漏</li><li> ThreadLocal 的内存泄露</li></ol><h3 id="（2）内存泄露的解决方案"><a href="#（2）内存泄露的解决方案" class="headerlink" title="（2）内存泄露的解决方案"></a>（2）内存泄露的解决方案</h3><p>因为内存泄漏是在堆内存中，所以对我们来说并不是可见的。通常我们可以借助MAT、LeakCanary等工具来检测应用程序是否存在内存泄漏。<br>1、MAT是一款强大的内存分析工具，功能繁多而复杂。</p><p>2、LeakCanary则是由Square开源的一款轻量级的第三方内存泄漏检测工具，当检测到程序中产生内存泄漏时，它将以最直观的方式告诉我们哪里产生了内存泄漏和导致谁泄漏了而不能被回收。</p><h2 id="5、内存溢出的具体原因及解决方法"><a href="#5、内存溢出的具体原因及解决方法" class="headerlink" title="5、内存溢出的具体原因及解决方法"></a>5、内存溢出的具体原因及解决方法</h2><h3 id="（1）内存溢出原因"><a href="#（1）内存溢出原因" class="headerlink" title="（1）内存溢出原因"></a>（1）内存溢出原因</h3><ol><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收</li><li>代码中存在死循环或循环产生过多重复的对象实体</li><li>启动参数内存值设定的过</li></ol><h3 id="（2）内存溢出的解决方案"><a href="#（2）内存溢出的解决方案" class="headerlink" title="（2）内存溢出的解决方案"></a>（2）内存溢出的解决方案</h3><p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p><p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</p><p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><ol><li><p>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p></li><li><p>检查List、Map否有使用完后，未清除的问题。List、Map等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p></li><li><p>检查代码中是否有死循环或递归调用。</p></li><li><p>检查是否有大循环重复产生新对象实体。</p></li></ol><p>第四步，使用内存查看工具动态查看内存使用情况.</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="JVM" scheme="https://yuhaicheng.xyz/categories/JVM/"/>
    
    
    <category term="内存" scheme="https://yuhaicheng.xyz/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>线程安全的list</title>
    <link href="https://yuhaicheng.xyz/2021-04-09-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84list.html"/>
    <id>https://yuhaicheng.xyz/2021-04-09-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84list.html</id>
    <published>2021-04-09T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发下的ArrayList"><a href="#并发下的ArrayList" class="headerlink" title="并发下的ArrayList"></a>并发下的ArrayList</h2><p>那么它究竟会出现什么问题呢？我们写一段简单的代码看一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread two = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        one.start();</span><br><span class="line">        two.start();</span><br><span class="line">        one.join();</span><br><span class="line">        two.join();</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我们创建了两个线程，同时对ArrayList添加10000个元素，如果我们运行这段代码，我们肯定期望它返回的是20000。可是我在JDK1.8环境中运行这段代码，多次验证，会出现两种结果：</p><p>第一种：抛出数组越界异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">163</span></span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:<span class="number">459</span>)</span><br><span class="line">at com.release.util.container.ArrayListDemo.lambda$main$<span class="number">0</span>(ArrayListDemo.java:<span class="number">15</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><p>第二种：结果&lt;20000</p><p>这是为什么呢？我们来看看ArrayList的部分源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存放list集合元素的数组,默认容量10</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//list大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>我们再来看看add源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确定添加元素之后，集合的大小是否足够，若不够则会进行扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们假如有两个线程在对list插入值，这时线程A获取到的size大小为9，线程B获取的size大小也为9，但是线程A在执行完ensureCapacityInternal(size + 1)后时间片用完了，线程B得以执行，这时线程B发现size+1=10，刚好满足容量大小，不需要进行扩容，这时线程A得到时间片，这时它来执行 elementData[size++] = e时，然而现在size大小为10，这时进行插入就会出现数组越界情况。另外，我们发现size字段没有使用volatile修饰，size++本身就是非原子性的，多个线程之间访问冲突，这时两个线程可能对同一个位置赋值，就可能出现size小于期望值的结果。</p><h4 id="1-Collections-SynchronizedList"><a href="#1-Collections-SynchronizedList" class="headerlink" title="1.Collections.SynchronizedList"></a>1.Collections.SynchronizedList</h4><p>java.util.Collections.synchronizedList(List list) 方法，获取一个线程安全的 List 实例对象。</p><p>正常情况下，Collections.synchronizedList(List list) 返回的是一个 SynchronizedList 的对象，这个对象以组合的方式将对 List 的接口方法操作，委托给传入的 list 对象，并且对所有的接口方法对象加锁，得到并发安全性。<br><strong>Collections.synchronizedList(List list) 方法源码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">        return (list instanceof RandomAccess ?</span><br><span class="line">                new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">                new SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入的 list 是 ArrayList 时，返回 SynchronizedRandomAccessList 对象；传入 LinkedList 时，返回 SynchronizedList 对象。<br>再来看看 SynchronizedList 源码，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">        SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">            <span class="keyword">super</span>(list);</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line">        SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;</span><br><span class="line">            <span class="keyword">super</span>(list, mutex);</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，SynchronizedList 的实现里，get, set, add 等操作都加了 mutex 对象锁，再将操作委托给最初传入的 list。</p><p>这就是以组合的方式，将非线程安全的对象，封装成线程安全对象，而实际的操作都是在原非线程安全对象上进行，只是在操作前给加了同步锁。</p><p>由于有很多业务场景下都有这种需求，所以 Java 类库中封装了这个工具类，给需要的模块使用。</p><h4 id="2-CopyOnWriteArrayList"><a href="#2-CopyOnWriteArrayList" class="headerlink" title="2.CopyOnWriteArrayList"></a>2.CopyOnWriteArrayList</h4><p>Collections.synchronizedList(List<T> list)，但是无论是读取还是写入，它都会进行加锁，当我们并发级别特别高，线程之间在任何操作上都会进行等待，因此在某些场景中它不是最好的选择。在很多的场景中，我们的读取操作可能远远大于写入操作，这时使用这种方式，显然不能让我们满意，那么怎么办呢？别担心，JDK已经为我们考虑好了，为了将读取的性能发挥到极致，提供了CopyOnWriteArrayList类，该类在使用过程中，读读之间不互斥并且更厉害的是读写也不互斥。下面，我们来看看它如何做到的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//得到旧数组并获取旧数组的长度</span></span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">   <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制旧数组的元素到新的数组中并且大小在原基础上加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//把值插入到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//使用新数组替换老数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中，我们可以看出add操作中使用了重入锁，但是此锁只针对<strong>写-写</strong>操作。为什么读写之间不用互斥，关键就在于添加值的操作并不是直接在原有数组中完成，而是使用原有数组复制一个新的数组，然后将值插入到新的数组中，最后使用新数组替换旧数组，这样插入就完成了。大家可以发现，使用这种方式，<strong>在add的过程中旧数组没有得到修改，因此写入操作不影响读取操作</strong>，另外，数组定义private transient volatile Object[] array，其中采用volatile修饰，保证内存可见性，读取线程可以马上知道这个修改。下面我们来看看读取的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">   <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取操作完全没有使用任何的同步控制或者是加锁，这是因为array数组内部结构不会发生任何改变，只会被另外一个array所替换，因此读取是线程安全的。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在JDK中，获取线程安全的List，我们可以使用Collections.synchronizedList(List<T> list)方式，也可以使用CopyOnWriteArrayList类。在真实环境中，使用它们可以根据我们的业务需要，在插入操作远远超过读取时，建议使用第一种方式，这是因为CopyOnWriteArrayList在插入的过程中会创建新的数组，这样在数据量特别大的情况下，对内存的消耗是很大的。当然，如果是读取操作远远大于插入时，第二种方式肯定更占优势，毕竟读取操作完全不需要加锁。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="安全的list" scheme="https://yuhaicheng.xyz/tags/%E5%AE%89%E5%85%A8%E7%9A%84list/"/>
    
  </entry>
  
  <entry>
    <title>树的基本问题</title>
    <link href="https://yuhaicheng.xyz/2021-04-08-%E6%A0%91%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html"/>
    <id>https://yuhaicheng.xyz/2021-04-08-%E6%A0%91%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.html</id>
    <published>2021-04-08T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h3><p>二叉树特点是每个结点最多只能有两棵子树，且有左右之分 。</p><p>二叉树是n个有限元素的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUIlODYlRTUlOTAlODgvMjkwODExNw==">集合<i class="fa fa-external-link-alt"></i></span>，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。</p><h4 id="1-1完全二叉树"><a href="#1-1完全二叉树" class="headerlink" title="1.1完全二叉树"></a>1.1完全二叉树</h4><p>完全二叉树满足 — 若设二叉树的高度为h，除第h层外，其他各层（1 ~ h-1）的节点数都达到了最大个数，第h层的叶子节点都是从左到右依次排序的。</p><h4 id="1-2满二叉树"><a href="#1-2满二叉树" class="headerlink" title="1.2满二叉树"></a>1.2满二叉树</h4><p>满二叉树满足 —  最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。</p><blockquote><p>国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p></blockquote><h4 id="1-3平衡二叉树"><a href="#1-3平衡二叉树" class="headerlink" title="1.3平衡二叉树"></a>1.3平衡二叉树</h4><p>平衡二叉树满足 —  平衡二叉树又被称为AVL树（不是AVL算法），它是一颗二叉排序树，并且满足它是一颗空树（root==null）或 它的左右两个子树的高度差的绝对值不大于1，并且左右两个子树都是一颗平衡二叉树。</p><h4 id="1-4二叉查找树（BST）"><a href="#1-4二叉查找树（BST）" class="headerlink" title="1.4二叉查找树（BST）"></a>1.4二叉查找树（BST）</h4><p>二叉查找树，也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3） 任意节点的左、右子树也分别为二叉查找树；</p><p>（4） 没有键值相等的节点。</p><h3 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h3><p>堆是具有以下性质的完全二叉树：</p><p>每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆。</p><p>每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。</p><h3 id="3、红黑树"><a href="#3、红黑树" class="headerlink" title="3、红黑树"></a>3、红黑树</h3><p>首先红黑树的前身是二叉查找树，但是在一些插入情况下会变成线性的数据结构，导致失去本身数据结构的意义。所以出现了自平衡查找二叉树：红黑树</p><p>特点：</p><ol><li>每个节点不是红色的就是黑色的</li><li>根节点总是黑色节点</li><li>每个叶子节点都是黑色的空节点</li><li>如果节点是红色的，则它的两个子节点必须是黑色的，反之不成立</li><li>从任一节点到其每个叶子的<strong>所有路径</strong>都包含相同数目的黑色节点。</li></ol><h3 id="4、B-、B-、B"><a href="#4、B-、B-、B" class="headerlink" title="4、B-、B+、B*"></a>4、B-、B+、B*</h3><p>动态查找树主要有二叉查找树、平衡二叉查找树、红黑树，都是二叉结构，查找的时间复杂度O(log2-N) 与树的深度相关，降低树的深度会提高查找效率，于是有了多路的B-tree、B+ -tree、B* -tree。</p><h4 id="1-B树，即B-tree"><a href="#1-B树，即B-tree" class="headerlink" title="1.B树，即B- tree"></a>1.B树，即B- tree</h4><p>B树是为了磁盘或其它存储设备而设计的一种多叉（路）平衡查找(又称排序)树。</p><p><strong>一棵m阶B树是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树</strong></p><p>1、根结点至少有两个子女；</p><p>2、每个非根节点所包含的关键字个数 j 满足：m/2 - 1 &lt;= j &lt;= m - 1；</p><p>3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：m/2 &lt;= k &lt;= m ；</p><p>4、所有的叶子结点都位于同一层。</p><p><strong>B-tree的特点</strong></p><ul><li>B-tree是一种多路搜索树（并不是二叉的），对于一棵M阶树：</li><li>定义任意非叶子结点最多只有M个孩子；且M&gt;2；</li><li>根结点的孩子数为[2, M]，除非根结点为叶子节点；</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>每个非叶子结点存放至少M/2-1（取上整）和至多M-1个关键字；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层；</li></ul><p><strong>B-树的特性</strong></p><p>1.关键字集合分布在整颗树中；</p><p>2.任何一个关键字出现且只出现在一个结点中；</p><p>3.搜索有可能在非叶子结点结束；</p><p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p><p>5.自动层次控制</p><h4 id="2-B-树，即B-tree"><a href="#2-B-树，即B-tree" class="headerlink" title="2.B+树，即B+ -tree"></a>2.B+树，即B+ -tree</h4><p>B+树是应文件系统所需而出的一种B-树的变型树。也是一种多路搜索树。</p><p>B+ 树通常用于<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlLzE0">数据库<i class="fa fa-external-link-alt"></i></span>和操作系统的文件系统中。</p><h4 id="3-B-树，即B-tree"><a href="#3-B-树，即B-tree" class="headerlink" title="3.B* 树，即B* -tree"></a>3.B* 树，即B* -tree</h4><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p><p><strong>小结</strong></p><p><strong>B-树：</strong></p><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键</p><p>字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p><strong>B+树：</strong></p><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点</p><p>中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><p>B* 树：</p><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率</p><p>从1/2提高到2/3</p><h4 id="4、3种树的优缺点"><a href="#4、3种树的优缺点" class="headerlink" title="4、3种树的优缺点"></a>4、3种树的优缺点</h4><p>B-树是一种平衡的多路查找(又称排序)<strong>树，在文件系统中有所应用。主要用作文件的索引。</strong>其中的B就表示平衡(Balance)</p><p>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。 </p><p>B+树支持range-query(区间查询)非常方便，而B树不支持。这是数据库选用B+树的最主要原因。 </p><blockquote><p>比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。 </p><p>B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就会成功并结束查询， 而B+树由于非叶节点只是索引部分，这些节点中只含有其子树中的最大(或最小)关键字，当非终端节点上的关键字等于给点值时，查找并不终止，而是继续向下直到叶子节点。 因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径 。 </p><p>有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。<br>另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。 mysql底层存储是用B+树实现的，因为内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。 </p></blockquote><p>B *  树<br>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B<em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；<br>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>B * 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B\</em>树分配新结点的概率比B+树要低，空间使用率更高；</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="数据结构" scheme="https://yuhaicheng.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="https://yuhaicheng.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="https://yuhaicheng.xyz/2021-04-07-%E5%86%85%E9%83%A8%E7%B1%BB.html"/>
    <id>https://yuhaicheng.xyz/2021-04-07-%E5%86%85%E9%83%A8%E7%B1%BB.html</id>
    <published>2021-04-07T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>把类定义在另一个类的内部，这个类就叫做内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//它就是内部类        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、内部类的访问规则"><a href="#2、内部类的访问规则" class="headerlink" title="2、内部类的访问规则"></a>2、内部类的访问规则</h3><p>内部类可以直接访问外部类的成员，包括私有的。</p><p>外部类要想访问内部类成员，必须创建对象。</p><h3 id="3、内部类的分类"><a href="#3、内部类的分类" class="headerlink" title="3、内部类的分类"></a>3、内部类的分类</h3><p>成员内部类</p><p>局部内部类</p><p>静态内部类</p><p>匿名内部类</p><h4 id="（1）成员内部类"><a href="#（1）成员内部类" class="headerlink" title="（1）成员内部类"></a>（1）成员内部类</h4><blockquote><p>成员内部类——就是位于外部类成员位置的类<br>特点：可以使用外部类中所有的成员变量和成员方法（包括private的）</p></blockquote><p>格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        oi.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员内部类不是静态的：</span></span><br><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.new 内部类名();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//成员内部类是静态的：</span></span><br><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名();    </span><br></pre></td></tr></table></figure><p>如果内部类是private修饰的，就不能通过创建对象的方法访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用，这样可以在public中增加一些判断语句，起到数据安全的作用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              System.out.println(“密码备份文件”);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//使用getXxx()获取成员内部类，可以增加校验语句（文中省略）</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(...)&#123;</span><br><span class="line">              ....</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">          Outer.Inner inner = outer.getInner();</span><br><span class="line">          inner.show();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>static 所修饰的内部类，按位置分，属于成员内部类，但也可以称作静态内部类，也常叫做嵌套内部类。</strong></p><p>经典题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;    </span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">20</span>;    </span><br><span class="line">          <span class="function"><span class="keyword">public</span> viod <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">int</span> age  = <span class="number">25</span>;</span><br><span class="line">              System.out.println(age);<span class="comment">//空1</span></span><br><span class="line">              System.out.println(<span class="keyword">this</span>.age);<span class="comment">//空2</span></span><br><span class="line">              System.out.println(Outer.<span class="keyword">this</span>.age);<span class="comment">//空3</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-局部内部类"><a href="#2-局部内部类" class="headerlink" title="(2) 局部内部类"></a>(2) 局部内部类</h4><blockquote><p>局部内部类——就是定义在一个方法或者一个作用域里面的类<br>特点：主要是作用域发生了变化，只能在自身所在方法和属性中被使用</p></blockquote><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在局部位置，可以创建内部类对象，通过对象调用和内部类方法</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> age2 = <span class="number">30</span>;</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  System.out.println(age);</span><br><span class="line">                  <span class="comment">//从内部类中访问方法内变量age2，需要将变量声明为最终类型。</span></span><br><span class="line">                  System.out.println(age2);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">          i.show();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>为什么局部内部类访问局部变量必须加final修饰呢？</strong></p><p>因为<strong>局部变量是随着方法的调用而调用</strong>，<strong>使用完毕就消失</strong>，<strong>而堆内存的数据并不会立即消失</strong>。</p><p>所以，堆内存还是用该变量，而该变量已经没有了。<strong>为了让该值还存在，就加final修饰。</strong></p><p>原因是，当我们使用final修饰变量后，堆内存直接存储的<strong>是值</strong>，而<strong>不是变量名</strong>。</p><p>（即上例 age2 的位置存储着常量30 而不是 age2 这个变量名）</p><h4 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="(3) 静态内部类"></a>(3) 静态内部类</h4><blockquote><p>我们所知道static是不能用来修饰类的,但是成员内部类可以看做外部类中的一个成员,所以可以用static修饰,这种用static修饰的内部类我们称作静态内部类,也称作嵌套内部类.<br>特点：静态内部类只能访问静态的外部属性和方法。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> ages = <span class="number">20</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              System.out.println(age);<span class="comment">//报错</span></span><br><span class="line">              System.out.println(ages);<span class="comment">//正确</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        inner.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="(4) 匿名内部类"></a>(4) 匿名内部类</h4><blockquote><p>一个没有名字的类，是内部类的简化写法</p></blockquote><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">    重写方法();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质：其实是继承该类或者实现接口的子类匿名对象</p><p>这也就是下例中，可以直接使用 new Inner() {}.show(); 的原因 == <strong>子类</strong>对象.show();</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        o.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="4、应用场景"><a href="#4、应用场景" class="headerlink" title="4、应用场景"></a>4、应用场景</h3><h4 id="1-封装性"><a href="#1-封装性" class="headerlink" title="(1)封装性"></a>(1)封装性</h4><p>对类的使用访问者的访问权限做出一定的限制，我们需要将一些我们不愿意让别人看到的操作隐藏起来，</p><p>如果我们的内部类不想轻易被任何人访问，可以选择使用private修饰内部类，这样我们就无法通过创建对象的方法来访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Demo &#123;</span><br><span class="line">      void show();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class Outer &#123;</span><br><span class="line">      private class test implements Demo &#123;</span><br><span class="line">          public void show() &#123;</span><br><span class="line">              System.out.println(&quot;密码备份文件&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public Demo getInner() &#123;</span><br><span class="line">      &#x2F;&#x2F;可以增加一些判断语句</span><br><span class="line">          return new test();</span><br><span class="line">      &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">          Outer outer &#x3D; new Outer();</span><br><span class="line">          Demo d &#x3D; outer.getInner();</span><br><span class="line">          i.show();&#x2F;&#x2F; 密码备份文件</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现多继承"><a href="#2-实现多继承" class="headerlink" title="(2) 实现多继承"></a>(2) 实现多继承</h4><p>我们之前的学习知道，java是不可以实现多继承的，一次只能继承一个类，我们学习接口的时候，有提到可以用接口来实现多继承的效果，即一个接口有多个实现，但是这里也是有一点弊端的，那就是，一旦实现一个接口就必须实现里面的所有方法，有时候就会出现一些累赘，但是使用内部类可以很好的解决这些问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BWH_Steven&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">email</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xxx.@163.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">extends</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.name();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> <span class="keyword">extends</span> <span class="title">Demo2</span>  </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">email</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.email();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> test1().name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">email</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> test2().email();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MyDemo md = <span class="keyword">new</span> MyDemo();</span><br><span class="line">        System.out.println(<span class="string">&quot;我的姓名:&quot;</span> + md.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;我的邮箱:&quot;</span> + md.email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写了两个待继承的类Demo1和Demo2，在MyDemo类中书写了两个内部类，test1和test2 两者分别继承了Demo1和Demo2类，这样MyDemo中就间接的实现了多继承。</p><h4 id="3-用匿名内部类实现回调功能"><a href="#3-用匿名内部类实现回调功能" class="headerlink" title="(3) 用匿名内部类实现回调功能"></a>(3) 用匿名内部类实现回调功能</h4><p>我们用通俗讲解就是说在Java中，通常就是编写一个接口，然后你来实现这个接口，然后把这个接口的一个对象作以参数的形式传到另一个程序方法中， 然后通过接口调用你的方法，匿名内部类就可以很好的展现了这一种回调功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(Demo demo)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyDemo md = <span class="keyword">new</span> MyDemo();</span><br><span class="line">        <span class="comment">//这里我们使用匿名内部类的方式将接口对象作为参数传递到test方法中去了</span></span><br><span class="line">        md.test(<span class="keyword">new</span> Demo)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;具体实现接口&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="JVM" scheme="https://yuhaicheng.xyz/categories/JVM/"/>
    
    
    <category term="内部类" scheme="https://yuhaicheng.xyz/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>某团春招一面</title>
    <link href="https://yuhaicheng.xyz/2021-04-06-%E7%BE%8E%E5%9B%A2%E6%98%A5%E6%8B%9B%E6%AD%BB%E4%BA%A11%E9%9D%A2.html"/>
    <id>https://yuhaicheng.xyz/2021-04-06-%E7%BE%8E%E5%9B%A2%E6%98%A5%E6%8B%9B%E6%AD%BB%E4%BA%A11%E9%9D%A2.html</id>
    <published>2021-04-06T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>美团一面</p><p>redis 为什么是单线程的<br>mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁<br>mysql下都有哪些数据结构，场景都用在哪里了<br>事物的回滚，a,b,c中a b成功了，c没成功，具体底层是怎么回滚的<br>事物的隔离级别<br>rpc框架通信的协议策略等，具体到可以解决哪个环节出现的问题<br>消息队列 具体是怎么削峰的（配置策略等），kafka把消息存在哪里，消息会溢出吗<br>hashtable 中写读、读写可以同时进行吗<br>层序遍历二叉树<br>定时任务的底层是怎么做到的<br>多线程中怎么抛出异常<br>java中都有什么锁，怎么实现加锁<br>软件工程学过吗，讲讲思想<br>机器开多少个多线程正常，比如说是和八核处理器，开多少个线程</p><h3 id="1-redis-为什么是单线程的"><a href="#1-redis-为什么是单线程的" class="headerlink" title="1.redis 为什么是单线程的"></a>1.redis 为什么是单线程的</h3><p>首先要了解Redis的<strong>高并发和快速</strong>原因：</p><p>1.redis是基于内存的，内存的读写速度非常快；</p><p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p><p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p><blockquote><p>上下文切换线程:</p><p>多线程编程中一般线程的个数都大于CPU核心的个数，而一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。<br>概括来说就是：当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。<br>Linux 相比与其他操作系统（包括其他类Unix系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p><strong>多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。</strong>因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。</p><h3 id="2-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁"><a href="#2-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁" class="headerlink" title="2.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁"></a>2.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁</h3><h4 id="（1）开销、加锁速度、死锁、粒度、并发性能"><a href="#（1）开销、加锁速度、死锁、粒度、并发性能" class="headerlink" title="（1）开销、加锁速度、死锁、粒度、并发性能"></a>（1）开销、加锁速度、死锁、粒度、并发性能</h4><ul><li>表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li><li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><table><thead><tr><th>引擎</th><th>行锁</th><th>表锁</th><th>页锁</th></tr></thead><tbody><tr><td>MyISAM</td><td></td><td>支持</td><td></td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td></td></tr></tbody></table><h4 id="（2）如何加表锁"><a href="#（2）如何加表锁" class="headerlink" title="（2）如何加表锁"></a>（2）如何加表锁</h4><p><strong>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p><blockquote><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p></blockquote><p>给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(total) <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(subtotal) <span class="keyword">from</span> order_detail;</span><br><span class="line">这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</span><br><span class="line"></span><br><span class="line"><span class="keyword">Lock</span> <span class="keyword">tables</span> orders <span class="keyword">read</span> <span class="keyword">local</span>, order_detail <span class="keyword">read</span> <span class="keyword">local</span>;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(total) <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(subtotal) <span class="keyword">from</span> order_detail;</span><br><span class="line"><span class="keyword">Unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>要特别说明以下两点内容。</p><ul><li>上面的例子在Lock tables时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面的章节中还会进一步介绍。</li><li>在用Lock tables给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行Lock tables后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</li></ul><p><strong>其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。</strong></p><h4 id="（3）InnoDB锁问题"><a href="#（3）InnoDB锁问题" class="headerlink" title="（3）InnoDB锁问题"></a>（3）InnoDB锁问题</h4><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p><p>InnoDB的行锁模式及加锁方法</p><p>InnoDB实现了以下两种类型的行锁。</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p></li><li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p></li><li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p></li></ul><p>上述锁模式的兼容情况具体如下表所示。</p><p> InnoDB行锁模式兼容性列表</p><table><thead><tr><th>请求锁模式  是否兼容当前锁模式</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p><strong>意向锁是InnoDB自动加的，不需用户干预</strong>。</p><p><strong>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句,InnoDB不会加任何锁；</strong></p><p>事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><ul><li>共享锁（S）：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。</span><br></pre></td></tr></table></figure><ul><li>排他锁（X)：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE。</span><br></pre></td></tr></table></figure><p>用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁。</p><h5 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a><strong>InnoDB行锁实现方式</strong></h5><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</p><p>InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。</p><p><strong>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</strong></p><p>a.在如下所示的例子中，开始tab_no_index表没有索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tab_no_index(id int,name varchar(10)) engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.15 sec)</span><br><span class="line">mysql&gt; insert into tab_no_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class="line"></span><br><span class="line">ok的</span><br><span class="line"></span><br><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class="line"></span><br><span class="line">session_2 等待 走的是表锁</span><br></pre></td></tr></table></figure><p>在如上表所示的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下表所示。</p><p>b.创建tab_with_index表，id字段有普通索引：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tab_with_index(id int,name varchar(10)) engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.15 sec)</span><br><span class="line">mysql&gt; alter table tab_with_index add index id(id);</span><br><span class="line">Query OK, 4 rows affected (0.24 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>  InnoDB存储引擎的表在使用索引时使用行锁例子</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class="line"></span><br><span class="line">ok的</span><br><span class="line"></span><br><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class="line"></span><br><span class="line">ok的</span><br></pre></td></tr></table></figure><p><strong>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。</strong></p><p>在如下表所示的例子中，表tab_with_index的id字段有索引，name字段没有索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">name</span>;</span><br><span class="line">Query OK, 4 rows affected (0.22 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; insert into tab_with_index  values(1,&#x27;4&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| 1    | 1    |</span><br><span class="line">| 1    | 4    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;1&#x27; for update;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;4&#x27; for update;</span><br><span class="line">等待</span><br><span class="line"></span><br><span class="line">虽然session_2访问的是和session_1不同的记录，但是因为使用了相同的索引，所以需要等待锁：</span><br></pre></td></tr></table></figure><p><strong>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</strong></p><p>在如下表所示的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table tab_with_index add index name(name);</span><br><span class="line">Query OK, 5 rows affected (0.23 sec)</span><br><span class="line">Records: 5  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p> InnoDB存储引擎的表使用不同索引的阻塞例子</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1 for update;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| 1    | 1    |</span><br><span class="line">| 1    | 4    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Session_2  使用<span class="keyword">name</span>的索引访问记录，因为记录没有被索引，所以可以获得锁：</span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> tab_with_index <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;2&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| 2    | 2    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Session_2 由于访问的记录已经被session_1锁定，所以等待获得锁。</span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> tab_with_index <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><strong>（4）</strong>即便在条件中使用了索引字段<strong>，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的</strong>，如果MySQL认为<strong>全表扫描</strong>效率更高，比如对一些很小的表，它就<strong>不会使用索引</strong>，这种情况下InnoDB将<strong>使用表锁，而不是行锁</strong>。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p><p>在下面的例子中，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。</p><p>例子中tab_with_index表的name字段有索引，但是name字段是varchar类型的，如果where条件中不是和varchar类型进行比较，则会对name进行类型转换，而执行的全表扫描。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table tab_no_index add index name(name);</span><br><span class="line">Query OK, 4 rows affected (8.06 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; explain select * from tab_with_index where name = 1 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">         id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tab_with_index</span><br><span class="line">         type: ALL   全表扫码</span><br><span class="line">possible_keys: name</span><br><span class="line">         key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">         ref: NULL</span><br><span class="line">        rows: 4</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; explain select * from tab_with_index where name = &#x27;1&#x27; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">       table: tab_with_index</span><br><span class="line">        type: ref         用索引了</span><br><span class="line">possible_keys: name</span><br><span class="line">        key: name</span><br><span class="line">      key_len: 23</span><br><span class="line">        ref: const</span><br><span class="line">       rows: 1</span><br><span class="line">     Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="（4）间隙锁（Next-Key锁）"><a href="#（4）间隙锁（Next-Key锁）" class="headerlink" title="（4）间隙锁（Next-Key锁）"></a>（4）间隙锁（Next-Key锁）</h4><p>解决了mysql幻读的问题。</p><p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</strong></p><p>**a.**举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span>  emp <span class="keyword">where</span> empid &gt; <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p><strong>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求</strong>，对于上面的例子，要是不使用间隙锁，如果其它事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p><strong>b.还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</strong></p><p>在如下表所示的例子中，假如emp表中只有101条记录，其empid的值分别是1,2,......,100,101。</p><p>InnoDB存储引擎的间隙锁阻塞例子</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>当前session对不存在的记录加for update的锁：                                                                       mysql&gt; select * from emp where empid = 102 for update;</td><td></td></tr><tr><td></td><td>这时，如果其他session插入empid为102的记录（注意：这条记录并不存在），也会出现锁等待：                   mysql&gt;insert into emp(empid,...) values(102,...);阻塞等待</td></tr><tr><td>Session_1 执行rollback：                                 mysql&gt; rollback;                                     Query OK, 0 rows affected (13.04 sec)</td><td></td></tr><tr><td></td><td>由于其他session_1回退后释放了Next-Key锁，当前session可以获得锁并成功插入记录：                               mysql&gt;insert into emp(empid,...) values(102,...);                Query OK, 1 row affected (13.35 sec)</td></tr></tbody></table><h4 id="（5）什么时候使用表锁"><a href="#（5）什么时候使用表锁" class="headerlink" title="（5）什么时候使用表锁"></a>（5）什么时候使用表锁</h4><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><ul><li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。</p><p>在InnoDB下，使用表锁要注意以下两点。</p><p>（1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。有关死锁，下一小节还会继续讨论。</p><p>（2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。正确的方式见如下语句：</p><p>例如，如果需要写表t1并从表t读，可以按如下做：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><h3 id="3-mysql下都有哪些数据结构，场景都用在哪里了"><a href="#3-mysql下都有哪些数据结构，场景都用在哪里了" class="headerlink" title="3.mysql下都有哪些数据结构，场景都用在哪里了"></a>3.mysql下都有哪些数据结构，场景都用在哪里了</h3><p>首先要知道Hash索引和B+树索引的底层实现原理:</p><p>hash索引底层就是hash表，进行查找时,调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</p><p>B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据。</p><p>那么可以看出他们有以下的不同:</p><ul><li>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</li></ul><p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p><ul><li>hash索引不支持使用索引进行排序,原理同上.</li><li>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.<strong>AAAA</strong>和<strong>AAAAB</strong>的索引没有相关性.</li><li>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</li><li>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</li></ul><p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p><h4 id="聚簇索引与非聚簇索引的区别"><a href="#聚簇索引与非聚簇索引的区别" class="headerlink" title="聚簇索引与非聚簇索引的区别"></a>聚簇索引与非聚簇索引的区别</h4><p> 在《数据库原理》里面，对聚簇索引的解释是: <strong>聚簇索引的顺序就是数据的物理存储顺序</strong>，聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p><p>而对非聚簇索引的解释是:<strong>索引顺序与数据物理排列顺序无关。</strong></p><p>正式因为如此，所以一个表最多只能有一个聚簇索引。聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是 索引节点，并保留一个链接指向对应 数据块。</p><p>在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. <strong>在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.</strong></p><p>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p><h3 id="4-事物的回滚，a-b-c中a-b成功了，c没成功，具体底层是怎么回滚的"><a href="#4-事物的回滚，a-b-c中a-b成功了，c没成功，具体底层是怎么回滚的" class="headerlink" title="4.事物的回滚，a,b,c中a b成功了，c没成功，具体底层是怎么回滚的"></a>4.事物的回滚，a,b,c中a b成功了，c没成功，具体底层是怎么回滚的</h3><h3 id="5-机器开多少个多线程正常，比如说是和八核处理器，开多少个线程"><a href="#5-机器开多少个多线程正常，比如说是和八核处理器，开多少个线程" class="headerlink" title="5.机器开多少个多线程正常，比如说是和八核处理器，开多少个线程"></a>5.机器开多少个多线程正常，比如说是和八核处理器，开多少个线程</h3><p>根据一些大厂经验：具体还得需要根据实际机器进行测试调控</p><p>CPU密集型：核心线程数 = CPU核数 + 1<br>IO密集型：核心线程数 = CPU核数 * 2+1<br>注：IO密集型（某大厂实践经验）<br>核心线程数 = CPU核数 / （1-阻塞系数）<br>例如阻塞系数 0.8，CPU核数为4，则核心线程数为20</p><blockquote><p><strong>CPU密集型（CPU-bound）</strong><br>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p><p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p><p><strong>IO密集型（I/O bound）</strong><br>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。</p><p>I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p></blockquote>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="面试" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="应届面试" scheme="https://yuhaicheng.xyz/tags/%E5%BA%94%E5%B1%8A%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>项目中的乱码和解决</title>
    <link href="https://yuhaicheng.xyz/2021-04-05-%E4%B9%B1%E7%A0%81%E5%92%8C%E8%A7%A3%E5%86%B3.html"/>
    <id>https://yuhaicheng.xyz/2021-04-05-%E4%B9%B1%E7%A0%81%E5%92%8C%E8%A7%A3%E5%86%B3.html</id>
    <published>2021-04-05T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天正式把项目跑通了，但是在外网项目上提交数据时，控制台上打的日志中文乱码，因为项目是同事们基本上都开发完了的，我是后拉取的，找了一下配置，在resources文件下的log4j2.xml文件中有Configuration-&gt;Appenders-&gt;Console标签下加<PatternLayout charset="UTF-8" pattern="${LOG.PATTERN}"/></p><p>然后解决日志打印的中文乱码，但是发现数据库中的中文数据还是乱码 ？？？</p><p>然后在xmm.jdbc.url=jdbc:mysql:数据库名://......后面加  <strong>&amp;characterEncoding=utf8</strong>，重点是数据库编码还是<strong>utf8 -- UTF-8 Unicode</strong>；具体为什么就不清楚了</p><blockquote><p>&amp;characterEncoding=UTF-8  ：在使用这个时应该开启这个功能 &amp;useUnicode=true，使用Unicode字符集</p><p>所以 &amp;useUnicode=true&amp;characterEncoding=UTF-8 一般都是一起使用的</p></blockquote><h2 id="1-在这里说一下-amp-characterEncoding-utf8-的作用"><a href="#1-在这里说一下-amp-characterEncoding-utf8-的作用" class="headerlink" title="1.在这里说一下 &amp;characterEncoding=utf8 的作用"></a>1.在这里说一下 &amp;characterEncoding=utf8 的作用</h2><p>前提是项目数据为UTF-8，数据库是GBK</p><ol><li><p>存数据时：</p><p>数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。</p></li><li><p>取数据时：</p><p>在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。</p></li></ol><p>项目和数据库都为UTF8的话，可以不写！！！</p><h2 id="2-连接数据库时allowMultiQueries-true的作用："><a href="#2-连接数据库时allowMultiQueries-true的作用：" class="headerlink" title="2.连接数据库时allowMultiQueries=true的作用："></a>2.连接数据库时allowMultiQueries=true的作用：</h2><ol><li>可以在sql语句后携带分号，实现多语句执行。</li><li>可以执行批处理，同时发出多个SQL语句。</li></ol><h2 id="3-既然整体说到这里，说一下整体的乱码解决方案"><a href="#3-既然整体说到这里，说一下整体的乱码解决方案" class="headerlink" title="3.既然整体说到这里，说一下整体的乱码解决方案"></a>3.既然整体说到这里，说一下整体的乱码解决方案</h2><p>以idea为例，配置全局属性，省的一个一个项目改；点击File | Settings | Editor | File Encodings;把上面的Global Encoding 和 Project Encoding 都设置为UTF-8，下面的Default encoding for propertiles 设置为 UTF-8并勾选后面的方格，最后选择最下面的Create UTF-8 files 为 with NO BOM；点击 Apply 应用  Ok 推出。</p><h2 id="4-spring系列框架中解决-前台从后台传递数据时出现中文乱码问题"><a href="#4-spring系列框架中解决-前台从后台传递数据时出现中文乱码问题" class="headerlink" title="4.spring系列框架中解决---前台从后台传递数据时出现中文乱码问题"></a>4.spring系列框架中解决---前台从后台传递数据时出现中文乱码问题</h2><p><strong>问题描述：</strong></p><p>当传递中文参数到controller类时，无乱是get方式还是post方式都出现乱码</p><p>解决：</p><p>1、保证所有的页面编码都是utf-8，包括jsp页面，浏览器编码设置和idea的编码设置。</p><p>2、spingmvc给我们提供了一个编码过滤器，只需要在配置文件web.xml中加入即可。如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置spring自带的过滤器中文乱码解决--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、以上两步有时只能解决post方式传递参数乱码问题，get方式还是出现乱码，则就需要该tomcat的配置文件了，打开tomcat的server.xml文件，找到以下行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector connectionTimeout&#x3D;&quot;20000&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; redirectPort&#x3D;&quot;8443&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>在上面行中插入URIEncoding=&quot;UTF-8&quot;，改成如下形式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connector URIEncoding&#x3D;&quot;UTF-8&quot;  connectionTimeout&#x3D;&quot;20000&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; redirectPort&#x3D;&quot;8443&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>这样就解决了springmvc中文参数传递乱码问题了。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="Mysql" scheme="https://yuhaicheng.xyz/categories/Mysql/"/>
    
    
    <category term="乱码问题" scheme="https://yuhaicheng.xyz/tags/%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>敏感数据加解密</title>
    <link href="https://yuhaicheng.xyz/2021-04-04-%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://yuhaicheng.xyz/2021-04-04-%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E5%AE%9E%E7%8E%B0.html</id>
    <published>2021-04-04T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用mybatis插件-Aces系统完成加解密（aec算法）"><a href="#1-使用mybatis插件-Aces系统完成加解密（aec算法）" class="headerlink" title="1.使用mybatis插件+Aces系统完成加解密（aec算法）"></a>1.使用mybatis插件+Aces系统完成加解密（aec算法）</h3><p>首先加入pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jd.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aces-mybatisclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用mbatis里的TypeHandlers标签,在<strong>mybatis-config.xml</strong>加入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.jd.security.aces.mybatis.handle.AcesIndexHandle&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.jd.security.aces.mybatis.type.AcesJavaType&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.jd.security.aces.mybatis.handle.AcesCipherTextHandle&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.jd.security.aces.mybatis.type.AcesJavaType&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.jd.security.aces.mybatis.handle.AcesPlainTextHandle&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.jd.security.aces.mybatis.type.AcesJavaType&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>AcesCipherTextHandle：对明文做加密，密文做解密用</li><li>AcesPlainTextHandle：aces.writePlaintext=true时写明文，aces.writePlaintext=false时不写明文</li><li>AcesIndexHandle：对明文生成hash256索引值，用于where等于查询</li></ul><p>根据是否去精确查找信息来判断是否加入密文索引字段。</p><p>使用的加密算法是对称加密算法aes，加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。</p><p>AES加密过程涉及到4种操作，分别是字节替代、行移位、列混淆和轮密钥加。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16个字节的明文、密文和轮密钥都以一个4x4的矩阵表示。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="面试" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="应届面试" scheme="https://yuhaicheng.xyz/tags/%E5%BA%94%E5%B1%8A%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于数据类型的一些坑</title>
    <link href="https://yuhaicheng.xyz/2021-04-03-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html"/>
    <id>https://yuhaicheng.xyz/2021-04-03-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.html</id>
    <published>2021-04-03T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、详细剖析一下java浮点型运算为什么会造成精度丢失？"><a href="#1、详细剖析一下java浮点型运算为什么会造成精度丢失？" class="headerlink" title="1、详细剖析一下java浮点型运算为什么会造成精度丢失？"></a>1、详细剖析一下java浮点型运算为什么会造成精度丢失？</h2><h3 id="1-首先我们要搞清楚下面两个问题："><a href="#1-首先我们要搞清楚下面两个问题：" class="headerlink" title="1.首先我们要搞清楚下面两个问题："></a>1.首先我们要搞清楚下面两个问题：</h3><pre><code> (1) 十进制整数如何转化为二进制数       算法很简单。举个例子，11表示成二进制数：                 11/2=5 余   1                   5/2=2   余   1                   2/2=1   余   0                   1/2=0   余   1                      0结束         11二进制表示为(从下往上):1011      这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。  (2) 十进制小数如何转化为二进制数       算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数                 0.9*2=1.8   取整数部分 1                 0.8(1.8的小数部分)*2=1.6    取整数部分 1                 0.6*2=1.2   取整数部分 1                 0.2*2=0.4   取整数部分 0                 0.4*2=0.8   取整数部分 0                 0.8*2=1.6 取整数部分 1                 0.6*2=1.2   取整数部分 0                          .........      0.9二进制表示为(从上往下): 1100100100100......       注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了&quot;减不尽&quot;的精度丢失问题。</code></pre><h3 id="2-float型在内存中的存储"><a href="#2-float型在内存中的存储" class="headerlink" title="2.float型在内存中的存储"></a><strong>2.float型在内存中的存储</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">众所周知、 Java 的float型在内存中占4个字节。float的32个二进制位结构如下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float内存存储结构</span><br><span class="line"></span><br><span class="line">             4bytes      31    30    29----23    22----0         </span><br><span class="line"></span><br><span class="line">                        表示       实数符号位    指数符号位        指数位          有效数位</span><br><span class="line"></span><br><span class="line">        其中符号位1表示正，0表示负。有效位数位24位，其中一位是实数符号位。</span><br><span class="line"></span><br><span class="line">         将一个float型转化为内存存储格式的步骤为：</span><br><span class="line"></span><br><span class="line">     （1）先将这个实数的绝对值化为二进制格式，注意实数的整数部分和小数部分的二进制方法在上面已经探讨过了。 </span><br><span class="line">     （2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。 </span><br><span class="line">     （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。 </span><br><span class="line">     （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。 </span><br><span class="line">     （5）如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n&#x3D;0，则第30位放入“0”。 </span><br><span class="line">     （6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n&#x3D;0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。</span><br><span class="line"></span><br><span class="line">          举例说明： 11.9的内存存储格式</span><br><span class="line"></span><br><span class="line">       (1) 将11.9化为二进制后大约是&quot; 1011. 1110011001100110011001100...&quot;。</span><br><span class="line"></span><br><span class="line">       (2) 将小数点左移三位到第一个有效位右侧： &quot;1. 011 11100110011001100110 &quot;。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。</span><br><span class="line"></span><br><span class="line">       (3) 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011 11100110011001100110 ”共23bit。将它放入float存储结构的第22到第0位。</span><br><span class="line"></span><br><span class="line">       (4) 因为11.9是正数，因此在第31位实数符号位放入“0”。</span><br><span class="line"></span><br><span class="line">       (5) 由于我们把小数点左移，因此在第30位指数符号位放入“1”。</span><br><span class="line"></span><br><span class="line">       (6) 因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。</span><br><span class="line"></span><br><span class="line">           最后表示11.9为： 0 1 0000010 011 11100110011001100110</span><br><span class="line"></span><br><span class="line">           再举一个例子：0.2356的内存存储格式</span><br><span class="line">      （1）将0.2356化为二进制后大约是0.00111100010100000100100000。 </span><br><span class="line">      （2）将小数点右移三位得到1.11100010100000100100000。 </span><br><span class="line">      （3）从小数点右边数出二十三位有效数字，即11100010100000100100000放</span><br><span class="line">入第22到第0位。 </span><br><span class="line">      （4）由于0.2356是正的，所以在第31位放入“0”。 </span><br><span class="line">      （5）由于我们把小数点右移了，所以在第30位放入“0”。 </span><br><span class="line">      （6）因为小数点被右移了3位，所以将3化为二进制，在左边补“0”补足七</span><br><span class="line">位，得到0000011，各位取反，得到1111100，放入第29到第23位。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           最后表示0.2356为：0 0 1111100 11100010100000100100000</span><br><span class="line"></span><br><span class="line">          将一个内存存储的float二进制格式转化为十进制的步骤： </span><br><span class="line">     （1）将第22位到第0位的二进制数写出来，在最左边补一位“1”，得到二十四位有效数字。将小数点点在最左边那个“1”的右边。 </span><br><span class="line">     （2）取出第29到第23位所表示的值n。当30位是“0”时将n各位求反。当30位是“1”时将n增1。 </span><br><span class="line">     （3）将小数点左移n位（当30位是“0”时）或右移n位（当30位是“1”时），得到一个二进制表示的实数。 </span><br><span class="line">     （4）将这个二进制实数化为十进制，并根据第31位是“0”还是“1”加上正号或负号即可。</span><br></pre></td></tr></table></figure><h3 id="3-浮点型的减法运算"><a href="#3-浮点型的减法运算" class="headerlink" title="3.浮点型的减法运算"></a><strong>3.浮点型的减法运算</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浮点加减运算过程比定点运算过程复杂。完成浮点加减运算的操作过程大体分为四步：</span><br><span class="line"></span><br><span class="line">(1) 0操作数的检查；</span><br><span class="line">        如果判断两个需要加减的浮点数有一个为0，即可得知运算结果而没有必要再进行有序的一些列操作。 </span><br><span class="line"></span><br><span class="line">(2) 比较阶码（指数位）大小并完成对阶；</span><br><span class="line">    两浮点数进行加减，首先要看两数的 指数位 是否相同，即小数点位置是否对齐。若两数 指数位 相同，表示小数点是对齐的，就可以进行尾数的加减运算。反之，若两数阶码不同，表示小数点位置没有对齐，此时必须使两数的阶码相同，这个过程叫做对阶 。</span><br><span class="line"></span><br><span class="line">    如何对 阶(假设两浮点数的指数位为 Ex 和 Ey )：</span><br><span class="line">    通过尾数的移位以改变 Ex 或 Ey ，使之相等。 由 于浮点表示的数多是规格化的，尾数左移会引起最高有位的丢失，造成很大误差；而尾数右移虽引起最低有效位的丢失，但造成的误差较小，因此，对阶操作规定使 尾数右移，尾数右移后使阶码作相应增加，其数值保持不变。很显然，一个增加后的阶码与另一个相等，所增加的阶码一定是小阶。因此在对阶时，总是使小阶向大阶看齐 ，即小阶的尾数向右移位 ( 相当于小数点左移 ) ，每右移一位，其阶码加 1 ，直到两数的阶码相等为止，右移的位数等于阶差 △ E 。 </span><br><span class="line"></span><br><span class="line">(3) 尾数（有效数位）进行加或减运算；</span><br><span class="line"></span><br><span class="line">(4) 结果规格化并进行舍入处理。</span><br></pre></td></tr></table></figure><p>java在计算浮点数的时候,由于二进制无法精确表示0.1的值(就好比十进制无法精确表示1/3一样),所以一般会对小数格式化处理.</p><p>但是如果涉及到金钱的项目,一点点误差都不能有,必须使用精确运算的时候,就可以使用BigDecimal方法计算.</p><p><strong>但是在使用中还需要注意一个问题:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接使用double类型数据进行运算</span><br><span class="line">System.out.println(0.05+0.01);</span><br><span class="line">&#x2F;&#x2F;使用BigDecimal的double参数的构造器</span><br><span class="line">BigDecimal bd1 &#x3D; new BigDecimal(0.05);</span><br><span class="line">BigDecimal bd2 &#x3D; new BigDecimal(0.01);</span><br><span class="line">System.out.println(bd1.add(bd2));</span><br><span class="line">&#x2F;&#x2F;使用BigDecimal的String参数的构造器</span><br><span class="line">BigDecimal bd3 &#x3D; new BigDecimal(&quot;0.05&quot;);</span><br><span class="line">BigDecimal bd4 &#x3D; new BigDecimal(&quot;0.01&quot;);</span><br><span class="line">System.out.println(bd3.add(bd4));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0.06000000000000000000006</span><br><span class="line">0.060000000000000000000062937...</span><br><span class="line">0.06</span><br></pre></td></tr></table></figure><p>所以在计算的时候,应该先把数字转换成String类型的,才能得到最精确的值.</p><p>附常用的方法:</p><p>add  加</p><p>subtract  减</p><p>multiply  乘</p><p>divide 除</p><p>abs 绝对值</p><p>getScale  根据一个规则取几位小数</p><p>pow  几次方</p><h2 id="2、mysql中-int-4-、int-10-的区别"><a href="#2、mysql中-int-4-、int-10-的区别" class="headerlink" title="2、mysql中 int(4) 、int(10)的区别"></a>2、mysql中 int(4) 、int(10)的区别</h2><p><strong>int(M)</strong></p><p>这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(4)只能存储 4个长度的数字，int(11)就会存储 11 个长度的数字，这是大错特错的。</p><p>int(10)也可以代表 2147483647 (2^32 /2  -1)这个值, int(11)也可以代表。</p><p>要查看出不同效果记得在创建类型的时候加 zerofill这个值，表示用 0 填充，否则看不出效果的。</p><p>我们通常在创建数据库的时候都不会加入这个选项，所以可以说他们之间是没有区别的。</p><p>声明字段是int类型的那一刻起，int就是占四个字节，一个字节 8 位，也就是4*8=32，可以表示的数字个数是 2的 32 次方(2^32 = 4 294 967 296个数字)。</p><p>4 294 967 296个数字也就是0~4 294 967 295，当然如果区分正负号的话所存的数字会比较小。</p><p>所以，<code>int(4)</code> 与<code>int(11)</code>后的括号中的字符表示<strong>显示宽度</strong>，整数列的显示宽度与 MySQL 需要用多少个字符来显示该列数值，与该整数需要的存储空间的大小都没有关系，</p><p><strong><code>int</code>类型的字段能存储的数据上限依旧是2147483647(有符号型)和4294967295(无符号型)。</strong></p><h2 id="3、mysql中varchar-和-char-的一些问题"><a href="#3、mysql中varchar-和-char-的一些问题" class="headerlink" title="3、mysql中varchar 和 char 的一些问题"></a>3、mysql中varchar 和 char 的一些问题</h2><h3 id="一-varchar存储规则"><a href="#一-varchar存储规则" class="headerlink" title="一. varchar存储规则"></a>一. varchar存储规则</h3><p><strong>4.0版本以下</strong>，varchar(20)，指的是20字节*，如果存放UTF8汉字时，只能存6个（每个汉字3字节）<br><strong>5.0版本以上</strong>，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以<strong>存放20个，最大大小是65533字节</strong> （65535-1-1）2^16-1 = 65536-1=65535</p><p>Mysql记录行数据是有限的。大小为64k,即65535个字节，而根据设置的varchar(m),M的宽度来决定变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计。</p><p>在物理存储上，varchar使用1到2个额外的字节表示实际存储的字符串长度（bytes）。如果列的最大长度小于256个字节，用一个字节表示（标识）。如果最大长度大于等于256，使用两个字节。</p><p>NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要 1bit 来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位。<strong>所以如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。</strong></p><h3 id="二-varchar和char-的区别"><a href="#二-varchar和char-的区别" class="headerlink" title="二. varchar和char 的区别"></a>二. varchar和char 的区别</h3><p>char是一种固定长度的类型</p><p>varchar则是一种可变长度的类型</p><p>它们的区别是： </p><p>char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用<strong>空格字符</strong>补足（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）</p><h3 id="三-MySQL中varchar最大长度是多少？"><a href="#三-MySQL中varchar最大长度是多少？" class="headerlink" title="三.MySQL中varchar最大长度是多少？"></a>三.MySQL中varchar最大长度是多少？</h3><p>这不是一个固定的数字。</p><h4 id="1、限制规则"><a href="#1、限制规则" class="headerlink" title="1、限制规则"></a>1、限制规则</h4><p><strong>字段的限制在字段定义的时候有以下规则：</strong></p><p><strong>a) 存储限制</strong></p><p>varchar最多能存储65535个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535bytes）。65535并不是一个很精确的上限，可以继续缩小这个上限。65535个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计. </p><p>NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要 1bit 来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位。</p><p><strong>如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。</strong></p><p>因为varchar类型存储变长字段的字符类型，与char类型不同的是，其存储时需要在前缀长度列表加上实际存储的字符，当存储的**字符串长度小于255字节时，其需要1字节的空间，当大于255字节时，需要2字节的空间。</p><p><strong>如果数据表只有一个varchar字段且该字段NOT NULL，那么该varchar字段的最大长度为65533个字节，即65535-2=65533byte</strong></p><p><strong>b) 编码长度限制</strong></p><p> <strong>字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;</strong></p><p> <strong>字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。</strong></p><p> <strong>若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。</strong></p><p><strong>c) 行长度限制</strong></p><p><strong>导致实际应用中varchar长度限制的是一个行定义的长度。 MySQL要求一个行的定义长度不能超过65535。若定义的表长度超过这个值，则提示</strong></p><p><strong>ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。</strong></p><h4 id="2、计算例子"><a href="#2、计算例子" class="headerlink" title="2、计算例子"></a><strong>2、计算例子</strong></h4><p><strong>举两个例说明一下实际长度的计算。</strong></p><p><strong>a)  若一个表只有一个varchar类型，如定义为</strong></p><p><strong>create table t4(c varchar(N)) charset=gbk;</strong></p><ol><li><strong>则此处N的最大值为(65535-1-2)/2= 32766。</strong></li><li><strong>减1的原因是实际行存储从第二个字节开始;</strong></li><li><strong>减2的原因是varchar头部的2个字节表示长度;</strong></li><li><strong>除2的原因是字符编码是gbk。</strong></li></ol><p><strong>b) 若一个表定义为</strong></p><p><strong>create table t4(c int, c2 char(30), c3 varchar(N)) charset=utf8;</strong></p><ol><li><strong>则此处N的最大值为 (65535-1-2-4-30*3)/3=21812</strong></li><li><strong>减1和减2与上例相同;</strong></li><li><strong>减4的原因是int类型的c占4个字节;</strong></li><li><strong>减30*3的原因是char(30)占用90个字节，编码是utf8。</strong> </li></ol><p><strong>如果被varchar超过上述的b规则，被强转成text类型，则每个字段占用定义长度为11字节，当然这已经不是varchar了。</strong></p><h4 id="3、varchar物理存储"><a href="#3、varchar物理存储" class="headerlink" title="3、varchar物理存储"></a>3、varchar物理存储</h4><p><strong>在物理存储上，varchar使用1到2个额外的字节表示实际存储的字符串长度（bytes）\</strong>。如果列的最大长度小于256个字节，用一个字节表示（标识）。如果最大长度大于等于256，使用两个字节。**</p><p><strong>当选择的字符集为latin1，一个字符占用一个byte</strong></p><p><strong>varchar(255)存储一个字符，一共使用2个bytes物理空间存储数据实际数据长度和数据值。</strong></p><p><strong>varchar(256)存储一个字符，使用2 bytes表示实际数据长度，一共需要3 bytes物理存储空间。</strong></p><p><strong>varchar对于不同的RDBMS引擎，有不通的物理存储方式，虽然有统一的逻辑意义。对于mysql的不同存储引擎，其实现方法与数据的物理存放方式也不同。</strong></p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="Mysql" scheme="https://yuhaicheng.xyz/categories/Mysql/"/>
    
    
    <category term="mysql数据类型坑" scheme="https://yuhaicheng.xyz/tags/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>集合set、list是如何保证自身特性的</title>
    <link href="https://yuhaicheng.xyz/2021-04-03-%E9%9B%86%E5%90%88set%E3%80%81list%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%87%AA%E8%BA%AB%E7%89%B9%E6%80%A7%E7%9A%84.html"/>
    <id>https://yuhaicheng.xyz/2021-04-03-%E9%9B%86%E5%90%88set%E3%80%81list%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%87%AA%E8%BA%AB%E7%89%B9%E6%80%A7%E7%9A%84.html</id>
    <published>2021-04-03T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Set"><a href="#1、Set" class="headerlink" title="1、Set"></a>1、Set</h3><p>无序，不重复的；</p><h4 id="不重复性："><a href="#不重复性：" class="headerlink" title="不重复性："></a><strong>不重复性：</strong></h4><p>因为当我们向Set集合加入数据时，要加入的数据会和集合里的数据比较</p><p>分步骤判断添加的Key值：<br>1、取到新添加Key值的hashCode值。<br>2、确定数组的index 根据Key的hashCode值和当前table的长度按位取并 h &amp; (length-1);<br>按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同<br>3、这里的hashcode在equals前面，JVM会先判断或运算||的前部分，当这一前部分为true的时候判断终止，返回true（这是为了提高JVM的效率），所以当hashcode不同的时候，equals是不会执行的。</p><p>注意：因为Set是接口，里面的方法偶都是抽象的，要想使用需要继承Set接口,HashSet就是一个实现Set的代表实现类。</p><p>而HashSet底层就是用HashMap来实现的，HashMap在put一个Key时会判断，将要放进去的Key的hash值与 目前HashMap中定位到的那个Key的hash值比较。</p><p>如果hashCode相同才会比较equals，equals相同，则两个对象相同，不能插入，equals不同，可以插入；<br>如果hashCode不同，就直接插入了，两个对象hashCode不相等，他们equals一定是false。</p><blockquote><p>重写equals方法后最好重写hashCode方法，否则两个等价对象可能得到不同的hashCode,这在集合框架中使用可能产生严重后果，这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，<br>当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，<br>导致混淆，因此，就也需要重写hashcode()</p></blockquote><p>注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：<br>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p><h4 id="无序性："><a href="#无序性：" class="headerlink" title="无序性："></a><strong>无序性：</strong></h4><p>Set系列集合添加元素无序的根本原因是因为底层采用了<strong>哈希表</strong>存储元素。也就是说在存储数据时数据结构是无法保证顺序的。</p><p>JDK1.8之前：哈希表 = 数组 + 链表 + (哈希算法)</p><p>JDK1.8之后：哈希表 = 数组 + 链表 + 红黑树 + (哈希算法)<br>当链表长度超过阈值(8)时，并且树组长度大于64，将链表转换为红黑树，这样大大减少了查找时间。</p><h3 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h3><h4 id="可重复性："><a href="#可重复性：" class="headerlink" title="可重复性："></a>可重复性：</h4><h4 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a>有序性：</h4><p>list集合代表一个有序集合，<strong>集合中每个元素都有其对应的顺序索引。所以List集合允许使用重复元素</strong>，可以通过索引来访问指定位置的集合元素。</p><p>List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p><p><strong>有序</strong>是根据自己本身的类排序达到的，具体看实现类中是怎做到的。</p><p>List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h3 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h3><p>key-value形式存储的，Map 可能会持有相同的值对象但键对象必须是唯一的。</p><p>list和set是继承collection接口的。<br>Map不是collection的子接口或者实现类。Map是一个接口。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/categories/%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>分页</title>
    <link href="https://yuhaicheng.xyz/2021-04-02-%E5%88%86%E9%A1%B5%E7%9A%84%E6%80%9D%E6%83%B3.html"/>
    <id>https://yuhaicheng.xyz/2021-04-02-%E5%88%86%E9%A1%B5%E7%9A%84%E6%80%9D%E6%83%B3.html</id>
    <published>2021-04-02T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-分页需要依靠数据库"><a href="#1-分页需要依靠数据库" class="headerlink" title="1.分页需要依靠数据库"></a>1.分页需要依靠数据库</h2><p>使用mysql数据库 limit。</p><p>首先要知道5个变量（属性）</p><p>1.数据总数        (查数据库，select count(*) ..)</p><p>2.页面大小（每页显示的数据条数）30        (用户自定义)</p><p>3.总页数        （程序自动计算：总页数=数据总数%页面大小==0 ？数据总数/页面大小：数据总数/页面大小+1）</p><p>4.当前页（页码）        （用户自定义）</p><p>5.当前页的对象集合（实体类集合）：每页所显示的所有数据 10个人信息   List<Student>   (查数据库，分页sql)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记录</span><br><span class="line">1</span><br><span class="line">..</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">..</span><br><span class="line">20</span><br><span class="line">（这里解释下：mysql的数据起始是从0开始的）</span><br><span class="line">页每页起始数  每页终止数</span><br><span class="line">009</span><br><span class="line">11019</span><br><span class="line">22029</span><br><span class="line">nn*10(n+1)*10-1</span><br><span class="line">每页都是10页</span><br><span class="line"></span><br><span class="line">对应的sql就是：</span><br><span class="line">select * from table limit n*10,10</span><br><span class="line">也就是 select * from table limit 当前页*页面大小,页面大小</span><br></pre></td></tr></table></figure><h3 id="自己手写一个分页步骤："><a href="#自己手写一个分页步骤：" class="headerlink" title="自己手写一个分页步骤："></a>自己手写一个分页步骤：</h3><p>**1.**我们需要在dao层写一个查所有记录的抽象方法，然后用select * from count(*).. 实现它.</p><p>**2.**写要查的对象方法，需要（传当前页、页面大小）可以直接传page对象；类似下面的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page&lt;BussFeeTask&gt; findByPage(Pageable pageable,</span><br><span class="line">BussFeeTaskQuery query);</span><br></pre></td></tr></table></figure><p>**3.**control l中进行获取 5个属性值 并封装</p><p>（1）当前页：当第一次进行分页查询时</p><p><strong>注意：</strong>我们control 中需要有一个默认值 当前页，也就是判断一个前端没传值，如果为null，我们自己就赋一个初值。</p><p>（2）当前页的数据集合：可以用 下面的 请求转发</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setAttribute(<span class="string">&quot;students&quot;</span>,students);</span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;index.jsp&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure><p>（3）总数据：进行调用service</p><p>（4）当前数据集合：进行调用service</p><p>（5）总页数不用赋值：但需要注意的时 我们构造方法中写pageSize的set（）方法中进行算得的，需要保证先得到totalCount ，再得到pageSize，所以封装时要注意顺序。</p><p>control -&gt; service  -&gt;  dao</p><p>**4.**写前端页面：</p><p>在分页的前提下，显示数据的jsp需要哪些数据：</p><p>当前页 currentPage</p><p>页面大小 pageSize</p><p>当前页的数据集合 students</p><p>总数据 totalCount</p><p>总页数 totalPage</p><p>为传递数据方便，封装以上五个字段 写一个工具实体类。</p><p><strong>注</strong>：这里需要注意的是总页数不用要写set方法，总页数=数据总数%页面大小==0 ？数据总数/页面大小：数据总数/页面大小+1；当我们调用 数据总数的set() 和 页面大小的set()以后，会自动计算出总页数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页 currentPage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentPage;</span><br><span class="line">    <span class="comment">//总页数 totalPage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPage;</span><br><span class="line">    <span class="comment">//页面大小 pageSize</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="comment">// 总数据 totalCount</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalCount;</span><br><span class="line">    <span class="comment">//当前页的数据集合 students</span></span><br><span class="line">    <span class="keyword">private</span> Student students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPage</span><span class="params">(<span class="keyword">int</span> currentPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public void setTotalPage(int totalPage) &#123;</span></span><br><span class="line"><span class="comment">        this.totalPage = totalPage;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPageSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPageSize</span><span class="params">(<span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里需要保证 要先进行totalCount的赋值，然后进行PageSize赋值，不然会出现空指针的现象，在control里进行数据封装时</span></span><br><span class="line">        <span class="comment">//当调用数据总数和页面大小的时候，自动计算总页数</span></span><br><span class="line">        <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">        <span class="keyword">this</span>.totalPage=<span class="keyword">this</span>.totalCount%<span class="keyword">this</span>.pageSize==<span class="number">0</span> ? <span class="keyword">this</span>.totalCount/<span class="keyword">this</span>.pageSize : <span class="keyword">this</span>.totalCount/<span class="keyword">this</span>.pageSize+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalCount</span><span class="params">(<span class="keyword">int</span> totalCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalCount = totalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(Student students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Page</span><span class="params">(<span class="keyword">int</span> currentPage, <span class="keyword">int</span> totalPage, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> totalCount, Student students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.totalPage = totalPage;</span><br><span class="line">        <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">        <span class="keyword">this</span>.totalCount = totalCount;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Page</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示页面还有这些参数：首页、上一页、下一页、尾页</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span>(page.currentPage==page.getTotalPage())&#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;a href=&quot;QueryStudentByPage?currentPage=1&quot;&gt;首页&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()-1%&gt;上一页&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;% &#125;else if (page.currentPage==1)&#123;</span></span><br><span class="line"><span class="string">     %&gt;</span></span><br><span class="line">&lt;a href=&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()+1%&gt;下一页&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;QueryStudentByPage?currentPage=&lt;%=page.getTotalPage()%&gt;尾页&lt;/a&gt;         </span></span><br><span class="line"><span class="string">&lt;% &#125;else&#123;</span></span><br><span class="line"><span class="string">    %&gt;</span></span><br><span class="line"><span class="string">&lt;a href=&quot;</span>QueryStudentByPage?currentPage=<span class="number">1</span><span class="string">&quot;&gt;首页&lt;/a&gt;</span></span><br><span class="line">&lt;a href=&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()-1%&gt;上一页&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;QueryStudentByPage?currentPage=&lt;%=page.getCurrent()+1%&gt;下一页&lt;/a&gt;</span></span><br><span class="line">&lt;a href=&quot;QueryStudentByPage?currentPage=&lt;%=page.getTotalPage()%&gt;尾页&lt;/a&gt;</span><br><span class="line">&lt;% &#125;</span><br><span class="line">         %&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>这里的上一页和下一页有一些细节问题：</p><p>在第一页时，上一页按钮应该是不好使的或不可见的</p><p>在最后一页时，下一页按钮应该是不好使的或不可见的</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="Mysql" scheme="https://yuhaicheng.xyz/categories/Mysql/"/>
    
    
    <category term="分页" scheme="https://yuhaicheng.xyz/tags/%E5%88%86%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://yuhaicheng.xyz/2021-04-01-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98.html"/>
    <id>https://yuhaicheng.xyz/2021-04-01-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98.html</id>
    <published>2021-04-01T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、分布式锁"><a href="#1、分布式锁" class="headerlink" title="1、分布式锁"></a>1、分布式锁</h2><p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。</p><h4 id="为什么要使用分布式锁"><a href="#为什么要使用分布式锁" class="headerlink" title="为什么要使用分布式锁"></a><strong>为什么要使用分布式锁</strong></h4><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\ss.png" alt="ss" loading="lazy"></p><h4 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h4><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li><li>高可用的获取锁与释放锁</li><li>高性能的获取锁与释放锁</li><li>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）</li><li>具备锁失效机制，防止死锁</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li></ul><h4 id="分布式锁的实现有哪些"><a href="#分布式锁的实现有哪些" class="headerlink" title="分布式锁的实现有哪些"></a>分布式锁的实现有哪些</h4><ul><li>Memcached：利用Memcached的add命令。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。</li><li>Redis: 和Memcached的方式类似，利用Redis的setnx命令。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。</li><li>Zookeeper：利用Zookeeper的顺序临时节点，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。</li><li>Chubby:  Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。</li></ul><h3 id="Nginx-有哪些负载均衡策略？"><a href="#Nginx-有哪些负载均衡策略？" class="headerlink" title="Nginx 有哪些负载均衡策略？"></a>Nginx 有哪些负载均衡策略？</h3><p>负载均衡，即是代理服务器将接收的请求均衡的分发到各服务器中。</p><p>Nginx 默认提供了 3 种负载均衡策略：</p><p>1、轮询（默认）round_robin</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p><p>2、IP 哈希 ip_hash</p><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。</p><p>当然，实际场景下，一般不考虑使用 ip_hash 解决 session 共享。</p><p>3、最少连接 least_conn</p><p>下一个请求将被分派到活动连接数量最少的服务器</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="分布式" scheme="https://yuhaicheng.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="锁" scheme="https://yuhaicheng.xyz/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>volatile和ThreadLocal</title>
    <link href="https://yuhaicheng.xyz/2021-03-30volatile%E3%80%81ThreadLocal.html"/>
    <id>https://yuhaicheng.xyz/2021-03-30volatile%E3%80%81ThreadLocal.html</id>
    <published>2021-03-30T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关于volatile关键字"><a href="#一、关于volatile关键字" class="headerlink" title="一、关于volatile关键字"></a>一、关于volatile关键字</h2><h3 id="1、首先了解下java内存模型，简称JMM"><a href="#1、首先了解下java内存模型，简称JMM" class="headerlink" title="1、首先了解下java内存模型，简称JMM"></a>1、首先了解下java内存模型，简称JMM</h3><p>在JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的Java内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p><p>要解决这个问题，就需要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。<br>说白了，volatile关键字的主要作用就是保证变量的可见性然。</p><blockquote><p>JMM本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p></blockquote><h3 id="2、并发编程的三个重要特性"><a href="#2、并发编程的三个重要特性" class="headerlink" title="2、并发编程的三个重要特性"></a>2、并发编程的三个重要特性</h3><p>1.原子性：一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<strong>synchronized可以保证代码片段的原子性。</strong></p><p>2.可见性：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile关键字可以保证共享变量的可见性。</p><p>3.有序性：代码在执行的过程中的先后顺序，Java在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。</p><blockquote><p>synchronized关键字和volatile关键字比较：</p><ol><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于<strong>变量</strong>而synchronized关键字可以修饰方法以及代码块。</li><li>synchronized关键字在jdk1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized 关键字的场景还是更多一些。(偏向锁、轻量级锁、重量级锁)</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证</strong></li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ol></blockquote><h3 id="3、volatile-存在的意义"><a href="#3、volatile-存在的意义" class="headerlink" title="3、volatile 存在的意义"></a>3、volatile 存在的意义</h3><h4 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h4><p>工作内存和主内存同步延迟现象导致的可见性问题，可以使用synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见。</p><h4 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2.有序性"></a>2.有序性</h4><p>对于指令重排导致的可见性问题和有序性问题，可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。</p><blockquote><p>指令重排应用的场景： 单例模式</p><p>DCL（双端检锁）机制不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排。</p><p>原因在于某一个线程执行到第一个检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。指令重排只会保证串行语义的执行一致性，但并不会关心多线程间的语义一致性。</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象指向刚分配的内存空间</li></ol><p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。</p></blockquote><h4 id="3-volatile-实现原理"><a href="#3-volatile-实现原理" class="headerlink" title="3.volatile 实现原理"></a>3.volatile 实现原理</h4><blockquote><p>在介绍volatile语义实现原理之前，我们先来看两个与CPU相关的专业术语：</p><p><strong>内存屏障</strong>（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。<br><strong>缓存行</strong>（cache line）：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。</p></blockquote><h5 id="可见性的实现"><a href="#可见性的实现" class="headerlink" title="可见性的实现"></a>可见性的实现</h5><p>借助了<strong>CPU的lock</strong>指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：</p><ol><li>写volatile时处理器会将缓存写回到主内存。</li><li>一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</li></ol><blockquote><p>具体cpu和内存间的通信：</p><p>为了提高处理速度，处理器一般不直接和内存通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完成后并不知道处理器何时将缓存数据写回到内存。但如果对加了volatile修饰的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量在缓存行的数据写回到系统内存。这时只是写回到系统内存，但其他处理器的缓存行中的数据还是旧的，要使其他处理器缓存行的数据也是新写回的系统内存的数据，就需要实现缓存一致性协议。即在一个处理器将自己缓存行的数据写回到系统内存后，其他的每个处理器就会通过嗅探在总线上传播的数据来检查自己缓存的数据是否已过期，当处理器发现自己缓存行对应的内存地址的数据被修改后，就会将自己缓存行缓存的数据设置为无效，当处理器要对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到自己的缓存行，重新缓存。</p></blockquote><h5 id="有序性的实现"><a href="#有序性的实现" class="headerlink" title="有序性的实现"></a>有序性的实现</h5><p>volatile有序性的保证就是通过禁止指令重排序来实现的。</p><p>指令重排序包括<strong>编译器</strong>和<strong>处理器</strong>重排序，JMM会分别限制这两种指令重排序。</p><p>实现就是加内存屏障，内存屏障是一种CPU指令。JMM为volatile加内存屏障有以下4种情况：</p><blockquote><p>在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。<br>在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。<br>在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序</p></blockquote><h2 id="二、关于ThreadLocal"><a href="#二、关于ThreadLocal" class="headerlink" title="二、关于ThreadLocal"></a>二、关于ThreadLocal</h2><h3 id="1、ThreadLocal简介"><a href="#1、ThreadLocal简介" class="headerlink" title="1、ThreadLocal简介"></a>1、ThreadLocal简介</h3><p><strong>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p><p>答：JDK中提供的ThreadLocal类正是为了解决这样的问题。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法。</strong></p><p>答：多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。</p><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p><strong>ThreadLocal是JDK包提供的</strong>，它提供线程本地变量，如果创建一ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，他们可以使用get（）和set（）方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h3 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h3><p>从Thread类源代码可以看出Thread 类中有一个threadLocals和一个inheritableThreadLocals 变量，它们都是ThreadLocalMap类型的变量，我们可以把ThreadLocalMap 理解为ThreadLocal类实现的定制化的HashMap。默认情况下这两个变量都是nu11，只有当前线程调用ThreadLocal类的set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的get（）、set（）方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">......</span><br><span class="line">&#x2F;&#x2F;与此线程有关的ThreadLocal值，由ThreadLocal类维护</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;与此线程有关的InheritableThreadLocal InheritableThreadLocal类维护</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体步骤：</p><p>最终的变量是放在了当前线程的 ThreadLocalMap中，并不是存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。ThrealLocal类中可以通过Thread.currentThread（）获取到当前线程对象后，直接通过getMap（Thread t）可以访问到该线程的ThreadLocalMap对象。<br>ThreadLocal 内部维护的是一个类似Map的ThreadLocalMap数据结构，key为当前对象的Thread 对象，值为0bject对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap（ThreadLocal&lt;？&gt; firstkey，Object firstValue）&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个ThreadLocal对象的话，会使用Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的key 就是ThreadLocal对象，value就是ThreadLocal对象调用set方法设置的值。</p><h3 id="3、ThreadLocal-内存泄露的问题"><a href="#3、ThreadLocal-内存泄露的问题" class="headerlink" title="3、ThreadLocal 内存泄露的问题"></a>3、ThreadLocal 内存泄露的问题</h3><p>ThreadLocalMap 中使用的key为ThreadLocal]的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap中就会出现key为null的Entry。假如我们不做任何措施的话，value永远无法被GC回收，这个时候就可能会产生内存泄露。</p><p>解决：</p><p><strong>ThreadLocalMap实现中已经考虑了这种情况，在调用set（）、get（）、remove（）方法的时候，会清理掉key为null的记录。</strong></p><p><strong>使用完ThreadLocal方法后最好手动调用remove（）方法</strong></p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="JVM" scheme="https://yuhaicheng.xyz/categories/JVM/"/>
    
    
    <category term="volatile" scheme="https://yuhaicheng.xyz/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java中值传递问题</title>
    <link href="https://yuhaicheng.xyz/2021-03-29-TestTransferValue.html"/>
    <id>https://yuhaicheng.xyz/2021-03-29-TestTransferValue.html</id>
    <published>2021-03-29T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransferValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        person.setName(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String s)</span></span>&#123;<span class="comment">//指向常量池中的abc</span></span><br><span class="line">        s = <span class="string">&quot;xxxx&quot;</span>;<span class="comment">//如果xxxx没在常量池中，会在常量池中创建一个 并指向它，方法结束就没了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        TestTransferValue test1 = <span class="keyword">new</span> TestTransferValue();</span><br><span class="line">        test1.changeValue1(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        test1.changeValue2(person);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line"></span><br><span class="line">        String s=<span class="string">&quot;abc&quot;</span>;<span class="comment">//首先在abc如果没在常量池中，会在常量池中创建一个</span></span><br><span class="line">        test1.changeValue3(s);<span class="comment">//</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">20</span></span><br><span class="line">xxxx</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/categories/java/"/>
    
    
    <category term="值传递" scheme="https://yuhaicheng.xyz/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>spring系列常用注解</title>
    <link href="https://yuhaicheng.xyz/2021-03-28-spring%E7%B3%BB%E5%88%97%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.html"/>
    <id>https://yuhaicheng.xyz/2021-03-28-spring%E7%B3%BB%E5%88%97%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.html</id>
    <published>2021-03-28T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring系列常用注解"><a href="#spring系列常用注解" class="headerlink" title="spring系列常用注解"></a>spring系列常用注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="meta">@RestController</span>：</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Required</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="meta">@RequestParam</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br></pre></td></tr></table></figure><p>1、@Controller</p><p>标识一个类是Spring MVC controller处理器，用来创建处理http请求的对象</p><p>2、@RequestMapping</p><p>作用在类定义处: 提供初步的请求映射信息，相对于 WEB 应用的根目录。<br>作用在方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。</p><p>3、RestController</p><p>Spring4之后加入的注解，原来的@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController代替@Controller就不需要@ResponseBody，默认返回json格式。</p><p>4、@Service</p><p>用于标注业务层组件，以注解的方式把这个类注入到spring配置中</p><p>5、Autowired</p><p>用来装配bean，都可以写在字段或方法上</p><p>默认情况下必须要求依赖的对象必须存在，如果要允许null值，可以设置它的required属性为false，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired(required=false)</span></span><br><span class="line"><span class="keyword">private</span> TestService service;</span><br></pre></td></tr></table></figure><blockquote><p>@Required（注释检查）</p><p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p><p>通俗的讲：该注解放在setter方法上，表示当前的setter修饰的属性必须在Spring.xml中进行装配，否则报错BeanInitializationException异常，所以这是个检查注解。</p></blockquote><p>6、@Resource</p><p>等同于@Autowired</p><p>@Autowired按照byType自动注入，而@Resource默认byName自动注入</p><p>@Resource有两个属性是比较重要，分别是name，type ；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果都不指定，这时将通过反射机制使用byName自动注入策略。</p><p>7、@RequestParam</p><p>用于将请求参数区的数据映射到功能方法的参数上，其中course_id就是接口传递的参数，id就是映射course_id的参数名，也可以不写value属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resp <span class="title">requ</span><span class="params">(<span class="meta">@RequestParam(value=&quot;course_id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Resp.success(consumerInfoService.fetch(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、@Component</p><p>把普通pojo实例化到spring容器中，相当于配置文件中的 <bean id="" class=""/><br>它泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p><p>此外，被@controller 、@service、@repository 、@component 注解的类，都会把这些类纳入进spring容器中进行管理</p><p>9、@Scope</p><p>是springIoc容器中的一个作用域</p><p>在Spring Ioc容器中作用域有：singleton（单例）默认的、prototype（多例）、web作用域（request、session、global session）、自定义作用域</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prototype原型模式：</span><br><span class="line"><span class="meta">@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span>这个是说在每次注入的时候回自动创建一个新的bean实例</span><br><span class="line"></span><br><span class="line">singleton单例模式：</span><br><span class="line"><span class="meta">@Scope(value=ConfigurableBeanFactory.SCOPE_SINGLETON)</span>单例模式，在整个应用中只能创建一个实例</span><br><span class="line"></span><br><span class="line">globalsession模式：</span><br><span class="line"><span class="meta">@Scope(value=WebApplicationContext.SCOPE_GLOBAL_SESSION)</span>全局session中的一般不常用</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(value=WebApplicationContext.SCOPE_APPLICATION)</span>在一个web应用中只创建一个实例</span><br><span class="line"></span><br><span class="line">request模式：</span><br><span class="line"><span class="meta">@Scope(value=WebApplicationContext.SCOPE_REQUEST)</span>在一个请求中创建一个实例</span><br><span class="line"></span><br><span class="line">session模式：</span><br><span class="line"><span class="meta">@Scope(value=WebApplicationContext.SCOPE_SESSION)</span>每次创建一个会话中创建一个实例</span><br></pre></td></tr></table></figure><p>10、@Bean</p><p>产生一个bean的方法，并且交给Spring容器管理，<em>相当于配置文件中的 <bean id="" class=""/>*</em></p><p>11、@Transactional</p><p>事物管理一般有编程式和声明式两种，编程式是在代码中侵入编写的；而声明式则是通过注解或者是在配置文件中进行配置的，非侵入式的。</p><p>12、@Aspect</p><p>作用是标记一个切面类（spring不会将切面注册为Bean也不会增强，但是需要扫描）</p><p>@Pointcut</p><p>定义切点，切点表达式(execution(权限访问符 返回值类型 方法所属的类名包路径.方法名(形参类型) 异常类型))</p><p>@Before</p><p>前置增强，配合@Pointcut一起使用</p><p>@AfterReturning</p><p>后置增强，配合@Pointcut一起使用</p><p>@Around</p><p>环绕增强，配合@Pointcut一起使用</p><p>@AfterThrowing</p><p>异常抛出增强，配合@Pointcut一起使用</p><p>@After</p><p>最终增强(最后执行)，配合@Pointcut一起使用  </p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="框架" scheme="https://yuhaicheng.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="注解" scheme="https://yuhaicheng.xyz/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>spring ioc流程 + 怎么解决循环依赖的问题</title>
    <link href="https://yuhaicheng.xyz/2021-03-26-spring%20ioc%E6%B5%81%E7%A8%8B%20+%20%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://yuhaicheng.xyz/2021-03-26-spring%20ioc%E6%B5%81%E7%A8%8B%20+%20%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2021-03-26T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-ioc流程-怎么解决循环依赖的问题"><a href="#spring-ioc流程-怎么解决循环依赖的问题" class="headerlink" title="spring ioc流程 + 怎么解决循环依赖的问题"></a>spring ioc流程 + 怎么解决循环依赖的问题</h2><p>先调用构造函数进行实例化，然后填充属性，再接着进行其他附加操作和初始化，正是这样的生命周期，才有了Spring的解决循环依赖，这样的解决机制是根据Spring框架内定义的三级缓存来实现的，也就是说：三级缓存解决了Bean之间的循环依赖。</p><p>一级一级向下寻找，找出了前面提到的三级缓存，也就是三个Map集合类：</p><p>singletonObjects：第一级缓存，里面放置的是实例化好的单例对象；</p><p>earlySingletonObjects：第二级缓存，里面存放的是提前曝光的单例对象；</p><p>singletonFactories：第三级缓存，里面存放的是要被实例化的对象的对象工厂。</p><p>所以当一个Bean调用构造函数进行实例化后，即使属性还未填充，就可以通过三级缓存向外暴露依赖的引用值（所以循环依赖问题的解决也是基于Java的引用传递），这也说明了另外一点，基于构造函数的注入，如果有循环依赖，Spring是不能够解决的。还要说明一点，Spring默认的Bean Scope是单例的，而三级缓存中都包含singleton，可见是对于单例Bean之间的循环依赖的解决，Spring是通过三级缓存来实现的。</p><h3 id="一、spring-ioc-的大致流程"><a href="#一、spring-ioc-的大致流程" class="headerlink" title="一、spring ioc 的大致流程"></a>一、spring ioc 的大致流程</h3><p><strong>bean的创建过程</strong></p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\bean的创建.png" alt="bean的创建" loading="lazy"></p><p><strong>简单的来说就是：</strong></p><p><strong>①实例化spring容器并初始化→②扫描指定包中的类创建beanDefinition对象→③执行beanFactoryPostProcessor</strong>（执行在bean创建之前，beanDefinition创建之后，算是一个spring的扩展点）→<strong>④推断构造方法，通过反射创建bean对象→⑤执行beanPostProcessor</strong>（在创建对象之后，算是一个spring的扩展点）→<strong>⑥填充属性</strong>（这里会有循环依赖产生，通过二级缓存解决，如果有多重循环依赖，三级缓存则发挥作用）<strong>→⑦执行aware接口重写方法（如果实现了）、执行生命周期初始化方法、执行配置的init-method→⑦将二级缓存和三级缓存中的工厂对象以及bean对象移除，放入到一级缓存中（单例池）</strong>（这里要说明一下：二级缓存是在创建完实例对象后，如果这个bean支持循环依赖，将根据实例对象生成的工厂放入二级缓存的，<strong>这个工厂的回调函数getEarlyRefenrence()会遍历BeanPostProcessor，其中包含了BeanNameAutoProxyCreator和SmartInstantiationAwareBeanPostProcessor接口，如果是BeanNameAutoProxyCreator则生成代理对象，如果是普通BeanPostProcessor则不作处理</strong></p><p>如果没有循环依赖的场景，不会用到三级缓存，直接将二级缓存中的工厂生产的bean对象放入一级缓存中，并移除二级缓存；如果存在循环依赖的场景，在该bean（接下来用A表示）所依赖的bean（接下来用B表示）执行populate填充A时调用getBean方法，进而调用getsingleton时，会将二级缓存的工厂对象取出生产具体的A对象并放入三级缓存中，如果对A还有循环依赖的，之后就可以直接从三级缓存中获取了，这样做的目的是提高性能，因为二级缓存中的工厂生产bean的过程是一个很漫长的过程，里面会执行很多后置处理器，很大的影响了性能</p><h3 id="二、什么是循环依赖"><a href="#二、什么是循环依赖" class="headerlink" title="二、什么是循环依赖"></a>二、什么是循环依赖</h3><p>循环依赖就是两个及以上的由spring管理的bean相互引用对方（相互作为对方的成员属性）形成的一种关系。如下图所示</p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\image2021-1-6_21-0-33.png" alt="image2021-1-6_21-0-33" loading="lazy"></p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\image2021-1-6_21-0-51.png" alt="image2021-1-6_21-0-51" loading="lazy"></p><p>在BeanFactory中，表示循环依赖的属性为allowCircleReferences，其默认值为true，也就是说spring是默认支持循环依赖的，循环依赖主要是在属性填充的时候触发，当A的bean还没创建好（可以理解成还没放到单例池中形成闭环）去填充B时，发现B里面也有A，如果只有一个缓存，你会发现A拿不到B，B也拿不到A，那么就成了一个死循环，spring在这里就用到了二级缓存来解决这样的问题，（三级缓存解决的是性能问题），接下来通过属性填充的过程来解释一下循环依赖的过程</p><p>![属性填充 (1)](D:\SoftwareInstallation\Typora\file\记事本\pictures\属性填充 (1).png)</p><p>简单的来说就是：<br>例：X中含有Y，Y中含有X。当X对象已经创建好了，此时开始将Y属性填充到X对象中：<br>X已经创建成功，二级缓存中已经存在→①通过getBean方法获取Y对象→②在doGetBean中调用getSingleton方法试着从缓存中获取Y，然而获取不到→④调用createBean创建Y→④创建好了Y对象后，将Y放入二级缓存中（工厂）→⑤填充Y中的属性X→⑥通过getBean方法获取X对象→⑦在doGetBean中调用getSingleton方法试着从缓存中获取X，在二级缓存中的工厂生产出X并返回→⑧完成Y中X属性的填充，将Y放入一级缓存中返回Y的bean→⑨完成X中Y属性的填充，将X放入一级缓存中，并返回X</p><p>三级缓存的作用：三级缓存主要是用来提升性能的，一般地，在两个bean循环依赖的场景下（x依赖Y，Y依赖x），是用不到三级缓存的。</p><p>三级缓存运用的时机：当存在循环依赖且一个bean被两个及两个以上的bean所依赖时（X依赖Y，Y依赖X，Z依赖X），三级缓存就会用到了，X先注入Y，通过实例化Y并注入X时，X就会从二级缓存中的工厂创建并放在三级缓存中，再当Z去注入X时，Z就直接从三级缓存中拿X的bean了，不会再从二级缓存中的工厂去生产了。</p><p>二级缓存和三级缓存的差异：二级缓存中的是一个工厂，这个工厂在生产bean的时候会经历很多BeanPostProcessor，值就大量的降低了性能，而三级缓存中的bean本来就是工厂生产出来的定制化的bean，完全可以省去工厂生产的步骤，进行复用，所以用三级缀存性能更强</p><p>二级缓存的作用：二级缓存的第一个较为常见的作用，就是代理实现AOP，比如说X所依赖的Y是实现了AOP的，那么我们通过X去获取的Y并不是我们所写的Y，而是一个代理对象，这里就需要工厂通过一系列的BeanPostProcessor来生产出代理对象，而二级缓存存放工厂而不是bean的目的就是在此。而二级缓存生产出的代理对象也好 还是其他定制化对象也好，如果有循环依赖的情况，最后都会放到三级缓存中。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="框架" scheme="https://yuhaicheng.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Bean" scheme="https://yuhaicheng.xyz/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的基本知识</title>
    <link href="https://yuhaicheng.xyz/2021-03-27-SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"/>
    <id>https://yuhaicheng.xyz/2021-03-27-SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html</id>
    <published>2021-03-26T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、SpringBoot的基本知识"><a href="#一、SpringBoot的基本知识" class="headerlink" title="一、SpringBoot的基本知识"></a>一、SpringBoot的基本知识</h2><h3 id="1、什么是-Spring-Boot？"><a href="#1、什么是-Spring-Boot？" class="headerlink" title="1、什么是 Spring Boot？"></a>1、什么是 Spring Boot？</h3><p>Spring Boot 是 Spring 开源组织下的<strong>子项目</strong>，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h3 id="2、为什么要用-Spring-Boot？"><a href="#2、为什么要用-Spring-Boot？" class="headerlink" title="2、为什么要用 Spring Boot？"></a>2、为什么要用 Spring Boot？</h3><p>Spring Boot 优点非常多，如：</p><ul><li>独立运行（内嵌tomcat等组件）</li><li>简化配置</li><li>自动配置（EnableAutoConfiguration）</li><li>无代码生成和XML配置</li><li>应用监控</li><li>上手容易</li></ul><h3 id="3、什么是-SpringBoot-自动装配？"><a href="#3、什么是-SpringBoot-自动装配？" class="headerlink" title="3、什么是 SpringBoot 自动装配？"></a>3、什么是 SpringBoot 自动装配？</h3><p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：</p><p><strong>SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件</strong>，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p><p><strong><code>spring.factories</code>中这么多配置，每次启动都要全部加载么？</strong></p><p>很明显，这是不现实的。会经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p></blockquote><p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p><p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p><h3 id="4、SpringBoot-是如何实现自动装配的？"><a href="#4、SpringBoot-是如何实现自动装配的？" class="headerlink" title="4、SpringBoot 是如何实现自动装配的？"></a>4、SpringBoot 是如何实现自动装配的？</h3><p>我们先看一下 SpringBoot 的核心注解 <code>SpringBootApplication</code> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line">&lt;<span class="number">1.</span>&gt;<span class="meta">@SpringBootConfiguration</span></span><br><span class="line">&lt;<span class="number">2.</span>&gt;<span class="meta">@ComponentScan</span></span><br><span class="line">&lt;<span class="number">3.</span>&gt;<span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//实际上它也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li></ul><h3 id="5、实际实现自动装配的注解"><a href="#5、实际实现自动装配的注解" class="headerlink" title="5、实际实现自动装配的注解"></a>5、实际实现自动装配的注解</h3><p><strong>@EnableAutoConfiguration:实现自动装配的核心注解</strong></p><p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在重点分析下<code>AutoConfigurationImportSelector</code> 类到底做了什么？</p><p><strong>AutoConfigurationImportSelector:加载自动装配类</strong></p><p><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p><h3 id="6、你如何理解-Spring-Boot-中的-Starters？"><a href="#6、你如何理解-Spring-Boot-中的-Starters？" class="headerlink" title="6、你如何理解 Spring Boot 中的 Starters？"></a>6、你如何理解 Spring Boot 中的 Starters？</h3><p>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="框架" scheme="https://yuhaicheng.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="SpringBoot" scheme="https://yuhaicheng.xyz/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring  Cloud的基本知识</title>
    <link href="https://yuhaicheng.xyz/2021-03-25-Spring%20%20Cloud%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"/>
    <id>https://yuhaicheng.xyz/2021-03-25-Spring%20%20Cloud%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html</id>
    <published>2021-03-25T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud的基本知识"><a href="#Spring-Cloud的基本知识" class="headerlink" title="Spring  Cloud的基本知识"></a>Spring  Cloud的基本知识</h2><h3 id="1、何为微服务"><a href="#1、何为微服务" class="headerlink" title="1、何为微服务"></a>1、何为微服务</h3><p>在了解SpringCloud之前，我们先来大致了解下微服务这个概念吧。</p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>简单来说，微服务架构是 SOA 架构思想的一种扩展，更加强调服务个体的独立性、拆分粒度更小。</p><p>其实服务化架构已经可以解决大部分企业的需求了，那么我们为什么要研究微服务呢？先说说它们的区别：</p><ul><li>微服务架构强调业务系统需要彻底的组件化和服务化，一个组件就是一个产品，可以独立对外提供服务</li><li>微服务不再强调传统SOA架构里面比较重的ESB企业服务总线</li><li>微服务强调每个微服务都有自己独立的运行空间，包括数据库资源。</li><li>微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行微服务的切分粒度会更小</li></ul><p><strong>微服务的好处有：服务独立、扩展性好、可靠性强，但同时，也面临一些新的问题，比如运维复杂性，分布式复杂性、监控复杂性等等。</strong></p><h3 id="2、传统单体架构"><a href="#2、传统单体架构" class="headerlink" title="2、传统单体架构"></a>2、传统单体架构</h3><p>单体架构在小微企业比较常见，典型代表就是一个应用、一个数据库、一个web容器就可以跑起来。里面集成了所有的功能。这在小型项目里面时比较好维护的，毕竟功能不多，也不复杂，但扩展性和可靠性比较差，因为所有功能集成在一个服务或者一个war包中，修改某个功能时，需要所有服务重新打包。可能前期开发比较快，后期随着功能的增长，交互的周期会越变越长的。</p><h3 id="3、服务化架构"><a href="#3、服务化架构" class="headerlink" title="3、服务化架构"></a>3、服务化架构</h3><p>也可以称之为SOA架构</p><p>SOA代表面向服务的架构，将应用程序根据不同的职责划分为不同的模块，不同的模块直接通过特定的协议和接口进行交互。这样使整个系统切分成很多单个组件服务来完成请求，当流量过大时通过水平扩展相应的组件来支撑，所有的组件通过交互来满足整体的业务需求。</p><h4 id="SOA服务化的优点"><a href="#SOA服务化的优点" class="headerlink" title="SOA服务化的优点"></a>SOA服务化的优点</h4><p>它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p><strong>需求</strong>：比如现我有一个数据库，一个JavaWeb的网站客户端，一个安卓app客户端，一个IOS客户端。现在我要给用户提供一个注册账号的功能。</p><p><strong>不用SOA的设计思想的实现</strong>：JavaWeb里面写一个注册账号的功能，安卓app里面写一个注册账号的功能，IOS同样如此。如过有一天，我的注册方法需要改动，那是不是三个地方都要改，而且要改的一模一样。当然问题不止这一个。</p><p><strong>SOA的设计思想实现</strong>：用Java（或者是其他语言皆可）单独创建一个工程部署在一台服务器上，并且写一个方法（或称函数）执行上述注册操作，然后提供一个借口，其他人可以通过某种途径（可以是http链接，或者是基于socket的RPC调用）访问这个方法来注册。就是说把这个操作封装到一个工程中去，然后暴露访问的方式，形成“服务”。</p><p><strong>服务化架构是一套松耦合的架构，服务的拆分原则是服务内部高内聚，服务之间低耦合。</strong></p><p>一般上我们使用dubbo来进行服务的治理功能，没有使用SpringCloud之前，基本上都是使用dubbo来拆分服务，进行服务间的调用。</p><h3 id="4、什么是SpringCloud"><a href="#4、什么是SpringCloud" class="headerlink" title="4、什么是SpringCloud"></a>4、什么是SpringCloud</h3><p>SpringCloud是基于SpringBoot的一整套实现微服务的<strong>框架</strong>。它提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等组件。最重要的是，基于SpringBoot，会让开发微服务架构非常方便。</p><h3 id="SpringCloud-和-Dubbo-的区别"><a href="#SpringCloud-和-Dubbo-的区别" class="headerlink" title="SpringCloud 和 Dubbo 的区别"></a>SpringCloud 和 Dubbo 的区别</h3><p>首先Dubbo是SOA时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而Spring Cloud诞生于微服务架构时代，考虑的是微服务治理的方面，另外由于依托了Spirng、Spirng Boot的优势之上，两个框架在开始目标就不一致，Dubbo定位服务治理、Spirng Cloud是一个生态。</p><p><strong>如果仅仅关注于服务治理的这个层面，Dubbo其实还优于Spring Cloud很多：</strong></p><ol><li>Dubbo 支持更多的协议，如：rmi、hessian、http、webservice、thrift、memcached、redis 等。</li><li>Dubbo 使用 RPC 协议效率更高，在极端压力测试下，Dubbo 的效率会高于 Spring Cloud 效率一倍多。</li><li>Dubbo 有更强大的后台管理，Dubbo 提供的后台管理 Dubbo Admin 功能强大，提供了路由规则、动态配置、访问控制、权重调节、均衡负载等诸多强大的功能。</li><li>可以限制某个 IP 流量的访问权限，设置不同服务器分发不同的流量权重，并且支持多种算法，利用这些功能我们可以在线上做灰度发布、故障转移等。</li><li>可通过dubbo-monitor和dubbo-admin进行监控和管理相关配置</li></ol><p><strong>所以Dubbo专注于服务治理；Spring Cloud关注于微服务架构生态。</strong></p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="微服务" scheme="https://yuhaicheng.xyz/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Cloud" scheme="https://yuhaicheng.xyz/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中锁的相关问题</title>
    <link href="https://yuhaicheng.xyz/2021-03-24-Mysql%E4%B8%AD%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"/>
    <id>https://yuhaicheng.xyz/2021-03-24-Mysql%E4%B8%AD%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html</id>
    <published>2021-03-24T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql中锁的相关问题"><a href="#Mysql中锁的相关问题" class="headerlink" title="Mysql中锁的相关问题"></a>Mysql中锁的相关问题</h2><h3 id="1-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁"><a href="#1-mysql-行锁、表锁、页锁下都有什么锁-怎么写一个表锁" class="headerlink" title="1.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁"></a>1.mysql 行锁、表锁、页锁下都有什么锁 怎么写一个表锁</h3><h4 id="（1）开销、加锁速度、死锁、粒度、并发性能"><a href="#（1）开销、加锁速度、死锁、粒度、并发性能" class="headerlink" title="（1）开销、加锁速度、死锁、粒度、并发性能"></a>（1）开销、加锁速度、死锁、粒度、并发性能</h4><ul><li>表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li><li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><table><thead><tr><th>引擎</th><th>行锁</th><th>表锁</th><th>页锁</th></tr></thead><tbody><tr><td>MyISAM</td><td></td><td>支持</td><td></td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td></td></tr></tbody></table><h4 id="（2）如何加表锁"><a href="#（2）如何加表锁" class="headerlink" title="（2）如何加表锁"></a>（2）如何加表锁</h4><p><strong>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p><blockquote><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p></blockquote><p>给MyISAM表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有各订单的总金额total，同时还有一个订单明细表order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(total) <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(subtotal) <span class="keyword">from</span> order_detail;</span><br><span class="line">这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</span><br><span class="line"></span><br><span class="line"><span class="keyword">Lock</span> <span class="keyword">tables</span> orders <span class="keyword">read</span> <span class="keyword">local</span>, order_detail <span class="keyword">read</span> <span class="keyword">local</span>;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(total) <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sum</span>(subtotal) <span class="keyword">from</span> order_detail;</span><br><span class="line"><span class="keyword">Unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>要特别说明以下两点内容。</p><ul><li>上面的例子在Lock tables时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，在后面的章节中还会进一步介绍。</li><li>在用Lock tables给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行Lock tables后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</li></ul><p><strong>其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。</strong></p><h4 id="（3）InnoDB锁问题"><a href="#（3）InnoDB锁问题" class="headerlink" title="（3）InnoDB锁问题"></a>（3）InnoDB锁问题</h4><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。</p><p>InnoDB的行锁模式及加锁方法</p><p>InnoDB实现了以下两种类型的行锁。</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p></li><li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p></li><li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p></li></ul><p>上述锁模式的兼容情况具体如下表所示。</p><p> InnoDB行锁模式兼容性列表</p><table><thead><tr><th>请求锁模式  是否兼容当前锁模式</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p><strong>意向锁是InnoDB自动加的，不需用户干预</strong>。</p><p><strong>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句,InnoDB不会加任何锁；</strong></p><p>事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><ul><li>共享锁（S）：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。</span><br></pre></td></tr></table></figure><ul><li>排他锁（X)：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE。</span><br></pre></td></tr></table></figure><p>用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁。</p><h5 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a><strong>InnoDB行锁实现方式</strong></h5><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</p><p>InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。</p><p><strong>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</strong></p><p>a.在如下所示的例子中，开始tab_no_index表没有索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tab_no_index(id int,name varchar(10)) engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.15 sec)</span><br><span class="line">mysql&gt; insert into tab_no_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class="line"></span><br><span class="line">ok的</span><br><span class="line"></span><br><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class="line"></span><br><span class="line">session_2 等待 走的是表锁</span><br></pre></td></tr></table></figure><p>在如上表所示的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下表所示。</p><p>b.创建tab_with_index表，id字段有普通索引：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tab_with_index(id int,name varchar(10)) engine=innodb;</span><br><span class="line">Query OK, 0 rows affected (0.15 sec)</span><br><span class="line">mysql&gt; alter table tab_with_index add index id(id);</span><br><span class="line">Query OK, 4 rows affected (0.24 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>  InnoDB存储引擎的表在使用索引时使用行锁例子</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 ;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 ;</span><br><span class="line"></span><br><span class="line">ok的</span><br><span class="line"></span><br><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 1 for update;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_no_index where id = 2 for update;</span><br><span class="line"></span><br><span class="line">ok的</span><br></pre></td></tr></table></figure><p><strong>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。</strong></p><p>在如下表所示的例子中，表tab_with_index的id字段有索引，name字段没有索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">name</span>;</span><br><span class="line">Query OK, 4 rows affected (0.22 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; insert into tab_with_index  values(1,&#x27;4&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| 1    | 1    |</span><br><span class="line">| 1    | 4    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;1&#x27; for update;</span><br><span class="line">session_2</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1 and name = &#x27;4&#x27; for update;</span><br><span class="line">等待</span><br><span class="line"></span><br><span class="line">虽然session_2访问的是和session_1不同的记录，但是因为使用了相同的索引，所以需要等待锁：</span><br></pre></td></tr></table></figure><p><strong>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</strong></p><p>在如下表所示的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table tab_with_index add index name(name);</span><br><span class="line">Query OK, 5 rows affected (0.23 sec)</span><br><span class="line">Records: 5  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p> InnoDB存储引擎的表使用不同索引的阻塞例子</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">session_1</span><br><span class="line">mysql&gt; select * from tab_with_index where id = 1 for update;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| 1    | 1    |</span><br><span class="line">| 1    | 4    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Session_2  使用<span class="keyword">name</span>的索引访问记录，因为记录没有被索引，所以可以获得锁：</span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> tab_with_index <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;2&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| 2    | 2    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Session_2 由于访问的记录已经被session_1锁定，所以等待获得锁。</span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> tab_with_index <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><strong>（4）</strong>即便在条件中使用了索引字段<strong>，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的</strong>，如果MySQL认为<strong>全表扫描</strong>效率更高，比如对一些很小的表，它就<strong>不会使用索引</strong>，这种情况下InnoDB将<strong>使用表锁，而不是行锁</strong>。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p><p>在下面的例子中，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。</p><p>例子中tab_with_index表的name字段有索引，但是name字段是varchar类型的，如果where条件中不是和varchar类型进行比较，则会对name进行类型转换，而执行的全表扫描。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table tab_no_index add index name(name);</span><br><span class="line">Query OK, 4 rows affected (8.06 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; explain select * from tab_with_index where name = 1 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">         id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: tab_with_index</span><br><span class="line">         type: ALL   全表扫码</span><br><span class="line">possible_keys: name</span><br><span class="line">         key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">         ref: NULL</span><br><span class="line">        rows: 4</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; explain select * from tab_with_index where name = &#x27;1&#x27; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">       table: tab_with_index</span><br><span class="line">        type: ref         用索引了</span><br><span class="line">possible_keys: name</span><br><span class="line">        key: name</span><br><span class="line">      key_len: 23</span><br><span class="line">        ref: const</span><br><span class="line">       rows: 1</span><br><span class="line">     Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="（4）间隙锁（Next-Key锁）"><a href="#（4）间隙锁（Next-Key锁）" class="headerlink" title="（4）间隙锁（Next-Key锁）"></a>（4）间隙锁（Next-Key锁）</h4><p>解决了mysql幻读的问题。</p><p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</strong></p><p>**a.**举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,...,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span>  emp <span class="keyword">where</span> empid &gt; <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其它事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p><p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p><strong>b.还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</strong></p><p>在如下表所示的例子中，假如emp表中只有101条记录，其empid的值分别是1,2,......,100,101。</p><p>InnoDB存储引擎的间隙锁阻塞例子</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>当前session对不存在的记录加for update的锁：                                                                       mysql&gt; select * from emp where empid = 102 for update;</td><td></td></tr><tr><td></td><td>这时，如果其他session插入empid为102的记录（注意：这条记录并不存在），也会出现锁等待：                   mysql&gt;insert into emp(empid,...) values(102,...);阻塞等待</td></tr><tr><td>Session_1 执行rollback：                                 mysql&gt; rollback;                                     Query OK, 0 rows affected (13.04 sec)</td><td></td></tr><tr><td></td><td>由于其他session_1回退后释放了Next-Key锁，当前session可以获得锁并成功插入记录：                               mysql&gt;insert into emp(empid,...) values(102,...);                Query OK, 1 row affected (13.35 sec)</td></tr></tbody></table><h4 id="（5）什么时候使用表锁"><a href="#（5）什么时候使用表锁" class="headerlink" title="（5）什么时候使用表锁"></a>（5）什么时候使用表锁</h4><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><ul><li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。</p><p>在InnoDB下，使用表锁要注意以下两点。</p><p>（1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。有关死锁，下一小节还会继续讨论。</p><p>（2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。正确的方式见如下语句：</p><p>例如，如果需要写表t1并从表t读，可以按如下做：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="Mysql" scheme="https://yuhaicheng.xyz/categories/Mysql/"/>
    
    
    <category term="锁" scheme="https://yuhaicheng.xyz/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySql中count、limit、order by、group by的用法</title>
    <link href="https://yuhaicheng.xyz/2021-03-23-Mysql%E4%B8%ADMySql%E4%B8%ADcount%E3%80%81limit%E3%80%81order%20by%E3%80%81group%20by%E7%9A%84%E7%94%A8%E6%B3%95.html"/>
    <id>https://yuhaicheng.xyz/2021-03-23-Mysql%E4%B8%ADMySql%E4%B8%ADcount%E3%80%81limit%E3%80%81order%20by%E3%80%81group%20by%E7%9A%84%E7%94%A8%E6%B3%95.html</id>
    <published>2021-03-23T04:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、count-1-、count-、count（字段）的区别"><a href="#1、count-1-、count-、count（字段）的区别" class="headerlink" title="1、count(1)、count(*)、count（字段）的区别"></a>1、count(1)、count(*)、count（字段）的区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、COUNT有几种用法？</span><br><span class="line">2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？</span><br><span class="line">3、COUNT(1)和COUNT(*)之间有什么不同？</span><br><span class="line">4、COUNT(1)和COUNT(*)之间的效率哪个更高？</span><br><span class="line">5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)</span><br><span class="line">6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？</span><br><span class="line">7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？</span><br><span class="line">8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？</span><br><span class="line">9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？</span><br><span class="line">10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</span><br></pre></td></tr></table></figure><p>以上10道题，如果可以全部准确无误的回答的话，那说明你真的很了解<code>COUNT</code>函数了。</p><h2 id="1-初识COUNT"><a href="#1-初识COUNT" class="headerlink" title="1.初识COUNT"></a>1.初识COUNT</h2><p>1、<code>COUNT(expr)</code> ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个<code>BIGINT</code>值。</p><p>2、如果查询结果没有命中任何记录，则返回0</p><p>3、但是，值得注意的是，<code>COUNT(*)</code> 的统计结果中，会包含值为NULL的行数。</p><p>除了<code>COUNT(id)</code>和<code>COUNT(*)</code>以外，还可以使用<code>COUNT(常量)</code>（如<code>COUNT(1)</code>）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 <code>COUNT(列名)</code>或 <code>COUNT(常量)</code>来替代 <code>COUNT(*)</code>呢？</p><h2 id="2-COUNT-字段-、COUNT-常量-和COUNT-之间的区别"><a href="#2-COUNT-字段-、COUNT-常量-和COUNT-之间的区别" class="headerlink" title="2.COUNT(字段)、COUNT(常量)和COUNT(*)之间的区别"></a>2.COUNT(字段)、COUNT(常量)和COUNT(*)之间的区别</h2><p><code>COUNT(常量)</code> 和 <code>COUNT(*)</code> 表示的是直接查询符合条件的数据库表的行数。</p><p>而<code>COUNT(列名)</code>表示的是查询符合条件的列的值不为<strong>NULL</strong>的行数(这里的空不是只空字符串或者0，而是表示null)。</p><p><code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，因为是标准语法，所以MySQL数据库进行过很多优化。</p><blockquote><p>SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</p></blockquote><h2 id="3-COUNT-的优化"><a href="#3-COUNT-的优化" class="headerlink" title="3.COUNT(*)的优化"></a>3.COUNT(*)的优化</h2><p><code>MySQL</code>主要使用2种执行引擎：</p><ul><li>InnoDB引擎</li><li>MyISAM引擎</li></ul><p><strong>MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。</strong></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行<code>count(*)</code>时可以直接返回，<u>前提是不能有where</u>条件。MyISAM是表级锁，不会有并发的行操作，所以查到的结果是准确的。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB不能使用这种缓存操作，因为支持事务，大部分操作都是行级锁，行可能被并行修改，那么缓存记录不准确。</p><p>但是，InnoDB还是针对COUNT(*)语句做了些优化的。</p><p>通过低成本的<strong>索引</strong>进行扫表，而不关注表的具体内容。</p><p>InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p><p><strong>MySQL会优先选择最小的非聚簇索引来扫表。</strong></p><p><u>优化的前提是查询语句中不包含where条件和group by条件。</u></p><h2 id="4-COUNT-和COUNT-1"><a href="#4-COUNT-和COUNT-1" class="headerlink" title="4.COUNT(*)和COUNT(1)"></a>4.COUNT(*)和COUNT(1)</h2><p>MySQL官方文档这么说：</p><blockquote><p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p></blockquote><p>所以，对于<code>count(1)</code>和<code>count(*)</code>，MySQL的优化是完全一样的，根本不存在谁更快！</p><p>但依旧建议使用<code>count(*)</code>，因为这是SQL92定义的标准统计行数的语法。</p><h2 id="5-COUNT-字段"><a href="#5-COUNT-字段" class="headerlink" title="5.COUNT(字段)"></a>5.COUNT(字段)</h2><p>进行全表扫描，判断指定字段的值是否为<code>NULL</code>，不为<code>NULL</code>则累加。</p><p>性能比<code>count(1)</code>和<code>count(*)</code>慢。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p><code>COUNT</code>函数的用法，主要用于统计表行数。主要用法有<code>COUNT(*)</code>、<code>COUNT(字段)</code>和<code>COUNT(1)</code>。</p><p>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供<code>COUNT(*)</code>查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。<strong>当然，这些优化的前提都是没有进行where和group的条件查询。</strong></p><p>在InnoDB中<code>COUNT(*)</code>和<code>COUNT(1)</code>实现上没有区别，而且效率一样，但是<code>COUNT(字段)</code>需要进行字段的非NULL判断，所以效率会低一些。</p><p>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用<code>COUNT(*)</code>查询表的行数！</p><h1 id="2、Mysql的limit用法"><a href="#2、Mysql的limit用法" class="headerlink" title="2、Mysql的limit用法"></a>2、Mysql的limit用法</h1><p>在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。**初始记录行的偏移量是 0(而不是 1)**： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p><ol><li><p>mysql&gt; <strong>SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</strong>  </p><p>//为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：  </p></li><li><p>mysql&gt; <strong>SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last</strong>  </p><p>//如果只给定一个参数，它表示返回最大的记录行数目：  </p></li><li><p>mysql&gt; <strong>SELECT * FROM table LIMIT 5; //检索前 5 个记录行</strong>  </p><p>//换句话说，LIMIT n 等价于 LIMIT 0,n。 </p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： </span><br><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果只给定一个参数，它表示返回最大的记录行数目： 换句话说，LIMIT n 等价于 LIMIT 0,n。</span><br><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行</span><br></pre></td></tr></table></figure><h2 id="需要特别注意的"><a href="#需要特别注意的" class="headerlink" title="需要特别注意的"></a>需要特别注意的</h2><p>1.比如差的这张表只有两条数据，而我们写sql limit 2，1 的时候会返回一条记录都为<strong>空</strong>的记录，不是0和null。</p><p>2.limit 后写两个参数时，第一个是偏移量，是从<strong>0</strong>开始的，想要从第一条记录开始必须从0，第二个参数是条数。</p><h1 id="3、order-by"><a href="#3、order-by" class="headerlink" title="3、order by"></a>3、order by</h1><h2 id="1-order-by的用法"><a href="#1-order-by的用法" class="headerlink" title="1.order by的用法"></a>1.order by的用法</h2><p>使用order by，一般是用来，依照查询结果的某一列（或多列）属性，进行排序（升序：ASC；降序：DESC；默认为升序）。</p><p>当排序列含空值时：</p><p>ASC：排序列为空值的元组最后显示。</p><p>DESC：排序列为空值的元组最先显示。</p><p>为了好记忆，我的理解是，可以把null值看做<strong>无穷大</strong>，因为不知道具体为多少。然后去考虑排序，asc升序null肯定在最后，而desc降序，null肯定在最前面。</p><p>1》单一列属性排序</p><p>举例1：默认排序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from s</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901014959861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from s order by sno desc</span><br></pre></td></tr></table></figure><p>按照sno降序：</p><p><img data-src="https://img-blog.csdn.net/20150901015222489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>2》多个列属性排序</p><p>选择多个列属性进行排序，然后排序的顺序是，<strong>从左到右</strong>，依次排序。</p><p>如果前面列属性有些是一样的话，再按后面的列属性排序。（前提一定要满足前面的属性排序，因为在前面的优先级高）。</p><p>举例2：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> s  </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sname <span class="keyword">desc</span>, sage <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901015819710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>首先按照sname降序排序，然后出现了xx一样的，在按照sage降序排序。（默认sage是升序）。</p><p>如果最开始使用sno排序,</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> s </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sno <span class="keyword">desc</span>,  sage <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901020349238?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>必须先满足前面列属性的排序（sno在前优先级高）。才会去考虑后续列属性的排序。</p><p><strong>注意：group by 必须放在 order by 和 limit之前</strong></p><h1 id="4、group-by的用法"><a href="#4、group-by的用法" class="headerlink" title="4、group by的用法"></a>4、group by的用法</h1><p><strong>group by按照查询结果集中的某一列（或多列），进行分组，值相等的为一组。</strong></p><p>1》细化集函数（count，sum，avg，max，min）的作用对象：</p><p>未对查询结果分组，集函数将作用于整个查询结果。</p><p>对查询结果分组后，集函数将分别作用于每个组。</p><p>例子1：</p><p>求各个课程号及相应的选课人数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cno,<span class="keyword">count</span>(sno) <span class="keyword">from</span> sc</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901020802381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>对整个表进行count。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cno,<span class="keyword">count</span>(sno) <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> cno</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901021021720?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>对分组的表进行count</p><p>sc表内容如下：</p><p><img data-src="https://img-blog.csdn.net/20150901021101360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>2》GROUP BY子句的作用对象是查询的中间结果表</p><p>分组方法：按指定的一列或多列值分组，值相等的为一组。</p><p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性（比如：sno）和集函数（比如：count（））。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sno,count(cno) from sc group by sno</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901021443417?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>3》多个列属性进行分组举例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cno,grade,count(cno) from sc group by cno,grade</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901021646837?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>cno为1且成绩为66的，有3个</p><p>4》使用HAVING短语筛选最终输出结果</p><p>只有满足HAVING短语指定条件的组才输出。</p><h2 id="HAVING短语与WHERE子句的区别"><a href="#HAVING短语与WHERE子句的区别" class="headerlink" title="HAVING短语与WHERE子句的区别"></a><strong>HAVING短语与WHERE子句的区别</strong></h2><p>作用对象不同</p><p>1》WHERE子句作用于<strong>基表或视图</strong>，从中选择满足条件的<strong>元组</strong>。</p><p>2》HAVING短语作用于<strong>组</strong>，从中选择满足条件的<strong>组</strong>。</p><p>举例：</p><p>查询选修了3门以上课程的学生学号：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> sno <span class="keyword">having</span> <span class="keyword">count</span>(cno)&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901021926006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><p>举例：</p><p>查询选修了3门以上课程，且<strong>所有课程</strong>成绩都高于60分的学生学号及课程数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sno , <span class="keyword">count</span>(cno)</span><br><span class="line"><span class="keyword">from</span> sc </span><br><span class="line"><span class="keyword">where</span> grade &gt; <span class="number">60</span>  </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno <span class="keyword">having</span> <span class="keyword">count</span>(cno) &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdn.net/20150901022048618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" loading="lazy"></p><h1 id="5、DISTINCT"><a href="#5、DISTINCT" class="headerlink" title="5、DISTINCT"></a>5、DISTINCT</h1><p>在 MySQL 查询中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p><p>关键词 DISTINCT 用于返回唯一不同的值，就是<span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2FjYWRlbXkvdGFnLyVFNSU4RSVCQiVFOSU4NyU4RA==">去重<i class="fa fa-external-link-alt"></i></span>啦。用法也很简单：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> * <span class="keyword">FROM</span> tableName</span><br></pre></td></tr></table></figure><p>DISTINCT 这个关键字来过滤掉多余的重复记录只保留一条。</p><p>另外，如果要对某个字段去重，并且保留别的字段可以试下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> nowamagic) <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> nowamagic</span><br></pre></td></tr></table></figure><p>这个用法，<span class="exturl" data-url="aHR0cDovL3d3dy5ub3dhbWFnaWMubmV0L2FjYWRlbXkvdGFnL015U1FM">MySQL<i class="fa fa-external-link-alt"></i></span>的版本不能太低。</p><p>注意：</p><ul><li>DISTINCT不能用在where后面，DISTINCT必须放在开头</li><li>select distinct name, id from table ;作用两个字段时，也就是必须得id与name都相同的才会被排除</li></ul>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="Mysql" scheme="https://yuhaicheng.xyz/categories/Mysql/"/>
    
    
    <category term="count等关键字" scheme="https://yuhaicheng.xyz/tags/count%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>MySql和Spring中事物的实现原理</title>
    <link href="https://yuhaicheng.xyz/2021-03-23-MySql%E5%92%8CSpring%E4%B8%AD%E4%BA%8B%E7%89%A9%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>https://yuhaicheng.xyz/2021-03-23-MySql%E5%92%8CSpring%E4%B8%AD%E4%BA%8B%E7%89%A9%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</id>
    <published>2021-03-23T03:15:14.000Z</published>
    <updated>2021-03-25T03:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MySql中事物的实现原理"><a href="#一、MySql中事物的实现原理" class="headerlink" title="一、MySql中事物的实现原理"></a>一、MySql中事物的实现原理</h2><h3 id="1、什么是事物"><a href="#1、什么是事物" class="headerlink" title="1、什么是事物"></a>1、什么是事物</h3><p>事务由单独单元的一个或者多个sql语句组成，在这个单元中，每个mysql语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或者产生错误，整个单元将会回滚，也就是所有受到影响的数据将会返回到事务开始以前的状态；如果单元中的所有sql语句均执行成功，则事务才会被顺利执行。</p><p><strong>MySQL默认采用的是自动提交的方式</strong>，也就是说如果不是显示的开始一个事务，则系统会自动向数据库提交结果。在当前连接中，还可以通过设置AUTOCONNIT变量来启用或者禁用自动提交模式。</p><p>正常我们在提交sql时，是有</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;  </span><br><span class="line">sql...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</span><br><span class="line">关闭自动提交功能后，只用当执行<span class="keyword">COMMIT</span>命令后，MySQL才将数据表中的资料提交到数据库中。如果执行<span class="keyword">ROLLBACK</span>命令，数据将会被回滚。如果不提交事务，而终止MySQL会话，数据库将会自动执行回滚操作。</span><br></pre></td></tr></table></figure><h3 id="2、事物必须满足的四个特性"><a href="#2、事物必须满足的四个特性" class="headerlink" title="2、事物必须满足的四个特性"></a>2、事物必须满足的四个特性</h3><ul><li>原子性：一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作。</li><li>一致性：一个事务的执行会使数据从一个一致状态切换到另一个一致的状态。</li><li>隔离性：事务一旦提交，其所做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</li><li>持久性： 一个事务一旦提交，则会永久的改变数据库的数据</li></ul><p>在mysql中，有很多存储引擎，都是以插件形式存在的，现在较为流行的是innodb存储引擎，他是支持事物的。（实际上支持事务的只有<code>InnoDB</code>跟<code>NDB Cluster</code>）</p><h3 id="3、具体mysql是怎么做到的，最最底层（抠到祖坟上）"><a href="#3、具体mysql是怎么做到的，最最底层（抠到祖坟上）" class="headerlink" title="3、具体mysql是怎么做到的，最最底层（抠到祖坟上）"></a>3、具体mysql是怎么做到的，最最底层（抠到祖坟上）</h3><p>在这里先了解一些概念：</p><h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1.redo log"></a>1.redo log</h4><h5 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h5><p>redo log叫做重做日志，用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。<strong>当事务提交之后会把所有<code>修改后的信息</code>存到该日志中。</strong></p><p>注：redo log存在于innodb引擎中。</p><p>流程示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;                                     </span><br><span class="line"><span class="keyword">select</span> balance <span class="keyword">from</span> bank <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&quot;zhangsan&quot;</span>;         </span><br><span class="line">// 生成 重做日志 balance=600                                 </span><br><span class="line"><span class="keyword">update</span> bank <span class="keyword">set</span> balance = balance - <span class="number">400</span>;                </span><br><span class="line">// 生成 重做日志 amount=400                               </span><br><span class="line"><span class="keyword">update</span> finance <span class="keyword">set</span> amount = amount + <span class="number">400</span>;          </span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\ds.jpg" alt="ds" loading="lazy"></p><h5 id="redo-log-的作用"><a href="#redo-log-的作用" class="headerlink" title="redo log 的作用"></a>redo log 的作用</h5><p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。</p><p>那么，如果数据同步之前宕机宕机或断电了怎么办？未来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</p><p>所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</p><h5 id="redo-log-的实现（持久性的实现）"><a href="#redo-log-的实现（持久性的实现）" class="headerlink" title="redo log 的实现（持久性的实现）"></a>redo log 的实现（持久性的实现）</h5><p>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：</p><blockquote><p><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取再放入缓冲池；</p><p><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p></blockquote><p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！</p><p>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。redo log就派上用处了。</p><p>既然redo log也需要存储，也涉及磁盘IO为啥还用上面的方式呢？</p><blockquote><p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p><p>（2）缓存同步是以数据页为单位的，每次传输的数据量大于redo log。</p></blockquote><p><strong>总结：</strong></p><p>redo log是用来恢复数据的 用于保障已提交事务的持久化特性。</p><h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h4><h5 id="什么是-undo-log"><a href="#什么是-undo-log" class="headerlink" title="什么是 undo log"></a>什么是 undo log</h5><p>undo log 叫做回滚日志，用于<strong>记录数据被修改前的信息</strong>。与重做日志所记录的数据相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\sdd.jpg" alt="sdd" loading="lazy"></p><h5 id="undo-log-的作用"><a href="#undo-log-的作用" class="headerlink" title="undo log 的作用"></a>undo log 的作用</h5><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><h5 id="undo-log-的实现（原子性的实现）"><a href="#undo-log-的实现（原子性的实现）" class="headerlink" title="undo log 的实现（原子性的实现）"></a>undo log 的实现（原子性的实现）</h5><p>undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，如:</p><ul><li>如果你在执行了一个insert语句，那么此时在Undo log日志中，对这个操作记录的回滚日志就生成对应的delete操作。</li><li> 如果你你要执行的是delete操作，那么要把你删除的那条数据数据记录下来，如果要回滚，就应该执行一个insert操作把那条数据插入回去。</li><li>如果你要是执行的是update语句，那么你要把你更新之前的那个值记录下来，回滚的时候重新update一下，把你之前更新前的旧值给他更新回去。</li></ul><p>所以：</p><ol><li>每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,<strong>并且回滚日志必须先于数据持久化到磁盘上</strong></li><li>所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</li></ol><p><strong>总结：</strong></p><p>undo log是用来回滚数据的用于保障 未提交事务的原子性</p><p>所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样</p><blockquote><p>正确理解回滚：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//创建表：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line"><span class="string">`f1`</span>  <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line"><span class="string">`f2`</span>  <span class="built_in">varchar</span>(<span class="number">11</span>)  <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`f1`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"></span><br><span class="line">//执行事务：</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>    (<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">VALUES</span>    (<span class="number">1</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这时已经开启了一个事务，并且已经执行了一条正确的插入语句，虽然没有体现在数据库中，但如果以后在该连接中又执行了一条commit 或begin或start transaction（新开一个事务会将该链接中的其他未提交的事务提交，相当于commit！）你会发现已经将刚才的INSERT INTO test_tab VALUES (1, &#39;2&#39;);写进了数据库。</p><p> <strong>正确的理解应该是，如果事务中所有sql语句执行正确则需要自己手动提交commit；否则有任何一条执行错误，需要自己提交一条<u>rollback</u>，这时会回滚所有操作，而不是<u>commit</u>会给你自动判断和回滚。</strong></p></blockquote><h4 id="3-mysql锁技术和MVCC基础"><a href="#3-mysql锁技术和MVCC基础" class="headerlink" title="3.mysql锁技术和MVCC基础"></a>3.mysql锁技术和MVCC基础</h4><h5 id="mysql锁技术"><a href="#mysql锁技术" class="headerlink" title="mysql锁技术"></a>mysql锁技术</h5><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。</p><p><strong>读写锁</strong></p><p>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可</p><blockquote><ol><li>共享锁(shared lock),又叫做&quot;读锁&quot;，读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</li><li>排他锁(exclusive lock),又叫做&quot;写锁&quot;，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</li></ol><p>通过读写锁，可以做到并行读操作，但是不能做到写读，并行写操作</p></blockquote><p><strong>总结：</strong></p><blockquote><p>事务的隔离性通过<strong>读写锁</strong>来实现！</p></blockquote><h5 id="MVCC基础"><a href="#MVCC基础" class="headerlink" title="MVCC基础"></a>MVCC基础</h5><blockquote><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。是用来在数据库中控制并发的方法，实现对数据库的并发访问用的。在MySQL中，MVCC只在读取已提交（Read Committed）和可重复读（Repeatable Read）两个事务级别下有效。其是通过Undo日志中的版本链和ReadView一致性视图来实现的。MVCC就是在多个事务同时存在时，SELECT语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。</p><p>他的主要实现思想是通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行。</p><p>MVCC在mysql中的实现依赖的是undo log与read view</p><ul><li>undo log :undo log 中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性</li></ul></blockquote><h5 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h5><p>在MySQL中，MVCC只在读取已提交（Read Committed）和可重复读（Repeatable Read）两个事务级别下有效。其是通过Undo日志中的版本链和ReadView一致性视图来实现的。MVCC就是在多个事务同时存在时，SELECT语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。</p><p>1、首先需要知道的是，在MySQL中，会默认为我们的表后面添加三个隐藏字段：</p><blockquote><p><strong>DB_ROW_ID</strong>：行ID，MySQL的B+树索引特性要求每个表必须要有一个主键。如果没有设置的话，会自动寻找第一个不包含NULL的唯一索引列作为主键。如果还是找不到，就会在这个DB_ROW_ID上自动生成一个唯一值，以此来当作主键（该列和MVCC的关系不大）；<br><strong>DB_TRX_ID</strong>：事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID（DELETE语句被当做是UPDATE语句的特殊情况，后面会进行说明）<strong>所以事务ID是执行一条更新操作（增删改）的语句后才会生成；</strong><br><strong>DB_ROLL_PTR</strong>：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针。</p></blockquote><p>2 、ReadView</p><blockquote><p>ReadView一致性视图主要是由两部分组成：</p><p>所有未提交事务的ID数组 和 已经创建的最大事务ID组成（实际上ReadView还有其他的字段，但不影响这里对MVCC的讲解）。比如：[100,200],300。事务100和200是当前未提交的事务，而事务300是当前创建的最大事务（已经提交了）。</p><p>当<strong>执行</strong>SELECT语句的时候会创建<strong>ReadView</strong></p><p>但是<strong>在读取已提交和可重复读两个事务级别下，生成ReadView的策略是不一样的</strong>： 在一个事务的前提下</p><p>读取已提交级别是<strong>每执行一次</strong>SELECT语句就会重新生成一份ReadView，而可重复读级别是<strong>只会在第一次</strong>SELECT语句执行的时候会生成一份，后续的SELECT语句会沿用之前生成的ReadView（即使后面有更新语句的话，也会继续沿用）。</p></blockquote><p>3 、版本链</p><blockquote><p>所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。</p></blockquote><h5 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h5><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。</p><p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>MySQL隔离级别有以下四种（级别由低到高）：</p><blockquote><ol><li>READUNCOMMITED(未提交读)</li><li>READCOMMITED(已提交读)</li><li>REPEATABLEREAD(可重复读)</li><li>SERIALIZABLE (串行化)</li></ol></blockquote><p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p><p>那么隔离性是要做到什么呢？ 隔离性是要管理<strong>多个并发读写请求的访问顺序</strong>。 这种顺序包括串行或者是并行</p><p>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\format,png" alt="img" loading="lazy"></p><p>总之，从隔离性的实现可以看出这是一场数据的<strong>可靠性与性能之间的权衡</strong>：</p><blockquote><p>可靠性性高的，并发性能低(比如Serializable)。可靠性低的，并发性能高(比如 Read Uncommited)</p></blockquote><p><strong>READ UNCOMMITTED</strong></p><blockquote><p>在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。</p><p>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到读写并行。</p><p>换句话说，读的操作不能排斥写请求。</p></blockquote><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\formaddt,png" alt="img" loading="lazy"></p><blockquote><p>优点：读写并行，性能高</p><p>缺点：造成脏读</p></blockquote><p><strong>READ COMMITTED</strong></p><blockquote><p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。</p><p>InnoDB在 READ COMMITTED，<strong>写数据使用排它锁,读取数据不加锁而是使用了MVCC机制</strong>。或者换句话说他采用了读写分离机制。</p><p>但是该级别会产生不可重读以及幻读问题。</p></blockquote><p><strong>什么是不可重读？</strong></p><blockquote><p>在一个事务内多次读取的结果不一样。</p></blockquote><p><strong>为什么会产生不可重复读？</strong></p><blockquote><p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新生成一个版本号，所以每次select的时候读的不是一个副本而是不同的副本。</p><p>在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读</p><p>REPEATABLE READ(Mysql默认隔离级别)</p><p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p></blockquote><p><strong>采用读写锁实现：</strong></p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\formssat,png" alt="img" loading="lazy"></p><p>为什么能可重复读？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。</p><blockquote><p>优点：实现起来简单</p><p>缺点：无法做到读写并行</p></blockquote><p><strong>采用MVCC实现：</strong></p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\forssssmat,png" alt="img" loading="lazy"></p><p>为什么能可重复读？因为多次读取只生成一个版本，读到的自然是相同数据。</p><blockquote><p>优点：读写并行</p><p>缺点：实现的复杂度高</p></blockquote><p>但是在该隔离级别下仍会存在幻读的问题。</p><p><strong>SERIALIZABLE</strong></p><p>该隔离级别理解起来最简单，实现也最简单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p><p><img data-src="D:\SoftwareInstallation\Typora\file\记事本\pictures\fggormat,png" alt="img" loading="lazy"></p><h4 id="4-事务的实现总结"><a href="#4-事务的实现总结" class="headerlink" title="4.事务的实现总结"></a>4.事务的实现总结</h4><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p><blockquote><ul><li>事务的原子性是通过undo log来实现。</li><li>事务的持久性性是通过redo log来实现</li><li>事务的隔离性是通过(读写锁+MVCC)来实现</li><li><strong>事务的一致性是通过原子性，持久性，隔离性共同实现</strong></li></ul></blockquote><p>原子性，持久性，隔离性的目的也是为了保障数据的一致性！</p><p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p><h2 id="二、spring-中的事务"><a href="#二、spring-中的事务" class="headerlink" title="二、spring 中的事务"></a>二、spring 中的事务</h2><h4 id="spring-和数据库事物之间的联系"><a href="#spring-和数据库事物之间的联系" class="headerlink" title="spring 和数据库事物之间的联系"></a>spring 和数据库事物之间的联系</h4><p><strong>spring的事务是建立在数据库的事务支持上的，如果你选择的数据库引擎不支持事务，如mysql的MyISAM引擎不支持事务，那么spring的事务也不会生效。</strong></p><p>具体内容是spring对事务传播行为和隔离级别的二次封装，因为不同项目可能在一个mysql的不同数据库上，所以可以在项目中配置数据库的传播行为和隔离级别。</p><h3 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h3><h4 id="1-声明式事务配置（XML方式）"><a href="#1-声明式事务配置（XML方式）" class="headerlink" title="1.声明式事务配置（XML方式）"></a>1.声明式事务配置（XML方式）</h4><ul><li><p>1-pom文件中，添加 AOP Aspectj 的支持</p></li><li><p>2-准备给deleteUser()增加事务操作</p></li><li><p>3-Spring配置文件中，配置声明式事务管理器 DataSourceTransactionManager</p></li><li><p>4-配置事务通知 ，“确定为哪个/哪些方法配置事务”</p></li><li><p>5-配置事务切入，“确定切入点（哪个类）”</p></li><li><p>6-测试</p></li></ul><h4 id="2-声明式事务配置（-Transactional注解方式）"><a href="#2-声明式事务配置（-Transactional注解方式）" class="headerlink" title="2.声明式事务配置（@Transactional注解方式）"></a>2.声明式事务配置（@Transactional注解方式）</h4><ul><li><p>1-在deleteUser()上增加@Transactional注解</p></li><li><p>2-pom文件里，启用事务注解</p></li></ul><h4 id="3-编程式事务"><a href="#3-编程式事务" class="headerlink" title="3.编程式事务"></a>3.编程式事务</h4><ul><li><p>1-pom引入driver和DataSource</p></li><li><p>2-编程式事务内核：在代码中侵入式控制事务</p></li></ul><p>声明式（注解配置）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注册事务管理类，Spring 基于数据源的事务管理器 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 以 @Transactional 标注来定义事务 --&gt;</span><br><span class="line">&lt;!-- 启用annotation的事务支持  --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;  proxy-target-class&#x3D;&quot;true&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul><li>声明式事务：非侵入式，本质是AOP，推荐！</li><li>编程式事务：侵入式，需要在代码中调用 commit()、rollback()等事务管方法，还需要在代码中通过try catch，不推荐！</li></ul><p>优缺点：</p><p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。</p><p>唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h3 id="2、原理："><a href="#2、原理：" class="headerlink" title="2、原理："></a>2、原理：</h3><p>Spring的事务管理机制实现的原理，是通过<strong>通过AOP的方式被织入</strong>了我们的业务逻辑中的，AOP的实现机制有两种：Proxy-based和Weaving-based。前者是依赖动态代理的方式达到对代理类增强的目的。后者应该是通过字节码增强的方式达到增强的目的。</p><p>常用的就是通过这样一个动态代理对所有需要事务管理的Bean进行加载，并根据配置在invoke方法中对当前调用的 方法名进行判定，并在method.invoke方法前后为其加上合适的事务管理代码，这样就实现了Spring式的事务管理。Spring中的AOP实 现更为复杂和灵活，不过基本原理是一致的。</p><h3 id="3、具体实现"><a href="#3、具体实现" class="headerlink" title="3、具体实现"></a>3、具体实现</h3><p>在serviceImpl类中方法上的使用，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//默认是遇到运行时异常回滚，调用rollbackfor,mysqlde rollback</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(FoBasicInfo foBasicInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = foBasicInfoMapper.insert(foBasicInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rows != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;新增异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、spring事务的传播性、隔离性。"><a href="#4、spring事务的传播性、隔离性。" class="headerlink" title="4、spring事务的传播性、隔离性。"></a>4、spring事务的传播性、隔离性。</h3><p><strong>事务的传播性、隔离性级别一般设置在service层。</strong></p><p><strong>@Transactional</strong><br>（1）这里说明一下，有的把这个注解放在类名称上面了，这样你配置的这个@Transactional 对这个类中的所有public方法都起作用.<br>（2）@Transactional 方法方法名上，只对这个方法有作用，同样必须是public的方法</p><p>我们在使用Spring声明式事务时，有一个非常重要的概念就是事务的属性。事务属性通常由事务的传播行为、事务的隔离级别、事务的超时值和事务的只读标识组成。我们在进行事务划分时，需要进行事务定义，也就是配置事务的属性。</p><p>Spring在TransactionDefinition接口中定义这些属性,以供PlatfromTransactionManager使用, PlatfromTransactionManager是spring事务管理的核心接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TransactionDefinition  </span><br><span class="line">public interface TransactionDefinition &#123;  </span><br><span class="line">    int getPropagationBehavior();  </span><br><span class="line">    int getIsolationLevel();  </span><br><span class="line">    int getTimeout();  </span><br><span class="line">    boolean isReadOnly();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>getTimeout()方法，它返回事务必须在多少秒内完成。<br>isReadOnly(),事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的。<br>getIsolationLevel()方法返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据。</p><p>getPropagationBehavior()返回事务的传播行为，由是否有一个活动的事务来决定一个事务调用。</p><h4 id="1-事务的隔离级别"><a href="#1-事务的隔离级别" class="headerlink" title="1.事务的隔离级别"></a>1.事务的隔离级别</h4><p>在TransactionDefinition接口中定义了五个不同的事务隔离级别 ：<br><strong>（a）</strong> ISOLATION_DEFAULT：（PlatfromTransactionManager的）默认的隔离级别。使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应 。<br><strong>（b）</strong>ISOLATION_READ_UNCOMMITTED：这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。<br>例如：<br>Mary的原工资为1000,财务人员将Mary的工资改为了8000，但未提交事务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection con1 &#x3D; getConnection();  </span><br><span class="line">con.setAutoCommit(false);  </span><br><span class="line">update employee set salary &#x3D; 8000 where empId &#x3D;&quot;Mary&quot;; </span><br></pre></td></tr></table></figure><p>与此同时，Mary正在读取自己的工资 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection con2 &#x3D; getConnection();  </span><br><span class="line">select  salary from employee where empId &#x3D;&quot;Mary&quot;;  </span><br><span class="line">con2.commit();</span><br></pre></td></tr></table></figure><p>Mary发现自己的工资变为了8000，欢天喜地！<br>而财务发现操作有误，而回滚了事务,Mary的工资又变为了1000 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con1.rollback(); 12</span><br></pre></td></tr></table></figure><p>像这样,Mary记取的工资数8000是一个脏数据。</p><p><strong>（c）</strong>ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p><p><strong>（d）</strong>ISOLATION_REPEATABLE_READ ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p><p>例如：<br>在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con1 &#x3D; getConnection();  </span><br><span class="line">select salary from employee empId &#x3D;&quot;Mary&quot;;  </span><br></pre></td></tr></table></figure><p>在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con2 &#x3D; getConnection();  </span><br><span class="line">update employee set salary &#x3D; 2000;  </span><br><span class="line">con2.commit();  </span><br></pre></td></tr></table></figure><p>在事务1中，Mary 再次读取自己的工资时，工资变为了2000</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select salary from employee empId &#x3D;&quot;Mary&quot;;  </span><br></pre></td></tr></table></figure><p>在一个事务中前后两次读取的结果并不致，导致了不可重复读。<br>使用ISOLATION_REPEATABLE_READ可以避免这种情况发生。</p><p><strong>（e）</strong>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p><p>目前工资为1000的员工有10人。<br>事务1,读取所有工资为1000的员工。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con1 &#x3D; getConnection();  </span><br><span class="line">Select * from employee where salary &#x3D;1000; </span><br></pre></td></tr></table></figure><p>共读取10条记录</p><p>这时另一个事务向employee表插入了一条员工记录，工资也为1000</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con2 &#x3D; getConnection();  </span><br><span class="line">Insert into employee(empId,salary) values(&quot;Lili&quot;,1000);  </span><br><span class="line">con2.commit();  </span><br></pre></td></tr></table></figure><p>事务1再次读取所有工资为1000的员工</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where salary &#x3D;1000;  </span><br></pre></td></tr></table></figure><p>共读取到了11条记录，这就产生了幻像读。<br>ISOLATION_SERIALIZABLE能避免这样的情况发生。但是这样也耗费了最大的资源。</p><h4 id="2-事务的传播性："><a href="#2-事务的传播性：" class="headerlink" title="2.事务的传播性："></a>2.事务的传播性：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROPAGATION_REQUIRED 支持当前事务，如果不存在，就新建一个(默认)</span><br><span class="line"></span><br><span class="line">PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就以非事务的方式</span><br><span class="line"></span><br><span class="line">PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</span><br><span class="line"></span><br><span class="line">PROPAGATION_REQUIRES_NEW  总是开启一个新的事务，挂起当前事务，创建一个新的事务</span><br><span class="line"></span><br><span class="line">PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务</span><br><span class="line"></span><br><span class="line">PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常</span><br><span class="line"></span><br><span class="line">PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</span><br></pre></td></tr></table></figure><p>在TransactionDefinition接口中定义了七个事务传播行为。</p><p>假如我写了两个service类。名字分别为ServiceA和ServiceB。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service(&quot;ServiceA&quot;)</span><br><span class="line">public class ServiceA &#123;</span><br><span class="line"></span><br><span class="line">    @Resource(name&#x3D;&quot;ServiceB&quot;)</span><br><span class="line">    private ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation&#x3D;Propagation.REQUIRED)</span><br><span class="line">    public methodA()&#123;</span><br><span class="line">       &#x2F;&#x2F;doSomething</span><br><span class="line">       serviceB.methodB(); </span><br><span class="line">       &#x2F;&#x2F;doSomething</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service(&quot;ServiceB&quot;)</span><br><span class="line">public class ServiceB &#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation&#x3D;Propagation.REQUIRED)</span><br><span class="line">    public methodB()&#123;</span><br><span class="line">       &#x2F;&#x2F;doSomething</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。</p><p><strong>（a）</strong>PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。<br>如果单独调用serviceB.methodB方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">   serviceB.methodB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main&#123;  </span><br><span class="line">  Connection con&#x3D;null;  </span><br><span class="line">  try&#123;  </span><br><span class="line">      con &#x3D; getConnection();  </span><br><span class="line">      con.setAutoCommit(false);  </span><br><span class="line">      &#x2F;&#x2F;方法调用  </span><br><span class="line">      methodB();  </span><br><span class="line">      &#x2F;&#x2F;提交事务  </span><br><span class="line">      con.commit();  </span><br><span class="line"> &#125;Catch(RuntimeException ex)&#123;  </span><br><span class="line">    &#x2F;&#x2F;回滚事务  </span><br><span class="line">    con.rollback();    </span><br><span class="line"> &#125;finally&#123;  </span><br><span class="line">    &#x2F;&#x2F;释放资源  </span><br><span class="line">    closeCon();  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring保证在methodB方法中所有的调用都获得到一个相同的连接。在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务。</p><p>如果单独调用MethodA时，在MethodA内又会调用MethodB.<br>执行效果相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main&#123;  </span><br><span class="line">   Connection con &#x3D; null;  </span><br><span class="line">   try&#123;  </span><br><span class="line">      con &#x3D; getConnection();  </span><br><span class="line">      methodA();  </span><br><span class="line">      con.commit();  </span><br><span class="line">   &#125;cathc(RuntimeException ex)&#123;  </span><br><span class="line">      con.rollback();  </span><br><span class="line">   &#125;finally&#123;  </span><br><span class="line">      closeCon();  </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>调用MethodA时，环境中没有事务，所以开启一个新的事务.<br>当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。</p><p><strong>（b）</strong>PROPAGATION_SUPPORTS ：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class="line">methodA()&#123;  </span><br><span class="line">  serviceB.methodB();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_SUPPORTS   </span><br><span class="line">methodB()&#123;  </span><br><span class="line">  ……  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>单纯的调用methodB时，methodB方法是非事务的执行的。<br>当调用methdA时,methodB则加入了methodA的事务中,事务地执行。</p><p><strong>（c）</strong>PROPAGATION_MANDATORY ：如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class="line">methodA()&#123;  </span><br><span class="line">  serviceB.methodB();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_MANDATORY   </span><br><span class="line">methodB()&#123;  </span><br><span class="line">  ……  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常<br>throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);</p><p>当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</p><p><strong>（d）</strong>PROPAGATION_REQUIRES_NEW ：如果一个事务已经存在，则将这个存在的事务挂起。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class="line">methodA()&#123;  </span><br><span class="line">   doSomeThingA();  </span><br><span class="line">   serviceB.methodB();  </span><br><span class="line">   doSomeThingB();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRES_NEW   </span><br><span class="line">methodB()&#123;  </span><br><span class="line">  ……  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>当单独调用methodB时，相当于把methodb声明为REQUIRED。开启一个新的事务，事务地执行。</p><p>当调用methodA时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line">  methodA();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>情况就大不一样了，相当于下面的效果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line"> TransactionManager tm &#x3D; null;  </span><br><span class="line"> try&#123;  </span><br><span class="line">  &#x2F;&#x2F;获得一个JTA事务管理器  </span><br><span class="line">   tm &#x3D; getTransactionManager();  </span><br><span class="line">   tm.begin();&#x2F;&#x2F;开启一个新的事务  </span><br><span class="line">   Transaction ts1 &#x3D; tm.getTransaction();  </span><br><span class="line">   doSomeThing();  </span><br><span class="line">   tm.suspend();&#x2F;&#x2F;挂起当前事务  </span><br><span class="line">   try&#123;  </span><br><span class="line">     tm.begin();&#x2F;&#x2F;重新开启第二个事务  </span><br><span class="line">     Transaction ts2 &#x3D; tm.getTransaction();  </span><br><span class="line">     methodB();  </span><br><span class="line">     ts2.commit();&#x2F;&#x2F;提交第二个事务  </span><br><span class="line"></span><br><span class="line">   &#125;Catch(RunTimeException ex)&#123;  </span><br><span class="line">     ts2.rollback();&#x2F;&#x2F;回滚第二个事务  </span><br><span class="line">   &#125;finally&#123;  </span><br><span class="line">    &#x2F;&#x2F;释放资源  </span><br><span class="line">   &#125;  </span><br><span class="line">   &#x2F;&#x2F;methodB执行完后，复恢第一个事务  </span><br><span class="line">   tm.resume(ts1);  </span><br><span class="line">   doSomeThingB();  </span><br><span class="line">   ts1.commit();&#x2F;&#x2F;提交第一个事务  </span><br><span class="line"> &#125;catch(RunTimeException ex)&#123;  </span><br><span class="line">  ts1.rollback();&#x2F;&#x2F;回滚第一个事务  </span><br><span class="line"> &#125;finally&#123;  </span><br><span class="line">  &#x2F;&#x2F;释放资源  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了methodB之外的其它代码导致的结果却被回滚了。<br>使用PROPAGATION_REQUIRES_NEW,需要使用JtaTransactionManager作为事务管理器。</p><p><strong>（e）</strong>PROPAGATION_NOT_SUPPORTED： 总是非事务地执行，并挂起任何存在的事务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class="line">methodA()&#123;  </span><br><span class="line">  doSomeThingA();  </span><br><span class="line">  serviceB.methodB();  </span><br><span class="line">  doSomeThingB();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_NOT_SUPPORTED   </span><br><span class="line">methodB()&#123;  </span><br><span class="line">  ……  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当单独调用methodB时，不启用任何事务机制，非事务地执行。</p><p>当调用methodA时，相当于下面的效果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line"> TransactionManager tm &#x3D; null;  </span><br><span class="line"> try&#123;  </span><br><span class="line">  &#x2F;&#x2F;获得一个JTA事务管理器  </span><br><span class="line">   tm &#x3D; getTransactionManager();  </span><br><span class="line">   tm.begin();&#x2F;&#x2F;开启一个新的事务  </span><br><span class="line">   Transaction ts1 &#x3D; tm.getTransaction();  </span><br><span class="line">   doSomeThing();  </span><br><span class="line">   tm.suspend();&#x2F;&#x2F;挂起当前事务  </span><br><span class="line">   methodB();  </span><br><span class="line">   &#x2F;&#x2F;methodB执行完后，复恢第一个事务  </span><br><span class="line">   tm.resume(ts1);  </span><br><span class="line">   doSomeThingB();  </span><br><span class="line">   ts1.commit();&#x2F;&#x2F;提交第一个事务  </span><br><span class="line"> &#125;catch(RunTimeException ex)&#123;  </span><br><span class="line">   ts1.rollback();&#x2F;&#x2F;回滚第一个事务  </span><br><span class="line"> &#125;finally&#123;  </span><br><span class="line">  &#x2F;&#x2F;释放资源  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。</p><p><strong>（f）</strong>PROPAGATION_NEVER ：总是非事务地执行，如果存在一个活动事务，则抛出异常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class="line">methodA()&#123;  </span><br><span class="line">  doSomeThingA();  </span><br><span class="line">  seviceB.methodB();  </span><br><span class="line">  doSomeThingB();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_NEVER   </span><br><span class="line">methodB()&#123;  </span><br><span class="line">  ……  </span><br><span class="line">&#125;  1234567891011</span><br></pre></td></tr></table></figure><p>单独调用methodB，则非事务的执行。<br>调用methodA则会抛出异常<br>throw new IllegalTransactionStateException(<br>“Transaction propagation ‘never’ but existing transaction found”);</p><p><strong>（g）</strong>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p><p>这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。</p><p>使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;<br>而nestedTransactionAllowed属性值默认为false;<br>例如如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;system.platformTransactionManager&quot; class&#x3D;&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;  </span><br><span class="line">        &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;system.sessionFactory&quot;&#x2F;&gt;  </span><br><span class="line">        &lt;property name&#x3D;&quot;nestedTransactionAllowed&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;  </span><br><span class="line">    &lt;&#x2F;bean&gt;1234</span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_REQUIRED   </span><br><span class="line">methodA()&#123;  </span><br><span class="line">  doSomeThingA();  </span><br><span class="line">  serviceB.methodB();  </span><br><span class="line">  doSomeThingB();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;事务属性 PROPAGATION_NESTED  </span><br><span class="line">methodB()&#123;  </span><br><span class="line">  ……  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果单独调用methodB方法，则按REQUIRED属性执行。</p><p>如果调用methodA方法，相当于下面的效果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line">Connection con &#x3D; null;  </span><br><span class="line">Savepoint savepoint &#x3D; null;  </span><br><span class="line">try&#123;  </span><br><span class="line">  con &#x3D; getConnection();  </span><br><span class="line">  con.setAutoCommit(false);  </span><br><span class="line">  doSomeThingA(); </span><br><span class="line">  &#x2F;&#x2F;创造一个事务的保存点 </span><br><span class="line">  savepoint &#x3D; con2.setSavepoint();  </span><br><span class="line">  try  </span><br><span class="line">      methodB();  </span><br><span class="line">  &#125;catch(RuntimeException ex)&#123;  </span><br><span class="line">     con.rollback(savepoint);  </span><br><span class="line">  &#125;  </span><br><span class="line">  finally&#123;  </span><br><span class="line">    &#x2F;&#x2F;释放资源  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  doSomeThingB();  </span><br><span class="line">  con.commit();  </span><br><span class="line">&#125;  </span><br><span class="line">catch(RuntimeException ex)&#123;  </span><br><span class="line">  con.rollback();  </span><br><span class="line">&#125;  </span><br><span class="line">finally&#123;  </span><br><span class="line">  &#x2F;&#x2F;释放资源  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。</p><p><strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p><p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。<br>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。</p><p>PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p><h4 id="3-事务的超时性、回滚和只读"><a href="#3-事务的超时性、回滚和只读" class="headerlink" title="3.事务的超时性、回滚和只读"></a>3.事务的超时性、回滚和只读</h4><p><strong>超时：</strong><br>@Transactional(timeout=30) //默认是30秒</p><p><strong>异常回滚：</strong><br>指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)</p><p>指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})<br>该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。</p><p><strong>正常的情况下也可以回滚：</strong></p><p>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</p><p><strong>只读</strong>：<br>@Transactional(readOnly=true)<br>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。</p><h3 id="5、注意的地方"><a href="#5、注意的地方" class="headerlink" title="5、注意的地方"></a>5、注意的地方</h3><p>1.@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.</p><p>2.用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚</p><p>3.默认遇到运行期异常（非受检查型异常）(throw new RuntimeException(&quot;注释&quot;);)会回滚；而遇到需要非运行时异常（受检查的异，捕获的异常）(throw new Exception(&quot;注释&quot;);)不会回滚；</p><p>要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .</p><p>如果让运行时异常不回滚： @Transactional(notRollbackFor=RunTimeException.class)</p><p>指定回滚,遇到异常Exception时回滚@Transactional(rollbackFor=Exception.class) </p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="事务" scheme="https://yuhaicheng.xyz/categories/%E4%BA%8B%E5%8A%A1/"/>
    
    
  </entry>
  
</feed>
