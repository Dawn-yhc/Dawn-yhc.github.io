<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曙光苑</title>
  
  <subtitle>有朋自远方来，不亦乐乎</subtitle>
  <link href="https://yuhaicheng.xyz/atom.xml" rel="self"/>
  
  <link href="https://yuhaicheng.xyz/"/>
  <updated>2021-03-27T14:05:14.000Z</updated>
  <id>https://yuhaicheng.xyz/</id>
  
  <author>
    <name>Dawn-yhc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池相关概念、回表</title>
    <link href="https://yuhaicheng.xyz/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.html"/>
    <id>https://yuhaicheng.xyz/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.html</id>
    <published>2021-03-26T14:05:14.000Z</published>
    <updated>2021-03-27T14:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1.线程池"></a>1.线程池</h4><p><strong>一、corePoolSize 核心线程大小</strong><br>线程池中最小的线程数量，即使处理空闲状态，也不会被销毁，除非设置了allowCoreThreadTimeOut。</p><p>CPU密集型：核心线程数 = CPU核数 + 1<br>IO密集型：核心线程数 = CPU核数 * 2+1<br>注：IO密集型（某大厂实践经验）<br>核心线程数 = CPU核数 / （1-阻塞系数）<br>例如阻塞系数 0.8，CPU核数为4，则核心线程数为20</p><p><strong>二、maximumPoolSize 线程池最大线程数量</strong><br>一个任务被提交后，首先会被缓存到工作队列中，等工作队列满了，则会创建一个新线程，处理从工作队列中的取出一个任务。</p><p><strong>三、keepAliveTime 空闲线程存活时间</strong><br>当线程数量大于corePoolSize时，一个处于空闲状态的线程，在指定的时间后会被销毁。</p><p><strong>四、unit 空间线程存活时间单位</strong><br>keepAliveTime的计量单位</p><p><strong>五、workQueue 工作队列</strong>，jdk中提供了四种工作队列<br>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。<br>①ArrayBlockingQueue<br>基于数组的有界阻塞队列，按FIFO排序。<br>②LinkedBlockingQuene<br>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。<br>④PriorityBlockingQueue<br>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p><p><strong>六、threadFactory 线程工厂</strong><br>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等<br><strong>七、handler 拒绝策略</strong><br>当工作队列中的任务已满并且线程池中的线程数量也达到最大，这时如果有新任务提交进来，拒绝策略就是解决这个问题的，jdk中提供了4中拒绝策略：<br>①CallerRunsPolicy<br>该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。<br>②AbortPolicy<br>该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。<br>③DiscardPolicy<br>该策略下，直接丢弃任务，什么都不做。<br>④DiscardOldestPolicy<br>该策略下，抛弃最早进入队列的那个任务，然后尝试把这次拒绝的任务放入队列。</p><h4 id="2-mysql-索引的分类（聚簇索引、非聚簇索引）回表"><a href="#2-mysql-索引的分类（聚簇索引、非聚簇索引）回表" class="headerlink" title="2.mysql 索引的分类（聚簇索引、非聚簇索引）回表"></a>2.mysql 索引的分类（聚簇索引、非聚簇索引）回表</h4><p>MyISAM引擎主要用的是非聚簇索引</p><p>InnoDB引擎主要用的是聚簇索引</p><h3 id="①mysql索引"><a href="#①mysql索引" class="headerlink" title="①mysql索引"></a>①mysql索引</h3><p><strong>B+Tree结构都可以用在MyISAM和InnoDB上</strong>。mysql中，不同的存储引擎对索引的实现方式不同，大致说下MyISAM和InnoDB两种存储引擎。</p><p><strong>MyISAM的是非聚簇索引，</strong>B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，<br>这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><p>InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。</p><p><strong>InnoDB使用的是聚簇索引</strong>，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用&quot;where id = 14&quot;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><h3 id="②聚簇索引"><a href="#②聚簇索引" class="headerlink" title="②聚簇索引"></a>②聚簇索引</h3><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。</p><p>聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。</p><h3 id="③非聚簇索引"><a href="#③非聚簇索引" class="headerlink" title="③非聚簇索引"></a>③非聚簇索引</h3><p>非聚集索引，类似于图书的附录，那个专业术语出现在哪个章节，这些专业术语是有顺序的，但是出现的位置是没有顺序的。每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放。但是，一个表可以有不止一个非聚簇索引。</p><h1 id="mysql-索引回表"><a href="#mysql-索引回表" class="headerlink" title="mysql 索引回表"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXVuaWNoL3AvMTI5NjM3NDkuaHRtbA==">mysql 索引回表<i class="fa fa-external-link-alt"></i></span></h1><p>因为主键索引对应的是整行数据块，通过主键索引查询只需要查询一次</p><p>通过普通索引查询到数据块记录的是主键索引，再通过主键索引查询到记录的过程叫回表</p><p>我们知道，Mysql中InnoDB中索引结构为B+树，这是综合了B+树寻址次数少且查询耗时较稳定等优点决定的。</p><p>那B+树中存储的是什么东西呢？根据索引树就能直接找到对应的数据行吗？要说明这一点，就要详细地聊一下B+树的储存内容。</p><p><strong>回表</strong><br>实际上，InnoDB除了维护了一个索引B+树之外，还维护了一个主键B+树。索引B+树节点上存放的数据实际上是主键的值，而主键B+树上存放的才是真正的数据行本身(因为InnoDB是聚集索引，所以直接存储了数据行，如果是MyIsam非聚集索引，这里储存的只是数据行的一个地址，还需要去磁盘中获取数据行。这点具体可以看一下聚集索引与非聚集索引的区别)</p><p>那么这点弄清楚了，就可以分析一下，如果一条指令通过索引(同时不是主键)来检索数据，会发生什么呢？</p><p>例如在一个居民表中，有以下字段，其中id是主键，并且建立了name索引。</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>remark</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>20</td><td>2</td></tr><tr><td>2</td><td>bbb</td><td>14</td><td>3</td></tr></tbody></table><p>当执行语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM MyTable WHERE name&#x3D;aaa;</span><br></pre></td></tr></table></figure><p>首先MySQL分析到该次查询是通过name索引来检索的,所以就会去检索索引B+树。</p><p>而刚才我们也说了，索引树上存的实际上是主键，所以不出意外的话，我们能从索引树上获取到id=1这个主键。</p><p>于是这时如果想查询出整行数据，就要发生 回表：拿着id=1这个主键，再去主键树上进行查询，进而查询出真正的一条数据行。这个查询语句才算执行完成了。</p><p>回顾一下，在这个查询过程了，我们一共进行了两次B+树的检索，其中后面一次就是回表。就像我们猜测的一样，回标操作必然会导致查询时间的增加，开销的增大。</p><p>如果此时使用覆盖索引就可以避免回表操作，那啥是覆盖索引？考虑这个SQL语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id FROM MyTable WHERE name&#x3D;aaa;</span><br></pre></td></tr></table></figure><p>那这样执行流程是怎么样？我们发现，检索索引树的时候，直接就把id给查询出来，符合我们的预期结果了，不需要再进行一次回表。那这种操作就叫做覆盖索引，实际中也经常使用覆盖索引来进行性能的优化。</p><p><strong>联合索引</strong><br>基于刚说完的覆盖索引，我们再考虑一个问题，当在一个需要进行”根据name查询出age“操作很频繁的场景之下，按照我们刚才所建立的主键和索引，我们不难判断这个操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT age FROM MyTable WHERE name&#x3D;aaa;</span><br></pre></td></tr></table></figure><p>或者这个操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 一个其他属性 FROM MyTable WHERE name&#x3D;aaaAND age&#x3D;20;</span><br></pre></td></tr></table></figure><p>每次执行时都需要进行回表操作(因为索引树中并没有age相关的数据)，这很明显是不太合理的。那咋办？把主键声明为age，利用覆盖索引避免回表操作？别傻了，不同的人可能会有相同的age，这怎么能作为主键呢？那这时，我们可以定义联合索引了。</p><p>取{name,age}作为一个联合索引，那么每次查询的时候，因为索引下推（会检索索引的所有值，只有都符合条件的时候，才会对该索引进行回表），MySQL除了查出name之外，还能查出age的值，这样我们就能从索引树直接获得age字段，而避免了一次回表操作。当然这样做也有缺点，联合索引因为比较复杂，通常来说维护起来也会产生比单个索引更大的开销，这个就要和实际情况相结合来进行取舍了。</p><p><strong>最左前缀原则</strong><br>回表的问题可算是解决了，建立一个联合索引{name,age}就可以。那问题又来了：</p><p>我不一定是通过name和age来检索数据啊，我们可能直接通过name来检索，那这时咋办，同时建立一个{name,age}联合索引来满足联合查询，和一个{name}单独索引来满足单独查询？是不是太繁琐了？</p><p>MySQL也考虑到了这个问题，所以MySQL有一个最左前缀原则。</p><p>拿{name,age}来举例，该索引中的最左边是name字段，根据最左前缀原则，该索引既可以用于name和age组合查询，也可以用于name的单独查询。那么这就好办了，只需要维护{name,age}就可以了，无需再多建立一个name索引。当然如果还需要一个单独的age索引，因为它不是在联合索引的最左边，所以还是需要额外建立age索引的，否则会进行全表扫描</p>]]></content>
    
    
    <summary type="html">线程</summary>
    
    
    
    <category term="线程池" scheme="https://yuhaicheng.xyz/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>linux下查看剩余内存、查看文件根据文件名字符串</title>
    <link href="https://yuhaicheng.xyz/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%89%A9%E4%BD%99%E5%86%85%E5%AD%98%E3%80%81%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://yuhaicheng.xyz/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%89%A9%E4%BD%99%E5%86%85%E5%AD%98%E3%80%81%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2.html</id>
    <published>2020-11-26T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux下查看剩余内存"><a href="#linux下查看剩余内存" class="headerlink" title="linux下查看剩余内存"></a>linux下查看剩余内存</h2><p>看linux系统中空闲内存/物理内存使用/剩余内存</p><p>查看系统内存有很多方法，<strong>但主要的是用top命令和free 命令</strong> 当执行top命令看到结果，要怎么看呢？</p><p>这里说明一下： Mem: 666666k total, 55555k used,并不是代表你的应用程序已经使用了55555k的内存,这55555k是包含了:应用程序内存 + 缓冲 + 缓存的内存的。 </p><p><strong>1.用free命令查看更直接： 下面是一个例子(单位是MB):</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@linuxzgf ~]# free -m</span><br><span class="line">                    total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          <span class="number">7982</span>       <span class="number">6811</span>       <span class="number">1171</span>          <span class="number">0</span>        <span class="number">350</span>       <span class="number">5114</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span>cache:       <span class="number">1346</span>       <span class="number">6636</span></span><br><span class="line">Swap:        <span class="number">16935</span>         <span class="number">11</span>      <span class="number">16924</span></span><br></pre></td></tr></table></figure><p>在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.  一些简单的计算方法：  物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M</p><p>物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存 </p><p>应用程序可用空闲内存 = 总物理内存 - 实际已用内存 </p><p>应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存</p><p><strong>2.top命令的结果详解 top命令 是Linux下常用的性能 分析工具 ，能够实时显示系统 中各个进程的资源占用状况，类似于Windows的任务管理 器。下面详细介绍它的使用方法。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top - <span class="number">0</span>2:<span class="number">53</span>:<span class="number">32</span> up <span class="number">16</span> days,  <span class="number">6</span>:<span class="number">34</span>, <span class="number">17</span> users,  load average: <span class="number">0.24</span>, <span class="number">0.21</span>, <span class="number">0.24</span></span><br><span class="line">Tasks: <span class="number">481</span> total,   <span class="number">3</span> running, <span class="number">474</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">4</span> zombie</span><br><span class="line">Cpu(s): <span class="number">10.3</span>%us,  <span class="number">1.8</span>%sy,  <span class="number">0.0</span>%ni, <span class="number">86.6</span>%id,  <span class="number">0.5</span>%wa,  <span class="number">0.2</span>%hi,  <span class="number">0.6</span>%si,  <span class="number">0.0</span>%st</span><br><span class="line">Mem:   <span class="number">4042764</span>k total,  <span class="number">4001096</span>k used,    <span class="number">41668</span>k free,   <span class="number">383536</span>k buffers</span><br><span class="line">Swap:  <span class="number">2104472</span>k total,     <span class="number">7900</span>k used,  <span class="number">2096572</span>k free,  <span class="number">1557040</span>k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line"><span class="number">32497</span> jacky     <span class="number">20</span>   <span class="number">0</span>  <span class="number">669</span>m <span class="number">222</span>m  <span class="number">31</span>m R   <span class="number">10</span>  <span class="number">5.6</span>       <span class="number">29</span>:<span class="number">27.62</span> firefox</span><br><span class="line"> <span class="number">4788</span> yiuwing   <span class="number">20</span>   <span class="number">0</span>  <span class="number">257</span>m  <span class="number">18</span>m  <span class="number">13</span>m S    <span class="number">5</span>  <span class="number">0.5</span>          <span class="number">5</span>:<span class="number">42.44</span> konsole</span><br><span class="line"> <span class="number">5657</span> Liuxiaof  <span class="number">20</span>   <span class="number">0</span>  <span class="number">585</span>m <span class="number">159</span>m  <span class="number">30</span>m S    <span class="number">4</span>  <span class="number">4.0</span>          <span class="number">5</span>:<span class="number">25.06</span> firefox</span><br><span class="line"> <span class="number">4455</span> xiefc      <span class="number">20</span>   <span class="number">0</span>  <span class="number">542</span>m  <span class="number">124</span>m  <span class="number">30</span>m R    <span class="number">4</span>  <span class="number">3.1</span>         <span class="number">7</span>:<span class="number">23.03</span> firefox</span><br><span class="line"> <span class="number">6188</span> Liuxiaof  <span class="number">20</span>   <span class="number">0</span>  <span class="number">191</span>m   <span class="number">17</span>m  <span class="number">13</span>m S    <span class="number">4</span>  <span class="number">0.5</span>          <span class="number">0</span>:<span class="number">0</span>1<span class="number">.16</span> konsole</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="linux" scheme="https://yuhaicheng.xyz/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="https://yuhaicheng.xyz/2020-11-25-SpringBoot%E6%95%B4%E5%90%88Redis.html"/>
    <id>https://yuhaicheng.xyz/2020-11-25-SpringBoot%E6%95%B4%E5%90%88Redis.html</id>
    <published>2020-11-25T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis</strong></p><p>基于内存进行存储，支持key-value的存储形式，底层是用C语言写的。</p><p>基于key-value形式的数据字典，结构非常简单，没有数据表的概念，直接用键值对的形式完成数据的管理，支持5种数据类型：</p><ul><li>字符串String</li><li>列表List</li><li>集合Set</li><li>有序集合zSet</li><li>哈希hash</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">offCOPY&#x2F;&#x2F;Redis启动批处理程序</span><br><span class="line">title redis-server</span><br><span class="line">set ENV_HOME&#x3D;&quot;C:\redis&quot;</span><br><span class="line">C:</span><br><span class="line">color 0F</span><br><span class="line">cd %ENV_HOME%</span><br><span class="line">redis-server redis.windows.conf</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-整合-Redis"><a href="#Spring-Boot-整合-Redis" class="headerlink" title="Spring Boot 整合 Redis"></a>Spring Boot 整合 Redis</h3><p>实际上使用Spring Data Redis操作Redis，</p><p>1、创建maven工程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.hhzhu&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redis_practice&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--连接池 redis客户端需要的支持--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--简化实体类的开发--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>2、创建实体类，实现序列化接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hhzhu.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author ZhuHh</span><br><span class="line"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">&#x2F;&#x2F;实现序列化接口，否则无法存入redis，因为redis是存在内存中的</span><br><span class="line">public class Student implements Serializable &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double score;</span><br><span class="line">    private Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、创建控制器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYpackage com.hhzhu.controller;</span><br><span class="line"></span><br><span class="line">import com.hhzhu.pojo.Student;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author ZhuHh</span><br><span class="line"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class StudentHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;set&quot;)</span><br><span class="line">    &#x2F;&#x2F;Request将json数据转换成java对象</span><br><span class="line">    public void set(@RequestBody Student student)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;student&quot;,student);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、创建配置文件appliacation.yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYspring:</span><br><span class="line">  redis:</span><br><span class="line">    database: 0</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure><p>5、创建启动类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYpackage com.hhzhu;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author ZhuHh</span><br><span class="line"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、CRUD</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYpackage com.hhzhu.controller;</span><br><span class="line"></span><br><span class="line">import com.hhzhu.pojo.Student;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author ZhuHh</span><br><span class="line"> * @data Create on 2020&#x2F;3&#x2F;15</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class StudentHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;set&quot;)</span><br><span class="line">    &#x2F;&#x2F;Request将json数据转换成java对象</span><br><span class="line">    public void set(@RequestBody Student student)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;student&quot;,student);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;get&#x2F;&#123;key&#125;&quot;)</span><br><span class="line">    public Student get(@PathVariable(&quot;key&quot;) String key)&#123;</span><br><span class="line">        return (Student) redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;delete&#x2F;&#123;key&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable(&quot;key&quot;) String key)&#123;</span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">        return redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis-5种数据类型"><a href="#Redis-5种数据类型" class="headerlink" title="Redis 5种数据类型"></a>Redis 5种数据类型</h3><ul><li><p><strong>字符串</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY@GetMapping(&quot;&#x2F;string&quot;)</span><br><span class="line">public String stringTest()&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;str&quot;,&quot;Hello world&quot;);</span><br><span class="line">    &#x2F;&#x2F;System.out.println(redisTemplate.opsForValue().get(&quot;str&quot;));</span><br><span class="line">    String str &#x3D; (String) redisTemplate.opsForValue().get(&quot;str&quot;);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>列表</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY@GetMapping(&quot;list&quot;)</span><br><span class="line">public List&lt;String&gt; listTest()&#123;</span><br><span class="line">    ListOperations&lt;String,String&gt; listOperations &#x3D; redisTemplate.opsForList();</span><br><span class="line">    listOperations.leftPush(&quot;list&quot;,&quot;hello&quot;);</span><br><span class="line">    listOperations.leftPush(&quot;list&quot;,&quot;world&quot;);</span><br><span class="line">    listOperations.rightPush(&quot;list&quot;,&quot;java&quot;);</span><br><span class="line">  </span><br><span class="line">    List&lt;String&gt; list &#x3D; listOperations.range(&quot;list&quot;,0,2);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>集合(set)</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY@GetMapping(&quot;&#x2F;set&quot;)</span><br><span class="line">public Set&lt;String&gt; setTest()&#123;</span><br><span class="line">    SetOperations&lt;String,String&gt; setOperations &#x3D; redisTemplate.opsForSet();</span><br><span class="line">    setOperations.add(&quot;set&quot;,&quot;Hello&quot;);</span><br><span class="line">    setOperations.add(&quot;set&quot;,&quot;Hello&quot;);</span><br><span class="line">    setOperations.add(&quot;set&quot;,&quot;world&quot;);</span><br><span class="line">    setOperations.add(&quot;set&quot;,&quot;world&quot;);</span><br><span class="line">    setOperations.add(&quot;set&quot;,&quot;java&quot;);</span><br><span class="line">    setOperations.add(&quot;set&quot;,&quot;java&quot;);</span><br><span class="line">  </span><br><span class="line">    Set&lt;String&gt; set &#x3D; setOperations.members(&quot;set&quot;);</span><br><span class="line">    return set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有序集合</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY@GetMapping(&quot;&#x2F;zset&quot;)</span><br><span class="line">public Set&lt;String&gt; zsetTest()&#123;</span><br><span class="line">    ZSetOperations&lt;String,String&gt; zSetOperations &#x3D; redisTemplate.opsForZSet();</span><br><span class="line">    zSetOperations.add(&quot;zset&quot;,&quot;Hello&quot;,1);</span><br><span class="line">    zSetOperations.add(&quot;zset&quot;,&quot;world&quot;,2);</span><br><span class="line">    zSetOperations.add(&quot;zset&quot;,&quot;java&quot;,3);</span><br><span class="line">  </span><br><span class="line">    Set&lt;String&gt; set &#x3D; zSetOperations.range(&quot;zset&quot;,0,2);</span><br><span class="line">    return set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>哈希</strong></p><p>Hash：key value</p><p>HashOperations：key hashkey value</p><p>key是每一组数据的ID，hashkey和value是一组完整的HashMap数据，通过key来区分不同的HashMap</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYHashMap hashMap &#x3D; new HashMap();</span><br><span class="line">hashMap.put(key1,value1);</span><br><span class="line">HashMap hashMap &#x3D; new HashMap();</span><br><span class="line">hashMap.put(key2,value2);</span><br><span class="line">HashMap hashMap &#x3D; new HashMap();</span><br><span class="line">hashMap.put(key3,value3);</span><br><span class="line"></span><br><span class="line">HashOperations&lt;String,String,String&gt; hashOperation &#x3D; redisTemplate.opsForHash();</span><br><span class="line">hashOperation.put(hashMap1,key1,value1);</span><br><span class="line">hashOperation.put(hashMap2,key2,value2);</span><br><span class="line">hashOperation.put(hashMap3,key3,value3);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY@GetMapping(&quot;&#x2F;hash&quot;)</span><br><span class="line">public void hashTest()&#123;</span><br><span class="line">    HashOperations&lt;String,String,String&gt; hashOperations &#x3D; redisTemplate.opsForHash();</span><br><span class="line">    hashOperations.put(&quot;key&quot;,&quot;hashKey&quot;,&quot;Hello&quot;);</span><br><span class="line">    System.out.println(hashOperations.get(&quot;key&quot;,&quot;hashKey&quot;));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="Redis" scheme="https://yuhaicheng.xyz/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>索引优化</title>
    <link href="https://yuhaicheng.xyz/2020-11-18-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96.html"/>
    <id>https://yuhaicheng.xyz/2020-11-18-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96.html</id>
    <published>2020-11-24T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引是什么？"><a href="#1-索引是什么？" class="headerlink" title="1.索引是什么？"></a>1.索引是什么？</h3><p>排好序的快速查找的数据结构；</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p><p>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p><h3 id="2-sql执行顺序"><a href="#2-sql执行顺序" class="headerlink" title="2.sql执行顺序"></a><strong>2.sql执行顺序</strong></h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。下面是经常出现的查询顺序：</p><p><strong>手写：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">&lt;<span class="keyword">select</span> <span class="keyword">list</span>&gt;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">&lt;<span class="keyword">left</span> <span class="keyword">table</span>&gt; &lt;<span class="keyword">join</span> <span class="keyword">type</span>&gt;</span><br><span class="line"><span class="keyword">JOIN</span>&lt; <span class="keyword">right</span> <span class="keyword">table</span>&gt; <span class="keyword">ON</span> &lt;<span class="keyword">join</span> condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">&lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">&lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">&lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">&lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p><strong>机读：</strong>从from开始做笛卡尔积计算，然后on 保留主表，然后同时做join和where判断，然后GROUP BY 、HAVING，然乎在select，最后用ORDER BY排序 、LIMIT限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">ON&lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP BY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><h3 id="3-索引的种类"><a href="#3-索引的种类" class="headerlink" title="3.索引的种类"></a>3.索引的种类</h3><ul><li>主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引，主键索引不允许为空</li><li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：即一个索引包含多个列；在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)当表的行数远大于索引列的数目时可以使用复合索引</li></ul><h4 id="索引建立成哪种索引类型？"><a href="#索引建立成哪种索引类型？" class="headerlink" title="索引建立成哪种索引类型？"></a>索引建立成哪种索引类型？</h4><p>根据数据引擎类型自动选择的索引类型；除开 innodb 引擎主键默认为聚簇索引 外。 innodb 的索引都采用的 B+TREE；myisam 则都采用的 B-TREE索引</p><h4 id="B-Tree与B-Tree-的区别？"><a href="#B-Tree与B-Tree-的区别？" class="headerlink" title="B+Tree与B-Tree 的区别？"></a>B+Tree与B-Tree 的区别？</h4><p>结论在内存有限的情况下，B+TREE 永远比 B-TREE好。无限内存则后者方便。</p><p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)<br>　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是<strong>减少磁盘访问次数</strong>。尽管B+树找到一个记录所需的比较次数要比B-树多，但是<strong>一次磁盘访问的时间相当于成百上千次内存比较的时间</strong>，因此实际中B+树的性能可能还会好些，<strong>而且B+树的叶子节点使用指针连接在一起，方便顺序遍历</strong>（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br>　<br>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p><ol><li>B+树的磁盘读写代价更低<br>　　<strong>B+树的内部结点并没有指向关键字具体信息的指针</strong>。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。<strong>相对来说IO读写次数也就降低了。</strong> </li><li>B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。<strong>所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</strong></li></ol><h3 id="4-使用索引但索引失效的场景（复合索引）"><a href="#4-使用索引但索引失效的场景（复合索引）" class="headerlink" title="4.使用索引但索引失效的场景（复合索引）"></a>4.使用索引但索引失效的场景（复合索引）</h3><h4 id="如何创建显示删除复合索引？"><a href="#如何创建显示删除复合索引？" class="headerlink" title="如何创建显示删除复合索引？"></a>如何创建显示删除复合索引？</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_id_name_age <span class="keyword">ON</span> <span class="string">`user`</span>(<span class="keyword">id</span>,<span class="keyword">name</span>,age)</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_id_name_age <span class="keyword">ON</span> <span class="string">`user`</span></span><br></pre></td></tr></table></figure><h4 id="EXPLAIN-是用来干什么的，怎么用？"><a href="#EXPLAIN-是用来干什么的，怎么用？" class="headerlink" title="EXPLAIN 是用来干什么的，怎么用？"></a>EXPLAIN 是用来干什么的，怎么用？</h4><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>能干什么：</p><ul><li>表的读取顺序</li><li>哪些索引可以使用</li><li>数据读取操作的操作类型</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>怎么样：</p><ul><li>Explain + SQL语句</li><li>执行计划包含的信息</li></ul><p><img data-src="https://i.loli.net/2020/11/24/U4dLfojQNkxAX7u.png" loading="lazy"></p><ul><li>id:  select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序;<strong>id相同，执行顺序由上至下;id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行;id相同不同，同时存在。</strong></li><li>select_type:  查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</li><li>table:  显示这一行的数据是关于哪张表的。</li><li>type:  type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是: system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL;一般来说，得保证查询至少达到range级别，最好能达到ref。</li><li>possible_keys:  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</li><li>key:  实际使用的索引。如果为NULL，则没有使用索引；查询中若使用了覆盖索引，则该索引和查询的select字段重叠</li><li>key_len:  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</li><li>ref:  显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</li><li>rows:  rows列显示MySQL认为它执行查询时必须检查的行数。越少越好</li><li>Extra:  包含不适合在其他列中显示但十分重要的额外信息</li></ul><p>Extra又包含：</p><ul><li><p><strong>Using filesort ：</strong> 说明mysql会对数据使用一个<strong>外部的索引排序</strong>，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。<strong>九死一生的,相当于是你在查找时从一楼直接让你上三楼，你自己只能自寻办法，不能走楼梯上去</strong></p></li><li><p><strong>Using temporary：</strong>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。<strong>十死无生的，相当于让你去二楼，然后没给你一楼，空中楼阁</strong></p></li><li><p><strong>USING index：</strong>表示相应的select操作中使用了**覆盖索引(Covering Index)**，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。比较好的！！</p><p>覆盖索引（Covering Index）也叫索引覆盖。理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。</p></li><li><p>Using where：表明使用了where过滤</p></li><li><p>using join buffer：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p></li><li><p>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p></li></ul><p>type又包含：<img data-src="https://i.loli.net/2020/11/24/rNUu1ex6acyA2I8.png" loading="lazy"></p><ul><li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li><li>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行；本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，<br>它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li><li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</li><li>all：Full Table Scan，将遍历全表以找到匹配的行</li></ul><p><strong>索引失效的场景</strong>：----------------------------------------------------------------------------------------------------------------------</p><p>最好的索引是全值索引，创建的索引都用到了（按序用的）</p><ol><li><strong>最佳左前缀法则：</strong>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。但是有前提条件：1. and 忽略左右关系。即使没有没有按顺序 由于优化器的存在，会自动优化。2. 建立索引CREATE INDEX idx_name_age ON <code>user</code>(name,age)，id为主键；<strong>当使用覆盖索引的方式时</strong>，(select name,age,id from <code>user</code> where age=23(后面没有其他没有索引的字段条件))，即使不是以 name 开头，也会使用 dx_name_age 索引。但是看rows 字段信息搜索的行数是全表的行数，type字段 是index。<strong>第二条是重点！！！</strong></li><li><strong>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</strong></li><li><strong>存储引擎不能使用索引中范围条件右边的列:</strong>  范围 若有索引则能使用到索引，范围条件右边的索引会失效,本身不会失效(范围条件右边与范围条件使用的同一个组合索引，右边的才会失效。若是不同索引则不会失效)</li><li>*<em>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select **</em></li><li><strong>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</strong>：使用 != 和 &lt;&gt; 的字段索引失效( != 针对数值类型。 &lt;&gt; 针对字符类型；前提 where and 后的字段在混合索引中的位置比当前字段靠后  where age != 10 and name=&#39;xxx&#39;  ,这种情况下，mysql自动优化，将 name=&#39;xxx&#39; 放在 age ！=10 之前，name 依然能使用索引。只是 age 的索引失效)</li><li><strong>is not null 也无法使用索引,但是is null是可以使用索引的</strong></li><li><strong>like以通配符开头(&#39;%abc...&#39;)，mysql索引失效会变成全表扫描的操作</strong>：like ‘%abc%’  type 类型会变成 all；like ‘abc%’  type 类型为 range ，算是范围，可以使用索引</li><li><strong>字符串不加单引号索引失效</strong>：底层进行转换使索引失效，使用了函数造成索引失效</li><li><strong>少用or,用它来连接时会索引失效</strong></li></ol>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="MySql" scheme="https://yuhaicheng.xyz/categories/MySql/"/>
    
    
    <category term="sql" scheme="https://yuhaicheng.xyz/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>linux下查看文件内容、实时查看</title>
    <link href="https://yuhaicheng.xyz/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B.html"/>
    <id>https://yuhaicheng.xyz/2020-11-24-linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E3%80%81%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B.html</id>
    <published>2020-11-24T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux下查看文件内容的命令"><a href="#Linux下查看文件内容的命令" class="headerlink" title="Linux下查看文件内容的命令"></a>Linux下查看文件内容的命令</h2><p>查看文件内容的命令：</p><p>cat   由第一行开始显示内容，并将所有内容输出</p><p>tac   从最后一行倒序显示内容，并将所有内容输出</p><p>more   根据窗口大小，一页一页的现实文件内容</p><p>less   和more类似，但其优点可以往前翻页，而且进行可以搜索字符</p><p>head   只显示头几行</p><p>tail   只显示最后几行</p><p>nl    类似于cat -n，显示时输出行号</p><p>tailf  类似于tail -f </p><h3 id="1-cat-与-tac"><a href="#1-cat-与-tac" class="headerlink" title="1.cat 与 tac"></a><strong>1.cat 与 tac</strong></h3><p>cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。但是cat并不常用，原因是当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。</p><p>cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</p><p>tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令也不常用。</p><p>tac语法：tac 文件名。</p><h3 id="2-more和less（常用）"><a href="#2-more和less（常用）" class="headerlink" title="2.more和less（常用）"></a>2.more和less（常用）</h3><p>more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</p><p>more的语法：more 文件名</p><p>Enter 向下n行，需要定义，默认为1行； </p><p>Ctrl f 向下滚动一屏； </p><p>空格键 向下滚动一屏； </p><p>Ctrl b 返回上一屏； </p><p>= 输出当前行的行号； </p><p>:f 输出文件名和当前行的行号； </p><p>v 调用vi编辑器； </p><p>! 命令 调用Shell，并执行命令； </p><p>q 退出more</p><p>less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</p><p>less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</p><p>less的语法：less 文件名</p><p>less还有一个功能，可以在文件中进行搜索你想找的内容，假设你想在passwd文件中查找有没有weblogic字符串，那么你可以这样来做：</p><p>[root@redhat etc]# less passwd</p><p>然后输入：</p><p>/weblogic</p><p>回车</p><p>此时如果有weblogic字符串，linux会把该字符已高亮方式显示。</p><p>退出查看页面，请按“q”键。</p><h3 id="3-head和tail"><a href="#3-head和tail" class="headerlink" title="3.head和tail"></a>3.head和tail</h3><p>head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</p><p>head的语法：head [n number] 文件名 (number 显示行数)</p><p>tail的功能恰好和head相反，只显示最后几行内容</p><p>tail的语法:tail [-n number] 文件名</p><h3 id="4-nl"><a href="#4-nl" class="headerlink" title="4.nl"></a>4.nl</h3><p>nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</p><p>nl的语法：nl 文件名 </p><h3 id="5-tailf"><a href="#5-tailf" class="headerlink" title="5.tailf"></a>5.tailf</h3><p>　tailf命令几乎等同于tail -f，严格说来应该与tail --follow=name更相似些。当文件改名之后它也能继续跟踪，特别适合于日志文件的跟踪（follow the growth of a log file）。与tail -f不同的是，如果文件不增长，它不会去访问磁盘文件（It is similar to tail -f but does not access the file when it is not growing. This has the side effect of not updating the access time for the file, so a filesystem flush does not occur periodically when no log activity is happening.）。tailf特别适合那些便携机上跟踪日志文件，因为它能省电，因为减少了磁盘访问嘛（tailf is extremely useful for monitoring log files on a laptop when logging is infrequent and the user desires that the hard disk spin down to conserve battery life.）。tailf命令不是个脚本，而是一个用C代码编译后的二进制执行文件，某些Linux安装之后没有这个命令，本文提供了怎么编译安装tailf命令的方法。</p><h2 id="面就谈谈二者的区别："><a href="#面就谈谈二者的区别：" class="headerlink" title="面就谈谈二者的区别："></a>面就谈谈二者的区别：</h2><ol><li><p>tailf 总是从文件开头一点一点的读， 而tail -f 则是从文件尾部开始读</p></li><li><p>tailf check文件增长时，使用的是文件名， 用stat系统调用；而tail -f 则使用的是已打开的文件描述符； 注：tail 也可以做到类似跟踪文件名的效果； 但是tail总是使用fstat系统调用，而不是stat系统调用；结果就是：默认情况下，当tail的文件被偷偷删除时，tail是不知道的，而tailf是知道的。</p><p>常用参数</p></li></ol><p>格式：tailf logfile</p><p>动态跟踪日志文件logfile，最初的时候打印文件的最后10行内容。</p><p>watch -n 1 aa.txt  #每个1秒显示aa.txt的内容</p><h3 id="Linux下实时显示文件内容"><a href="#Linux下实时显示文件内容" class="headerlink" title="Linux下实时显示文件内容"></a>Linux下实时显示文件内容</h3><ol><li><p> watch -n 1 aa.txt    #每个1秒显示aa.txt的内容</p></li><li><p>tail -f  ***.log</p></li></ol><p>Linux shell中有一个tail命令，常用来显示一个文件的最后n行文档内容</p><p>但更多情况下，我们要在服务器端运行程序，并且需要实时监控运行日志，这时候有什么办法实时滚动显示log文件内容？</p><p>这里可以利用tail命令加参数f实现，具体用法如下：</p><p>tail -f  ***.log</p><p>参数说明-f, --follow[={name|descriptor}]：output appended data as the file grows; -f, --follow, and --follow=descriptor are equivalent</p><p>用法：tail  (-10f)  test ：（-10f）可选，tail  -10f server.xml    </p><p>tail  (-10f)  test：中间-10f为可选，不输入该属性时，显示文件的全部内容；如-10f，显示当前文件的最后10行内容，10为显示文件的行数，可变，如果不输入中间参数例如10的时候，我们直接tail -f  server.xml查看实时内容。</p><p>tail其它参数运行 man tail 查看</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="linux" scheme="https://yuhaicheng.xyz/categories/linux/"/>
    
    
    <category term="linux下查看文件内容" scheme="https://yuhaicheng.xyz/tags/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://yuhaicheng.xyz/2020-11-24-redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
    <id>https://yuhaicheng.xyz/2020-11-24-redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</id>
    <published>2020-11-24T13:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Redis雪崩、穿透、击穿、并发等难题解决方案"><a href="#一、Redis雪崩、穿透、击穿、并发等难题解决方案" class="headerlink" title="一、Redis雪崩、穿透、击穿、并发等难题解决方案"></a>一、Redis雪崩、穿透、击穿、并发等难题解决方案</h1><p><strong>使用缓存的主要目是提升查询速度和减轻数据库压力。而缓存最常见的问题是缓存穿透、击穿和雪崩，在高并发下这三种情况都会有大量请求落到数据库，导致数据库资源占满，引起数据库故障。</strong></p><h2 id="1-缓存雪崩"><a href="#1-缓存雪崩" class="headerlink" title="1.缓存雪崩"></a>1.缓存雪崩</h2><p>定义：在高并发下，缓存（key）在同⼀时间内⼤⾯积的失效，所以后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。</p><p>雪崩过程：</p><ol><li>redis集群大面积故障</li><li>缓存失效，但依然大量请求访问缓存服务redis</li><li>redis大量失效后，大量请求转向到mysql数据库</li><li>mysql的调用量暴增，很快就扛不住了，甚至直接宕机</li><li>由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。</li></ol><p>解决办法：</p><ol><li>事前：①<strong>保证redis高可用</strong>，配置redis集群，如果发现有宕机的尽快补上；这种方案就是在发生雪崩前对缓存集群实现高可用，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。②选择合适的<strong>内存淘汰策略</strong>，让缓存失效的时间点尽量均匀。③<strong>数据预热</strong>，数据预热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中；在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li><li>事中：<strong>使用本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</strong>；使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster （集群）完全不可用的时候，ehcache 本地缓存还能够支撑一阵。使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。</li><li>事后：<strong>利⽤ redis 持久化机制保存的数据尽快恢复缓存</strong>；一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</li></ol><h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h2><p>定义：缓存穿透就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这⼀层，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。。</p><p>穿透过程：</p><ol><li>请求的key首先到达redis缓存中，发现不存在，访问数据库；如果是正常访问，存在就直接返回数据了。</li><li>然后请求到达数据库，然后数据库中还不存在，直接返回结果；如果存在则把数据缓存到redis中，并返回数据。</li></ol><blockquote><p>⼀般MySQL 默认的最⼤连接数在 150 左右，这个可以通过 show variables like &#39;%max_connections%&#39;;命令来查看。最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹络等⽆⼒条件都是其运⾏指标，这些指标都会限制其并发能⼒！所以，⼀般 3000 个并发请求就能打死⼤部分数据库了。</p></blockquote><p>解决办法：</p><p>最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的数据库 id 不能⼩于 0、传⼊的邮箱格式不正确的时候直接返回错误消息给客户端等等。</p><ol><li>缓存⽆效 key :  如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时间，具体命令如下： SET key value EX 10086。这种⽅式可以解决请求的 key 变化不频繁的情况，如果⿊客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存⼤量⽆效的 key 。很明显，这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key的过期时间设置短⼀点⽐如 1 分钟。另外，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。</li><li>布隆过滤器：布隆过滤器是⼀个⾮常神奇的<strong>数据结构</strong>，<strong>通过它我们可以⾮常⽅便地判断⼀个给定数据是否存在与海量数据中</strong>。我们需要的就是判断 key 是否合法，<strong>拦截对 不存在数据的请求</strong>。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会⾛下⾯的流程。<strong>使用：</strong>将数据库中所有的查询条件，放入布隆过滤器中，当一个查询请求过来时，先经过布隆过滤器进行查看，如果判断请求查询值存在，则继续查；如果判断请求查询不存在，直接丢弃。</li></ol><p>布隆过滤器这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</p><blockquote><h3 id="布隆过滤器的原理介绍"><a href="#布隆过滤器的原理介绍" class="headerlink" title="布隆过滤器的原理介绍"></a>布隆过滤器的原理介绍</h3><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p><p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><strong>应用场景</strong></p><ol><li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li><li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li></ol></blockquote><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>定义：在高并发下，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。会造成某一时刻数据库请求量过大，压力剧增。这种现象我们称为<strong>缓存击穿</strong>。</p><p>解决办法：</p><ol><li>使用锁，单机用synchronized,lock等，分布式用分布式锁：上<strong>面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它；其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</strong></li><li>缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。</li><li>在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。</li><li>设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存</li></ol><h2 id="4-Redis为什么时高并发的、快速的"><a href="#4-Redis为什么时高并发的、快速的" class="headerlink" title="4.Redis为什么时高并发的、快速的"></a>4.Redis为什么时高并发的、快速的</h2><p>1.redis是基于内存的，内存的读写速度非常快；</p><p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p><p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p><p>下面重点介绍单线程设计和IO多路复用核心设计快的原因。</p><p><strong>为什么Redis是单线程的？</strong></p><p><strong>1.官方答案</strong></p><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p><strong>2.性能指标</strong></p><p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p><strong>3.详细原因</strong></p><p><strong>1）不需要各种锁的性能消耗</strong></p><p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p><p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p><strong>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</strong></p><p><strong>2）单线程多进程集群方案</strong></p><p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p><strong>所以单线程、多进程的集群不失为一个好的解决方案。</strong></p><p><strong>3）CPU消耗</strong></p><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p><p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p><p>Redis单线程的优劣势</p><p><strong>单进程单线程优势</strong></p><ul><li>代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU</li></ul><p><strong>单进程单线程弊端</strong></p><ul><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li></ul><p><strong>IO多路复用技术</strong></p><p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p>多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p><strong>Redis高并发快总结</strong></p><ol><li><p>Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</p></li><li><p>再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</p></li><li><p>Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p></li><li><p>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p></li><li><p>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p></li></ol><blockquote><p>什么是上下⽂切换?<br>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。<br>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。<strong>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</strong></p></blockquote>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="redis" scheme="https://yuhaicheng.xyz/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis缓存中数据和数据库中数据不一致的解决办法</title>
    <link href="https://yuhaicheng.xyz/2020-11-24-redis%E7%BC%93%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html"/>
    <id>https://yuhaicheng.xyz/2020-11-24-redis%E7%BC%93%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</id>
    <published>2020-11-24T13:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会发生数据库和缓存数据的不一致问题。"><a href="#为什么会发生数据库和缓存数据的不一致问题。" class="headerlink" title="为什么会发生数据库和缓存数据的不一致问题。"></a>为什么会发生数据库和缓存数据的不一致问题。</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</p><h3 id="1-一性是什么，一致性包含了以下两种："><a href="#1-一性是什么，一致性包含了以下两种：" class="headerlink" title="1. 一性是什么，一致性包含了以下两种："></a>1. 一性是什么，一致性包含了以下两种：</h3><ol><li>缓存中有数据，那么数据库的数据必须要和缓存的数据要一致。</li><li>缓存中没有数据，在数据库值必须要是最新的数据。</li></ol><p>不符合以上两种情况的数据就是发生了数据不一致问题，对于读写缓存来说，就会发生这样的问题，此时我们要需要相应的策略去做做同步还是异步：</p><ol><li>同步写回策略：就是写入缓存时，必须要写入数据库，保证数据一致性。</li><li>异步写回策略：想写入缓存，等到缓存失效或者淘汰的时候，再写入数据库，此时如果还没有写入数据库，缓存就挂了，这样数据就会丢失，数据库就没有最新的值了。</li></ol><p>对于读写缓存来说，要想数据一致性就要采用同步写回策略，如果数据不是必要的数据，可以采用数据的异步写回策略，比如电商商品的非重要参数。<br>如果我们采用同步写回策略，就要保证写入缓存和数据的数据能到保证原子性，也就是说，缓存和数据的数据要同时增删改，一起更新或者都不更新。</p><h3 id="2-删除数据怎么保Redis和数据库的一致性问题"><a href="#2-删除数据怎么保Redis和数据库的一致性问题" class="headerlink" title="2. 删除数据怎么保Redis和数据库的一致性问题"></a>2. 删除数据怎么保Redis和数据库的一致性问题</h3><p>数据删除时，先选择删除数据库还是先选择缓存。 </p><h4 id="一、选择先删除数据库。"><a href="#一、选择先删除数据库。" class="headerlink" title="一、选择先删除数据库。"></a>一、选择先删除数据库。</h4><ol><li>当我们删除数据的时候，先选择删除数据库，后选择删除缓存时，会在一定事件内发生数据不一致问题，比如线程A和B还有其他，A在删除数据数据的时候，B和其他线程来读取数据，这个时候，B和其他线程会读取到旧值，当A线程删除完成删除缓存后就可以消除读取旧值问题。这个会造成一小段时间内会读取到旧值。</li><li>当我们删除数据的时候，先选择删除数据库，在删除缓存时，删除缓存失败了，会造成旧数据一直会读取。比如线程A和B还有其他，A在删除数据库成功了，A和其他线程删除缓存失败。就会造成B和其他线程一直在读取旧值。<strong>解决方法选择删除数据库的时候，通过消息中间件MQ或者Kafka发送一条删除指令，在数据库删除完成之后启动一个线程去删除缓存，如果删除失败一直做删除操作，一直到删除成功。</strong></li></ol><h4 id="二、选择先删除缓存。"><a href="#二、选择先删除缓存。" class="headerlink" title="二、选择先删除缓存。"></a>二、选择先删除缓存。</h4><ol><li>当我们删除数据的时候，先选择删除缓存，后选择删除数据库，会导致缓存出问题，比如线程A和B还有其他线程，A线程删除了缓存，还没有来及删除数据库（比如网络延迟），此时B和其他线程来读取消息，会发生缓存中没有数据，就会去数据库查询数据，数据库中的值还是以前的值，这样会造成缓存被重新更新为旧值，解决方法：<strong>可以使用缓存双删，可以把线程A休眠一段时间，这个时间是B线程读取数据被把数据写到缓存中的时间，这个时间还需要开发者在测试中找到比较准确的时间，来设置这个A线程的休眠时间。</strong></li><li>当我们删除数据的时候，先选择删除缓存，后选择删除数据库时删除失败了，这样会造成缓存数据一直在数据库没有被删除，导致一直读取的时旧值，<strong>这样可以通过消息中间件去操作，直到数据库更新成功，在去删除缓存，这样的实现用到了缓存双删和消息中间件。</strong></li></ol><h4 id="三，自我认为还是选择先删除数据库在去删缓存。"><a href="#三，自我认为还是选择先删除数据库在去删缓存。" class="headerlink" title="三，自我认为还是选择先删除数据库在去删缓存。"></a>三，自我认为还是选择先删除数据库在去删缓存。</h4><ol><li> 首先如果删除缓存，缓存缺失，会给数据库带来一定的压力。</li><li> 如果业务中读数据和写缓存的时间控制的不好设置，那么双删的等待时间就不好设置。</li></ol><h4 id="四，如果业务中必须要准确的数据，保证数据一致性。"><a href="#四，如果业务中必须要准确的数据，保证数据一致性。" class="headerlink" title="四，如果业务中必须要准确的数据，保证数据一致性。"></a>四，如果业务中必须要准确的数据，保证数据一致性。</h4><ol><li>当删除数据库的值时，其他客户端短暂把并发请求暂存，等数据库删除和缓存更新之后再去发起请求，从而保证数据的一致性。这样下来并发就减小了。</li></ol><h3 id="3-添加数据怎么保证Redis和数据库的一致性问题"><a href="#3-添加数据怎么保证Redis和数据库的一致性问题" class="headerlink" title="3. 添加数据怎么保证Redis和数据库的一致性问题"></a>3. 添加数据怎么保证Redis和数据库的一致性问题</h3><h4 id="一、选择先添加数据库。"><a href="#一、选择先添加数据库。" class="headerlink" title="一、选择先添加数据库。"></a>一、选择先添加数据库。</h4><ol><li>当把数据先添加数据库时，添加缓存的操作出了问题，下一次查询数据导致缓存中没有数据，对数据库的压力较大。</li></ol><h4 id="二、选择先添加缓存。"><a href="#二、选择先添加缓存。" class="headerlink" title="二、选择先添加缓存。"></a>二、选择先添加缓存。</h4><ol><li>当把数据先添加缓存时，添加数据库的操作出了问题，我们可以采用Mq或Kafka消息中间件发送添加指令，直到数据添加到数据库，则结束操作。</li></ol><h3 id="4-修改数据怎么保Redis和数据库的一致性问题"><a href="#4-修改数据怎么保Redis和数据库的一致性问题" class="headerlink" title="4. 修改数据怎么保Redis和数据库的一致性问题"></a>4. 修改数据怎么保Redis和数据库的一致性问题</h3><h4 id="一-选择先更新数据库，对于读写缓存的读写并发操作"><a href="#一-选择先更新数据库，对于读写缓存的读写并发操作" class="headerlink" title="一.选择先更新数据库，对于读写缓存的读写并发操作"></a>一.选择先更新数据库，对于读写缓存的读写并发操作</h4><ol><li>当先更新数据到新数据库时，数据库更新完毕后，在更新缓存，当缓存更新失败，会导致访问命中的缓存一直都是旧值，直到这个缓存失效或者淘汰，才能得到新的数据。</li><li>比如A和B其他线程，A线程更新数据库，数据库更新数据完毕后，更新缓存，当缓存更新失败，B和其他线程就会一直读取旧值，直到此数据失效或者淘汰之后，才能读取到新的值。</li></ol><h4 id="二-选择先更新缓存，对于读写缓存的读写并发操作"><a href="#二-选择先更新缓存，对于读写缓存的读写并发操作" class="headerlink" title="二.选择先更新缓存，对于读写缓存的读写并发操作"></a>二.选择先更新缓存，对于读写缓存的读写并发操作</h4><ol><li>当先更新数据到缓存，数据更新完毕之后，在更新数据库，此时数据库跟新失败，会导致访问命中的缓存是最新值，当数据失效或者淘汰之后再去读取数据，还是读取的数据库的旧值，这样数据就会不一致。比如A和B其他线程，A线程先去更新缓存的值时，更新数据库的值失败之后，B和其他线程读取的时最新的数据，等到数据失效，B和其他线程读取的值就是旧值。</li></ol><p>解决以上两种修改操作，我们可以利用消息中间件可以做到，当失败了一直等到数据一致，保证数据库能更新，和缓存数据能够写进去，和删除的效果是一致的。</p><h4 id="三-选择先更新数据库，对于读写缓存的写写并发操作"><a href="#三-选择先更新数据库，对于读写缓存的写写并发操作" class="headerlink" title="三.选择先更新数据库，对于读写缓存的写写并发操作"></a>三.选择先更新数据库，对于读写缓存的写写并发操作</h4><ol><li>当先更新数据到数据库时，有两个线程A和B线程时，当A线程去修改数据库，B线程也去修改数据库，B线程去修改缓存，A线程在去修改缓存，会造成数据不一致问题。</li></ol><h4 id="四-选择先更新缓存，对于读写缓存的写写并发操作"><a href="#四-选择先更新缓存，对于读写缓存的写写并发操作" class="headerlink" title="四.选择先更新缓存，对于读写缓存的写写并发操作"></a>四.选择先更新缓存，对于读写缓存的写写并发操作</h4><ol><li>当先更新数据到缓存时，有两个线程A和B线程时，当A线程去修改缓存，B线程也去修改缓存，B线程去修改数据库，A线程在去修改数据库，会造成数据不一致问题。</li></ol><p>解决以上两种方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。</p><p>综上使用读写缓存读写并发的时候，可以使用消息中间件来维护数据不一致问题，在读写模式下对业务造成的影响不是很大。当使用读写缓存写写并发的时候，可以使用加分布式锁来维护数据不一致问题。</p><p>另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。</p><h3 id="5-具体解决办法"><a href="#5-具体解决办法" class="headerlink" title="5.具体解决办法"></a>5.具体解决办法</h3><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。</p><p><strong>缓存和数据库一致性解决方案</strong></p><h4 id="第一种方案：采用延时双删策略（双淘汰策略）"><a href="#第一种方案：采用延时双删策略（双淘汰策略）" class="headerlink" title="第一种方案：采用延时双删策略（双淘汰策略）"></a><strong>第一种方案：采用延时双删策略（双淘汰策略）</strong></h4><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p><p><strong>1.具体的步骤就是：</strong></p><ol><li>先删除缓存</li><li>再写数据库</li><li>休眠（一定的时间）毫秒：</li><li>再次删除缓存</li></ol><p><strong>2.确定休眠时间</strong></p><p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保<strong>读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。</p><p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p><h5 id="3-设置缓存过期时间"><a href="#3-设置缓存过期时间" class="headerlink" title="3.设置缓存过期时间"></a>3.设置缓存过期时间</h5><p>从理论上来说，给<strong>缓存设置过期时间，是保证最终一致性的解决方案</strong>。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p><h5 id="4-该方案的弊端"><a href="#4-该方案的弊端" class="headerlink" title="4.该方案的弊端"></a>4.该方案的弊端</h5><p>结合<strong>双删策略+缓存超时</strong>设置，这样最差的情况就是在<strong>超时时间内数据存在不一致，而且又增加了写请求的耗时</strong>。</p><h4 id="第二种方案：异步更新缓存-基于订阅binlog的同步机制"><a href="#第二种方案：异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="第二种方案：异步更新缓存(基于订阅binlog的同步机制)"></a><strong>第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></h4><p><strong>技术整体思路：</strong></p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><p>1）读Redis：热数据基本都在Redis</p><p>2）写MySQL:增删改都是操作MySQL</p><p>3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis</p><p>3.1）数据操作主要分为两大块：</p><ul><li>一个是全量(将全部数据一次写入到redis)</li></ul><ul><li>一个是增量（实时更新）</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p>3.2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p><p>最后： 我的理解是多个线程的读或写操作都放进了队列，这样可以保证写库并且删了缓存之后再执行下一个线程的读操作，通过这种方式保证了操作的原子性，另外只要异步消息处理的足够快，那么是不会有问题的</p><h3 id="6-推荐解决方案"><a href="#6-推荐解决方案" class="headerlink" title="6.推荐解决方案"></a>6.推荐解决方案</h3><h4 id="一-解决不一致两种方法"><a href="#一-解决不一致两种方法" class="headerlink" title="一.解决不一致两种方法:"></a>一.解决不一致两种方法:</h4><ol><li><p>CAP理论(Cache Aside Pattern):<strong>缓存</strong>+<strong>数据库</strong>读写的模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</span><br><span class="line">2.更新的时候，先更新数据库，然后再删除缓存。</span><br></pre></td></tr></table></figure></li><li><p>读<strong>请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求</span><br></pre></td></tr></table></figure></li></ol><h4 id="二-CAP为什么是删除缓存，而不是更新缓存"><a href="#二-CAP为什么是删除缓存，而不是更新缓存" class="headerlink" title="二.CAP为什么是删除缓存，而不是更新缓存"></a>二.CAP为什么是删除缓存，而不是更新缓存</h4><p>原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p><p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p><p>另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？</p><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p><h4 id="三-CAP可能会出现上述的数据库-缓存不一致的情况"><a href="#三-CAP可能会出现上述的数据库-缓存不一致的情况" class="headerlink" title="三.CAP可能会出现上述的数据库+缓存不一致的情况"></a>三.CAP可能会出现上述的数据库+缓存不一致的情况</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了</p><h5 id="解决方案如下："><a href="#解决方案如下：" class="headerlink" title="解决方案如下："></a>解决方案如下：</h5><p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。</p><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个<strong>优化点</strong>，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><h5 id="高并发的场景下，该解决方案要注意的问题："><a href="#高并发的场景下，该解决方案要注意的问题：" class="headerlink" title="高并发的场景下，该解决方案要注意的问题："></a>高并发的场景下，该解决方案要注意的问题：</h5><ul><li><p>读请求长时阻塞<br>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p><p>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p><p>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每隔库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。</p><p>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p><p>如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。</p><p>其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p></li><li><p>读请求并发量过高<br>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p><p>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p></li><li><p>多服务实例部署的请求路由<br>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，<strong>都通过 Nginx 服务器路由到相同的服务实例上</strong>。<br>比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p></li><li><p>热点商品的路由问题，导致请求的倾斜<br>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p></li></ul>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="redis" scheme="https://yuhaicheng.xyz/categories/redis/"/>
    
    
    <category term="数据不一致" scheme="https://yuhaicheng.xyz/tags/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    
  </entry>
  
  <entry>
    <title>索引种类</title>
    <link href="https://yuhaicheng.xyz/2020-11-24%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB.html"/>
    <id>https://yuhaicheng.xyz/2020-11-24%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB.html</id>
    <published>2020-11-23T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="MySQL索引种类"><a href="#MySQL索引种类" class="headerlink" title="MySQL索引种类"></a>MySQL索引种类</h2><p>在 InnoDB 中，有聚簇索引和普通索引之分，聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，根据主键查询可以直接利用聚簇索引定位到所在记录。而普通索引根据申明这个索引时候的列来构建，叶子节点存放的是这一行记录对应的主键的值，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。如果我们查询一整行记录的话，一定要去聚簇索引上查找，而如果我们只需要根据普通索引查询主键的值，由于这些值在普通索引上已经存在，所以并不需要回表，这个称为索引覆盖，在一定程度上可以提高查询效率。</p><p>1.普通索引<br>2.唯一索引<br>3.主键索引<br>4.组合索引<br>5.全文索引</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a><strong>语句</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name[col_name data type]</span><br><span class="line">[unique|fulltext][index|key][index_name](col_name[length])[asc|desc]</span><br></pre></td></tr></table></figure><p>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引<br>2.index和key为同义词，两者作用相同，用来指定创建索引<br>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择<br>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值<br>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度<br>6.asc或desc指定升序或降序的索引值存储</p><p>1.普通索引<br>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p><p>（2）修改表结构的方式添加索引</p><p>（3）创建表的时候同时创建索引</p><p>2.唯一索引<br>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p><p>（2）修改表结构</p><p>（3）创建表的时候直接指定</p><p>3.主键索引<br>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</p><p>4.组合索引<br>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p><p>5.全文索引<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br>（1）创建表的适合添加全文索引</p><p>（2）修改表结构添加全文索引</p><p>（3）直接创建索引</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.虽然索引大大提高了查询速度，<strong>同时却会降低更新表的速度</strong>，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。</p><p>2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。</p><p>索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用索引时，有以下一些技巧和注意事项：</p><p>1.最佳左前缀法则</p><p>2.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一至）），减少select *</p><p>3.索引列排序</p><p>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><p>4.like语句操作<br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p><p>5.不要在列上进行运算（函数）<br>这将导致索引失效而进行全表扫描，例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE YEAR(column_name)&lt;2017;</span><br></pre></td></tr></table></figure><p>6.不使用！=和&lt;&gt;操作</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><strong>InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号。</strong>每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。</p><p>所谓的<code>MVCC（Multi-Version Concurrency Control ，多版本并发控制）</code>指的就是在使用<code>读已提交（READ COMMITTD）、可重复读（REPEATABLE READ）</code>这两种隔离级别的事务<strong>在执行普通的SELECT操作时访问记录的版本链的过程</strong>，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>这两个隔离级别的一个很大不同就是：<code>生成ReadView的时机不同</code>，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，数据的可重复读其实就是ReadView的重复使用。</p><p>这样去解释这些技术，主要是希望大家对现象背后的本质多点思考，不然你去背出这几种隔离级别，以及各种数据现象是没有任何意义的，实际开发过程中真的出现了问题，你不懂本质以及过程，你去排查也会很难受的，到头来还是要看书，看资料。</p><p><strong>在REPEATABLE READ的条件下：</strong></p><p>SELECT InnoDB会根据以下两个条件检查每行纪录：</p><ul><li>InnoDB只查找版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li><li>行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。 只有符合上述两个条件的纪录，才能作为查询结果返回。</li></ul><p>INSERT - InnoDB为插入的每一行保存当前系统版本号作为行版本号。</p><p>DELETE - InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p><p>UPDATE - InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时，保存当前系统版本号到原来的行作为行删除标识。</p><p>优点： 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好。</p><p>缺点： 每行纪录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p><p>读到这里，也许会有一个疑问，考虑如下执行序列：</p><p><img data-src="https://pic1.zhimg.com/80/v2-ed8058116c2d603a88c69209e795f490_720w.jpg" alt="img" loading="lazy"></p><p>按照之前的Select规则，会话B 的事务是在 会话A的后面开启的，那么B的事务版本号大于A的事务版本号。这样在A中插入的数据在未提交的情况下，B可以读到A修改的数据，这不就自相矛盾了么？其实不然，InnoDB每个事务在开始的时候，会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list）创建一个副本（read view），然后一致性读去比较记录的tx id的时候，并不是根据当前事务的tx id，而是根据read view最早一个事务的tx id（read view-&gt;up_limit_id）来做比较的，这样就能确保在事务B之前没有提交的所有事务的变更，B事务都是看不到的。如下图所示：</p><p><img data-src="https://pic3.zhimg.com/80/v2-f76b5721c5b6f4b2ecfaccf892db57be_720w.jpg" alt="img" loading="lazy"></p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="MySql" scheme="https://yuhaicheng.xyz/categories/MySql/"/>
    
    
    <category term="sql" scheme="https://yuhaicheng.xyz/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>某东实习一面</title>
    <link href="https://yuhaicheng.xyz/2020-11-20-%E6%9F%90%E4%B8%9C%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2.html"/>
    <id>https://yuhaicheng.xyz/2020-11-20-%E6%9F%90%E4%B8%9C%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2.html</id>
    <published>2020-11-20T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-谈谈Spring框架"><a href="#1-谈谈Spring框架" class="headerlink" title="1.谈谈Spring框架"></a>1.谈谈Spring框架</h4><p>Spring是一个优秀的轻量级框架，大大的提高了项目的开发管理与维护。spring的轻量级是是从它的大小和开销来说的，完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。3</p><p>Spring是非侵入式的,spring的api是不会出现在业务逻辑上出现的，对于应用而言，业务逻辑可以从当前应用剥离出来，实现复用，对于框架而言，业务逻辑也可以从spring框架中快速的移植到别的框架</p><p>spring提供容器功能，容器可以管理对象的生命周期，对象和对象之间的依赖关系等。通常我们都是可以写一个配置文件，在上面定义对象的名字等，在容器启动以后，这些对象就被实例化好了，我们可以直接去用。而且依赖关系也建立好了。</p><p>Spring有两个核心模块。一个是IOC，一个是AOP。</p><p>IOC:　就是控制反转的意思，指的是我们将对象的控制权从应用代码本身转移到外部容器。通过IOC容器在程序运行期间基于JAVA反射机制</p><p>动态的创建对象，配置对象，建立对象之间的依赖关系，管理对象的生命周期。<strong>而DI作为依赖注入，是实现IOC控制反转的一种手段。</strong>常见的依赖注入方式有:set方式注入、构造器方式注入、接口注入、注解注入。通过依赖注入在程序运行期间动态的注入依赖对象，建立对象之间的依赖关系，降低对象之间的耦合度。</p><p>AOP:面向切面编程，是对面向对象编程的补充。我们将通用的业务功能代码块封装起来作为切面，通过指定切入点，也就是指定切面作用的目标方法，</p><p>最后通过不同类型的通知，告诉容器在调用目标方法的什么时机插入切面代码块。像Spring的声明式事物管理就是基于AOP，在程序运行期间，通过动态代理技术给service层的bean追加事物管理，保证事物的ACID特性。我们可以通过AOP将一些任务单独封装，通过动态代理技术，在不改变原有代码的情况下追加功能，提高代码的复用和简化编程。</p><h4 id="2-bean的作用域"><a href="#2-bean的作用域" class="headerlink" title="2.bean的作用域"></a>2.bean的作用域</h4><p>Spring Bean 中所说的作用域，在配置文件中即是“<strong>scope</strong>”，在面向对象程序设计中<strong>作用域一般指对象或变量之间的可见范围。</strong></p><p>而在Spring容器中<strong>是指其创建的Bean对象相对于其他Bean对象的请求可见范围</strong>。</p><ul><li>singleton:  Spring的默认作用域，容器里拥有唯一的Bean实例</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>prototype：针对每个getBean请求，容器都会创建一个Bean实例</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; prototype &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>request：会为每个Http请求创建一个Bean实例,而且该Bean只在当前request内是有效的</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; request &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>session：会为每个session创建一个Bean实例,而且该Bean只在当前http session内是有效的。</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userInfo&quot; class=&quot;cn.lovepi.UserInfo&quot; scope=&quot; session &quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效.Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userInfo&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;cn.lovepi.UserInfo&quot;</span>scope=“globalSession<span class="string">&quot;&gt;&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-aop实现原理"><a href="#3-aop实现原理" class="headerlink" title="3.aop实现原理"></a>3.aop实现原理</h4><p>Spring采用的方式，通过动态代理的方式，实现简单（运行时织入）</p><h4 id="4-在你的项目中那个场景用到了aop"><a href="#4-在你的项目中那个场景用到了aop" class="headerlink" title="4.在你的项目中那个场景用到了aop"></a>4.在你的项目中那个场景用到了aop</h4><h4 id="5-常用的集合类，hashmap、hashtable区别"><a href="#5-常用的集合类，hashmap、hashtable区别" class="headerlink" title="5.常用的集合类，hashmap、hashtable区别"></a>5.常用的集合类，hashmap、hashtable区别</h4><h4 id="6-开发过程中常用的IO操作"><a href="#6-开发过程中常用的IO操作" class="headerlink" title="6.开发过程中常用的IO操作"></a>6.开发过程中常用的IO操作</h4><h4 id="7-左连接、右连接、内连接的区别"><a href="#7-左连接、右连接、内连接的区别" class="headerlink" title="7.左连接、右连接、内连接的区别"></a>7.左连接、右连接、内连接的区别</h4><h4 id="8-mysql的存储引擎都有哪些"><a href="#8-mysql的存储引擎都有哪些" class="headerlink" title="8.mysql的存储引擎都有哪些"></a>8.mysql的存储引擎都有哪些</h4><h4 id="9-INNODB下，行锁-情况下对每行进行updata-没有加where条件他锁的是什么-，或是加了where没有走索引会有什么问题"><a href="#9-INNODB下，行锁-情况下对每行进行updata-没有加where条件他锁的是什么-，或是加了where没有走索引会有什么问题" class="headerlink" title="9.INNODB下，行锁 情况下对每行进行updata 没有加where条件他锁的是什么 ，或是加了where没有走索引会有什么问题"></a>9.INNODB下，行锁 情况下对每行进行updata 没有加where条件他锁的是什么 ，或是加了where没有走索引会有什么问题</h4><h4 id="10-mybatis-和-的区别"><a href="#10-mybatis-和-的区别" class="headerlink" title="10.mybatis #{}和${}的区别"></a>10.mybatis #{}和${}的区别</h4><ul><li><p>${}是 Properties ⽂件中的变量占位符，它可以⽤于标签属性值和 sql 内部，属于静态⽂本替换，⽐如${driver}会被静态替换为 com.mysql.jdbc.Driver。</p></li><li><p>#{}是 sql 的参数占位符，mybatis在处理#{}时，会将sql中的#{}替换为 ?，调用PreparedStatement的set方法来赋值，按序给 sql 的?号占位符设置参数值；使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</p></li></ul><p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectPerson&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;hashmap&quot;&gt;</span><br><span class="line">  SELECT * FROM PERSON WHERE ID &#x3D; #&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：#{id}</p><p>这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 近似的 JDBC 代码，非 MyBatis 代码...</span><br><span class="line">String selectPerson &#x3D; &quot;SELECT * FROM PERSON WHERE ID &#x3D; ?&quot;;</span><br><span class="line">PreparedStatement ps &#x3D; conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(1,id);</span><br></pre></td></tr></table></figure><h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><strong>引用：</strong></h3><h4 id="什么是MySql注入"><a href="#什么是MySql注入" class="headerlink" title="什么是MySql注入"></a><strong>什么是MySql注入</strong></h4><blockquote><p>SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p></blockquote><p>简单说，就是我们在拼接sql的时候，没有过滤用户的非法sql，导致查询结果和我们预想的不一样。</p><p><strong>举个简单例子来帮助理解（实际开发中可能不存在这种简单的错误）</strong></p><p><strong>比如我们要根据用户名和密码进行登录，我们后台sql这样写</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = ? <span class="keyword">and</span> <span class="keyword">password</span> = ?</span><br></pre></td></tr></table></figure><p><strong>我们预想的：用户输入 username：张三，password：123456</strong></p><p><strong>但实际人家黑客这样输入： username：张三，password： &quot; or 1 = 1 --</strong></p><p><strong>根据黑客输入的参数，我们的sql将变成这样了</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = <span class="string">&quot;张三&quot;</span> <span class="keyword">and</span> <span class="keyword">password</span> = <span class="string">&quot;&quot;</span> <span class="keyword">or</span> <span class="number">1</span> = <span class="number">1</span> <span class="comment">-- &quot;</span></span><br></pre></td></tr></table></figure><p>后面这个 -- 就是注释，它注释了后面的其它内容，整个sql就变成下面这样，因为 or 1 = 1，所以怎么都会出结果</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = <span class="string">&quot;张三&quot;</span> <span class="keyword">and</span> <span class="keyword">password</span> = <span class="string">&quot;&quot;</span> <span class="keyword">or</span> <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当然了上面只是一个简单的sql注入，有人说实际开发中，我们根本不会这样去做。当然了实际情况中黑客也比我牛批一亿倍，这个例子是为了让你简单理解什么是sql注入。</p><h4 id="防止Sql注入攻击"><a href="#防止Sql注入攻击" class="headerlink" title="防止Sql注入攻击"></a>防止Sql注入攻击</h4><p><strong>1.（简单又有效的方法）PreparedStatement</strong></p><p> 采用预编译语句集，它内置了处理SQL注入的能力，只要使用它的setXXX方法传值即可。</p><p> 使用好处：</p><ol><li><p> 代码的可读性和可维护性.</p></li><li><p>PreparedStatement尽最大可能提高性能.</p></li><li><p>最重要的一点是极大地提高了安全性.</p><p>原理：</p><p>sql注入只对sql语句的准备(编译)过程有破坏作用</p><p>而PreparedStatement已经准备好了,执行阶段只是把输入串作为数据处理, 而不再对sql语句进行解析准备,因此也就避免了sql注入问题.</p></li></ol><p><strong>2.使用正则表达式过滤传入的参数</strong></p><p><strong>3.字符串过滤</strong></p><p><strong>4.jsp中调用该函数检查是否包函非法字符</strong></p><p> 防止SQL从URL注入：</p><p><strong>5.JSP页面判断代码：</strong></p><p> 使用<span class="exturl" data-url="aHR0cDovL2xpYi5jc2RuLm5ldC9iYXNlL2phdmFzY3JpcHQ=">JavaScript<i class="fa fa-external-link-alt"></i></span>在客户端进行不安全字符屏蔽</p><p> 功能介绍：检查是否含有”‘”,”\”,”/”</p><p> 参数说明：要检查的字符串</p><p> 返回值：0：是1：不是</p><p> 总的说来，防范一般的SQL注入只要在代码规范上下点功夫就可以了。</p><p> 凡涉及到执行的SQL中有变量时，用JDBC（或者其他数据持久层）提供的如：<strong>PreparedStatement</strong>就可以 ，切记不要用拼接字符串的方法就可以了。</p>]]></content>
    
    
    <summary type="html">电话面23min</summary>
    
    
    
    <category term="面试" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>深演智能一面视频</title>
    <link href="https://yuhaicheng.xyz/2020-11-20-%E6%B7%B1%E6%BC%94%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91.html"/>
    <id>https://yuhaicheng.xyz/2020-11-20-%E6%B7%B1%E6%BC%94%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91.html</id>
    <published>2020-11-20T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux 下查内存命令</p><p>jscri 中怎么用隐藏的标签（就是怎么把vlaue值隐藏）</p><p>spring 中事务在项目中怎么用的 配置文件了吗</p><p>mybatis 开启一级和二级缓存 怎么保证删除数据库中的文件后缓存中数据的一致性</p><p>怎么看自己项目的gc</p><p>怎么解决oom</p><p>linux 查看文件名称包含哪个字符串怎么查找</p><p>inux 下查剩余内存命令</p><p>数据库limit的使用</p><p>索引失效的举例</p>]]></content>
    
    
    <summary type="html">面试</summary>
    
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>某米一面视频面</title>
    <link href="https://yuhaicheng.xyz/2020-11-19-%E6%9F%90%E7%B1%B3%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91%E9%9D%A2.html"/>
    <id>https://yuhaicheng.xyz/2020-11-19-%E6%9F%90%E7%B1%B3%E4%B8%80%E9%9D%A2%E8%A7%86%E9%A2%91%E9%9D%A2.html</id>
    <published>2020-11-19T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>某米面试</p><p>视频面：</p><p>面试官网很卡，用的牛客视频面，上来就是两个算法题</p><p>然后介绍自己的项目，说说项目的难点及解决方案</p><p>讲一下Spring架构</p><p>面试官在面试过程中一再说明基础很重要，并且要有解决难点的能力，求支</p><p>多线程并发用到了哪种方式，线程之间的通信、同步一般怎么做</p><p>线程和进程通讯的区别</p><p>ArrayList、LinkedLIst区别</p><p>设计模式：观察者</p><p>堆、栈的区别</p><h3 id="1-讲一下Spring架构"><a href="#1-讲一下Spring架构" class="headerlink" title="1.讲一下Spring架构"></a>1.讲一下Spring架构</h3><p>轻量<br>框架的大小和运行开销都是轻量级的<br>Spring是非侵入式框架：应用中的对象不依赖于Spring框架中的类。</p><p>控制反转<br>通过IOC容器实现控制反转促进松耦合<br>将依赖关系的管理从Java对象中解放出来,交给IOC容器完成,实现对象之间的关系解耦<br>将原来对象-对象的个关系,转化为对象-IOC容器-对象的关系<br>依赖对象会被动的由容器实现装载，不需要对象自己完成创建</p><p>面向切面<br>通过AOP,以动态和非侵入式的方式来增强服务功能<br>应用的业务逻辑与系统级服务相分离,提高内聚性<br>应用对象只需实现业务逻辑即可,无需负责其他系统级关注点,例如日志和事务支持</p><p>容器<br>Spring的Bean容器,包含并管理应用对象的配置和生命周期<br>如:可配置bean如何被创建(单例,原型及类之间的依赖关系)</p><p>框架<br>Spring可以将简单的组件配置、组合成为复杂的应用。<br>例如:Spring中,对象可以在一个XML文件里被声明式的组合<br>例如:Spring框架下实现多个子框架的组合:<br>    这些子框架之间可以彼此独立，也可以使用其它的框架方案加以代替，<br>Spring提供了很多基础功能(如:事务管理、持久化框架集成等),而开发者只需要关注应用逻辑的开发</p><p>1、Spring Core：主要组件是BeanFactory，创建JavaBean的工厂，使用控制反转（IOC） 模式，将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p><p>2、Spring AOP：集成了面向切面的编程功能（AOP把一个业务流程分成几部分，例如权限检查、业务处理、日志记录，每个部分单独处理，然后把它们组装成完整的业务流程。每个部分被称为切面），可以将声明性事物管理集成到应用程序中。</p><p>3、Spring context：一个核心配置文件，为Spring框架提供上下文信息。</p><p>4、Spring dao：Spring操作数据库的模块。</p><p>5、Spring ORM：Spring集成了各种orm（object relationship mapping 对象关系映射）框架的模块，集成mybatis</p><p>6、Spring web：集成各种优秀的web层框架的模块（Struts、Springmvc）</p><p>7、Spring web mvc：Spring web层框架</p><h3 id="2-进程之间的通信"><a href="#2-进程之间的通信" class="headerlink" title="2.进程之间的通信"></a>2.进程之间的通信</h3><p>进程间通信又称<code>IPC(Inter-Process Communication)</code>,指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:</p><ul><li>低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)</li><li>高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等)。</li></ul><p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。</p><ol><li>管道/匿名管道(Pipes) ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。</li><li>有名管道(Names Pipes) : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘⽂件的⽅式存在，可以实现本机任意两个进程通信。</li><li>信号(Signal) ：信号是⼀种⽐较复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；</li><li>消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字 节流以及缓冲区⼤⼩受限等缺。</li><li>信号量(Semaphores) ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</li><li>共享内存(Shared memory) ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。</li><li>套接字(Sockets) : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持TCP/IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</li></ol><h3 id="3-线程之间的通信"><a href="#3-线程之间的通信" class="headerlink" title="3.线程之间的通信"></a>3.线程之间的通信</h3><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p><p><strong>① 锁机制</strong></p><p>互斥锁、条件变量、读写锁和自旋锁。</p><ul><li><code>互斥锁</code>确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。</li><li><code>读写锁</code>当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。</li><li><code>条件变量</code>可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li><li><code>自旋锁</code>上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。</li></ul><p><strong>② 信号量机制(Semaphore)</strong></p><p>包括无名线程信号量和命名线程信号量。线程的信号和进程的信号量类似，使用线程的信号量可以高效地完成基于线程的资源计数。信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。</p><p><strong>③ 信号机制(Signal)</strong></p><p>类似进程间的信号处理。</p><p><strong>④ violate全局变量-共享内存</strong></p><p>关于violate可以参考博文：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQvYXJ0aWNsZS9kZXRhaWxzLzg1MzE4MDc1">多线程并发之volatile的底层实现原理<i class="fa fa-external-link-alt"></i></span></p><p><strong>⑤ wait/notify</strong></p><p>阻塞/唤醒，关于这个参考博文：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0owODA2MjQvYXJ0aWNsZS9kZXRhaWxzLzUyNzAwNDEz">Thread入门与线程方法详解及多线程安全<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4.多线程"></a>4.多线程</h3><p><strong>01知识点汇总</strong></p><p><img data-src="https://pic2.zhimg.com/80/v2-65315ef1db4e1baa4720e095f6cca761_720w.png" alt="img" loading="lazy"></p><p>多线程协作时，因为对资源的锁定与等待会产生死锁，需要了解产生死锁的四个基本条件，要明白竞争条件与临界区的概念，知道通过破坏造成死锁的4个条件来防止死锁。</p><p>除了了解进程间的通信方式，还要知道线程的通信方式，通信主要指线程之间的协作机制，例如Wait、Notify</p><p>另外需要知道Java为多线程提供的一些机制，例如Threadlocal用来保存线程独享的数据，Fork/Foin机制用于大任务的分割与汇总，Volatile对多线程数据可见性的保证以及线程的中断机制。</p><p>其他还有: Threadlocal的实现机制。Fork/Join的工作窃取算法等内容。</p><p><strong>02</strong>知识点详解</p><p><strong>1、详解-线程的状态转换</strong></p><p>先介绍线程状态转换。</p><p>线程是Jvm执行任务的最小单元，理解线程的状态转换是理解后续多线程问题的基础。</p><p>第一个详解知识点介绍线程状态转换。</p><p>在Jvm运行中，线程一共有New、Runnable、Blocked、Waiting、Timed_waiting、Terminated六种状态，这些状态对应Thread.State枚举类中的状态。</p><p>当创建一个线程的时候，线程处在New状态，运行Thread的Start方法后，线程进入Runnable可运行状态。</p><p><img data-src="https://pic3.zhimg.com/80/v2-78af03b97e138fb44d14ce4ce273d21a_720w.png" alt="img" loading="lazy"></p><p>这个时候，所有可运行状态的线程并不能马上运行，而是需要先进入就绪状态等待线程调度，如图中间的Ready状态。在获取到Cpu后才能进入运行状态，如图中的Running。运行状态可以随着不同条件转换成除New以外的其他状态。</p><p>先看左边，在运行态中的线程进入Synchronized同步块或者同步方法时，如果获取锁失败，则会进入到Blocked状态。当获取到锁后，会从Blocked状态恢复到就绪状态。</p><p>再看右边，运行中的线程还会进入等待状态，这两个等待一个是有超时时间的等待，例如调用Object.wait、Thread.join等。另外一个时无超时的等待，例如调用Thread.join或者Locksupport.park。</p><p>这两种等待都可以通过Notify或Unpark结束等待状态恢复到就绪状态。</p><p>最后是线程运行完成结束时，如图下方，线程状态变成Terminated</p><p><strong>2、详解-CAS与ABA问题</strong></p><p>解决线程同步与互斥的主要方式是Cas、Synchronized、和Lock。</p><p>Cas是属于乐观锁的一种实现，是一种轻量级锁，Juc中很多工具类的实现就是基于Cas。</p><p>Cas操作是线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。</p><p>比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。</p><p>Cas容易出现Aba问题，如果线程T1读取值A之后，发生过两次写入，先由线程T2写回了b，又由T3写回了A，此时T1在写回比较时，值还是A，就无法判断是否发生过修改。</p><p>Aba问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳。Juc工具包中提供了这样的类。</p><p><strong>3、详解-Synchronized</strong></p><p>Synchronized是最常用的线程同步手段之一，它是如何保证同一时刻只有一个线程可以进入临界区呢？</p><p>我们知道Synchronized是对对象进行加锁，在Jvm中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向Monitor对象的起始地址。当Monitor被某个线程持有后，就会处于锁定状态，Owner部分会指向持有Monitor对象的线程。另外Monitor中还有两个队列，用来存放进入及等待获取锁的线程。</p><p>Synchronized应用在方法上时，在字节码中是通过方法的AccCC_Synchronized标志来实现的，Synchronized应用在同步块上时，在字节码中是通过Monitorenter和Monitorexit实现的。</p><p>针对Synchronized获取锁的方式，Jvm使用了锁升级的优化方式，就是先使用偏向锁优先同一线程再次获取锁，如果失败，就升级为Cas轻量级锁，如果再失败会短暂自旋，防止线程被系统挂起。最后如果以上都失败就是升级为重量级锁。</p><p><strong>4、详解-Aqs与Lock</strong></p><p>在介绍Lock前，先介绍Aqs，也就是队列同步器，这是实现Lock的基础。</p><p>Aqs有一个State标记位，值为1时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。</p><p>当获得锁的线程需要等待某个条件时，会进入Condition的等待队列，等待队列可以有多个。</p><p>当Condition条件满足时，线程会从等待队列重新进入到同步队列进行获取锁的竞争。</p><p>Reentrantlock就是基于Aqs实现的，Reentrantlock内部有公平锁和非公平锁两种实现，差别就在于新来的线程会不会比已经在同步队列中的等待线程更早获得锁。</p><p>和Reentrantlock实现方式类似，Semaphore也是基于aqs，差别在于Reentrantlock是独占锁，Semaphore是共享锁。</p><p><strong>5、详解-线程池</strong></p><p>线程池通过复用线程，避免线程频繁创建和销毁。</p><p>Java的Executors工具类中，提供了5种类型线程池的创建方法，它们的特点和适用场景如下：</p><p><strong>第1种是：固定大小线程池</strong>，特点是线程数固定，使用无界队列，适用于任务数量不均匀的场景、对内存压力不敏感，但系统负载比较敏感的场景；</p><p><strong>第2种是：Cached线程池</strong>，特点是不限制线程数，适用于要求低延迟的短期任务场景；</p><p><strong>第3种是：单线程线程池</strong>，也就是一个线程的固定线程池，适用于需要异步执行但需要保证任务顺序的场景；</p><p><strong>第4种是：Scheduled线程池</strong>，适用于定期执行任务场景，支持按固定频率定期执行和按固定延时定期执行两种方式；</p><p><strong>第5种是：工作窃取线程池</strong>，使用的ForkJoinPool，是固定并行度的多任务队列，适合任务执行时长不均匀的场景。</p><p><strong>6、详解-线程池参数介绍</strong></p><p>前面提到的线程池，除了工作窃取线程池外，都是通过ThreadPoolExecutor的不同初始化参数来创建的。</p><p><img data-src="https://pic3.zhimg.com/80/v2-19cb3e86c1812d7c1d98ac7b35e72956_720w.png" alt="img" loading="lazy"></p><p><strong>第1个参数：</strong>设置核心线程数。默认情况下核心线程会一直存活。</p><p><strong>第2个参数：</strong>设置最大线程数。决定线程池最多可以创建的多少线程。</p><p><strong>第3个参数和第4个参数：</strong>用来设置线程空闲时间，和空闲时间的单位，当线程闲置超过空闲时间就会被销毁。可以通过AllowCoreThreadTimeOut方法来允许核心线程被回收。</p><p><strong>第5个参数：</strong>设置缓冲队列，图中左下方的三个队列是设置线程池时常使用的缓冲队列。其中Array Blocking Queue是一个有界队列，就是指队列有最大容量限制。Linked Blocking Queue是无界队列，就是队列不限制容量。最后一个是Synchronous Queue，是一个同步队列，内部没有缓冲区。</p><p><strong>第6个参数：</strong>设置线程池工厂方法，线程工厂用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的Group、线程名、优先级等。一般使用默认工厂类即可。</p><p><strong>第7个参数：</strong>设置线程池满时的拒绝策略。如右下角所示有四种策略，abort策略在线程池满后，提交新任务时会抛出Rejected Execution Exception，这个也是默认的拒绝策略。</p><p>Discard策略会在提交失败时对任务直接进行丢弃。CallerRuns策略会在提交失败时，由提交任务的线程直接执行提交的任务。Discard Oldest策略会丢弃最早提交的任务。</p><p><strong>■前面的5种线程池都是使用怎样的参数来创建的呢？</strong></p><p>固定大小线程池创建时核心和最大线程数都设置成指定的线程数，这样线程池中就只会使用固定大小的线程数。队列使用无界队列Linked Blocking Queue。</p><p>Single线程池就是线程数设置为1的固定线程池。Cached线程池的核心线程数设置为0，最大线程数是Integer.Max_Value，主要是通过把缓冲队列设置成SynchronousQueue，这样只要没有空闲线程就会新建。scheduled线程池与前几种不同的是使用了Delayed Work Queue，这是一种按延迟时间获取任务的优先级队列。</p><p><strong>7、详解-线程池执行流程</strong></p><p>我们向线程提交任务时可以使用Execute和Submit，区别就是Submit可以返回一个Future对象，通过Future对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。Submit最终也是通过Execute执行的。</p><p><strong>线程池提交任务时的执行顺序如下：</strong></p><p>向线程池提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</p><ul><li>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</li><li>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</li><li>如果已经达到了最大线程数，则执行指定的拒绝策略。这里需要注意队列的判断与最大线程数判断的顺序，不要搞反。</li></ul><p><strong>8、详解-JUC工具类</strong></p><p>前面基础知识部分已经提到过，Juc是Java提供的用于多线程处理的工具类库，其中的常用工具类的作用如下：</p><p><img data-src="https://pic3.zhimg.com/80/v2-0eff7d812a12f5b88cfbd71652aa2222_720w.png" alt="img" loading="lazy"></p><p>第一行的类都是基本数据类型的原子类：包括Atomicboolean、Atomiclong、Atomicinteger类。</p><p>AtomicLong通过Unsafe类实现，基于Cas。Unsafe类是底层工具类，Juc中很多类的底层都使用到了Unsafe包中的功能。Unsafe类提供了类似C的指针操作，提供Cas等功能。Unsafe类中的所有方法都是Native修饰的；</p><p>另外Longadder等四个类是Jdk1.8中提供的更高效的操作类。LongAdder基于Cell实现，使用分段锁思想，是一种空间换时间的策略，更适合高并发场景；</p><p>LongAccumulator提供了比LongAdder更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。</p><p>第二行中的类提供了对对象的原子读写功能，后两个类Atomic Stamped Reference和Atomic Markable Reference是用来解决我们前面提到的Abs问题，分别基于时间戳和标记位来解决。</p><p><strong>9、详解-JUC2</strong></p><p><img data-src="https://pic3.zhimg.com/80/v2-be70189f84bf14ce5957080bf4903912_720w.png" alt="img" loading="lazy"></p><p>这一页表格中，第一行的类主要是锁相关的类，例如我们前面介绍过的Reentrant重入锁。<br>与Reentrant Lock的独占锁不同，Semaphore是共享锁，允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，例如100个车辆要使用20个停车位，那么最多允许20个车占用停车位。</p><p>Stamped Lock是1.8改进的读写锁，是使用一种Clh的乐观锁，能够有效防止写饥饿。所谓写饥饿就是在多线程读写时，读线程访问非常频繁，导致总是有读线程占用资源，写线程很难加上写锁。</p><p>第二行中主要是异步执行相关的类，这里可以重点了解jdk1.8中提供的CompletableFuture，可以支持流式调用，可以方便的进行多Future的组合使用，例如可以同时执行两个异步任务，然后对执行结果进行合并处理。还可以很方便的设置完成时间。</p><p>另外一个是1.7中提供的ForkJoinPool，采用分治思想，将大任务分解成多个小任务处理，然后在合并处理结果。ForkJoinPool的特点是使用工作窃取算法，可以有效平衡多任务时间长短不一的场景。</p><p><strong>10、详情-JUC3</strong></p><p><img data-src="https://pic4.zhimg.com/80/v2-251dd271af2975a82836d6c64cb26e87_720w.png" alt="img" loading="lazy"></p><p>表格中第一行是常用的阻塞队列，刚才讲解线程池时已经简单介绍过了，这里在补充一点，Linked Blocking Deque是双端队列，也就是可以分别从队头和队尾操作入队、出队。<br>而Array Blocking Queue单端队列，只能从队尾入队，队头出队。</p><p>第二行是控制多线程协作时使用的类。其中Count Down Latch实现计数器功能，可以用来控制等待多个线程执行任务后进行汇总。</p><p>Cyclic Barrier可以让一组线程等待至某个状态之后，再全部同时执行，一般在测试时使用，可以让多线程更好的并发执行。</p><p>Semaphore前面已经介绍过，用来控制对共享资源的访问并发度。</p><p>最后一行是比较常用的两个集合类，可以了解一下Copy On Write ArrayList，Cow通过在写入数据时进行Copy修改，然后在更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。</p><p><strong>03面试考察点</strong></p><p><strong>第1点：</strong>是要理解线程的同步与互斥的原理，包括临界资源、临界区的概念，知道重量级锁、轻量级锁、自旋锁、偏向锁、重入锁、读写锁的概念。</p><p><strong>第2点：</strong>要掌握线程安全相关机制，例如 Cas、Synchronized、Lock三种同步方式的实现原理、要明白Threadlocal是每个线程独享的局部变量，了解Threadlocal使用弱引用的ThreadLocalMap保存不同的Threadlocal变量。</p><p><strong>第3点：</strong>要了解Juc中的工具类的使用场景与主要的几种工具类的实现原理，例如Reentrantlock，Concurrenthashmap、Longadder等实现方式</p><p><strong>第4点：</strong>要熟悉线程池的原理、使用场景、常用配置，例如大量短期任务的场景适合使用Cached线程池；系统资源比较紧张时，可以选择固定线程池。</p><p>另外注意慎用无界队列，可能会有Oom的风险。</p><p><strong>第5点：</strong>要深刻理解线程的同步与异步、阻塞与非阻塞，同步和异步的区别是任务是否是同一个线程执行，阻塞与非阻塞的区别是异步执行任务时，线程是不是会阻塞等待结果，还是会继续执行后续逻辑。</p><p><strong>04面试加分项</strong></p><p>掌握了上面这些内容，如果能做到这几点加分项，一定会给面试官留下更好的印象。</p><p><strong>第1点：</strong>是可以结合实际项目经验或者实际案例介绍原理，例如介绍线程池设置时，可以提到自己的项目中有一个需要高吞吐量的场景，使用了Cached的线程池。</p><p><strong>第2点：</strong>如果有过解决多线程问题的经验或者排查思路的话会获得面试加分</p><p><strong>第3点：</strong>能够熟悉常用的线程分析工具与方法，例如会用Jstack分析线程的运行状态，查找锁对象持有状况等</p><p><strong>第4点：</strong>了解Java8对Juc工具类做了哪些增强，例如提供了Longadder来替换Atomiclong，更适合并发度比较高的场景。</p><p><strong>最后，</strong>可以了解一下Reactive异步编程思想，了解Back Pressure背压的概念与应用场景。</p><p>相信研究完以上内容，你会对并发与多线程有一定了解，从容准备面试，祝你拿到心仪Offer。</p><h3 id="5-堆栈区别"><a href="#5-堆栈区别" class="headerlink" title="5.堆栈区别"></a>5.堆栈区别</h3><p> Java把内存划分成两种：一种是堆内存，一种是栈内存。</p><p>堆：主要用于存储实例化的对象，数组。由JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以共享数据的。</p><p>栈：主要用于存储局部变量和对象的引用变量，每个线程都会有一个独立的栈空间，所以线程之间是不共享数据的。</p><p>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><p>堆内存用来存放由new创建的对象和数组。  在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><p>二、栈与堆的共同点和优缺点</p><p>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p><p>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>Java中的数据类型有两种。</p><p>一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。</p><p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。</p><p>假设我们同时定义<br> int a = 3; int b = 3；<br> 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。<br> 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p><p>另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显式地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p><p>三、Java堆和栈的区别</p><p>java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别</p><p>1、各司其职<br> 最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p><p>2、独有还是共享<br> 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p><p>3、异常错误<br> 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br> 而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p><p>4、空间大小<br> 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。</p><p>你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。</p><p>这就是Java中堆和栈的区别。理解好这个问题的话，可以对你解决开发中的问题，分析堆内存和栈内存使用，甚至性能调优都有帮助。</p><p>四、JVM中的堆和栈<br> JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. 从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p><p>每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程 共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。<br> Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java <img data-src="https://img.javatt.com/18/184543bd25712d1e8ed8fc46149fb7b5.png" alt="这里写图片描述" loading="lazy"></p><p>会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;某米面试&lt;/p&gt;
&lt;p&gt;视频面：&lt;/p&gt;
&lt;p&gt;面试官网很卡，用的牛客视频面，上来就是两个算法题&lt;/p&gt;
&lt;p&gt;然后介绍自己的项目，说说项目的难点及解决方案&lt;/p&gt;
&lt;p&gt;讲一下Spring架构&lt;/p&gt;
&lt;p&gt;面试官在面试过程中一再说明基础很重要，并且要有解决难点的能力，求</summary>
      
    
    
    
    <category term="面试" scheme="https://yuhaicheng.xyz/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="java" scheme="https://yuhaicheng.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器</title>
    <link href="https://yuhaicheng.xyz/2020-11-18-JUC%E5%AE%B9%E5%99%A8.html"/>
    <id>https://yuhaicheng.xyz/2020-11-18-JUC%E5%AE%B9%E5%99%A8.html</id>
    <published>2020-11-18T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>juc</code>是java中<code>java.util.concurrent</code>包的简称.这个包里面的东西就是<code>Doug Lea</code>写的,它主要包括<code>atomic</code>支持原子操作类相关代码,<code>locks</code>java中锁相关代码,还有其他并发容器相关代码.</p><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>这个包里面提供了许多支持原子相关操作类的代码,例如:<code>AtomicBoolean</code>,<code>AtomicInteger</code>...等等.这些类就是通过<code>CAS</code>来提供原子操作支持的.</p><h2 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h2><p>这个包主要提供了很多java中的锁.例如:<code>ReentrantLock</code>,<code>ReentrantReadWriteLock</code>...等等.这些类就是通过<code>AQS</code>来实现的.</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在<code>java.util.concurrent</code>下的其他类主要提供了并发容器相关类,例如:<code>ConcurrentHashMap</code>,<code>ConcurrentLinkedQueue</code>...等等相关类.还有线程池相关类,例如:<code>ThreadPoolExecutor</code>,<code>ScheduledThreadPoolExecutor</code>...等等.</p><p>CopyOnWriteArrayList，底层使用到了重入锁，在写的时候加锁，在读的时候不加锁。写的时候复制一份要操作的数组，之后再设置回去。而这个数组用volatile保证内存可见性。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="JUC" scheme="https://yuhaicheng.xyz/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Spring 原理</title>
    <link href="https://yuhaicheng.xyz/2020-11-18-Spring-%E5%8E%9F%E7%90%86.html"/>
    <id>https://yuhaicheng.xyz/2020-11-18-Spring-%E5%8E%9F%E7%90%86.html</id>
    <published>2020-11-18T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是Spring-Bean类"><a href="#1、什么是Spring-Bean类" class="headerlink" title="1、什么是Spring Bean类"></a><strong>1、什么是Spring Bean类</strong></h3><p>Spring Bean是事物处理组件类和实体类（POJO）对象的总称，Spring Bean被Spring IOC容器初始化，装配和管理。</p><h3 id="2、Bean类的配置项"><a href="#2、Bean类的配置项" class="headerlink" title="2、Bean类的配置项"></a><strong>2、Bean类的配置项</strong></h3><p>Spring IOC容器管理Bean时，需要了解Bean的类名、名称、依赖项、属性、生命周期及作用域等信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。</p><ul><li>① class: 该配置项是强制项，用于指定创建Bean实例的Bean类的路径。</li><li>② name: 该配置项是强制项，用于指定Bean唯一的标识符，在基于 XML 的配置项中，可以使用 id和或 name 属性来指定 Bean唯一 标识符。</li><li>③ scope: 该配置项是可选项，用于设定创建Bean对象的作用域。</li><li>④ constructor-arg: 该配置项是可选项，用于<strong>指定通过构造函数注入依赖数据到Bean</strong>。</li><li>⑤ properties: 该配置项是可选项，用于<strong>指定通过set方法注入依赖数据到Bean</strong>。</li><li>⑥ autowiring mode: 该配置项是可选项，用于<strong>指定通过自动依赖方法注入依赖数据到Bean</strong>。</li><li>⑦ lazy-initialization mode: 该配置项是可选项，用于<strong>指定IOC容器延迟创建Bean</strong>，在用户请求时创建Bean，而不要在启动时就创建Bean。</li><li>⑧ initialization: 该配置项是可选项，用于<strong>指定IOC容器完成Bean必要的创建后，调用Bean类提供的回调方法对Bean实例进一步处理</strong>。</li><li>⑨ destruction: 该配置项是可选项，用于<strong>指定IOC容器在销毁Bean时，调用Bean类提供的回调方法</strong>。</li></ul><p><strong>3、将Bean类添加到Spring IOC容器</strong></p><p>将Bean类添加到Spring IOC容器有三种方式。</p><ul><li>一种方式是基于XML的配置文件；</li><li>一种方式是基于注解的配置；</li><li>一种方式是基于Java的配置。</li></ul><p>下面主要介绍基于XML的配置方式，基于注解和基于Java的配置放在后面进行讨论，放在后面讨论的原因是一些其它重要的Spring概念还需要掌握。</p><p><strong>（1）XML配置文件的创建与存储</strong></p><p><strong>（2）Spring配置文件的加载</strong></p><p>加载Spring的配置文件有多种方式，比较常用的是在web.xml加载配置文件。</p><p>① 使用ContextLoaderListener加载配置文件</p><p>ContextLoaderListener类在启动Web容器时，自动加载Spring applicationContext.xml的配置信息。</p><p>② 加载自命名的配置文件</p><p>③ 通过配置目录加载配置文件</p><p><strong>（3）在Spring配置文件中定义Bean</strong></p><p><bean>标签用于定义Bean，各属性说明如下：</p><p>① id：Bean的唯一标识，ApplicationContext对象可以通过id获取该Bean的实例。</p><p>② calss：Bean类的存储路径。</p><p><property>标签用于从外部注入Bean的属性值， <property>标签各属性说明如下：</p><p>① name：Bean类的属性名称。</p><p>② value：name所值属性的值。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="框架" scheme="https://yuhaicheng.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://yuhaicheng.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot原理（启动机制）</title>
    <link href="https://yuhaicheng.xyz/2020-11-18-Spring%20Boot%E5%8E%9F%E7%90%86%EF%BC%88%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%EF%BC%89.html"/>
    <id>https://yuhaicheng.xyz/2020-11-18-Spring%20Boot%E5%8E%9F%E7%90%86%EF%BC%88%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%EF%BC%89.html</id>
    <published>2020-11-18T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们搭建一个基于spring的web应用，我们需要做以下工作：</p><p>1、pom文件中引入相关jar包，包括spring、springmvc、redis、mybaits、log4j、mysql-connector-java 等等相关jar ...</p><p>2、配置web.xml，Listener配置、Filter配置、Servlet配置、log4j配置、error配置 ...</p><p>3、配置数据库连接、配置spring事务</p><p>4、配置视图解析器</p><p>5、开启注解、自动扫描功能</p><p>6、配置完成后部署tomcat、启动调试</p><p>......</p><p>搭个初始项目不一会就一个小时甚至半天过去了。而用springboot后，一切都变得很简便快速。下来我们来一步步分析springboot的起步依赖与自动配置这两个核心原理。</p><h3 id="启动依赖："><a href="#启动依赖：" class="headerlink" title="启动依赖："></a>启动依赖：</h3><p>在springboot中我们只需要引入下面简单的几步就可以完成一个ssm后台项目的初始搭建。</p><p>1、引入jar</p><ul><li>spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，</li><li>mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。</li><li>spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。</li></ul><p>2、配置数据源（yml文件）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">     url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/mybatis_test</span></span><br><span class="line">     username: root</span><br><span class="line">     password: root</span><br><span class="line">     driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">     type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">     dbcp2:</span><br><span class="line">       min-idle: <span class="number">5</span></span><br><span class="line">       initial-size: <span class="number">5</span></span><br><span class="line">       max-total: <span class="number">5</span></span><br><span class="line">       max-wait-millis: <span class="number">200</span></span><br></pre></td></tr></table></figure><p>stater机制帮我们完成了项目起步所需要的的相关jar包。那问题又来了，传统的spring应用中不是要在application.xml中配置很多bean的吗，比如dataSource的配置，transactionManager（事务管理器）的配置 ... springboot是如何帮我们完成这些bean的配置的？下面我们来分析这个过程</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><h4 id="基于java代码的bean配置"><a href="#基于java代码的bean配置" class="headerlink" title="基于java代码的bean配置"></a>基于java代码的bean配置</h4><p>以<strong>mybatis</strong>为例，我们发下mybatis-spring-boot-starter这个包帮我们引入了mybatis-spring-boot-autoconfigure这个包，里面有<strong>MybatisAutoConfiguration</strong>这个类，打开这个类看看有什么东西。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MybatisProperties properties;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor[] interceptors;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DatabaseIdProvider databaseIdProvider;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ConfigurationCustomizer&gt; configurationCustomizers;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MybatisAutoConfiguration</span><span class="params">(MybatisProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ResourceLoader resourceLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = interceptorsProvider.getIfAvailable();</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="keyword">this</span>.databaseIdProvider = databaseIdProvider.getIfAvailable();</span><br><span class="line">    <span class="keyword">this</span>.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConfigFileExists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(<span class="keyword">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">      Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(<span class="keyword">this</span>.properties.getConfigLocation());</span><br><span class="line">      Assert.state(resource.exists(), <span class="string">&quot;Cannot find config location: &quot;</span> + resource</span><br><span class="line">          + <span class="string">&quot; (please add config file or check your Mybatis configuration)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean factory = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>里面主要就是这两个注解 @Configuration、@Bean</p><p>@Configuration、@Bean这两个注解一起使用就可以创建一个基于java代码的配置类，可以用来替代相应的xml配置文件。</p><p>@Configuration注解的类可以看作是能<strong>生产让Spring IoC容器管理的Bean实例的工厂。</strong></p><p>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到spring容器中。</p><p><strong>传统的基于xml的bean配置方法如下：</strong></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;  </span><br><span class="line">    &lt;bean id = <span class="string">&quot;car&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itpsc.Car&quot;</span>&gt;  </span><br><span class="line">        &lt;property name=&quot;wheel&quot; ref = &quot;wheel&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">    &lt;bean id = &quot;wheel&quot; class=&quot;com.itpsc.Wheel&quot;&gt;&lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>相当于用基于java代码的配置方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Conf</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Car car = <span class="keyword">new</span> Car();  </span><br><span class="line">        car.setWheel(wheel());  </span><br><span class="line">        <span class="keyword">return</span> car;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Bean</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wheel <span class="title">wheel</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheel();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以上面的MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。</p><h4 id="自动配置条件依赖"><a href="#自动配置条件依赖" class="headerlink" title="自动配置条件依赖"></a>自动配置条件依赖</h4><p>从MybatisAutoConfiguration这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span><br><span class="line">@ConditionalOnBean(&#123;DataSource.class&#125;)</span><br><span class="line">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span><br><span class="line">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line">public class MybatisAutoConfiguration &#123;</span><br><span class="line">//....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是springboot特有的，常见的条件依赖注解有：</p><ul><li>@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。</li><li>@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。</li><li>@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。</li><li>@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。</li><li>@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。</li><li>@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。</li><li>@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。</li><li>@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。</li></ul><p>所以要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。</p><p>进入DataSourceAutoConfiguration这个类，可以看到这个类属于这个包：org.springframework.boot.autoconfigure.jdbc</p><p>这个包又属于spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包，自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。很多包需要我们引入相应jar后自动配置才生效。</p><h4 id="bean参数获取"><a href="#bean参数获取" class="headerlink" title="bean参数获取"></a><strong>bean参数获取</strong></h4><p>到此我们已经知道了bean的配置过程，但是还没有看到springboot是如何读取yml或者properites配置文件的的属性来创建数据源的？</p><p>在DataSourceAutoConfiguration类里面，我们注意到使用了EnableConfigurationProperties这个注解。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span><br><span class="line">@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)</span><br><span class="line">@EnableConfigurationProperties(DataSourceProperties.class)</span><br><span class="line">@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</span><br><span class="line">public class DataSourceAutoConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSourceProperties中封装了数据源的各个属性，且使用了注解ConfigurationProperties指定了配置文件的前缀。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> generateUniqueName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String jndiName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@EnableConfigurationProperties与@ConfigurationProperties这两个注解又有什么用呢？</strong></p><p>@ConfigurationProperties注解的作用是把yml或者properties配置文件转化为bean。</p><p>@EnableConfigurationProperties注解的作用是使@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。</p><p><strong>通过这种方式，把yml或者properties配置参数转化为bean，这些bean又是如何被发现与加载的？</strong></p><h4 id="bean发现"><a href="#bean发现" class="headerlink" title="bean发现"></a>bean发现</h4><p>springboot默认扫描启动类所在的包下的主类与子类的所有组件，但并没有包括依赖包的中的类，那么依赖包中的bean是如何被发现和加载的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;nameGenerator&quot;)</span></span><br><span class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>我们通常在启动类中加@SpringBootApplication这个注解</strong></p><p>实际上重要的只有三个Annotation（注解）：</p><ul><li>@Configuration（@SpringBootConfiguration里面还是应用了@Configuration）</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>@Configuration的作用上面我们已经知道了，被注解的类将成为一个bean配置类。</p><p>@ComponentScan的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。</p><p>@EnableAutoConfiguration 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableAutoConfiguration注解引入了@AutoConfigurationPackage和@Import这两个注解。</p><p>@AutoConfigurationPackage的作用就是自动配置的包，@Import导入需要自动配置的组件。</p><p>进入@AutoConfigurationPackage，发现也是引入了@Import注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    </span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImports(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new PackageImports(metadata).getPackageNames().toArray(new String[0])</p><p>new PackageImports(metadata)</p><p>这两句代码的作用就是加载启动类所在的包下的主类与子类的所有组件注册到spring容器，这就是前文所说的springboot默认扫描启动类所在的包下的主类与子类的所有组件。</p><p><strong>那问题又来了，要搜集并注册到spring容器的那些beans来自哪里？</strong></p><p>进入 AutoConfigurationImportSelector类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(AutoConfigurationImportSelector.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE = <span class="string">&quot;spring.autoconfigure.exclude&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"><span class="keyword">private</span> ClassLoader beanClassLoader;</span><br><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"><span class="keyword">private</span> ConfigurationClassFilter configurationClassFilter;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());<span class="comment">//调用</span></span><br><span class="line">Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportFilter&gt; <span class="title">getAutoConfigurationImportFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportListener&gt; <span class="title">getAutoConfigurationImportListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>SpringFactoriesLoader.loadFactoryNames方法调用loadSpringFactories方法从所有的jar包中读取META-INF/spring.factories文件信息。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">       Map&lt;String, List&lt;String&gt;&gt; result = (Map)cache.get(classLoader);</span><br><span class="line">       <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           HashMap result = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Enumeration urls = classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                   URL url = (URL)urls.nextElement();</span><br><span class="line">                   UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                   Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                   Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                       Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                       String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                       String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                       String[] var10 = factoryImplementationNames;</span><br><span class="line">                       <span class="keyword">int</span> var11 = factoryImplementationNames.length;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">for</span>(<span class="keyword">int</span> var12 = <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">                           String factoryImplementationName = var10[var12];</span><br><span class="line">                           ((List)result.computeIfAbsent(factoryTypeName, (key) -&gt; &#123;</span><br><span class="line">                               <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">                           &#125;)).add(factoryImplementationName.trim());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               result.replaceAll((factoryType, implementations) -&gt; &#123;</span><br><span class="line">                   <span class="keyword">return</span> (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));</span><br><span class="line">               &#125;);</span><br><span class="line">               cache.put(classLoader, result);</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var14);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是spring-boot-autoconfigure这个jar中spring.factories文件部分内容，其中有一个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值定义了需要自动配置的bean，通过读取这个配置获取一组@Configuration类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>每个xxxAutoConfiguration都是一个基于java的bean配置类。实际上，这些xxxAutoConfiguratio不是所有都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static &lt;T&gt; T instantiateFactory(String instanceClassName, Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class ex &#x3D; ClassUtils.forName(instanceClassName, classLoader);</span><br><span class="line">            if(!factoryClass.isAssignableFrom(ex)) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Class [&quot; + instanceClassName + &quot;] is not assignable to [&quot; + factoryClass.getName() + &quot;]&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return ReflectionUtils.accessibleConstructor(ex, new Class[0]).newInstance(new Object[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to instantiate factory class: &quot; + factoryClass.getName(), var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 如上代码段，通过反射机制将spring.factories中@Configuration类实例化为对应的java实列。到此我们已经知道怎么发现要自动配置的bean了，最后一步就是怎么样将这些bean加载到spring容器。</p><h4 id="bean加载"><a href="#bean加载" class="headerlink" title="bean加载"></a>bean加载</h4><p>如果要让一个普通类交给Spring容器管理，通常有以下方法：</p><p>1、使用 @Configuration与@Bean 注解</p><p>2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描</p><p>3、使用@Import 方法</p><p>springboot中使用了@Import 方法</p><p>@EnableAutoConfiguration注解中使用了@Import({AutoConfigurationImportSelector.class})注解，AutoConfigurationImportSelector实现了DeferredImportSelector接口，</p><p>DeferredImportSelector接口继承了ImportSelector接口，ImportSelector接口有一个selectImports方法。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;String&gt; <span class="title">getExclusionFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们先通过一个简单例子看看@Import注解是如何将bean导入到spring容器的。</p><p>1、新建一个bean</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">private String phone;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、创建一个ItpscSelector类继承ImportSelector接口并实现selectImports方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ItpscSelector implements ImportSelector &#123;</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.itpsc.entity.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、创建ImportConfig类，使用@Configuration、@Import(ItpscSelector.class)注解。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(ItpscSelector.class)</span><br><span class="line">public class ImportConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、从容器获取bean</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ImportSelectorTests &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectImport() &#123;</span><br><span class="line">        ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(ImportConfig.class);</span><br><span class="line">        String[] beanDefinitionNames &#x3D; ctx.getBeanDefinitionNames();</span><br><span class="line">        for (String name : beanDefinitionNames) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">importConfig</span><br><span class="line">com.itpsc.entity.User</span><br></pre></td></tr></table></figure><p>很直观，selectImports方法返回一组bean，@EnableAutoConfiguration注解借助@Import注解将这组bean注入到spring容器中，springboot正是通过这种机制来完成bean的注入的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们可以将自动配置的关键几步以及相应的注解总结如下：</p><p>1、@Configuration与@Bean-&gt;基于java代码的bean配置</p><p>2、@Conditional-&gt;设置自动配置条件依赖</p><p>3、@EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。</p><p>4、@EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="框架" scheme="https://yuhaicheng.xyz/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://yuhaicheng.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>集合容器</title>
    <link href="https://yuhaicheng.xyz/2020-11-18-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8.html"/>
    <id>https://yuhaicheng.xyz/2020-11-18-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8.html</id>
    <published>2020-11-18T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合容器概述"><a href="#集合容器概述" class="headerlink" title="集合容器概述"></a>集合容器概述</h2><h3 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h3><p><strong>集合框架</strong>：用于存储数据的容器。</p><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p><p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p><p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p><p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p><p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。它减少了程序设计的辛劳。</p><p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。<br>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p><h3 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h3><p>集合的特点主要有如下两点：</p><ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li><li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li></ul><h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><p><strong>数据结构</strong>：就是容器中存储数据的方式。</p><p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p><p>集合容器在不断向上抽取过程中，出现了集合体系。<strong>在使用一个体系的原则：参阅顶层内容。建立底层对象。</strong></p><h3 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h3><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h3 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h3><p>Map接口和Collection接口是所有集合框架的父接口：</p><ol><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h3 id="List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#List，Set，Map三者的区别？List、Set、Map-是否继承自-Collection-接口？List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？"></a>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</h3><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p><p>Collection集合主要有List和Set两大接口</p><ul><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</li></ul><p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><h3 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h3><p>Collection</p><ol><li>List</li></ol><ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul><ol><li>Set</li></ol><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul><p>Map</p><ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，并且判断数组长度是否小于64，小于则扩容数组，否则将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h3><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><h3 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>是java集合的一种错误检测机制，当多个线程对集合进行<strong>结构上的改变</strong>的操作时，有可能会产生 fail-fast 机制。</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>解决办法：</p><ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol><h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h4 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>一种最常见的<strong>错误</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><p>遍历方式有以下几种：</p><ol><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ol><p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li></ul><p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><h4 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h4><p>ArrayList的优点如下：</p><ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul><p>ArrayList 的缺点如下：</p><ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul><p>ArrayList 比较适合顺序添加、随机访问的场景。</p><h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">Arrays.asList(array);</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><p>补充：数据结构基础之双向链表</p><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><h4 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p><p>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</p><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</p><h4 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h4><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h4 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 中的数组定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>再看一下 ArrayList 的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">12</span></span><br></pre></td></tr></table></figure><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    *<span class="comment">// Write out element count, and any hidden stuff*</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    *<span class="comment">// Write out array length*</span></span><br><span class="line">        s.writeInt(elementData.length);</span><br><span class="line">    *<span class="comment">// Write out all elements in the proper order.*</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h4 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h4><p>List , Set 都是继承自Collection 接口</p><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p><p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p><p>Set和List对比</p><p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>以下是HashSet 部分源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p><strong>hashCode（）与equals（）的相关规定</strong>：</p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同</li></ol><h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="BlockingQueue是什么？"><a href="#BlockingQueue是什么？" class="headerlink" title="BlockingQueue是什么？"></a>BlockingQueue是什么？</h4><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h3><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>HashMap 基于 Hash 算法实现的</p><ol><li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ol><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p><h3 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；\</strong>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法**的方式可以解决哈希冲突。</p><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img data-src="https://img-blog.csdnimg.cn/2019121422243983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="jdk1.7中HashMap数据结构" loading="lazy"></p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img data-src="https://img-blog.csdnimg.cn/20191214222452844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="jdk1.8中HashMap数据结构" loading="lazy"></p><h4 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h4><p>JDK1.8主要解决或优化了一下问题：</p><ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：<code>inflateTable()</code></td><td>直接集成到了扩容函数<code>resize()</code>中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table><h3 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h3><p>当我们put的时候，首先计算 <code>key</code>的<code>hash</code>值，这里调用了 <code>hash</code>方法，<code>hash</code>方法实际是让<code>key.hashCode()</code>与<code>key.hashCode()&gt;&gt;&gt;16</code>进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<code>index = (table.length - 1) &amp; hash</code>，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>putVal方法执行流程图</p><p><img data-src="https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="putVal方法执行流程图" loading="lazy"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Map.put和相关方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建 </span></span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理  </span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树 </span></span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表 </span></span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断该链表尾部指针是不是空的</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//链表结构转树形结构</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687</span></span><br></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab指向hash桶数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//返回</span></span><br><span class="line">        &#125;<span class="comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 双倍扩容阀值threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class="line">    <span class="comment">// 直接将该值赋给新的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的threshold = 新的cap * 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//新建hash桶数组</span></span><br><span class="line">    table = newTab;<span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    <span class="comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历新数组的所有桶下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class="line">                                <span class="comment">// 代表下标保持不变的链表的头元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                <span class="comment">// loTail.next指向当前e</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// loTail指向当前的元素e</span></span><br><span class="line">                            <span class="comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class="line">                            <span class="comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class="line">                            <span class="comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697</span></span><br></pre></td></tr></table></figure><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><p>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p><h4 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h4><p><strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）</strong>；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数</strong>。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易</strong>；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化</p><h4 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h4><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p><h4 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h4><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTc5OGYxMzg3ZTNmOGRlOWEucG5n?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>通过上面的<strong>链地址法（使用散列表）\</strong>和**扰动函数**我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p><h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h3 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h3><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ol><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ol><h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p><ol><li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li></ol><h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p><strong>那怎么解决呢？</strong></p><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol><h3 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><h3 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h3><ol><li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ol><h3 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）</strong>： ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图</strong>：</p><p>HashTable:</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>JDK1.7的ConcurrentHashMap：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h3 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><p><strong>JDK1.7</strong></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n?x-oss-process=image/format,png" alt="img" loading="lazy"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><p><strong>JDK1.8</strong></p><p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><p>结构如下：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p><strong>附加源码，有需要的可以看看</strong></p><p>插入元素过程（建议去看看源码）：</p><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><ol><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ol><h2 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h2><h3 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h3><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h3 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h3><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，</p><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>]]></content>
    
    
    <summary type="html">详细从源码解析ConcurrentHashMap</summary>
    
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>锁</title>
    <link href="https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html"/>
    <id>https://yuhaicheng.xyz/2020-11-18-%E9%94%81.html</id>
    <published>2020-11-18T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中划分锁的方式不同，就产生了各种对锁的定义，如果不能清楚知道不同锁的特点那么就很容易将JUC中的锁弄混淆，在学习JUC方面知识之前先学习下锁的划分。</p><h2 id="悲观锁、乐观锁"><a href="#悲观锁、乐观锁" class="headerlink" title="悲观锁、乐观锁"></a>悲观锁、乐观锁</h2><p>对于悲观锁和乐观锁划分关键是：是否默认在进行多线程操作时，总认为有其他线程会进行同步操作。</p><p>悲观锁：顾名思义，每次去拿数据的时候都被认为别人会修改，所以每次在拿数据的时候都会被锁上，这样别人想拿这个数据就会block直到它拿到锁，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先锁上。</p><p>java中的悲观锁是synchronized<strong>，AQS框架下的锁则是先尝试CAS乐观锁去获取，获取不到，才会转为悲观锁，如RetreenLock</strong></p><p>乐观锁：每次去拿数据的时候都认为别人不会修改，<strong>所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号等机制</strong>。乐观锁适用于多度的应用类型，这样可以<strong>提高吞吐量</strong>。</p><p>乐观锁策略：提交版本必须大于记录当前版本才能执行更新。java乐观锁基本都通过<code>CAS</code>操作实现的，<code>CAS</code>是一种依赖系统指令集实现原子操作，比较当前变量值与预期值是否一样,如果相同就使用系统原语进行更新。</p><p>例如：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值大于前数据库中的 version 值时才更新，否则重试更新操作，直到更新成功。</p><h3 id="排它锁、共享锁"><a href="#排它锁、共享锁" class="headerlink" title="排它锁、共享锁"></a>排它锁、共享锁</h3><p><code>排它锁</code>其实就是悲观锁机制实现的锁、<code>共享锁</code>就是乐观锁机制实现的锁。</p><h2 id="可重入锁、不可重入锁"><a href="#可重入锁、不可重入锁" class="headerlink" title="可重入锁、不可重入锁"></a>可重入锁、不可重入锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">functionA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;iAmFunctionA&quot;</span>);</span><br><span class="line">        functionB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">functionB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;iAmFunctionB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p><code>可重入锁</code>：当线程拥有对象的同步方法锁后可访问其他同步方法 ，java中synchronized和ReentrantLock都是可重入锁<br><code>不可重入</code>：当线程拥有对象的同步方法锁后再访问其他同步方法也需要排队或等待</p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p><code>公平锁</code>是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</p><p><code>非公平锁</code>不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁</p><p>synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过构造函数进行设置</p><h2 id="Synchronized锁的优化"><a href="#Synchronized锁的优化" class="headerlink" title="Synchronized锁的优化"></a>Synchronized锁的优化</h2><p>Synchronized</p><p>在Java中<code>Synchronized</code>是我们常用的<code>同步互斥手段</code>，在早期版本中，它是一个<code>悲观锁</code>设计下的<code>独占锁</code>，并且<code>可重入</code>。<code>Synchronized在获取到同步锁后，其他线程将会阻塞，对于阻塞或者唤醒一个线程都需要操作系统来完成，这就需要从用户态切换到内核态，这样的操作就需要消耗很多处理器时间，具有很强的性能损耗</code>，因此Synchronized在1.6中做了很多的优化，减少频繁的切换到内核态。</p><p>在1.6之中为了提高Synchronized的性能，增加了<code>自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等来高效地共享数据，解决竞争问题</code>。<br><code>自旋锁</code>:在多线程操作中共享数据的锁定可能是和短暂的，避免线程在很短的时间内做用户态的切换，那么在允许多线程并行的基础上，让后面请求锁的线程“等待一下”，等待过程不放弃处理器的执行时间，为了让线程等待只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br><code>自适应自旋</code>是对自旋锁的优化，自旋锁的缺点就是如果锁占用的时间很长，那么就会浪费处理器资源，并且还对处理器有要求。加入自适应自旋就是自旋的时间不再固定，而是由前一个在同一个锁上的自旋时间以及锁的拥有者的状态决定，如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么虚拟机会认为这次自旋很可能再次成功，应此可能允许等待时间更长；如果某一个锁上，很少自旋成功，那么将跳过自旋过程，避免资源浪费。虚拟机使用这一的策略和技术完成对Synchronized的一种优化</p><p><code>锁消除</code>是指在虚拟机及时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除如：消除锁的判断主要来于逃逸分析的数据支持，如果判断在一段代码中，堆上的数据都不会逃逸出去从而被其他线程访问到，那么就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁就自热无效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1,String s2，String s3)</span></span>&#123;</span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> SrringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line">sb.append(s3);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>对于上述代码，StringBuffer.append()方法都具有一个同步块，锁就是对象sb,但sb变量永远不会被其他线程所访问，其一直动态作用域被限制在concatString方法中，其他线程并不能访问。因此此处的锁可以被安全的消除掉。</p><p><code>锁粗化</code>一段代码里面对同一个对象进行反复的加锁和解锁，那么也会带来性能的损耗，应该将锁同步范围扩展（粗化）到整个操作序列的外部。如上面代码就是扩展到第一个append()操作之前直至追后一个append()操作之后，这样就只需要加一次锁</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的作用是在没有多线程的前提下，<code>减少重量级锁在使用操作系统互斥量产生的新能消耗</code>。在无竞争的情况下获取锁使用的是<code>CAS</code>操作。CAS操作主要是用于更新对象头中thread ID， 要理解轻量级锁，得先了解HotPost虚拟机的对象头部分，对象头中一部分保存这GC年龄代，哈希码等信息，官方称为Mark Work，在32位的HotPost下，PostMark Work的32bit存储空间中，有25bit用于存储对象哈希码，4bit用于存储对象的分代年龄，2bit用于存储锁标志位，1bit固定为0；</p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀（重量级锁定）</td></tr><tr><td>空、不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向锁ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>偏向锁</code>是<code>在无竞争的情况下把整个同步都消除掉</code>，偏向锁的意思是<code>同步锁会偏向第一次获得它的线程，如果在接下来的执行中，该锁没有其他线程获取，则持有偏向锁的线程将永远不需要再进行同步</code>。使用偏向锁需要虚拟机默认支持，如果在没有设置的情况下将不支持偏向锁。接下来用一张图讲解轻量级锁和偏向锁的转换关系</p><h3 id="轻量级锁、偏向锁的状态准换"><a href="#轻量级锁、偏向锁的状态准换" class="headerlink" title="轻量级锁、偏向锁的状态准换"></a>轻量级锁、偏向锁的状态准换</h3><p><img data-src="https://img-blog.csdnimg.cn/20190507233042199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oZWcyMDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>首先根据<code>偏向锁可用</code>和<code>不可用</code>分为左右两种逻辑</p><p><code>可偏向左边上面部分</code>：如果偏向锁可用，初始化的的对象标志位为01，那么这是一个未锁定、未偏向但是可偏向的对象</p><p><code>可偏向左边下面部分</code>：当第一次线程获取到锁的时候，那么虚拟机将头中的标志位设置为<code>01</code>，<code>同时使用CAS操作将线程的thread ID写入到Mark Work中</code>，成功后，持有偏向锁的线程再进入这个锁的相关同步块时，都不用做同步操作。<br>对象Mark Work中写入了thread ID状态下，对象可能处于锁定状态或未锁定状态。如果是<code>在锁定</code>情况下，有另一个线程去获取这个锁时，偏向锁模式将结束，将回到轻量级锁定。<br>如果是在<code>没有锁定</code>状态下，有另一个线程去获取这个锁时，偏向锁模式将结束，将回到未锁定、未偏向但是可偏向状态，如果撤销偏向，将回到未锁定、不可偏向对象</p><p><code>不可偏向右上部分</code>：如果偏向锁不可用，初始化的的对象标志位为<code>01</code>，那么这是一个未锁定、不可偏向对象</p><p><code>不可偏向中间部分</code>：当有一个线程获取同步对象时，如果同步对象没有被锁定，那么在<code>当前线程的栈帧中开辟一个叫“Lock Record”的空间保存一份同步对象的Mark Word部分的拷贝，并且使用CAS操作将这个对象的Mark Word更新指向栈帧的“Lock Record”</code>，如果成功，那么将标志位改为<code>00</code>；如果更新失败，但当前线程已经拥有对象锁，那就直接运行同步块代码；否则说明有线程在争夺锁，那么轻量级锁就不再有效，要膨胀成重量级锁</p><p><code>不可偏向下面部分</code>：当同步对象已经是轻量级锁，但有另一个线程在竞争锁资源时，轻量级锁将膨胀成重量级锁，锁的标志位状态值变为<code>“10”</code>，Mark Word中存储的指向重量级锁的指针，后面等待锁的线程也将进入阻塞状态。</p><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="AQS-对资源的共享⽅式"><a href="#AQS-对资源的共享⽅式" class="headerlink" title="AQS 对资源的共享⽅式"></a>AQS 对资源的共享⽅式</h2><p>AQS定义两种资源共享⽅式</p><p><strong>Exclusive（独占）</strong>：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：</p><ul><li><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p></li><li><p>⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的</p></li></ul><p><strong>Share（共享）</strong>：多个线程可同时执⾏，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后⾯讲到。</p><p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：</p><p><img data-src="https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png" alt="img" loading="lazy"></p><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink" title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p><p><img data-src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img" loading="lazy"></p><p>下面通过伪代码，进行更加直观的比较：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; **************************Synchronized的使用方式**************************</span><br><span class="line">&#x2F;&#x2F; 1.用于代码块</span><br><span class="line">synchronized (this) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 2.用于对象</span><br><span class="line">synchronized (object) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 3.用于方法</span><br><span class="line">public synchronized void test () &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 4.可重入</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">synchronized (this) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; **************************ReentrantLock的使用方式**************************</span><br><span class="line">public void test () throw Exception &#123;</span><br><span class="line">&#x2F;&#x2F; 1.初始化选择公平锁、非公平锁</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock(true);</span><br><span class="line">&#x2F;&#x2F; 2.可用于代码块</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; 3.支持多种加锁方式，比较灵活; 具有可重入特性</span><br><span class="line">if(lock.tryLock(100, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">&#x2F;&#x2F; 4.手动释放锁</span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink" title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5qUTVNVEk1T0E9PSZtaWQ9MjY1MTc0OTQzNCZpZHg9MyZzbj01ZmZhNjNhZDQ3ZmUxNjZmMmYxYTlmNjA0ZWQxMDA5MSZjaGtzbT1iZDEyYTU3NzhhNjUyYzYxNTA5ZDllNzE4YWIwODZmZjI3YWQ4NzY4NTg2ZWE5YjM4YzNkY2Y5ZTAxN2E4ZTQ5YmNhZTNkZjliY2M4JnNjZW5lPTM4I3dlY2hhdF9yZWRpcmVjdA==">不可不说的Java“锁”事<i class="fa fa-external-link-alt"></i></span>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p><p>非公平锁源码中的加锁流程如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock#NonfairSync</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非公平锁</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">...</span><br><span class="line">final void lock() &#123;</span><br><span class="line">if (compareAndSetState(0, 1))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">else</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的含义为：</p><ul><li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li><li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li></ul><p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p><ul><li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li></ul><p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p><p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><ul><li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li><li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li><li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li></ul><p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock#FairSync</span><br><span class="line"></span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">  ...  </span><br><span class="line">final void lock() &#123;</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p><h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p><p><img data-src="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img" loading="lazy"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p><p><img data-src="https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt="img" loading="lazy"></p><h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><p>主要原理图如下：</p><p><img data-src="https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png" alt="img" loading="lazy"></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h4 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构</h4><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p><p><img data-src="https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png" alt="img" loading="lazy"></p><p>解释一下几个方法和属性值的含义：</p><table><thead><tr><th align="left">方法和属性值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">waitStatus</td><td align="left">当前节点在队列中的状态</td></tr><tr><td align="left">thread</td><td align="left">表示处于该节点的线程</td></tr><tr><td align="left">prev</td><td align="left">前驱指针</td></tr><tr><td align="left">predecessor</td><td align="left">返回前驱节点，没有的话抛出npe</td></tr><tr><td align="left">nextWaiter</td><td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="left">next</td><td align="left">后继指针</td></tr></tbody></table><p>线程两种锁的模式：</p><table><thead><tr><th align="left">模式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SHARED</td><td align="left">表示线程以共享的模式等待锁</td></tr><tr><td align="left">EXCLUSIVE</td><td align="left">表示线程正在以独占的方式等待锁</td></tr></tbody></table><p>waitStatus有下面几个枚举值：</p><table><thead><tr><th align="left">枚举</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">当一个Node被初始化的时候的默认值</td></tr><tr><td align="left">CANCELLED</td><td align="left">为1，表示线程获取锁的请求已经取消了</td></tr><tr><td align="left">CONDITION</td><td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td align="left">PROPAGATE</td><td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td align="left">SIGNAL</td><td align="left">为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table><h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h4><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected final int getState()</td><td align="left">获取State的值</td></tr><tr><td align="left">protected final void setState(int newState)</td><td align="left">设置State的值</td></tr><tr><td align="left">protected final boolean compareAndSetState(int expect, int update)</td><td align="left">使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img data-src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png" alt="img" loading="lazy"><img data-src="https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img" loading="lazy"></p><p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p><h2 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink" title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected boolean isHeldExclusively()</td><td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td align="left">protected boolean tryAcquire(int arg)</td><td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected boolean tryRelease(int arg)</td><td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected int tryAcquireShared(int arg)</td><td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td align="left">protected boolean tryReleaseShared(int arg)</td><td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p><p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p><p><img data-src="https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png" alt="img" loading="lazy"></p><p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p><p><img data-src="https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png" alt="img" loading="lazy"></p><p>加锁：</p><ul><li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li><li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li><li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li><li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li></ul><p>解锁：</p><ul><li>通过ReentrantLock的解锁方法Unlock进行解锁。</li><li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li><li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li><li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li></ul><p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p><p><img data-src="https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt="img" loading="lazy"></p><h2 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink" title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h2><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p><p>在非公平锁中，有一段这样的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">...</span><br><span class="line">final void lock() &#123;</span><br><span class="line">if (compareAndSetState(0, 1))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">else</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这个Acquire是怎么写的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下tryAcquire方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p><h3 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列</h3><h4 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1 加入队列的时机</h4><p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p><h4 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列</h4><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">&#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">Node pred &#x3D; tail;</span><br><span class="line">if (pred !&#x3D; null) &#123;</span><br><span class="line">node.prev &#x3D; pred;</span><br><span class="line">if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next &#x3D; node;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的流程如下：</p><ul><li>通过当前的线程和锁模式新建一个节点。</li><li>Pred指针指向尾节点Tail。</li><li>将New中Node的Prev指针指向Pred。</li><li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">stateOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">headOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">tailOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">waitStatusOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">nextOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line">&#125; catch (Exception ex) &#123; </span><br><span class="line">    throw new Error(ex); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p><ul><li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">Node t &#x3D; tail;</span><br><span class="line">if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">if (compareAndSetHead(new Node()))</span><br><span class="line">tail &#x3D; head;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">node.prev &#x3D; t;</span><br><span class="line">if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next &#x3D; node;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p>总结一下，线程获取锁的时候，过程大体如下：</p><ol><li>当没有线程获取到锁时，线程1获取锁成功。</li><li>线程2申请锁，但是锁被线程1占有。</li></ol><p><img data-src="https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png" alt="img" loading="lazy"></p><ol><li>如果再有线程要获取锁，依次在队列中往后排队即可。</li></ol><p>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">&#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class="line">&#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class="line">&#x2F;&#x2F; thread is first in queue.</span><br><span class="line">Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class="line">Node h &#x3D; head;</span><br><span class="line">Node s;</span><br><span class="line">return h !&#x3D; t &amp;&amp; ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><blockquote><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><br><span class="line"></span><br><span class="line">if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">if (compareAndSetHead(new Node()))</span><br><span class="line">tail &#x3D; head;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">node.prev &#x3D; t;</span><br><span class="line">if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next &#x3D; node;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h4 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink" title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h4><p>回到最初的源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">&#x2F;&#x2F; 标记是否成功拿到资源</span><br><span class="line">boolean failed &#x3D; true;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; 标记等待过程中是否中断过</span><br><span class="line">boolean interrupted &#x3D; false;</span><br><span class="line">&#x2F;&#x2F; 开始自旋，要么获取锁，要么中断</span><br><span class="line">for (;;) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取当前节点的前驱节点</span><br><span class="line">final Node p &#x3D; node.predecessor();</span><br><span class="line">&#x2F;&#x2F; 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><br><span class="line">if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取锁成功，头指针移动到当前node</span><br><span class="line">setHead(node);</span><br><span class="line">p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">failed &#x3D; false;</span><br><span class="line">return interrupted;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">head &#x3D; node;</span><br><span class="line">node.thread &#x3D; null;</span><br><span class="line">node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 靠前驱节点判断当前线程是否应该被阻塞</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取头结点的节点状态</span><br><span class="line">int ws &#x3D; pred.waitStatus;</span><br><span class="line">&#x2F;&#x2F; 说明头结点处于唤醒状态</span><br><span class="line">if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">return true; </span><br><span class="line">&#x2F;&#x2F; 通过枚举值我们知道waitStatus&gt;0是取消状态</span><br><span class="line">if (ws &gt; 0) &#123;</span><br><span class="line">do &#123;</span><br><span class="line">&#x2F;&#x2F; 循环向前查找取消节点，把取消节点从队列中剔除</span><br><span class="line">node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">pred.next &#x3D; node;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 设置前任节点等待状态为SIGNAL</span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的流程图如下：</p><p><img data-src="https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png" alt="img" loading="lazy"></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img data-src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png" alt="img" loading="lazy"></p><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ul><li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li><li>是在什么时间释放节点通知到被挂起的线程呢？</li></ul><h3 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink" title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h3><p>acquireQueued方法中的Finally代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">boolean failed &#x3D; true;</span><br><span class="line">try &#123;</span><br><span class="line">    ...</span><br><span class="line">for (;;) &#123;</span><br><span class="line">final Node p &#x3D; node.predecessor();</span><br><span class="line">if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">...</span><br><span class="line">failed &#x3D; false;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将无效节点过滤</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">  &#x2F;&#x2F; 设置该节点不关联任何线程，也就是虚节点</span><br><span class="line">node.thread &#x3D; null;</span><br><span class="line">Node pred &#x3D; node.prev;</span><br><span class="line">  &#x2F;&#x2F; 通过前驱节点，跳过取消状态的node</span><br><span class="line">while (pred.waitStatus &gt; 0)</span><br><span class="line">node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">  &#x2F;&#x2F; 获取过滤后的前驱节点的后继节点</span><br><span class="line">Node predNext &#x3D; pred.next;</span><br><span class="line">  &#x2F;&#x2F; 把当前node的状态设置为CANCELLED</span><br><span class="line">node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">  &#x2F;&#x2F; 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span><br><span class="line">  &#x2F;&#x2F; 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span><br><span class="line">if (node &#x3D;&#x3D; tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">compareAndSetNext(pred, predNext, null);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int ws;</span><br><span class="line">    &#x2F;&#x2F; 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span><br><span class="line">    &#x2F;&#x2F; 如果1和2中有一个为true，再判断当前节点的线程是否为null</span><br><span class="line">    &#x2F;&#x2F; 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span><br><span class="line">if (pred !&#x3D; head &amp;&amp; ((ws &#x3D; pred.waitStatus) &#x3D;&#x3D; Node.SIGNAL || (ws &lt;&#x3D; 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread !&#x3D; null) &#123;</span><br><span class="line">Node next &#x3D; node.next;</span><br><span class="line">if (next !&#x3D; null &amp;&amp; next.waitStatus &lt;&#x3D; 0)</span><br><span class="line">compareAndSetNext(pred, predNext, next);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span><br><span class="line">unparkSuccessor(node);</span><br><span class="line">&#125;</span><br><span class="line">node.next &#x3D; node; &#x2F;&#x2F; help GC</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的流程：</p><ul><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：</li></ul><p>(1) 当前节点是尾节点。</p><p>(2) 当前节点是Head的后继节点。</p><p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p><p>根据上述第二条，我们来分析每一种情况的流程。</p><p>当前节点是尾节点。</p><p><img data-src="https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png" alt="img" loading="lazy"></p><p>当前节点是Head的后继节点。</p><p><img data-src="https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png" alt="img" loading="lazy"></p><p>当前节点不是Head的后继节点，也不是尾节点。</p><p><img data-src="https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png" alt="img" loading="lazy"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h3><p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">if (tryRelease(arg)) &#123;</span><br><span class="line">Node h &#x3D; head;</span><br><span class="line">if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.Sync</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法返回当前锁是不是没有被线程持有</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">&#x2F;&#x2F; 减少可重入次数</span><br><span class="line">int c &#x3D; getState() - releases;</span><br><span class="line">&#x2F;&#x2F; 当前线程不是持有锁的线程，抛出异常</span><br><span class="line">if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">throw new IllegalMonitorStateException();</span><br><span class="line">boolean free &#x3D; false;</span><br><span class="line">&#x2F;&#x2F; 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">free &#x3D; true;</span><br><span class="line">setExclusiveOwnerThread(null);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);</span><br><span class="line">return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来解释下述源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">&#x2F;&#x2F; 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><br><span class="line">if (tryRelease(arg)) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取头结点</span><br><span class="line">Node h &#x3D; head;</span><br><span class="line">&#x2F;&#x2F; 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><br><span class="line">if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p><p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p><p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>再看一下unparkSuccessor方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取头结点waitStatus</span><br><span class="line">int ws &#x3D; node.waitStatus;</span><br><span class="line">if (ws &lt; 0)</span><br><span class="line">compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">&#x2F;&#x2F; 获取当前节点的下一个节点</span><br><span class="line">Node s &#x3D; node.next;</span><br><span class="line">&#x2F;&#x2F; 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><br><span class="line">if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">s &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><br><span class="line">for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">s &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果当前节点的下个节点不为空，而且状态&lt;&#x3D;0，就把当前节点unpark</span><br><span class="line">if (s !&#x3D; null)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p><p>之前的addWaiter方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">&#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">Node pred &#x3D; tail;</span><br><span class="line">if (pred !&#x3D; null) &#123;</span><br><span class="line">node.prev &#x3D; pred;</span><br><span class="line">if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next &#x3D; node;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p><h3 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4 中断恢复后的执行流程</h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">LockSupport.park(this);</span><br><span class="line">return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">boolean failed &#x3D; true;</span><br><span class="line">try &#123;</span><br><span class="line">boolean interrupted &#x3D; false;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">final Node p &#x3D; node.predecessor();</span><br><span class="line">if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">failed &#x3D; false;</span><br><span class="line">return interrupted;</span><br><span class="line">&#125;</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p><ol><li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li><li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li></ol><p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p><h3 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h3><p>我们在1.3小节中提出了一些问题，现在来回答一下。</p><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？</p><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><h2 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h2><h3 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink" title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h3><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><p>公平锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span><br><span class="line"></span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">int nextc &#x3D; c + acquires;</span><br><span class="line">if (nextc &lt; 0)</span><br><span class="line">throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">setState(nextc);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span><br><span class="line"></span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">if (compareAndSetState(0, acquires))&#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">int nextc &#x3D; c + acquires;</span><br><span class="line">if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">setState(nextc);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>接下来看State这个字段主要的过程：</p><ol><li>State初始化的时候为0，表示没有任何线程持有锁。</li><li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li><li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li></ol><h3 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景</h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table><thead><tr><th align="left">同步工具</th><th align="left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="left">Semaphore</td><td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="left">CountDownLatch</td><td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="left">ThreadPoolExecutor</td><td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h3 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h3><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LeeLock  &#123;</span><br><span class="line"></span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire (int arg) &#123;</span><br><span class="line">            return compareAndSetState(0, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease (int arg) &#123;</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively () &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Sync sync &#x3D; new Sync();</span><br><span class="line">    </span><br><span class="line">    public void lock () &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void unlock () &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过我们自己定义的Lock完成一定的同步功能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LeeMain &#123;</span><br><span class="line"></span><br><span class="line">    static int count &#x3D; 0;</span><br><span class="line">    static LeeLock leeLock &#x3D; new LeeLock();</span><br><span class="line"></span><br><span class="line">    public static void main (String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run () &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(runnable);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，并返或true，否则返回false。整个比较并替换的操作是一个原子操作。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上面源码分析时，提到最后调用了compareAndSwapInt方法，接着继续深入探讨该方法，该方法在Unsafe中对应的源码如下。</p><p><img data-src="https://img-blog.csdn.net/20180314222522710" alt="img" loading="lazy"></p><p>可以看到调用了“Atomic::cmpxchg”方法，“Atomic::cmpxchg”方法在linux_x86和windows_x86的实现如下。</p><p><strong>linux_x86的实现：</strong></p><p><img data-src="https://img-blog.csdn.net/20180314222533843" alt="img" loading="lazy"></p><p><strong>windows_x86的实现：</strong></p><p><img data-src="https://img-blog.csdn.net/20180314222539318" alt="img" loading="lazy"></p><p><strong>Atomic::cmpxchg方法解析：</strong></p><p>mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。</p><ol><li>如果当前系统是多处理器，该函数返回1。</li><li>否则，返回0。</li></ol><p>LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。</p><ol><li>如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。</li><li>否则，不加lock前缀。</li></ol><p>这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。</p><h2 id="intel手册对lock前缀的说明如下："><a href="#intel手册对lock前缀的说明如下：" class="headerlink" title="intel手册对lock前缀的说明如下："></a>intel手册对lock前缀的说明如下：</h2><ol><li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第1点保证了CAS操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有volatile读和volatile写的内存语义。</p><h2 id="CAS的缺点："><a href="#CAS的缺点：" class="headerlink" title="CAS的缺点："></a>CAS的缺点：</h2><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p><ol><li>循环时间长开销很大。</li><li>只能保证一个变量的原子操作。</li><li>ABA问题。</li></ol><h2 id="循环时间长开销很大："><a href="#循环时间长开销很大：" class="headerlink" title="循环时间长开销很大："></a>循环时间长开销很大：</h2><p>CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p><h2 id="只能保证一个变量的原子操作："><a href="#只能保证一个变量的原子操作：" class="headerlink" title="只能保证一个变量的原子操作："></a>只能保证一个变量的原子操作：</h2><p>当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p><h2 id="什么是ABA问题？ABA问题怎么解决？"><a href="#什么是ABA问题？ABA问题怎么解决？" class="headerlink" title="什么是ABA问题？ABA问题怎么解决？"></a>什么是ABA问题？ABA问题怎么解决？</h2><p>在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。 假设有以下顺序事件：</p><blockquote><p>1、线程1从内存位置V中取出A </p><p>2、线程2从内存位置V中取出A </p><p>3、线程2进行了写操作，将B写入内存位置V </p><p>4、线程2将A再次写入内存位置V </p><p>5、线程1进行CAS操作，发现V中仍然是A，交换成功</p></blockquote><p>尽管线程1的CAS操作成功，但线程1并不知道内存位置V的数据发生过改变</p><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。根据实际情况，判断是否处理ABA问题。如果ABA问题并不会影响我们的业务结果，可以选择性处理或不处理;如果ABA会影响我们的业务结果的，这时就必须处理ABA问题了。对于AtomicInteger等,没有什么可修改的属性;且我们只在意其结果值，所以对于这些类来说，本身就算发生了ABA现象，也不会对原线程的结果造成什么影响。</p><p>这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类<strong>“AtomicStampedReference”</strong>，它可以通过<strong>控制变量值的版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>1.使⽤ volatile 修饰变量就可以<strong>禁⽌ JVM 的指令重排</strong>，保证在多线程环境下也能正常运⾏。 </p><p>2.在 JDK1.2 之前，<strong>Java 的内存模型</strong>实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致。要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使⽤它都到主存中进⾏读取。所以，volatile 关键字 除了防⽌ JVM 的指令重排 ，还有⼀个重要的作⽤就是<strong>保证变量的可⻅性。</strong></p><h1 id="内存屏蔽"><a href="#内存屏蔽" class="headerlink" title="内存屏蔽"></a>内存屏蔽</h1><h2 id="1-指令重排序"><a href="#1-指令重排序" class="headerlink" title="1. 指令重排序"></a>1. 指令重排序</h2><p>程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问行为出现的理由是为了提升程序运行时的性能。这种内存乱序问题主要是由两种原因引起的：</p><ul><li>编译器在编译时进行了编译优化，导致指令重排；</li><li>在多cpu环境下，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。</li></ul><p><strong>为什么需要内存屏障</strong><br>我们知道，在多CPU（核）场景下，为了充分利用CPU，会通过流水线将指令并行进行。为了能并行执行，又需要将指令进行重排序以便进行并行执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则（如Happens Before 规则）之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性, 不能确保内存与CPU缓存数据一致性的指令也不能重排，<strong>内存屏障正是通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法</strong>。</p><h2 id="2-java-内存模型中的happen-before原则"><a href="#2-java-内存模型中的happen-before原则" class="headerlink" title="2. java 内存模型中的happen before原则"></a>2. java 内存模型中的happen before原则</h2><p>JSR-1337制定了Java内存模型(Java Memory Model, JMM)中规定的hb原则大致有以下几点：</p><ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul><p>jmm 对java语义的比较重要的两个扩展是：</p><ul><li>对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。</li><li>对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（前提是没有this引用溢出）。</li></ul><h2 id="3-内存屏障-Memory-Barrier"><a href="#3-内存屏障-Memory-Barrier" class="headerlink" title="3. 内存屏障(Memory Barrier)"></a>3. 内存屏障(Memory Barrier)</h2><ul><li>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。</li><li>Memory barrier是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</li><li>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。</li></ul><p>Memory Barrier可以被分为以下几种类型：</p><ul><li><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p></li><li><p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p></li><li><p><strong>Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序</strong>。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。具体用法可以看下disruptor的Sequence的set方法。</p></li><li><p>Intel 64/IA-32架构下写操作之间不会发生重排序，也就是说在处理器上操作的顺序是可以保证的，这时候使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。采用putOrderedObject可以解决这个问题。</p></li><li><p>即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。</p></li></ul><h2 id="4-volatile语义中的内存屏障"><a href="#4-volatile语义中的内存屏障" class="headerlink" title="4. volatile语义中的内存屏障"></a>4. volatile语义中的内存屏障</h2><ul><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</li></ul><p>volatile的内存屏障策略非常严格保守，保证了线程可见性。</p><h2 id="5-final语义中的内存屏障"><a href="#5-final语义中的内存屏障" class="headerlink" title="5. final语义中的内存屏障"></a>5. final语义中的内存屏障</h2><ul><li>新建对象过程中，构造体中对final域的初始化写入(StoreStore屏障)和这个对象赋值给其他引用变量，这两个操作不能重排序；</li><li>初次读包含final域的对象引用和读取这个final域（LoadLoad屏障），这两个操作不能重排序；</li><li>Intel 64/IA-32架构下写操作之间不会发生重排序StoreStore会被省略，这种架构下也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li></ul><p><strong>常见的应用场景</strong></p><p>（1）通过 Synchronized关键字包住的代码区域,当线程进入到该区域读取变量信息时,保证读到的是最新的值.这是因为在同步区内对变量的写入操作,在离开同步区时就将当前线程内的数据刷新到内存中,而对数据的读取也不能从缓存读取,只能从内存中读取,保证了数据的读有效性.这就是插入了StoreStore屏障；<br>（2）使用了volatile修饰变量,则对变量的写操作,会插入StoreLoad屏障；<br>（3）其余的操作,则需要通过Unsafe这个类来执行；</p>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="锁的分类" scheme="https://yuhaicheng.xyz/categories/%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="锁" scheme="https://yuhaicheng.xyz/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://yuhaicheng.xyz/2020-11-17-%E9%93%BE%E8%A1%A8.html"/>
    <id>https://yuhaicheng.xyz/2020-11-17-%E9%93%BE%E8%A1%A8.html</id>
    <published>2020-11-17T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）</strong>。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值（NULL）。单向链表只可向一个方向遍历。查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。也可以提前把一个节点的位置另外保存起来，然后直接访问。</p><p>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><strong>双向链表</strong></h3><p>双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。第一个节点的&quot;前连接&quot;指向NULL，最后一个节点的&quot;后连接&quot;指向NULL。这样可以从任何一个节点访问前一个节点，也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。</p><p>单链表只有一个指向下一结点的指针，也就是只能next.<br>双链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</p><h4 id="单链表和双向链表区别"><a href="#单链表和双向链表区别" class="headerlink" title="单链表和双向链表区别"></a>单链表和<strong>双向链表</strong>区别</h4><p>1、因为在双向链表中，我们可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表。</p><p>所以删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样的，指针的总的移动操作都会有2*i次。而如果用双向链表，则不需要定位前驱结点。因此指针总的移动操作为i次。</p><p>2、查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍。</p><p>可是为什么市场上单链表的使用多余双链表呢？</p><p>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a><strong>循环链表</strong></h3><p>在一个循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。循环链表可以被视为&quot;无头无尾&quot;。</p><p>循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大。</p><p>在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。</p><p><strong>对于循环链表来说唯一的区别是循环结束的条件改为是否指向头指针。</strong></p><h4 id="单向循环链表："><a href="#单向循环链表：" class="headerlink" title="单向循环链表："></a>单向循环链表：</h4><p>如果把单链表的最后一个节点的指针指向链表头部，而不是指向NULL，那么就构成了一个单向循环链表，通俗讲就是把尾节点的下一跳指向头结点。</p><h4 id="双向循环链表："><a href="#双向循环链表：" class="headerlink" title="双向循环链表："></a>双向循环链表：</h4><p>双（向）链表中有两条方向不同的链，即每个结点中除next域存放后继结点地址外，还增加一个指向其直接前趋的指针域prior。</p><h3 id="联系："><a href="#联系：" class="headerlink" title="联系："></a>联系：</h3><h4 id="LinkedList用的是单链表还是双链表？"><a href="#LinkedList用的是单链表还是双链表？" class="headerlink" title="LinkedList用的是单链表还是双链表？"></a>LinkedList用的是单链表还是双链表？</h4><p>JDK1.6之前为循环双向链表，JDK1.7取消了循环。</p><h4 id="双向链表和双向循环链表的区别"><a href="#双向链表和双向循环链表的区别" class="headerlink" title="双向链表和双向循环链表的区别"></a>双向链表和双向循环链表的区别</h4><p>双向链表： 包含两个指针，⼀个prev指向前⼀个节点，⼀个next指向后⼀个节点。</p><p>双向循环链表： 最后⼀个节点的 next 指向head，⽽ head 的prev指向最后⼀个节点，构成⼀个环</p><h4 id="LinkedList-为什么不用单链表，而是用双链表？"><a href="#LinkedList-为什么不用单链表，而是用双链表？" class="headerlink" title="LinkedList 为什么不用单链表，而是用双链表？"></a>LinkedList 为什么不用单链表，而是用双链表？</h4><h4 id="LinkedList-删除元素，默认是删除最后一个还是第一个元素？"><a href="#LinkedList-删除元素，默认是删除最后一个还是第一个元素？" class="headerlink" title="LinkedList 删除元素，默认是删除最后一个还是第一个元素？"></a>LinkedList 删除元素，默认是删除最后一个还是第一个元素？</h4><h3 id="链表跟数组的区别？"><a href="#链表跟数组的区别？" class="headerlink" title="链表跟数组的区别？"></a>链表跟数组的区别？</h3><ol><li>数组静态分配内存，链表动态分配内存；</li><li>数组在内存中连续，链表不连续；</li><li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</li><li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li></ol><h4 id="数组的优点"><a href="#数组的优点" class="headerlink" title="数组的优点"></a>数组的优点</h4><ul><li>随机访问性强（通过下标进行快速定位）</li><li>查找速度快</li></ul><h4 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h4><ul><li>插入和删除效率低（插入和删除需要移动数据）</li><li>可能浪费内存（因为是连续的，所以每次申请数组之前必须规定数组的大小，如果大小不合理，则可能会浪费内存）</li><li>内存空间要求高，必须有足够的连续内存空间。</li><li>数组大小固定，不能动态拓展</li></ul><h4 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h4><ul><li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li><li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li><li>大小没有固定，拓展很灵活。</li></ul><h4 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h4><ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    <category term="数据结构" scheme="https://yuhaicheng.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="单向链表、双向链表" scheme="https://yuhaicheng.xyz/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="https://yuhaicheng.xyz/2020-11-17-ConcurrentHashMap.html"/>
    <id>https://yuhaicheng.xyz/2020-11-17-ConcurrentHashMap.html</id>
    <published>2020-11-17T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img data-src="https://i.loli.net/2020/11/17/3LAd5JPm4V8N6RU.png" loading="lazy"></p><p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现.</p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><p>通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Creates a new, empty map with a default initial capacity (16),</span><br><span class="line"> * load factor (0.75) and concurrencyLevel (16).</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 默认初始化容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认负载因子</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认并发级别</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure><p>接着看下这个有参构造函数的内部实现逻辑。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    &#x2F;&#x2F; 参数校验</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#x2F;&#x2F; 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line">    &#x2F;&#x2F; Find power-of-two sizes best matching arguments</span><br><span class="line">    &#x2F;&#x2F; 2的多少次方</span><br><span class="line">    int sshift &#x3D; 0;</span><br><span class="line">    int ssize &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 记录段偏移量</span><br><span class="line">    this.segmentShift &#x3D; 32 - sshift;</span><br><span class="line">    &#x2F;&#x2F; 记录段掩码</span><br><span class="line">    this.segmentMask &#x3D; ssize - 1;</span><br><span class="line">    &#x2F;&#x2F; 设置容量</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    &#x2F;&#x2F; c &#x3D; 容量 &#x2F; ssize ，默认 16 &#x2F; 16 &#x3D; 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span><br><span class="line">    int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">    if (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    &#x2F;&#x2F;Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span><br><span class="line">    while (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;&#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; create segments and segments[0]</span><br><span class="line">    &#x2F;&#x2F; 创建 Segment 数组，设置 segments[0]</span><br><span class="line">    Segment&lt;K,V&gt; s0 &#x3D; new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]</span><br><span class="line">    this.segments &#x3D; ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造<strong>默认值是 16.</strong></li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 segments[0]**，</strong>默认大小为 2<strong>，</strong>负载因子 0.75<strong>，</strong>扩容阀值是 2*0.75=1.5**，插入第二个值时才会进行扩容。</li></ol><h3 id="3-put"><a href="#3-put" class="headerlink" title="3. put"></a>3. put</h3><p>接着上面的初始化参数继续查看 put 方法源码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Maps the specified key to the specified value in this table.</span><br><span class="line"> * Neither the key nor the value can be null.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;&#x2F;tt&gt; method</span><br><span class="line"> * with a key that is equal to the original key.</span><br><span class="line"> *</span><br><span class="line"> * @param key key with which the specified value is to be associated</span><br><span class="line"> * @param value value to be associated with the specified key</span><br><span class="line"> * @return the previous value associated with &lt;tt&gt;key&lt;&#x2F;tt&gt;, or</span><br><span class="line"> *         &lt;tt&gt;null&lt;&#x2F;tt&gt; if there was no mapping for &lt;tt&gt;key&lt;&#x2F;tt&gt;</span><br><span class="line"> * @throws NullPointerException if the specified key or value is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    &#x2F;&#x2F; hash 值无符号右移 28位（初始化时获得），然后与 segmentMask&#x3D;15 做与运算</span><br><span class="line">    &#x2F;&#x2F; 其实也就是把高4位与segmentMask（1111）做与运算</span><br><span class="line">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">        &#x2F;&#x2F; 如果查找到的 Segment 为空，初始化</span><br><span class="line">        s &#x3D; ensureSegment(j);</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the segment for the given index, creating it and</span><br><span class="line"> * recording in segment table (via CAS) if not already present.</span><br><span class="line"> *</span><br><span class="line"> * @param k the index</span><br><span class="line"> * @return the segment</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;</span><br><span class="line">    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    &#x2F;&#x2F; 判断 u 位置的 Segment 是否为null</span><br><span class="line">    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto &#x3D; ss[0]; &#x2F;&#x2F; use segment 0 as prototype</span><br><span class="line">        &#x2F;&#x2F; 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span><br><span class="line">        int cap &#x3D; proto.table.length;</span><br><span class="line">        &#x2F;&#x2F; 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span><br><span class="line">        float lf &#x3D; proto.loadFactor;</span><br><span class="line">        &#x2F;&#x2F; 计算扩容阀值</span><br><span class="line">        int threshold &#x3D; (int)(cap * lf);</span><br><span class="line">        &#x2F;&#x2F; 创建一个 cap 容量的 HashEntry 数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; recheck</span><br><span class="line">            &#x2F;&#x2F; 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span><br><span class="line">            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            &#x2F;&#x2F; 自旋检查 u 位置的 Segment 是否为null</span><br><span class="line">            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 使用CAS 赋值，只会成功一次</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment.</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>Segment.put 插入 key,value 值。</p></li></ol><p>上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F; 计算要put的数据位置</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        &#x2F;&#x2F; CAS 获取 index 坐标的值</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                &#x2F;&#x2F; 容量大于扩容阀值，小于最大容量，进行扩容</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    &#x2F;&#x2F; index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li><p>tryLock() 获取锁，获取不到使用 <strong><code>scanAndLockForPut</code></strong> 方法继续获取。</p></li><li><p>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</p></li><li><p>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。</p><p>如果这个位置上的 <strong>HashEntry 不存在</strong>：</p><ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接头插法插入。</li></ol><p>如果这个位置上的 <strong>HashEntry 存在</strong>：</p><ol><li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li><li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ol><li>如果当前容量大于扩容阀值，小于最大容量，<strong>进行扩容</strong>。</li><li>直接链表头插法插入。</li></ol></li></ol></li><li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.</p></li></ol><p>这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; null;</span><br><span class="line">    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node</span><br><span class="line">    &#x2F;&#x2F; 自旋获取锁</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                retries &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key.equals(e.key))</span><br><span class="line">                retries &#x3D; 0;</span><br><span class="line">            else</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            &#x2F;&#x2F; 自旋达到指定次数后，阻塞等到只到获取到锁</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;</span><br><span class="line">            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed</span><br><span class="line">            retries &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-扩容-rehash"><a href="#4-扩容-rehash" class="headerlink" title="4. 扩容 rehash"></a>4. 扩容 rehash</h3><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F; 老容量</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    &#x2F;&#x2F; 新容量，扩大两倍</span><br><span class="line">    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;</span><br><span class="line">    &#x2F;&#x2F; 新的扩容阀值 </span><br><span class="line">    threshold &#x3D; (int)(newCapacity * loadFactor);</span><br><span class="line">    &#x2F;&#x2F; 创建新的数组</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable &#x3D; (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    &#x2F;&#x2F; 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span><br><span class="line">    int sizeMask &#x3D; newCapacity - 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历老数组</span><br><span class="line">        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            &#x2F;&#x2F; 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span><br><span class="line">            int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line">            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F;  Single node on list</span><br><span class="line">                &#x2F;&#x2F; 如果当前位置还不是链表，只是一个元素，直接赋值</span><br><span class="line">                newTable[idx] &#x3D; e;</span><br><span class="line">            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot</span><br><span class="line">                &#x2F;&#x2F; 如果是链表了</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">                int lastIdx &#x3D; idx;</span><br><span class="line">                &#x2F;&#x2F; 新的位置只可能是不便或者是老的位置+老的容量。</span><br><span class="line">                &#x2F;&#x2F; 遍历结束后，lastRun 后面的元素位置都是相同的</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last &#x3D; next; last !&#x3D; null; last &#x3D; last.next) &#123;</span><br><span class="line">                    int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">                    if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">                        lastIdx &#x3D; k;</span><br><span class="line">                        lastRun &#x3D; last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span><br><span class="line">                newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line">                &#x2F;&#x2F; Clone remaining nodes</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 遍历剩余元素，头插法到指定 k 位置。</span><br><span class="line">                    V v &#x3D; p.value;</span><br><span class="line">                    int h &#x3D; p.hash;</span><br><span class="line">                    int k &#x3D; h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 头插法插入新的节点</span><br><span class="line">    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] &#x3D; node;</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。</p><h3 id="5-get"><a href="#5-get" class="headerlink" title="5. get"></a>5. get</h3><p>到这里就很简单了，get 方法只需要两步即可。</p><ol><li>计算得到 key 的存放位置。</li><li>遍历指定位置查找相同 key 的 value 值。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h &#x3D; hash(key);</span><br><span class="line">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    &#x2F;&#x2F; 计算得到 key 的存放位置</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class="line">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果是链表，遍历查找到相同 key 的 value。</span><br><span class="line">            K k;</span><br><span class="line">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img data-src="https://i.loli.net/2020/11/17/54tSzRX2UGPLWOk.png" loading="lazy"></p><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h3 id="2-初始化-initTable"><a href="#2-初始化-initTable" class="headerlink" title="2. 初始化 initTable"></a>2. 初始化 initTable</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        ／／　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br><span class="line">        if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class="line">            &#x2F;&#x2F; 让出 CPU 使用权</span><br><span class="line">            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table &#x3D; tab &#x3D; nt;</span><br><span class="line">                    sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl &#x3D; sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以发现 ConcurrentHashMap 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有N-1个线程正在进行扩容</li><li>表示 table 初始化大小，如果 table 没有初始化</li><li>表示 table 容量，如果 table　已经初始化。</li></ol><h3 id="3-put-1"><a href="#3-put-1" class="headerlink" title="3. put"></a>3. put</h3><p>直接过一遍 put 源码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    &#x2F;&#x2F; key 和 value 不能为空</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        &#x2F;&#x2F; f &#x3D; 目标位置元素</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;&#x2F;&#x2F; fh 后面存放目标位置的元素 hash 值</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;&#x2F; 数组桶为空，初始化数组桶（自旋+CAS)</span><br><span class="line">            tab &#x3D; initTable();</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span><br><span class="line">            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;  &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; 使用 synchronized 加锁加入节点</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 说明是链表</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        &#x2F;&#x2F; 循环加入新的或者覆盖节点</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 红黑树</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount &#x3D; 2;</span><br><span class="line">                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) !&#x3D; null) &#123;</span><br><span class="line">                            oldVal &#x3D; p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val &#x3D; value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal !&#x3D; null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ol><h3 id="4-get"><a href="#4-get" class="headerlink" title="4. get"></a>4. get</h3><p>get 流程比较简单，直接过一遍源码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    &#x2F;&#x2F; key 所在的 hash 位置</span><br><span class="line">    int h &#x3D; spread(key.hashCode());</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果指定位置元素存在，头结点hash值相同</span><br><span class="line">        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                &#x2F;&#x2F; key hash 值相等，key值相同，直接返回元素 value</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            &#x2F;&#x2F; 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span><br><span class="line">            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">        while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 是链表，遍历查找</span><br><span class="line">            if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下 get 过程：</p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之。</li></ol><p>总结：</p><p>总的来说 ConcruuentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><p>有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的<strong>锁升级</strong>。</p><h4 id="1-ConcurrentHashMap-和-Hashtable-的区别"><a href="#1-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="1.ConcurrentHashMap 和 Hashtable 的区别"></a>1.ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。底层数据结构： JDK1.7的 ConcurrentHashMap 底层采⽤ 分段的数组+链表 实现，JDK1.8 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊⼆叉树。Hashtable 和 JDK1.8 之前的HashMap 的底层数据结构类似都是采⽤ 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的；实现线程安全的⽅式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进⾏了分割分段(Segment)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和CAS 来操作。（JDK1.6以后对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同⼀把锁) :使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。</p><h4 id="2-synchronized关键字"><a href="#2-synchronized关键字" class="headerlink" title="2.synchronized关键字"></a>2.synchronized关键字</h4><p>解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。<strong>庆幸的是在 Java 6 之后 Java 官⽅对从 JVM 层⾯</strong>对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。J<strong>DK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</strong></p><h4 id="3-synchronized-关键字和-volatile-关键字区别"><a href="#3-synchronized-关键字和-volatile-关键字区别" class="headerlink" title="3.synchronized 关键字和 volatile 关键字区别"></a>3.synchronized 关键字和 volatile 关键字区别</h4><p>synchronized 关键字和 volatile 关键字是两个互补的存在，⽽不是对⽴的存在！</p><p>volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定⽐ synchronized 关键字要好。但是volatile 关键字只能⽤于变量⽽ synchronized 关键字可以修饰⽅法以及代码块。<strong>volatile 关键字能保证数据的可⻅性，但</strong>不能保证数据的原⼦性。<strong>synchronized 关键字两者都能保证。</strong></p><p>volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性</p><p>⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性。</p><h4 id="4-ConcurrentHashmap不支持key或者value为null"><a href="#4-ConcurrentHashmap不支持key或者value为null" class="headerlink" title="4.ConcurrentHashmap不支持key或者value为null"></a>4.ConcurrentHashmap不支持key或者value为null</h4><p>ConcurrentHashmap HashMap和Hashtable都是key-value存储结构，但他们有一个不同点是 ConcurrentHashmap、Hashtable不支持key或者value为null，而HashMap是支持的。为什么会有这个区别？在设计上的目的是什么？</p><p>ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。</p><p>key不能为空，因为采用了fail-safe机制，这种机制会使得读取的数据不一定是最新的，使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，HashTable同理。故在入参时，若为 null 就报空指针异常，而且在取hashcode时，压根就没考虑空的情况。</p><pre><code>/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123;    if (key == null || value == null) throw new NullPointerException();    int hash = spread(key.hashCode());    int binCount = 0;    ......&#125;</code></pre>]]></content>
    
    
    <summary type="html">详细从源码解析ConcurrentHashMap</summary>
    
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="JUC" scheme="https://yuhaicheng.xyz/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="https://yuhaicheng.xyz/2020-11-17-HashMap.html"/>
    <id>https://yuhaicheng.xyz/2020-11-17-HashMap.html</id>
    <published>2020-11-17T14:05:14.000Z</published>
    <updated>2020-12-01T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap</p><h3 id="HashMap-概述"><a href="#HashMap-概述" class="headerlink" title="HashMap 概述"></a>HashMap 概述</h3><p>HashMap 是 Map 接口的实现，HashMap 允许空的 key-value 键值对，HashMap 被认为是 Hashtable 的增强版，HashMap 是一个非线程安全的容器，如果想构造线程安全的 Map 考虑使用 ConcurrentHashMap。HashMap 是无序的，因为 HashMap 无法保证内部存储的键值对的有序性。</p><p>HashMap 的底层数据结构是数组 + 链表的集合体，数组在 HashMap 中又被称为<code>桶(bucket)</code>。遍历 HashMap 需要的时间损耗为 HashMap 实例桶的数量 + (key - value 映射) 的数量。因此，如果遍历元素很重要的话，不要把初始容量设置的太高或者负载因子设置的太低。</p><p>HashMap 实例有两个很重要的因素，初始容量和负载因子，初始容量指的就是 hash 表桶的数量，负载因子是一种衡量哈希表填充程度的标准，当哈希表中存在足够数量的 entry，以至于超过了负载因子和当前容量，这个哈希表会进行 rehash 操作，内部的数据结构重新 rebuilt。</p><p>注意 HashMap 不是线程安全的，如果多个线程同时影响了 HashMap ，并且至少一个线程修改了 HashMap 的结构，那么必须对HashMap 进行同步操作。可以使用 <code>Collections.synchronizedMap(new HashMap)</code> 来创建一个线程安全的 Map。</p><p>HashMap 会导致除了迭代器本身的 remove 外，外部 remove 方法都可能会导致 fail-fast 机制，因此尽量要用迭代器自己的 remove 方法。如果在迭代器创建的过程中修改了 map 的结构，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><h3 id="1-HashMap-中的构造函数："><a href="#1-HashMap-中的构造函数：" class="headerlink" title="1.HashMap 中的构造函数："></a>1.HashMap 中的构造函数：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial </span></span><br><span class="line"><span class="string">capacity: &quot;</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">                                               </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    <span class="comment">//最终也会调用到上面的构造函数，不过这个默认的负载因子就是 HashMap 的默认负载因子也就是 0.75f</span></span><br><span class="line">    &#125;</span><br><span class="line">                                               </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//默认初始值为16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class="comment">//带有 Map 的构造函数，会直接把外部元素批量放入 HashMap 中。</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">                                               </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">// 默认加载因子0.75；</span></span><br><span class="line"><span class="comment">//HashMap默认初始容量16，加载因子0.75，也就是说最多能放16*0.75=12个元素，当put第13个时，HashMap</span></span><br><span class="line"><span class="comment">//将发生rehash，rehash的一系列处理比较影响性能，所以当我们需要向HashMap存放较多元素时，最好指定合</span></span><br><span class="line"><span class="comment">//适的初始容量和加载因子，否则HashMap默认只能存12个元素，将会发生多次rehash操作。                                               </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16;默认初始容量为16，</span></span><br><span class="line"><span class="comment">//这里是不是有个疑问？int 占用四个字节，按说最大容量应该是左移 31 位，为什么 HashMap 最大容量是左移 30 位呢？因为在数值计算中</span></span><br><span class="line"><span class="comment">//最高位也就是最左位的位 是代表着符号为，0 -&gt; 正数，1 -&gt; 负数，容量不可能是负数，所以 HashMap 最高位只能移位到 2 ^ 30 次幂。                                                                                                </span></span><br></pre></td></tr></table></figure><h3 id="2-HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩"><a href="#2-HashMap-为什么总是使⽤2的幂作为哈希表的⼤⼩" class="headerlink" title="2.HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩"></a>2.HashMap 为什么总是使⽤2的幂作为哈希表的⼤⼩</h3><ol><li>HashMap<strong>在确定数组下标Index的时候</strong>，采用的是( length-1) &amp; hash 的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，因为只要输入的Hash值本身分布均匀，Hash算法的结果就是均匀的。所以HashMap规定了其容量必须是2的n次方.</li><li>由于HashMap规定了其<strong>容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小</strong>。使用位运算同时还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运算符表示就是 1 &lt;&lt; 30，<strong>int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</strong></li></ol><p><strong>下⾯这个⽅法（tableSizeFor）保证了 HashMap 总是使⽤2的幂作为哈希表的⼤⼩，也就是说但你创建一个大小不是2的幂的大小，最后会给你返回一个离最近2的幂的大小的值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY </span><br><span class="line">: n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*  &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0</span></span><br><span class="line"><span class="comment">比如7的二进制是0111，7&gt;&gt;&gt;2表示右移2位，变成001，即为1</span></span><br><span class="line"><span class="comment">cap=8;n=7;n=0111  n|n&gt;&gt;&gt;1 = 0111 | 0011 = 0111 n|n&gt;&gt;&gt;2 0111 | 0001 = 0111</span></span><br><span class="line"><span class="comment">n|n&gt;&gt;&gt;4 0111 | 0000 = 0111 最后一步 return=n+1=8</span></span><br><span class="line"><span class="comment">综上可得，当hashMap指定初始值的时候，会调用tableSizeFor方法，总是返回2的n次方的值；</span></span><br><span class="line"><span class="comment">并且总是等于该算法接近该初始值并比它大的那个值;</span></span><br><span class="line"><span class="comment">就是让最高位的1后面的位全变为1。最后再让结果n+1，即得到了2的整数次幂的值了。当指定初始值入参</span></span><br><span class="line"><span class="comment">为0时，返回实际容量为1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//最大容量为2的30次方 </span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="3-HashMap-的数据结构"><a href="#3-HashMap-的数据结构" class="headerlink" title="3.HashMap 的数据结构"></a>3.HashMap 的数据结构</h3><p>JDK1.7 中，HashMap 采用<code>数组（位桶） + 链表</code>的实现，即使用<code>链表</code>来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多（哈希冲突），即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。</p><p>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。</p><p><strong>解决哈希冲突的方法：</strong></p><ol><li><p>开放定址法：使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。</p></li><li><p>再哈希法：同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。这种方法不易产生聚集，但增加了计算时间。</p></li><li><p>链地址法：将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p></li><li><p>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><p><strong>红黑树：</strong></p></li></ol><p>红黑树是AVL树的变种，红黑树通过一些着色法则确保没有一条路径会比其它路径长出两倍，因而达到接近平衡的目的。所谓红黑树，不仅是一个二叉搜索树，而且必须满足一下规则：<br>   1、每个节点不是红色就是黑色。<br>   2、根节点为黑色。<br>   3、如果节点为红色，其子节点必须为黑色。<br>   4、任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同。<br>上面的这些约束保证了这个树大致上是平衡的，这也决定了红黑树的插入、删除、查询等操作是比较快速的。 根据规则4，新增节点必须为红色；根据规则3，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形</p><p><strong>链表：</strong></p><p>HashMap中的链表是单链表</p><p>jdk1.7: <strong>数组的每个元素都是一个单链表的头节点</strong></p><p>jdk1.8: 树化操作的过程有点复杂，将原本的单链表转化为双向链表，再遍历这个双向链表转化为红黑树。</p><h3 id="4-HashMap-的-put-过程"><a href="#4-HashMap-的-put-过程" class="headerlink" title="4.HashMap 的 put 过程"></a>4.HashMap 的 put 过程</h3><p>大致过程如下，首先会使用 hash 方法计算对象的哈希码，根据哈希码来确定在数组（桶）中存放的位置，如果桶中没有 Node 节点则直接进行 put，如果对应桶已经有 Node 节点，会对链表长度进行分析，判断长度是否大于 8，如果链表长度小于 8 ，在 JDK1.7 前会使用头插法，在 JDK1.8 之后更改为尾插法。如果链表长度大于 8 会进行树化操作（并且数组长度大于64），把链表转换为红黑树，在红黑树上进行存储。</p><p>以 JDK 1.8 为基准进行分析，后面也是。先贴出整段代码，后面会逐行进行分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">// 如果table 为null 或者没有为 table 分配内存，就resize一次</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">// 指定hash值节点为空则直接插入，这个(n - 1) &amp; hash才是表中真正的哈希</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 如果不为空</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">// 计算表中的这个真正的哈希值与要插入的key.hash相比</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 若不同的话，并且当前节点已经在 TreeNode 上了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      <span class="comment">// 采用红黑树存储方式</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">// key.hash 不同并且也不再 TreeNode 上，在链表上找到 p.next==null</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 在表尾插入</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 新增节点后如果节点个数到达阈值，则进入 treeifyBin() 进行再次判断</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了同 hash、key 的节点，那么直接退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 更新 p 指向下一节点</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map中含有旧值，返回旧值</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map调整次数 + 1</span></span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">// 键值对的数量达到阈值，需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下 <code>putVal</code> 方法，这个方法是 final 的，如果你自已定义 HashMap 继承的话，是不允许你自己重写 put 方法的，然后这个方法涉及五个参数</p><ul><li>hash -&gt; put 放在桶中的位置，在 put 之前，会进行 hash 函数的计算。</li><li>key -&gt; 参数的 key 值</li><li>value -&gt; 参数的 value 值</li><li>onlyIfAbsent -&gt; 是否改变已经存在的值，也就是是否进行 value 值的替换标志</li><li>evict -&gt; 是否是刚创建 HashMap 的标志</li></ul><p>在调用到 putVal 方法时，<strong>首先会进行 hash 函数计算应该插入的位置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希函数的源码如下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK1.8 之前 HashMap 底层是 数组和链表 结合在⼀起使⽤也就是 链表散列。HashMap 通过 key 的</span></span><br><span class="line">    <span class="comment">//hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置</span></span><br><span class="line"> <span class="comment">//（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash</span></span><br><span class="line"><span class="comment">//值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</span></span><br><span class="line"><span class="comment">//所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现</span></span><br><span class="line"><span class="comment">//⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少碰撞。</span></span><br></pre></td></tr></table></figure><p>首先先来理解一下 hash 函数的计算规则</p><p>Hash 函数</p><p>hash 函数会根据你传递的 key 值进行计算，首先计算 key 的 <code>hashCode</code> 值，然后再对 hashcode 进行无符号右移操作，最后再和 hashCode 进行<code>异或 ^</code> 操作。</p><blockquote><p><code>&gt;&gt;&gt;</code>: 无符号右移操作，它指的是 <strong>无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong> ，也就是不管是正数还是负数，右移都会在空缺位补 0 。</p></blockquote><p>在得到 hash 值后，就会进行 put 过程。</p><p>首先会判断 HashMap 中的 Node 数组是否为 null，如果第一次创建 HashMap 并进行第一次插入元素，首先会进行数组的 resize，也就是<code>重新分配</code>，这里还涉及到一个 <code>resize()</code> 扩容机制源码分析，我们后面会介绍。</p><p><strong>扩容完毕后，会计算出 HashMap 的存放位置，通过使用 ( n - 1 ) &amp; hash 进行计算得出。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"> <span class="comment">// 1. HashMap在确定数组下标Index的时候，采用的是( length-1) &amp; hash      </span></span><br><span class="line"> <span class="comment">//的方式，只有当length为2的指数幂的时候才能较均匀的分布元素，所以HashMap规定了其容量必须是2的n次方</span></span><br><span class="line"> <span class="comment">// 2. 由于HashMap规定了其容量是2的n次方，所以我们采用位运算&lt;&lt;来控制HashMap的大小。使用位运算同时 </span></span><br><span class="line">     <span class="comment">//还提高了Java的处理速度。HashMap内部由Entry[]数组构成，Java的数组下标是由Int表示的。所以对于           </span></span><br><span class="line">     <span class="comment">//HashMap来说其最大的容量应该是不超过int最大值的一个2的指数幂，而最接近int最大值的2个指数幂用位运</span></span><br><span class="line">     <span class="comment">//算符表示就是 1 &lt;&lt; 30，int总共4字节，最高位是符号位，如果写成(1&lt;&lt;31)就变成负数了。</span></span><br></pre></td></tr></table></figure><p>然后会把这个位置作为数组的下标作为存放元素的位置。如果不为空，那么计算表中的这个真正的哈希值与要插入的 key.hash 相比。如果哈希值相同，key-value 不一样，再判断是否是树的实例，如果是的话，那么就把它插入到树上。如果不是，就执行尾插法在 entry 链尾进行插入。</p><h3 id="5-扩容机制"><a href="#5-扩容机制" class="headerlink" title="5.扩容机制"></a>5.扩容机制</h3><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。好在 HashMap 是一种自动扩容的数据结构，在这种基于变长的数据结构中，扩容机制是非常重要的。</p><p>在 HashMap 中，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。HashMap 中的扩容机制是由 <code>resize()</code> 方法来实现的，下面我们就来一次认识下。</p><p>HashMap 中有两个非常重要的变量，一个是 <code>loadFactor</code> ，一个是 <code>threshold</code> ，loadFactor 表示的就是负载因子，threshold 表示的是下一次要扩容的阈值，当 threshold = loadFactor * 数组长度时，数组长度扩大位原来的两倍，来重新调整 map 的大小，并将原来的对象放入新的 bucket 数组中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">// 存储old table 的大小</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">// 存储扩容阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果old table数据已达最大，那么threshold也被设置成最大</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左移扩大二倍,</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">// 扩容成原来二倍</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果oldThr                                                                                                                                               !&gt; 0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="comment">// 如果old table &lt;= 0 并且 存储的阈值 &lt;= 0</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果扩充阈值为0</span></span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 扩容阈值为 初始容量*负载因子</span></span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重新给负载因子赋值</span></span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="comment">// 获取扩容后的数组</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="comment">// 如果第一次进行table 初始化不会走下面的代码</span></span><br><span class="line">  <span class="comment">// 扩容之后需要重新把节点放在新扩容的数组中</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容机制源码比较长，我们耐心点进行拆分</p><p>我们以 if...else if...else 逻辑进行拆分，上面代码主要做了这几个事情</p><ul><li>判断 HashMap 中的数组的长度，也就是 <code>(Node&lt;K,V&gt;[])oldTab.length()</code> ，再判断数组的长度是否比最大的的长度也就是 2^30 次幂要大，大的话直接取最大长度，否则利用位运算 <code>&lt;&lt;</code>扩容为原来的两倍</li></ul><p><img data-src="https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135604592-1504962060.png" alt="img" loading="lazy"></p><ul><li>如果数组长度不大于0 ，再判断扩容阈值 <code>threshold</code> 是否大于 0 ，也就是看有无外部指定的扩容阈值，若有则使用，这里需要说明一下 threshold 何时是 <code>oldThr &gt; 0</code>，因为 oldThr = threshold ，这里其实比较的就是 threshold，因为 HashMap 中的每个构造方法都会调用 <code>HashMap(initCapacity,loadFactor)</code> 这个构造方法，所以如果没有外部指定 initialCapacity，初始容量使用的就是 16，然后根据 <code>this.threshold = tableSizeFor(initialCapacity);</code> .</li></ul><p><img data-src="https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135614686-238811487.png" alt="img" loading="lazy"></p><ul><li>否则，直接使用默认的初始容量和扩容阈值，走 else 的逻辑是在 table 刚刚初始化的时候。</li></ul><p><img data-src="https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135622150-1149800383.png" alt="img" loading="lazy"></p><p>然后会判断 newThr 是否为 0 ，笔者在刚开始研究时发现 <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code> 一直以为这是常量做乘法，怎么会为 0 ，其实不是这部分的问题，在于上面逻辑判断中的扩容操作，可能会导致<code>位溢出</code>。</p><p>导致位溢出的示例：oldCap = 2^28 次幂，threshold &gt; 2 的三次方整数次幂。在进入到 <code>float ft = (float)newCap * loadFactor;</code> 这个方法是 2^28 * 2^(3+n) 会直接 &gt; 2^31 次幂，导致全部归零。</p><p><strong>在扩容后需要把节点放在新扩容的数组中，这里也涉及到三个步骤</strong></p><ul><li>循环桶中的每个 Node 节点，判断 Node[i] 是否为空，为空直接返回，不为空则遍历桶数组，并将键值对映射到新的桶数组中。</li><li>如果不为空，再判断是否是树形结构，如果是树形结构则按照树形结构进行拆分，拆分方法在 <code>split</code> 方法中。</li><li>如果不是树形结构，则遍历链表，并将链表节点按原顺序进行分组。</li></ul><p><img data-src="https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135633904-751470058.png" alt="img" loading="lazy"></p><h3 id="6-讲一讲-get-方法全过程"><a href="#6-讲一讲-get-方法全过程" class="headerlink" title="6.讲一讲 get 方法全过程"></a>6.讲一讲 get 方法全过程</h3><p>我们上面讲了 HashMap 中的 put 方法全过程，下面我们来看一下 <code>get</code> 方法的过程</p><p>首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到真实的元素位置</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会check 一下第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">        ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是第一个元素，并且下一个元素不是空的</span></span><br><span class="line">    <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否属于 TreeNode，如果是 TreeNode 实例，直接从 TreeNode.getTreeNode 取</span></span><br><span class="line">      <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果还不是 TreeNode 实例，就直接循环数组元素，直到找到指定元素位置</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来简单介绍下吧，首先会检查 table 中的元素是否为空，然后根据 hash 算出指定 key 的位置。然后检查链表的第一个元素是否为空，如果不为空，是否匹配，如果匹配，直接返回这条记录；如果匹配，再判断下一个元素的值是否为 null，为空直接返回，如果不为空，再判断是否是 <code>TreeNode</code> 实例，如果是 TreeNode 实例，则直接使用 <code>TreeNode.getTreeNode</code> 取出元素，否则执行循环，直到下一个元素为 null 位置。</p><p><code>getNode</code> 方法有一个比较重要的过程就是 <strong>(n - 1) &amp; hash</strong>，这段代码是确定需要查找的桶的位置的，那么，为什么要 (n - 1) &amp; hash 呢？</p><p>n 就是 HashMap 中桶的数量，这句话的意思也就是说 (n - 1) &amp; hash 就是 (桶的容量 - 1) &amp; hash</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么 HashMap 的检索位置是 (table.size - 1) &amp; hash</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debug 得知 1 的 hash 值算出来是 49</span></span><br><span class="line">  map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line">  <span class="comment">// debug 得知 1 的 hash 值算出来是 50</span></span><br><span class="line">  map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line">  <span class="comment">// debug 得知 1 的 hash 值算出来是 51</span></span><br><span class="line">  map.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么每次算完之后的 (n - 1) &amp; hash ，依次为</p><p><img data-src="https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135651991-667806972.png" alt="img" loading="lazy"></p><p>也就是 <strong>tab[(n - 1) &amp; hash]</strong> 算出的具体位置。</p><h3 id="7-HashMap-的遍历方式"><a href="#7-HashMap-的遍历方式" class="headerlink" title="7.HashMap 的遍历方式"></a>7.HashMap 的遍历方式</h3><p>HashMap 的遍历，也是一个使用频次特别高的操作</p><p>HashMap 遍历的基类是 <code>HashIterator</code>，它是一个 Hash 迭代器，它是一个 HashMap 内部的抽象类，它的构造比较简单，只有三种方法，<strong>hasNext 、 remove 和 nextNode</strong> 方法，其中 nextNode 方法是由三种迭代器实现的</p><p>这三种迭代器就就是</p><ul><li><code>KeyIterator</code> ，对 key 进行遍历</li><li><code>ValueIterator</code>，对 value 进行遍历</li><li><code>EntryIterator</code>， 对 Entry 链进行遍历</li></ul><p>虽然说看着迭代器比较多，但其实他们的遍历顺序都是一样的，构造也非常简单，都是使用 <code>HashIterator</code> 中的 <code>nextNode</code> 方法进行遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashIterator 中的遍历方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; next;        <span class="comment">// 下一个 entry 节点</span></span><br><span class="line">  Node&lt;K,V&gt; current;     <span class="comment">// 当前 entry 节点</span></span><br><span class="line">  <span class="keyword">int</span> expectedModCount;  <span class="comment">// fail-fast 的判断标识</span></span><br><span class="line">  <span class="keyword">int</span> index;             <span class="comment">// 当前槽</span></span><br><span class="line"></span><br><span class="line">  HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = <span class="keyword">null</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">      <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next 和 current 分别表示下一个 Node 节点和当前的 Node 节点，HashIterator 在初始化时会遍历所有的节点。下面我们用图来表示一下他们的遍历顺序</p><p><img data-src="https://img2020.cnblogs.com/blog/1515111/202006/1515111-20200623135703898-308748730.png" alt="img" loading="lazy"></p><p>你会发现 <code>nextNode()</code> 方法的遍历方式和 HashIterator 的遍历方式一样，只不过判断条件不一样，构造 HashIterator 的时候判断条件是有没有链表，桶是否为 null，而遍历 nextNode 的判断条件变为下一个 node 节点是不是 null ，并且桶是不是为 null。</p><h3 id="8-HashMap-中的移除方法"><a href="#8-HashMap-中的移除方法" class="headerlink" title="8.HashMap 中的移除方法"></a>8.HashMap 中的移除方法</h3><p>HashMap 中的移除方法也比较简单了，源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">    <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      node = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key ||</span><br><span class="line">               (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            node = e;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          p = e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                         (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">        tab[index] = node.next;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        p.next = node.next;</span><br><span class="line">      ++modCount;</span><br><span class="line">      --size;</span><br><span class="line">      afterNodeRemoval(node);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法有很多，最终都会调用到 removeNode 方法，只不过传递的参数值不同，我们拿 remove(object) 来演示一下。</p><p>首先会通过 hash 来找到对应的 bucket，然后通过遍历链表，找到键值相等的节点，然后把对应的节点进行删除。</p><h3 id="9-HashMap-为啥线程不安全"><a href="#9-HashMap-为啥线程不安全" class="headerlink" title="9.HashMap 为啥线程不安全"></a>9.HashMap 为啥线程不安全</h3><p>HashMap 不是一个线程安全的容器，不安全性体现在多线程并发对 HashMap 进行 put 操作上。如果有两个线程 A 和 B ，首先 A 希望插入一个键值对到 HashMap 中，在决定好桶的位置进行 put 时，此时 A 的时间片正好用完了，轮到 B 运行，B 运行后执行和 A 一样的操作，只不过 B 成功把键值对插入进去了。如果 A 和 B 插入的位置（桶）是一样的，那么线程 A 继续执行后就会覆盖 B 的记录，造成了数据不一致问题。</p><p>还有一点在于 HashMap 在扩容时，因 resize 方法会形成环，造成死循环，导致 CPU 飙高。</p><h3 id="10-HashMap-是如何处理哈希碰撞的"><a href="#10-HashMap-是如何处理哈希碰撞的" class="headerlink" title="10.HashMap 是如何处理哈希碰撞的"></a>10.HashMap 是如何处理哈希碰撞的</h3><p>HashMap 底层是使用位桶 + 链表实现的，位桶决定元素的插入位置，位桶是由 hash 方法决定的，当多个元素的 hash 计算得到相同的哈希值后，HashMap 会把多个 Node 元素都放在对应的位桶中，形成链表，这种处理哈希碰撞的方式被称为链地址法。</p><p>其他处理 hash 碰撞的方式还有 <strong>开放地址法、rehash 方法、建立一个公共溢出区</strong>这几种方法。</p><h3 id="11-HashMap-线程安全的实现有哪些"><a href="#11-HashMap-线程安全的实现有哪些" class="headerlink" title="11.HashMap 线程安全的实现有哪些"></a>11.HashMap 线程安全的实现有哪些</h3><p>因为 HashMap 不是一个线程安全的容器，所以并发场景下推荐使用 <code>ConcurrentHashMap</code> ，或者使用线程安全的 HashMap，使用 <code>Collections</code> 包下的线程安全的容器，比如说</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure><p>还可以使用 HashTable ，它也是线程安全的容器，基于 key-value 存储，经常用 HashMap 和 HashTable 做比较就是因为 HashTable 的数据结构和 HashMap 相同。</p><p>上面效率最高的就是 ConcurrentHashMap。</p><h3 id="11-HashMap和Hashtable的区别"><a href="#11-HashMap和Hashtable的区别" class="headerlink" title="11.HashMap和Hashtable的区别:"></a>11.HashMap和Hashtable的区别:</h3><ol><li><p>线程是否安全： HashMap 是⾮线程安全的，Hashtable 是线程安全的；<strong>Hashtable 内部的⽅法基本都经过 synchronized 修饰</strong>。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap吧！）；</p></li><li><p>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，Hashtable 基本被淘汰，不要在代码中使⽤它；</p></li><li><p>对Null key 和Null value的⽀持： HashMap 中，null 可以作为键，这样的键只有⼀个，可以有⼀个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有⼀个 null，直接抛出 NullPointerException。</p></li></ol><ol start="4"><li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ①<strong>创建时如果不指定容量初始值，Hashtable 默认的初始⼤⼩为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化⼤⼩为16。之后每次扩充（resize（）），容量变为原来的2倍</strong>。②创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为2的幂次⽅⼤⼩（HashMap 中的 <strong>tableSizeFor</strong>()⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤2的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是2的幂次⽅。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时(将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树），将链表转化为红⿊树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。</li></ol><h5 id="HashMap中的key可以是任何对象或数据类型吗"><a href="#HashMap中的key可以是任何对象或数据类型吗" class="headerlink" title="HashMap中的key可以是任何对象或数据类型吗"></a><strong>HashMap中的key可以是任何对象或数据类型吗</strong></h5><ul><li><strong>可以为null，但不能是可变对象</strong>，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li><li><strong>如果可变对象在 HashMap 中被用作键</strong>，<strong>那就要小心在改变对象状态的时候，不要改变它的哈希值了</strong>。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li></ul>]]></content>
    
    
    <summary type="html">详细从源码解析HashMap</summary>
    
    
    
    <category term="集合" scheme="https://yuhaicheng.xyz/categories/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Map" scheme="https://yuhaicheng.xyz/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>SSM中的过滤器和拦截器</title>
    <link href="https://yuhaicheng.xyz/2020-11-13-SSM%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
    <id>https://yuhaicheng.xyz/2020-11-13-SSM%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8.html</id>
    <published>2020-11-17T07:05:14.000Z</published>
    <updated>2020-12-17T08:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器-Filter-和拦截器-Interceptor"><a href="#过滤器-Filter-和拦截器-Interceptor" class="headerlink" title="过滤器(Filter)和拦截器(Interceptor)"></a>过滤器(Filter)和拦截器(Interceptor)</h3><p>过滤器(Filter)和拦截器(Interceptor)都是可以作用于若干种不同的请求路径的组件，都可以对某种请求进行阻止，不允许继续向后执行，也可以选择放行，按照原本设定的处理流程继续执行！并且，在同一个项目中，允许同时存在若干个过滤器或拦截器，以形成过滤器链或拦截器链，如果某个请求涉及多个过滤器或拦截器，必须每个过滤器或拦截器都放行，才可以继续执行！</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li>过滤器是Java EE中的组件，而拦截器是SpringMVC中的组件！只要是Java EE(web)项目，都可以使用过滤器，但是，只有使用了SpringMVC框架，才可以使用拦截器，并且，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！</li><li>过滤器和拦截器的执行时间节点、执行的方法的数量都不相同，过滤器是在所有Servlet组件之前执行的！而拦截器的第1次执行是在DispatcherServlet之后，且在Controller组件之前执行的，而且，当拦截器选择“放行”时，在Controller执行之后，和执行最终的响应之前，还会各执行1次！</li><li>过滤器和拦截器的配置也不相同，过滤器是在<strong>web.xml</strong>中配置的，在配置过程中，可以配置若干个请求路径，也可以使用星号(*)作为通配符，但是，无法配置例外路径（白名单），而拦截器是在Spring的配置文件中进行配置的，其配置方式非常灵活，可以配置若干个请求路径，也可以使用通配符，还可以配置若干个例外路径！</li></ol><p>在一般情况下，我们更关注项目的管理，由于过滤器和拦截器都会出现在真正处理请求的组件之前，所以，都可以实现“阻止”和“放行”的效果，那么，哪个简单、易用、功能更强大，就使用哪个！所以，更优先推荐使用拦截器解决项目中的问题！但是，这也并不代表拦截器就可以完全取代过滤器，例如，某些处理过程应该出现在更早的执行时间节点，就必须使用过滤器，而不能使用拦截器！</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p><p>过滤器</p><ul><li>servlet规范中的一部分，任何java web工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对<strong>所有要访问的资源</strong>进行拦截</li></ul><p>拦截器</p><ul><li>拦截器是springMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器只会<strong>拦截访问的控制器方法</strong>，仅当被SpringMVC框架处理的请求才可能被拦截器进行处理，例如使用SpringMVC框架时，将DispatcherServlet处理请求的路径设置为*.do，则只有以.do作为后缀的请求才可能被拦截器处理！，如果访问的是jsp/html/css/image/js是不会进行拦截</li></ul>]]></content>
    
    
    <summary type="html">过滤器和拦截器的区别</summary>
    
    
    
    <category term="SSM" scheme="https://yuhaicheng.xyz/categories/SSM/"/>
    
    
    <category term="SSM框架" scheme="https://yuhaicheng.xyz/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
