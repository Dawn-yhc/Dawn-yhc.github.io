<!DOCTYPE html>
<html lang="zh-CN,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="1111RcBkV43JHcyiH4z1Yk2xu-mqlS1fQNk5Dzv7_q0">
  <meta name="msvalidate.01" content="1111BC77E02800759CE29C4ACCE487BD">
  <meta name="yandex-verification" content="11112a93328de5da">
  <meta name="baidu-site-verification" content="1111-wFDrn4lvkD">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuhaicheng.xyz","root":"/","scheme":"Gemini","version":"8.0.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="null">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM垃圾回收+多线程">
<meta property="og:url" content="https://yuhaicheng.xyz/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">
<meta property="og:site_name" content="曙光苑">
<meta property="og:description" content="null">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/11/06/8LZ5c9TNjwvnHRF.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/i3vfuLBRtVydUc4.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/GuPFaKpw6iLcV7z.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/jBbFgwu3Q5yfZsR.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/epE8AaUqD1CYnj2.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/CsQVw6y7xSzthai.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/Q8jx3FaohNR5G4D.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/jHqgf4yWZR3unL7.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/XLRkuels7qVa3SN.png">
<meta property="article:published_time" content="2020-11-11T02:05:14.000Z">
<meta property="article:modified_time" content="2020-11-26T02:37:40.921Z">
<meta property="article:author" content="Dawn-yhc">
<meta property="article:tag" content="垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/11/06/8LZ5c9TNjwvnHRF.png">


<link rel="canonical" href="https://yuhaicheng.xyz/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM垃圾回收+多线程 | 曙光苑</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-108155018-3"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-108155018-3');
      }
    </script>






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="曙光苑" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">曙光苑</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">有朋自远方来，不亦乐乎</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">46</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-baidusitemap">

    <a href="/baidusitemap.xml" rel="section"><i class="fa fa-cloud fa-fw"></i>百度站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81JVM"><span class="nav-number">1.1.</span> <span class="nav-text">一、JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%B7%B2%E7%BB%8F%E6%AD%BB%E4%BA%A1%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6%E4%BA%86%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1如何判断哪些对象已经死亡了，可以回收了？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.垃圾回收算法都有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.垃圾收集器都有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A0-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Ⅰ.新生代垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Ⅱ.老年代垃圾回收器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">二、多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.什么是进程和线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.多线程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.什么是线程安全？线程安全级别有什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.怎么保证线程安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.5.</span> <span class="nav-text">5.多线程的实现方式和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">6.怎么启动多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">7.有几种线程池,是怎么实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E8%AF%B4%E8%AF%B4-sleep-%E2%BD%85%E6%B3%95%E5%92%8C-wait-%E2%BD%85%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.2.8.</span> <span class="nav-text">8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E2%BD%A4-start-%E2%BD%85%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E2%BE%8F-run-%E2%BD%85%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E2%BD%A4run-%E2%BD%85%E6%B3%95%EF%BC%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dawn-yhc"
      src="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg">
  <p class="site-author-name" itemprop="name">Dawn-yhc</p>
  <div class="site-description" itemprop="description">JAVA、技术</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhd24teWhjLw==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dawn-yhc&#x2F;"><i class="fab fa-github fa-fw"></i></span>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93ZWlsaW5pbmcuZ2l0aHViLmlv" title="https:&#x2F;&#x2F;weilining.github.io">Ln</span>
        </li>
    </ul>
  </div>

  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.html" title="面试记录.html"></a>
        </li>
    </ul>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/time.js" async="async"></script>


<div id="binft"class="links-of-recent-posts motion-element"></div>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/word.js" async="async"></script>
      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhd24teWhjL0Rhd24teWhjLmdpdGh1Yi5pbw==" title="Fork NexT on GitHub" aria-label="Fork NexT on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuhaicheng.xyz/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/weilining/blog.io/images/logo.svg">
      <meta itemprop="name" content="Dawn-yhc">
      <meta itemprop="description" content="JAVA、技术">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曙光苑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM垃圾回收+多线程<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhd24teWhjL0Rhd24teWhjLmdpdGh1Yi5pby9lZGl0L21haW4vc291cmNlL19wb3N0cy8yMDIwLTExLTExLUpWTeWeg+WcvuWbnuaUtivlpJrnur/nqIsubWQ=" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-11 10:05:14" itemprop="dateCreated datePublished" datetime="2020-11-11T10:05:14+08:00">2020-11-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-26 10:37:40" itemprop="dateModified" datetime="2020-11-26T10:37:40+08:00">2020-11-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

            <div class="post-description"></div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="一、JVM"><a href="#一、JVM" class="headerlink" title="一、JVM"></a>一、JVM</h2><h3 id="1如何判断哪些对象已经死亡了，可以回收了？"><a href="#1如何判断哪些对象已经死亡了，可以回收了？" class="headerlink" title="1如何判断哪些对象已经死亡了，可以回收了？"></a>1如何判断哪些对象已经死亡了，可以回收了？</h3><p><strong>1.使用引用计数法</strong></p>
<p>给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。</p>
<p>总结：但是原始引用计数无法解决循环引用的问题</p>
<p><strong>2.可达性分析算法</strong></p>
<p>这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。</p>
<p>在Java 语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<h3 id="2-垃圾回收算法都有哪些？"><a href="#2-垃圾回收算法都有哪些？" class="headerlink" title="2.垃圾回收算法都有哪些？"></a>2.垃圾回收算法都有哪些？</h3><p><strong>1.标记-清除算法</strong></p>
<p>该算法分为“标记”和“清除”两个阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的象。它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到的。</p>
<p>这种垃圾收集算法会带来两个明显的问题：</p>
<ul>
<li>效率问题</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/06/8LZ5c9TNjwvnHRF.png" alt="图片" loading="lazy"></p>
<p><strong>2.复制算法</strong></p>
<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。</p>
<p>优点：解决了效率低的问题</p>
<p>缺点：造成空间的浪费，使用一块内存，真正只使用了他的一半</p>
<p><img data-src="https://i.loli.net/2020/11/06/i3vfuLBRtVydUc4.png" loading="lazy"></p>
<p><strong>3.标记-整理（压缩）算法</strong></p>
<p>根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，<strong>⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。</strong></p>
<p>优点：不会造成空间问题产生大量碎片</p>
<p>缺点：但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p>
<p><img data-src="https://i.loli.net/2020/11/06/GuPFaKpw6iLcV7z.png" loading="lazy"></p>
<p><strong>4.分代收集算法</strong></p>
<p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收呢，来看一下对象的分配有啥规律。</p>
<p><strong>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</strong></p>
<p>细节问题（敲黑板，咳咳）：</p>
<p>大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。</p>
<p><img data-src="https://i.loli.net/2020/11/06/jBbFgwu3Q5yfZsR.png" loading="lazy"></p>
<p><strong>分代收集工作原理</strong></p>
<p><strong>1、对象在新生代的分配与回收</strong></p>
<ol>
<li>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</li>
<li>当 Eden 区将满时，触发 Minor GC</li>
<li>我们之前怎么说来着，大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间</li>
<li>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</li>
<li>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</li>
</ol>
<p><strong>2、对象何时晋升老年代</strong></p>
<ul>
<li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li>
<li>年龄阈值设置为 15， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代！</li>
<li>大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代.</li>
<li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li>
</ul>
<p><strong>3、空间分配担保</strong></p>
<p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p>
<p><strong>4、Stop The World</strong></p>
<p>如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。</p>
<p>什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p>
<p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW,但只会触发轻微的 STW,因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p>
<p>现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p>
<p>由于 Full GC（或Minor GC） 会影响性能，<strong>所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，</strong>这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：</p>
<ul>
<li>循环的末尾</li>
<li>方法返回前</li>
<li>调用方法的 call 之后</li>
<li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li>
</ul>
<h3 id="3-垃圾收集器都有哪些？"><a href="#3-垃圾收集器都有哪些？" class="headerlink" title="3.垃圾收集器都有哪些？"></a>3.垃圾收集器都有哪些？</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器</p>
<p><img data-src="https://i.loli.net/2020/11/06/epE8AaUqD1CYnj2.png" loading="lazy"></p>
<ul>
<li>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge</li>
<li>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</li>
<li>同时在新老生代工作的垃圾回收器：G1</li>
</ul>
<p>图片中的垃圾收集器如果存在连线，则代表它们之间可以配合使用，接下来我们来看看各个垃圾收集器的具体功能。</p>
<h4 id="Ⅰ-新生代垃圾回收器"><a href="#Ⅰ-新生代垃圾回收器" class="headerlink" title="Ⅰ.新生代垃圾回收器"></a>Ⅰ.新生代垃圾回收器</h4><p><strong>1.Serial 收集器</strong></p>
<p>Serial收集器是工作在新生代的，<strong>单线程的垃圾收集器</strong>，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说<strong>在 GC 期间，此时的应用不可用。</strong></p>
<p>但是Serial收集器有没有优于其他垃圾收集器的地⽅呢？</p>
<p>当然有，它简单⽽⾼效（与其他收集器的单线程相⽐）。Serial收集器由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。Serial收集器对于运⾏在Client模式下的虚拟机来说是个不错的选择。</p>
<p><strong>2.ParNew 收集器</strong> </p>
<p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完全一样，在底层上，这两种收集器也共用了相当多的代码。</p>
<p><strong>ParNew 主要工作在 Server 模式</strong>，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为<strong>除了 Serial  收集器，只有它能与 CMS 收集器配合工作</strong>，CMS 是一个划时代的垃圾收集器，是真正意义上的<strong>并发收集器</strong>，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。</p>
<p>在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。</p>
<p><strong>3.Parallel Scavenge 收集器</strong> </p>
<p>Parallel Scavenge 收集器也是一个使用<strong>复制算法</strong>，<strong>多线程</strong>，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗</p>
<p><strong>关注点不同</strong>，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 <strong>Parallel Scavenge 目标是达到一个可控制的吞吐量（</strong>吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 <strong>CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。</strong></p>
<p>Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）</p>
<p>除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！</p>
<h4 id="Ⅱ-老年代垃圾回收器"><a href="#Ⅱ-老年代垃圾回收器" class="headerlink" title="Ⅱ.老年代垃圾回收器"></a>Ⅱ.老年代垃圾回收器</h4><p><strong>1.Serial Old 收集器</strong> </p>
<p>上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下</p>
<p><img data-src="https://i.loli.net/2020/11/06/CsQVw6y7xSzthai.png" loading="lazy"></p>
<p><strong>2.Parallel Old 收集器</strong> </p>
<p>Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标</p>
<p><img data-src="https://i.loli.net/2020/11/06/Q8jx3FaohNR5G4D.png" loading="lazy"></p>
<p><strong>3.CMS 收集器</strong> </p>
<p>CMS（Concurrent Mark Sweep）收集器是⼀种以<strong>获取最短回收停顿时间为⽬标的收集器</strong>。它⽽⾮常符合在注重⽤户体验的应⽤上使⽤。<br>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第⼀款真正意义上的并发收集器，它第⼀次实现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。</p>
<p>我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤：</p>
<ol>
<li>初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li>
<li>并发标记：同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以GC线程⽆法保证可达性分析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。</li>
<li>重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对象的标记记录，这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短</li>
<li>并发清除：开启⽤户线程，同时GC线程开始对为标记的区域做清扫。</li>
</ol>
<p><img data-src="https://i.loli.net/2020/11/06/jHqgf4yWZR3unL7.png" loading="lazy"></p>
<p>从它的名字就可以看出它是⼀款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下⾯三个明显的缺点：</p>
<ul>
<li>对CPU资源敏感；</li>
<li>⽆法处理浮动垃圾；</li>
<li>它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。</li>
</ul>
<p><strong>4.G1（Garbage First） 收集器</strong></p>
<p>G1 (Garbage-First)是⼀款⾯向服务器的垃圾收集器,被称为驾驭一切的垃圾回收器；主要针对配备多颗处理器及⼤容量内存的机器以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征.</p>
<p>G1 收集器的工作步骤如下</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
<p><img data-src="https://i.loli.net/2020/11/06/XLRkuels7qVa3SN.png" loading="lazy"></p>
<p>G1收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的Region也就是它的名字Garbage-First的由来)。这种使⽤Region划分内存空间以及有优先级的区域回收⽅式保证了GF收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。</p>
<h2 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h2><h3 id="1-什么是进程和线程？"><a href="#1-什么是进程和线程？" class="headerlink" title="1.什么是进程和线程？"></a>1.什么是进程和线程？</h3><p>进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</p>
<p>线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。</p>
<p>举个例子：进程和线程区别，用java内存区域来说；线程与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。</p>
<h3 id="2-多线程是什么？"><a href="#2-多线程是什么？" class="headerlink" title="2.多线程是什么？"></a>2.多线程是什么？</h3><p>提到多线程这里要说两个概念，就是<strong>串行和并行</strong>，搞清楚这个我们才能更好的理解多线程。</p>
<p>所谓串行其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子，我们下载多个文件，在串行中它是按照一定的顺序去进行下载的，也就是说必须等下载完A之后，才能开始下载B，它们在时间上是不可能发生重叠的。</p>
<p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的在同一时刻发生的，并行在时间上是重叠的。</p>
<p>了解了这两个概念之后我们再来说说什么是多线程，举个例子，我们打开腾讯管家，腾讯管家本身就是一个程序也就是说它就是一个进程，它里面有很多的功能，能查杀病毒、清理垃圾、电脑加速等众多功能，按照单线程来说，你想要清理垃圾还要病毒查杀，那么你必须先做完其中的一件事才能做下一件事，是有一个执行的顺序的，如果是多线程的话，我们其实在清理垃圾的时候还可以查杀病毒、电脑加速等等其他的操作，这个是严格意义上的同一时刻发生的，没有执行的先后顺序。</p>
<p><strong>所以：多线程就是一个进程运行中产生了多个线程</strong></p>
<h3 id="3-什么是线程安全？线程安全级别有什么？"><a href="#3-什么是线程安全？线程安全级别有什么？" class="headerlink" title="3.什么是线程安全？线程安全级别有什么？"></a>3.什么是线程安全？线程安全级别有什么？</h3><p>既然是线程安全问题，那么毫无疑问所有的隐患都是出现在多个线程访问的情况下产生的，也就是我们要确保在多条线程访问的时候，<u>我们的程序还能按照我们预期的行为去执行</u>，<strong>也就是说：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。</strong></p>
<p>线程安全级别：</p>
<ol>
<li><p>不可变：不变的对象绝对是线程安全的，不需要线程同步，如String、Long、BigInteger</p>
</li>
<li><p>绝对的线程安全：对象自身做了 足够的内部同步，也不需要外部同步，如 Random 、ConcurrentHashMap、Concurrent集合、atomic</p>
</li>
<li><p>相对的线程安全：对象的部分方法可以无条件安全使用，但是有些方法需要外部同步，需要Collections.synchronized；有条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器</p>
</li>
<li><p>线程兼容：对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如ArrayList HashMap</p>
</li>
<li><p>线程对立：即使外部进行了同步调用，也不能保证线程安全，这种情况非常少，如System.setOut()、System.runFinalizersOnExit()</p>
</li>
</ol>
<h3 id="4-怎么保证线程安全？"><a href="#4-怎么保证线程安全？" class="headerlink" title="4.怎么保证线程安全？"></a>4.怎么保证线程安全？</h3><p><strong>当多个线程要共享一个实例对象的值得时候，那么在考虑安全的多线程并发编程时就要保证下面3个要素：</strong></p>
<ul>
<li>原子性（Synchronized, Lock）</li>
<li>有序性(Volatile，Synchronized, Lock)</li>
<li>可见性(Volatile，Synchronized,Lock)</li>
</ul>
<p>但是由于synchronized和Lock保证每个时刻只有一个线程执行同步代码，所以是线程安全的，也可以实现这一功能，<strong>但是由于线程是同步执行的，所以会影响效率。</strong></p>
<p><strong>下面是对3个要素的详细解释：</strong></p>
<ul>
<li><strong>原子性</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，<strong>基本数据类型的变量的读取和赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</li>
<li><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p><strong>volatile的作用：保证数据的可见性和防止指令重排。</strong></p>
<ul>
<li>volatile仅能用在变量级别，而synchronized可用在变量和方法中。</li>
<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取共享变量时，它会去内存中读取新值。</li>
<li>普通的共享变量不能保证可见性，因为普通共享变量被修改后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li>
<li>更新主存的步骤：当前线程将其他线程的工作内存中的缓存变量的缓存行设置为无效，然后当前线程将变量的值跟新到主存，更新成功后将其他线程的缓存行更新为新的主存地址</li>
<li>其他线程读取变量时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</li>
<li> 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li>
</ul>
<p><strong>1、使用安全类，比如 Java. util. concurrent</strong></p>
<p><strong>2、使用synchronized关键字，自动锁</strong> </p>
<p><strong>定义</strong>：synchronized关键字解决的是多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</strong>当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用。</p>
<p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 <strong>Java 6 之后 Java 官⽅对从 JVM 层⾯对synchronized较⼤优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销；主要解决以下三种场景:</strong></p>
<ul>
<li>只有一个线程进入临界区，偏向锁</li>
<li>多线程未竞争，轻量级锁</li>
<li>多线程竞争，重量级锁</li>
</ul>
<p>偏向锁→轻量级锁→重量级锁过程，<strong>锁可以升级但不能降级</strong>，这种策略是为了提高获得锁和释放锁的效率</p>
<p><strong>底层原理：</strong></p>
<p>① synchronized 同步语句块的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执⾏monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种⽅式获取锁的，也是为什么Java中任意对象可以作为锁的原因)的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执⾏monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>
<p>② synchronized 修饰⽅法的的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronized ⽅法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法，JVM 通过该 ACC_SYNCHRONIZED 访问<br>标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。</p>
<p><strong>3、使用Lock类，手动锁</strong></p>
<p>先来说说它跟synchronized有什么区别吧，Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，什么意思？</p>
<p>就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。我们先来看下一般是如何使用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// ReentrantLock是Lock的子类</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">      lock.lock(); <span class="comment">// 获取锁对象</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">          <span class="comment">// Thread.sleep(2000);</span></span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程名：&quot;</span>+thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">          lock.unlock(); <span class="comment">// 释放锁对象</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-多线程的实现方式和区别"><a href="#5-多线程的实现方式和区别" class="headerlink" title="5.多线程的实现方式和区别"></a>5.多线程的实现方式和区别</h3><p>①继承Thread类</p>
<p>②实现Rannable接口</p>
<p>③使用Callable和Future创建线程</p>
<ul>
<li><p>上面的两种方式都有这两个问题;二第三个方法就是解决这两个问题的</p>
<ul>
<li>无法获取子线程的返回值</li>
<li>run方法不可以抛出异常</li>
</ul>
</li>
</ul>
<p><strong>前三种实现多线程的比较：</strong></p>
<p>第一种和后面两种的对比：</p>
<ul>
<li>通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换</li>
<li>但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。</li>
</ul>
<p>第二种和第三种方式对比：</p>
<ul>
<li>同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换</li>
<li>第三种方法有两个优点：有返回值、可以抛出异常</li>
</ul>
<h3 id="6-怎么启动多线程？"><a href="#6-怎么启动多线程？" class="headerlink" title="6.怎么启动多线程？"></a>6.怎么启动多线程？</h3><p>调用start()方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String name2 = Thread.currentThread().getName();</span><br><span class="line">		System.out.println(name2+<span class="string">&quot;:你好啊 我是一个线程!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		threadTest();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">没错就是这么简单,只需要<span class="keyword">new</span> Thread()然后重写run方法就可以实现创建一个线程,使用start方法即可启动该线程.</span><br></pre></td></tr></table></figure>

<h3 id="7-有几种线程池-是怎么实现的？"><a href="#7-有几种线程池-是怎么实现的？" class="headerlink" title="7.有几种线程池,是怎么实现的？"></a>7.有几种线程池,是怎么实现的？</h3><ol>
<li><strong>newFixedThreadPool</strong>: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</li>
<li><strong>newCachedThreadPool</strong>: 建一个可缓存线程池，是一个会根据需要创建新线程的线程池;如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是: 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。**如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1 分钟)**，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。在使用CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
<li><strong>newSingleThreadExecutor</strong>: 创建一个单线程池，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </li>
<li><strong>newScheduledThreadPoolExecutor</strong>: 创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3 秒执行。 </li>
</ol>
<p><strong>底层具体实现：</strong></p>
<p>通过Executor 框架的⼯具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：</p>
<ul>
<li><strong>newSingleThreadExecutor</strong></li>
<li><strong>newFixedThreadPool</strong></li>
<li><strong>newCachedThreadPool</strong></li>
</ul>
<p>下⾯这些对创建 ⾮常重要，在后⾯使⽤线程池的过程中你⼀定会⽤到！所以，务必拿着⼩本本记清楚。</p>
<p><strong>ThreadPoolExecutor构造函数重要参数分析</strong> </p>
<ul>
<li>corePoolSize : 核⼼线程数线程数定义了<strong>最⼩可以同时运⾏的线程数量</strong>。</li>
<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运⾏的线程数<br>量变为最⼤线程数。</li>
<li>workQueue: 当新任务来的时候会先判断当前运⾏的线程数量是否达到核⼼线程数，如果达到<br>的话，新任务就会被存放在队列中。</li>
</ul>
<p>ThreadPoolExecutor其他常⻅参数:</p>
<ol>
<li><p>keepAliveTime:当线程池中的线程数量⼤于 corePoolSize 的时候，如果这时没有新的任务提交，核⼼线程外的线程不会⽴即销毁，⽽是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁；</p>
</li>
<li><p>unit : keepAliveTime 参数的时间单位。</p>
</li>
<li><p>threadFactory :executor 创建新线程的时候会⽤到。</p>
</li>
<li><p>handler :饱和策略。关于饱和策略下⾯单独介绍⼀下。<br>ThreadPoolExecutor 饱和策略<br>ThreadPoolExecutor 饱和策略定义:<br>如果当前同时运⾏的线程数量达到最⼤线程数量并且队列也已经被放满了任时， ThreadPoolTaskExecutor 定义⼀些策略:ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。ThreadPoolExecutor.CallerRunsPolicy：调⽤执⾏⾃⼰的线程运⾏任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应⽤程序可以承受此延迟并且你不能任务丢弃任何⼀个任务请求的话，你可以选择这个策略。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //线程池的核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, //最大线程数。</span></span></span><br><span class="line"><span class="function"><span class="params">                          Long keepAliveTime,// 设置线程超时时间。</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params">                          BLockingQueue&lt;Runnable&gt;workQueue,   //阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, //线程工厂,线程池利用该工厂创建线程 </span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandLer handler)</span></span>&#123;<span class="comment">//  线程任务拒绝策略。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-说说-sleep-⽅法和-wait-⽅法区别和共同点"><a href="#8-说说-sleep-⽅法和-wait-⽅法区别和共同点" class="headerlink" title="8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?"></a>8. 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h3><p>两者最主要的区别在于：sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。</p>
<ul>
<li>两者都可以暂停线程的执⾏。</li>
<li>Wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</li>
<li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者notifyAll() ⽅法。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。</li>
<li>sleep() ⽅法执⾏完成后，线程会⾃动苏醒。</li>
</ul>
<h3 id="9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？"><a href="#9-为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？" class="headerlink" title="9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？"></a>9.为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</h3><p>这是另⼀个⾮常经典的 java 多线程⾯试问题，⽽且在⾯试中会经常被问到。很简单，但是很多⼈都回答不上来！</p>
<p>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。</p>
<p>总结： 调⽤ start ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ run ⽅法只是 thread 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。</p>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Dawn-yhc 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Dawn-yhc 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文博主： </strong>Dawn-yhc
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://yuhaicheng.xyz/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" title="JVM垃圾回收+多线程">https://yuhaicheng.xyz/2020-11-11-JVM垃圾回收+多线程.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"><i class="fa fa-tag"></i> 垃圾回收</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020-11-08-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html" rel="prev" title="贪心算法">
                  <i class="fa fa-chevron-left"></i> 贪心算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020-11-11-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F.html" rel="next" title="冒泡排序">
                  冒泡排序 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NDkyOC8yMTQ1MA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawn-yhc</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">295k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:28</span>
  </span>
</div><div class="footer-custom">

<span id="jinrishici-sentence">正在加载今日诗词....</span>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/jinrishici.js" charset="utf-8" async="async"></script>
</div>
<script color= "255, 255, 255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>
<div>
    <canvas id="snow" width="570" height="696"></canvas>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/src/snow.min.js" async="async"></script>
</div>
<!-- 社会主义价值观 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/weilining/blog.io/js/cursor/text.js" async="async"></script>


    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/motion.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="//cdn.jsdelivr.net/npm/hexo-theme-next@8.0.1/source/js/local-search.js"></script>










<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>



  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>


  








    <div class="pjax">
  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://yuhaicheng.xyz/2020-11-11-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6+%E5%A4%9A%E7%BA%BF%E7%A8%8B.html',]
      });
      });
  </script>

<script>
NexT.utils.loadComments('#lv-container', () => {
  window.livereOptions = {
    refer: "2020-11-11-JVM垃圾回收+多线程.html"
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
</body>
</html>
